<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Microfacet model概述</title>
    <link href="/2024/11/27/%E7%AC%94%E8%AE%B0/Microfacet%20model%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/11/27/%E7%AC%94%E8%AE%B0/Microfacet%20model%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p><span class="math display">\[\newcommand{\vec}{\bold}\newcommand{\w}{\pmb\omega}\]</span></p><p><strong><font color="#dd0000">=== 待更新 ===</font></strong></p><h4 id="基本物理观念">基本物理观念</h4><ol type="1"><li>金属的折射光会被自由电子立刻吸收，几乎只有反射。非金属才有明显散射行为。</li><li>非金属的镜面反射是无彩色的（白色），金属才具有彩色的镜面反射。</li><li>光打中平面后，只发生反射（镜面反射）和折射，折射入物体内部后一部分被吸收，另一部分散射出来成为漫反射。其中漫反射部分又可以拆分出次表面散射，即散射距离显著大于像素大小时，散射影响到了附件的其他像素上，称为次表面散射。</li></ol><p><imgsrc="https://raw.githubusercontent.com/QianMo/PBR-White-Paper/master/content/part%202/media/db572e0923acd8d22e67a4e1875fb206.png" /></p><h4 id="brdf">BRDF</h4><p>BRDF的定义式： <span class="math display">\[f_r = \frac{dL_o}{d E_i}\]</span> 此前我疑惑过为什么不简单定义为 <spanclass="math inline">\(\frac{dL_o}{dL_i}\)</span>，在搞明白Radiance之后理解了。<spanclass="math inline">\(L_o\)</span>为反射方向的Radiance，贡献来自于整个上半球，<spanclass="math inline">\(dL_o\)</span> 指 <spanclass="math inline">\(dw_i\)</span> 方向的入射光对 <spanclass="math inline">\(L_o\)</span> 的贡献；<spanclass="math inline">\(E\)</span>为表面接受到Irradiance，贡献来自于整个上半球， <spanclass="math inline">\(dE_i\)</span> 指 <spanclass="math inline">\(dw_i\)</span> 方向的入射光对 <spanclass="math inline">\(E\)</span> 的贡献。</p><p>简单而言，他们都是微分量，都是对入射角的微分；而 <spanclass="math inline">\(dL_i\)</span> 则说不清具体含义；也不可能定义成<span class="math inline">\(\frac{dL_o}{L_i}\)</span>的形式，它是一个趋于0的值，需要除上一个微分立体角才能有意义。</p><p><span class="math display">\[L_o = L_i \cdot f_r(i,o)\cdot cos(i) \\L_i = L_o \cdot f_r(o,i)\cdot cos(o)\]</span></p><p>那为什么不定义为 <span class="math inline">\(\frac{dL_o}{L_idw_i}\)</span> 的形式呢？（相比正式定义少了个 <spanclass="math inline">\(cos\)</span>）</p><p>还可以从实际测量的角度理解，实际测量中 <spanclass="math inline">\(dL_o\)</span></p><p>....</p><p>除此之外，在最常见的微表面模型中，这种定义的BRDF是可逆的，带上cos之后就不可逆了。</p><h5 id="microfacet-brdf推导">Microfacet BRDF推导</h5><p>下面推导微表面模型中的 <span class="math inline">\(f_r\)</span>具体形式，暂时忽略菲涅尔项和几何遮蔽。</p><p>我们用 <span class="math inline">\(cos(i,n)\)</span>这样的形式来表示两向量夹角的 <spanclass="math inline">\(cos\)</span>。</p><p>设 <span class="math inline">\(D(h)\)</span> 指代微法线在 <spanclass="math inline">\(dw_h\)</span>微立体角内的微表面面积与宏表面面积的比例，有 <spanclass="math display">\[\int D(h) \cdot cos(n,h) \cdot dw_h = 1\]</span> 先推导 <span class="math inline">\(dL_o\)</span>，它指 <spanclass="math inline">\(dw_i\)</span> 方向的入射光对 <spanclass="math inline">\(L_o\)</span> 的贡献。</p><p>首先，<span class="math inline">\(dw_h\)</span> 方向的微表面面积为<span class="math display">\[d^2A_h = dA \cdot D(h) \cdot dw_h\]</span> 可以得出进入表面（且对 <spanclass="math inline">\(L_o\)</span>有贡献）的辐射通量（微平面视角下理解）： <span class="math display">\[d^3\phi = L_i \cdot d^2A_h \cdot dw_i \cdot cos(h,i)\]</span> <span class="math inline">\(\phi\)</span>是由输入到输出的不变量 <spanclass="math inline">\(\phi_i=\phi_o\)</span>，那么可以得到（回到宏观视角）：<span class="math display">\[dL_o = \frac{d^3\phi}{dA\cdot dw_o \cdot cos(n,o)}\]</span> 左侧是 <spanclass="math inline">\(dL_o\)</span>，因为右侧还是对 <spanclass="math inline">\(dw_i\)</span> 微分的一个量，得到的正是 <spanclass="math inline">\(dw_i\)</span> 方向对 <spanclass="math inline">\(L_o\)</span> 的贡献。也可以从 <spanclass="math inline">\(d\)</span> 的次数守恒来理解。</p><p><span class="math inline">\(dE_i\)</span> 比较简单： <spanclass="math display">\[E_i = \int L_i \cdot cos(n,i) \cdot dw_i \\dE_i = L_i \cdot cos(n,i) \cdot dw_i\]</span> 那么展开上述式子，得到： <span class="math display">\[f_r = \frac{D(h) \cdot cos(h,i) \cdot dw_h}{cos(n,o) \cdot cos(n, i)\cdot dw_o}\]</span> <span class="math inline">\(dw_h\)</span> 与 <spanclass="math inline">\(dw_o\)</span> 之间存在一个几何上的关系（想象对<span class="math inline">\(h\)</span> 产生一个扰动 <spanclass="math inline">\(dw_h\)</span>，然后 <spanclass="math inline">\(o\)</span> 将产生的扰动 <spanclass="math inline">\(dw_o\)</span> 与 <spanclass="math inline">\(dw_h\)</span> 的关系如下）</p><p><img src="http://lxtyin.ac.cn/img/Gemo/reflection_jaco.png" /></p><p>另一个理解是，首先有 <span class="math inline">\(d_{\theta o} =2d_{\theta h}\)</span>，<span class="math inline">\(d_{\phi o} =2d_{\phi h}\)</span></p><p>从立体角定义的角度，<span class="math inline">\(dw_h = d_{\theta h}d_{\phi h}cos(\theta_h)\)</span>，我们将 <spanclass="math inline">\(h\)</span> 摆到竖直的位置上，就有了 <spanclass="math display">\[dw_h = d_{\theta h} d_{\phi h} \\dw_o = d_{\theta o} d_{\phi o} |w_o\cdot w_h| = 4|w_o\cdot w_h|dw_h\]</span> 于是有： <span class="math display">\[f_r = \frac{D(h)}{4cos(n,i) \cdot cos(n,o)}\]</span></p><p>再加上几何项G与菲涅尔项F，就得到了经典的<code>Cook-Torrance BRDF</code>形式： <span class="math display">\[f_r=\frac{DFG}{4cos(n,i) \cdot cos(n,o)}\]</span>当然，这里只考虑了reflect，通常的反射模型还要再加一个diffuse部分。</p><p><strong>可逆性：</strong><spanclass="math inline">\(f_r(w_r\rightarrow w_i)=f_r(w_i\rightarroww_r)\)</span></p><p><strong>能量守恒：</strong>理想的BRDF是能量守恒的（不考虑吸收啥的），但实际上由于多次散射很难计量，次一级的要求是能量保守（可能衰减，但不会增加）的BRDF，这决定了能量是否能够收敛。<span class="math display">\[\int f_r cos(n,i) dw_i \le 1\]</span> 这也是白炉测试的基础，如果来自四面八方的 <spanclass="math inline">\(L_i\)</span>一致，那么从任一方向观察散射表面，能量应该与环境光一致（若不损失能量）。</p><h5 id="diffuse">Diffuse</h5><ul><li>最简单的Lambert均匀漫反射：<spanclass="math inline">\(f_{lambert}=\frac{q}{\pi}\)</span></li></ul><p>因为需要能量守恒： <span class="math display">\[\int_{\Omega^+} f_p cos\theta d_w = 1\]</span> 得 <span class="math inline">\(f_p =\frac{1}{\pi}\)</span>，再加上albedo系数即可。</p><ul><li>Disney经验模型，在漫反射部分也加上了菲涅尔因子，公式如下：</li></ul><p><span class="math display">\[f_d = \frac{baseColor}{\pi}(1+(F_{D90} - 1)(1 - cos_{NL})^5)(1+(F_{D90}- 1)(1 - cos_{NV})^5)\\F_{D90} = 0.5 + 2roughness \times cos_{VH}^2\]</span></p><ul><li>次表面散射也属于Diffuse，暂略。</li></ul><h5 id="d项">D项</h5><p><span class="math inline">\(D(h)\)</span> 指微表面中法线为 <spanclass="math inline">\(h\)</span>的微表面面积比例，是微表面模型中最重要的一个统计量。</p><p>它指的是微表面面积 / 宏观面积，故乘上余弦项后积分才为1。 <spanclass="math display">\[\int_{\Omega^+} D(h)(h\cdot n)dw_h = 1\\\int_{\Omega^+} D(h)(h\cdot v)dw_h = v\cdot n\]</span> 关于2式的理解：</p><p><imgsrc="https://raw.githubusercontent.com/QianMo/PBR-White-Paper/master/content/part%204/media/b6a70732fd616c56ad51468b2d5630cc.png" /></p><p>比较常用各项同性GGX分布： <span class="math display">\[D_{GGX}(h)=\frac{\alpha^2}{\pi(cos_{NH}^2(\alpha^2-1)+1)^2}\]</span></p><p>式子中 <span class="math inline">\(\alpha\)</span> 表示粗糙度<code>roughness</code> ，其值越大，反射越不集中。</p><p>除此之外还有许多中分布模型，大多公式不是推导出来的，而是凭借经验和直觉拟合测量结果得出的。</p><p>形状不变性：缩放 <span class="math inline">\(\alpha\)</span>时，等价于拉伸微观几何。GGX具备形状不变性，而另一个常见的GTR模型不具备。</p><p>各向异性：暂略</p><h5 id="g项">G项</h5><p>几何项，微表面模型中，一部分微表面会被遮挡，导致即使其法线方向符合，也没有产生贡献。我们用<span class="math inline">\(G1(h,v)\)</span> 表示沿视图 <spanclass="math inline">\(v\)</span> 方向，可见的法线为 <spanclass="math inline">\(h\)</span> 的微平面比例，作为对 <spanclass="math inline">\(D\)</span> 项的补充。</p><p>之前的 <span class="math inline">\(D\)</span>项、漫反射项的常用分布，都是人们依据经验拟合的，而G项是依赖所选D项，可以推导的。</p><p>单D项还不能推导出G，因为D项仅定义了分布，未定义“轮廓”，还需要一个定义轮廓的模型。目前常用的轮廓模型是<strong>Smith遮蔽函数</strong>。</p><p>Smith模型将微表面看做若干不连续的表面（无自相关性，即任一点的高度和法线无关），单独考虑高度上的遮蔽和局部的法线遮蔽（<spanclass="math inline">\(w\cdot w_m &gt;0\)</span>），这在表面随机的情况下表现很好，对于具备一定规律的表面材质（例如布料），一般使用专门的模型。</p><p>Smith遮蔽函数是常见遮蔽函数中，唯一既满足能量守恒又具有法线遮蔽独立性（即法线/高度都和相邻点无关）便利特性的函数。</p><p>几何函数的理论形式为 <span class="math inline">\(G(m,v)\)</span>，它表示朝向 <span class="math inline">\(m\)</span>的所有微平面中，在 <span class="math inline">\(v\)</span>方向上可见的比例。 <span class="math display">\[\int_\Omega G(w_o, w_m)&lt;w_o, w_m&gt;D(w_m)dw_m = 在w_o上的投影面积 =w_o\cdot w_n\]</span> 然而在Smith模型的假设中，<spanclass="math inline">\(G\)</span> 函数与 <spanclass="math inline">\(m\)</span> 无关（有的会用 <spanclass="math inline">\(\chi^+(w_o \cdot w_m)\)</span>来剔除反方向的表面，但这未必要在几何项中完成），因此也经常看到 <spanclass="math inline">\(G(v)\)</span> 的形式。</p><p>GGX导出的G项：Smith-GGX函数为 <span class="math display">\[G_{GGX}(v)=\frac{2(n\cdot v)}{(n\cdot v)+\sqrt{a^2+(1-a^2)(n\cdot v)^2}}\]</span></p><p>其中 <span class="math inline">\(v\)</span>为光线方向，显然角度越大，这个项越小（衰减越重）</p><p>其中 <spanclass="math inline">\(\alpha=(\frac{1+roughness}{2})^2\)</span>，也有其他形式的<span class="math inline">\(\alpha\)</span>。</p><p>我们通常使用的几何项是分离的遮蔽阴影函数，<spanclass="math inline">\(G=G_{GGX}(w_i)G_{GGX}(w_o)\)</span>，除此之外，也有高度相关的版本。</p><p>G项虽然基本都用Smith，但是有很多不同的近似方案，内容较多，具体见https://github.com/QianMo/PBR-White-Paper/blob/master/content/part%205/README.md</p><p><strong>Kulla-Conty近似：</strong></p><p>简单地乘以G项显然会导致能量丢失，事实上，被遮挡的部分会经过反弹再出去。</p><p>这里需要做一个fix【暂略】</p><p>不能单纯加上一个diffuse！</p><h5 id="f项">F项</h5><p>菲涅尔项，指物体镜面反射的能量比例，入射角与法线夹角越大，反射率越大。通常用<span class="math inline">\(F_0\)</span>表示0度角（垂直）入射时的反射率。金属的 <spanclass="math inline">\(F_0\)</span> 值通常为 <spanclass="math inline">\(0.5-1\)</span>，非金属通常为 <spanclass="math inline">\(0.02-0.05\)</span>。</p><p>在掠射（90度）时，菲涅尔项达到1（全反射），不过由于微表面的存在，宏观观察的菲涅尔项达不到1也很正常。</p><p>菲涅尔项的实际计算比较复杂，它与材质的折射率、波动光学相关，不同材质的菲涅尔项差别也很大。但是经过一些观察，人们发现了一些共性：</p><ul><li>对于0-45度的入射角（与法线夹角），菲涅尔项几乎不变。</li><li>45-75度，菲涅尔项明显增大，75-90度，菲涅尔项总是快速达到1。</li></ul><p>因此可以用 <span class="math inline">\(F_0\)</span>来近似地确定整个菲涅尔函数。</p><p>一种近似求法 SchlickFresnel： <span class="math display">\[F=F_0+(1-F_0)(1-cos\theta)^5\]</span> <span class="math inline">\(cos\theta\)</span>为入射方向与法线的夹角（<span class="math inline">\(w_i\cdoth\)</span>），随角度增大逐渐拉到全部反射。</p><p>常见材质的 <span class="math inline">\(F_0\)</span>可以查表得出，也可以用 <spanclass="math inline">\(F_0=(\frac{n_1-n_2}{n_1+n_2})^2\)</span>来计算，这里看到 <span class="math inline">\(F_0\)</span>其实并不是一个属于材质的属性，而是与两边介质的折射率均有关，大多数情况下<span class="math inline">\(n_1 = 1\)</span>。</p><p>在相对IOR接近1时，上述式子误差较大，此时可以直接使用精确菲涅尔方程计算。</p><p>据人们观察，非金属的菲涅尔效应在光的各个波长上表现比较一致，而金属的菲涅尔效应随波长变化明显。因此实现上，金属的F0可以定义为彩色，非金属F0定义为白色，混合介质的<span class="math inline">\(F_0\)</span>可以简单地线性估计：<code>F_0=mix(vec3(0.04), albedo, metallic)</code>，这个式子中，非金属F0取典型值0.04，金属部分F0=albedo，这也是M/R工作流中的常见做法，albedo同时作为非金属的漫反射颜色和金属的F0。</p><p>菲涅尔项是可逆的（仅限目前的几何光学），就是说 <spanclass="math inline">\(F(w_i, w_o)=F(w_o,w_i)\)</span>，这一点无论是反射还是折射都成立。</p><h4 id="disney模型">Disney模型</h4><p>Disney BRDF将物体视为金属部分和非金属部分，依据金属度<code>metallic</code>混合。由于仅非金属具有漫反射，我们为diffuse部分乘一个系数 <spanclass="math inline">\((1-metallic)\)</span>，右部specular为金属和非金属共同作用的，金属度体现在<span class="math inline">\(F\)</span> 项中的 <spanclass="math inline">\(F_0 = mix(0.04, albedo, metallic)\)</span>。</p><p>漫反射属于折射后的散射，理应也具有与菲涅尔相关的系数，Disney没有使用简单的lambert模型也没有乘（1-F），而是单独加了一些菲涅尔因子（具体见上Diffuse）</p><p><span class="math display">\[f_r = (1 - metallic)f_d +\frac{D_{GGX}F_{SchlickFresnel}G_{SchlickGGX}}{4cos_i cos_o}\]</span></p><h4 id="bsdf">BSDF</h4><p>BSDF = BRDF + BTDF</p><p>BTDF（双向透射分布函数）的积分域是下半球面，与BRDF组合后就是一个完整的球面积分。</p><p>BTDF同样可以使用微表面模型，将微表面看做光滑的，只会朝固定方向折射。</p><p>那么BTDF前面的推导过程和BRDF完全一致，得到： <spanclass="math display">\[f_t = \frac{D(h) \cdot cos(h,i) \cdot dw_h}{cos(n,o) \cdot cos(n, i)\cdot dw_o}\]</span> 最后的 <span class="math inline">\(\frac{dw_h}{dw_o}\)</span>和BRDF不同（仅仅是几何关系上不同），见Walter论文中的图，可以推出关系：<span class="math display">\[dw_h = \frac{dw_o \cdot \eta^2 \cdot cos(h,o)}{||h||^2}\]</span> 这里的 <span class="math inline">\(\eta =\frac{\eta_o}{\eta_i}\)</span>，合并起来，得到 <spanclass="math inline">\(f_t\)</span> 的表达式： <spanclass="math display">\[f_t =\frac{cos(h,i) \cdot cos(h,o)}{cos(n,o) \cdot cos(n, i)}\cdot\frac{D(h) \cdot \eta^2}{||h||^2}\]</span> 再添加菲涅尔项（1-F）和几何项，定义都与BRDF中一致。</p><p>由于折射两边的介质不同，我们发现这个式子并不是可逆的，但幸运的是还有另一种可逆性存在：<span class="math display">\[f_t(i,o) \cdot \eta_i^2 = f_t(o,i) \cdot \eta_o^2\]</span></p><h4 id="disney-bsdf">Disney BSDF</h4><p><imgsrc="https://raw.githubusercontent.com/QianMo/PBR-White-Paper/master/content/part%203/media/e7f8349e326040400f36d6de724d1871.png" /></p><p>原先的BRDF依据metallic划分为了散射和反射两部分，现在继续在散射中划分为折射（SpecularBSDF）和漫反射两部分（Disney方法使用specTrans参数）。</p><p>折射部分和反射很接近，只不过菲涅尔项需要使用 <spanclass="math inline">\(1-F\)</span> 以及 <spanclass="math inline">\(IOR\)</span>修正，此时的菲涅尔项可以直接用折射率算出来精确值。</p><p>折射下的半法向：<spanclass="math inline">\(h=normalize(wi+\frac{\eta_2}{\eta_1}wo)\)</span></p><p>它的分布 <span class="math inline">\(D(h)\)</span>可以按照和BRDF相同的方式得出。</p><p>实际应用中，我们通常以表面法线朝向作为外侧，定义介质内外两侧的折射率（外侧通常视为空气）</p><h4 id="重要性采样">重要性采样</h4><h5 id="对d进行重要性采样">对D进行重要性采样</h5><p>我们很难严格画出渲染方程的曲线，故通常只对法线分布函数进行重要性采样。</p><p><imgsrc="https://img2020.cnblogs.com/blog/519775/202010/519775-20201010225605808-1680627455.png" /></p><p>如上，<span class="math inline">\(D(h)\)</span> 实际应满足 <spanclass="math inline">\(\int_{\Omega^+}D(h)cos\theta_hd_w=1\)</span>，<spanclass="math inline">\(\theta_h\)</span> 为宏面法线和 <spanclass="math inline">\(h\)</span> 的夹角，那太方便了，直接拿 <spanclass="math inline">\(D(h)cos\theta_h\)</span> 当概率密度，采样 <spanclass="math inline">\(h\)</span>。</p><p>将向量转化到球面坐标系 <spanclass="math inline">\(\theta,\phi\)</span>： <spanclass="math display">\[\int_0^{2\pi}\int_0^{\pi} D(\theta, \phi) cos_\theta sin_\thetad_{\theta}d_{\phi}\]</span> 显然这里的式子与 <span class="math inline">\(\phi\)</span>无关，我们可以得到 <spanclass="math inline">\(pdf(\theta)=\frac{2\alpha^2cos\thetasin\theta}{(cos^2\theta(\alpha^2-1)+1)^2}\)</span></p><p>接下来的问题是如何生成一个符合这个概率的随机数：</p><h6 id="逆分布函数方法">逆分布函数方法</h6><p>首先计算 <span class="math inline">\(pdf(x)\)</span> 的累计分布函数<span class="math inline">\(P(x)\)</span>，它的值域是 <spanclass="math inline">\([0, 1]\)</span>，然后利用反函数 <spanclass="math inline">\(P^{-1}(x)\)</span> 。</p><p>这样就可以利用 <span class="math inline">\([0,1]\)</span>之间的均匀随机数生成符合 <span class="math inline">\(pdf(x)\)</span>的随机数。</p><p>为了方便起见，设 <span class="math inline">\(x=cos\theta\)</span><span class="math display">\[\begin{aligned}p(\theta)=&amp;\frac{2\alpha^2cos\thetasin\theta}{(x^2(\alpha^2-1)+1)^2}, x\in[0,1]\\P(t)=&amp;\int_0^t\frac{2\alpha^2cos\thetasin\theta}{(x^2(\alpha^2-1)+1)^2}d\theta\\=&amp;\int_{..}\frac{\alpha^2}{(x^2(\alpha^2-1)+1)^2}dx^2\\=&amp;\int_{..}\frac{a^2}{u^2(a^2-1)}du,u=x^2(a^2-1)\\=&amp;\frac{a^2}{(a^2-1)(cos^2t(a^2-1)+1)}-\frac{1}{a^2-1}\\P^{-1}(x)=&amp;\arccos\sqrt \frac{1-x}{x(a^2-1)+1}\end{aligned}\]</span> 故随机抽样 <span class="math inline">\(x\in[0,1]\)</span>，然后得出 <spanclass="math inline">\(\theta=P^{-1}(x)\)</span>。<spanclass="math inline">\(\phi\)</span> 这一项是均匀的， 在 <spanclass="math inline">\([0,2\pi]\)</span> 上随机即可。注意pdf还需除以这个<span class="math inline">\(2\pi\)</span></p><p>注意如此采样的是 <spanclass="math inline">\(h\)</span>，随后可以进行反射得到 <spanclass="math inline">\(wo\)</span> 方向，此时还需要再次应用 <spanclass="math inline">\(wh,wo\)</span> 之间的变换比例：<spanclass="math inline">\(pdf /= 4cos_{ih}\)</span>。</p><h5 id="对环境贴图重要性采样">对环境贴图重要性采样</h5><p>以HDR环境贴图作为主要光源时，对其进行重要性采样。</p><p>首先将HDR贴图的颜色值归一化为概率密度</p><p>此时我们相当于有了一个函数 <span class="math inline">\(pdf(x,y)\)</span>​，只不过没有解析式，求不出cdf，那就只能二分了。</p><p>可以求出边缘密度函数 <spanclass="math inline">\(F_x(x)=F(x,\infty)\)</span>，它相当于前缀和，我们可以在[0,1]间均匀抽样，然后在<span class="math inline">\(F_x\)</span> 上面二分得到采样的 <spanclass="math inline">\(x\)</span></p><p>然后在 <span class="math inline">\(x\)</span> 列上求出每个 <spanclass="math inline">\(y\)</span> 的条件概率密度 <spanclass="math inline">\(f_{Y|X}(y)\)</span>，在这个东西的CDF上同理二分得到<span class="math inline">\(y\)</span>。</p><p>在GPU中二分实在太慢，我们可以先预处理一个二维缓冲，在这个缓冲中以<span class="math inline">\((u,v)\)</span>采样的值对应上述过程中，随机数为 <spanclass="math inline">\(u,v\)</span> 时采得的 <spanclass="math inline">\(x,y\)</span>坐标。同时还需要传递这个位置的pdf，一共三个浮点数，正好利用三个通道。</p><p>显然这个cache和原图的关系基本上是“连续”的，被插值了也没有关系。</p><p>关于pdf：谨记它表示的是这个值被采样到的概率，而非此次采样发生的概率，不可忽略。</p><h3 id="待合并microfacet">待合并：Microfacet</h3><p>简单回顾一下微表面模型的一些性质： <span class="math display">\[\int_{\Omega^+} D(\w_m)(\w_m\cdot\w_g)d\w_m = 1 \\\int_{\Omega^+} D(\w_m)(\w_m\cdot\w_o)d\w_m = cos(\w_o) \\\]</span> 第二个式子包含了反向表面的负贡献，与正向表面能够抵消 <spanclass="math display">\[设 \quad A^+ = \int_{\Omega^+} D(\w_m)&lt;\w_m\cdot\w_o&gt;d\w_m \\A^- = \int_{\Omega^+} D(\w_m)&lt;-\w_m\cdot\w_o&gt;d\w_m \\则也有 \quad A^+ - A^-=cos(\w_o) \\\]</span> 几何遮蔽项关注正向表面中，有多少是被挡住的，其定义为： <spanclass="math display">\[\int_{\Omega^+} G_1(\w_o, \w_m)D(\w_m)&lt;\w_m\cdot\w_o&gt;d\w_m =cos(\w_o)\]</span> 事实上，这定义了一个约束，几何遮蔽函数必须满足这一约束。</p><h3 id="smith-model">Smith model</h3><p>假设：微表面的高度和法线不相关，也就是可以分别用一个高度分布函数<span class="math inline">\(P(h)\)</span> 和一个法线分布 <spanclass="math inline">\(D(\w_m)\)</span>表示，直观来看，Smith假设下的表面是不连续的微平面，各个微平面与其领域完全不相关（这也使得它容易和microflake结合）。</p><p>几何遮蔽 <span class="math inline">\(G\)</span> 项包括两个部分：<spanclass="math inline">\(G_1(\w_o,\w_m) = G_1^{dist}(\w_o)G_1^{local}(\w_o,\w_m)\)</span>，其中 <span class="math inline">\(G_1^{dist}\)</span>表示被其他微平面挡住的部分，与微法线 <spanclass="math inline">\(\w_m\)</span> 无关；<spanclass="math inline">\(G_1^{local}\)</span> 则表示自身法线的遮挡，即<span class="math display">\[G_1^{local}(\w_o, \w_m) = \chi^+(\w_o \cdot \w_m)\]</span> 将拆分的几何项带入定义，<spanclass="math inline">\(G_1^{local}\)</span> 被合并，我们得到： <spanclass="math display">\[G_1^{dist}(\w_o)\int_{\Omega^+} D(\w_m)&lt;\w_m\cdot\w_o&gt;d\w_m =cos(\w_o) \\G_1^{dist}(\w_o)A^+ = cos(\w_o)\]</span> 在斜率空间进行一番推导（这块很复杂，具体看论文Understandingthe Masking-Shadowing Function in Microfacet-Based BRDFs），最终得到<span class="math display">\[G_1^{dist}(\w_o) = \frac{1}{1+\Lambda(\w_o)} \\\]</span> <span class="math inline">\(\Lambda(\w_o)\)</span>的定义是一个复杂的斜率上的积分形式，各个NDF可以推导出不同的 <spanclass="math inline">\(\Lambda\)</span>，重要的是它的含义： <spanclass="math display">\[G_1^{dist} = \frac{A^+-A^-}{A^+}, \quad \Lambda = \frac{A^-}{A^+-A^-}\]</span> 也就是被遮蔽的表面与可见表面的比例。</p><h3 id="与microflake的联系">与microflake的联系</h3><p>首先，smith模型将微平面看做不连续的小平面，我们可以把它们当成microflake；</p><p>在 <code>[Heitz et al. 2016]</code>的方法中，微表面被等价为不均匀介质（密度变化），而<code>[Dupuy et al. 2016]</code>将微表面映射到半无限空间中的均匀介质中。具体映射为： <spanclass="math display">\[z = log(C(\xi)) \\\xi = C^{-1}(exp(z)) \\\]</span> 其中 <span class="math inline">\(z\in [0, -\infty)\)</span>表示volume的深度，<span class="math inline">\(\xi\)</span>表示microfacet的height field，<span class="math inline">\(C(\xi) \in [0,1]\)</span>，介质密度 <span class="math inline">\(\rho(z) =1\)</span>。</p><p>在这种映射下，smith模型在高度 <spanclass="math inline">\(\xi\)</span> 处对应的microsurface密度即为： <spanclass="math display">\[\rho_{smith}(\xi) = \rho(z)\frac{dz}{d\xi} = \frac{P(\xi)}{C(\xi)}\]</span> 符合 <code>[Heitz et al. 2016]</code>的定义（虽然没看懂，为啥密度应该是这个）。</p><p>microflake的投影面积与shadowing-masking有很大的关联，有： <spanclass="math display">\[\sigma(\w_i) = \int_{S^2}&lt;-\w_i, \w_m&gt;D(\w_m)d\w_m = A^- =\Lambda(\w_i) cos(\w_i) \\\sigma(-\w_i) = \int_{S^2}&lt;\w_i, \w_m&gt;D(\w_m)d\w_m = A^+ =(1+\Lambda(\w_i)) cos(\w_i)\]</span>我们要证明这样的volume与microfacet等价，只需要证明任意方向的几何遮蔽<span class="math inline">\(G_1^{dist}(\w)\)</span>是相同的（二者的散射性质都取决于NDF，可以认为相同）。</p><p>volume的平均遮蔽为： <span class="math display">\[G_1^{volume}(\w_i) &amp;=&amp; \int_0^1exp(-|log(u)|\frac{\sigma(\w_i)}{cos\w_i})du \\&amp;=&amp; \frac{1}{1+\frac{\sigma(\w_i)}{cos\w_i}} \\&amp;=&amp; \frac{1}{1+\Lambda(\w_i)}\]</span> 这时，我们已经完成了遮蔽项的对齐，同时我们发现 <spanclass="math inline">\(\sigma(\w_i) \neq\sigma(-\w_i)\)</span>，这并不是一个对称的经典微薄片，而是一种单向的。事实上，<spanclass="math inline">\(D\)</span>项也并不是对称的，它应该和microfacet对齐，这才能保证微表面和这种volume等价。</p><h3 id="不理解的地方">不理解的地方</h3><p>Multiple-scattering microfacet BSDFs with the Smith model中提到了<span class="math inline">\(G_1^{dist}(\w_o, h)\)</span>这一形式，它的含义是某一高度的微平面，在 <spanclass="math inline">\(\w_o\)</span> 方向上可见的比例。 <spanclass="math display">\[G_1^{dist}(\w_o, h) = C(h)^{\Lambda(\w_o)}  \\G_1^{dist}(\w_o) = \int_{-\infty}^{+\infty} G_1^{dist}(\w_o, h)P(h)dh =\frac{1}{1+\Lambda(\w_o)}\]</span> 这里 <span class="math inline">\(P,C\)</span>分别是高度分布（pdf）和对应的CDF。</p><p>我的理解是先有下面的积分式子，再倒推得到的 <spanclass="math inline">\(G_1^{dist}(\w_o, h)\)</span> 的定义。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>Microfacet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Volume rendering概述</title>
    <link href="/2024/11/27/%E7%AC%94%E8%AE%B0/Volume%20Rendering%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/11/27/%E7%AC%94%E8%AE%B0/Volume%20Rendering%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><span class="math display">\[\newcommand{\w}{\pmb\omega}\newcommand{\vec}{\mathbf}\]</span></p><p><strong><font color="#dd0000">=== 待更新 ===</font></strong></p><p>Volume Rendering考虑参与介质（如雾、烟等）中的光线传播情况。</p><h4 id="辐射传输方程">辐射传输方程</h4><p>Radiative Transfer Equation, RTE</p><p>考虑光线沿 <span class="math inline">\(\w\)</span>方向传播，经过参与介质中一段微分距离 <span class="math inline">\(d\vecx\)</span> 时，radiance的变化量：</p><p><span class="math display">\[\nabla L(\vec x, \w) = -\sigma_t L(\vec x, \w) + \sigma_aL_e(\vec x, \w)+ \sigma_s\int_{S^2}f_p(\vec x,\w,\w&#39;)L(\vec x, \w&#39;)d\w&#39;\]</span> 其中：</p><p><span class="math inline">\(\sigma_a\)</span>为吸收系数，表示光线被介质吸收的比例。</p><p><span class="math inline">\(\sigma_s\)</span>为散射系数，表示光线被散射到其他方向的比例。</p><p>$ _t = _a + _s$，即光线撞击到粒子的比例。</p><p><span class="math inline">\(f_p\)</span> 为Phase function，<spanclass="math inline">\(f_p(\w_i \rightarrow \w_o)\)</span> 表示 <spanclass="math inline">\(\w_i\)</span>入射的光<strong>发生散射后</strong>，散射到 <spanclass="math inline">\(\w_o\)</span> 方向的比例。注意，<spanclass="math inline">\(f_p\)</span>仅衡量散射性质，而入射光并不都发生散射。因此，<spanclass="math inline">\(L_o \leftarrow \sigma_tf_pL_i\)</span>。事实上，<span class="math inline">\(f_p\)</span>也需要带上 <span class="math inline">\(\sigma_t\)</span> 才可逆。</p><p><span class="math inline">\(L_e\)</span> 为介质的自发光。</p><p>通常在推导时会用到反照率 <code>albedo</code>，它等于 <spanclass="math inline">\(\frac{\sigma_s}{\sigma_t}\)</span></p><p>上述的各个 <span class="math inline">\(\sigma\)</span>在各项异性介质中，也可能是位置和角度的函数。</p><h4 id="volume-rendering-equation">Volume Rendering Equation</h4><p>VRE即RTE的积分形式，考虑光线在介质中传播一段距离，得到的radiance（注意这也包括了这段路径上，每一处接收到的来自其他方向的散射<spanclass="math inline">\(L_s\)</span>，因此这是一个二重的积分，一维是距离，一维是方向）<span class="math display">\[L(\vec x, \w) = \int_0^z T(\vec x, \vec y)[\sigma_a L_e(\vec y,\w) +\sigma_s L_s(\vec x, \w)]d\vec y \\L_s(\vec x, \w) = \int_{S^2}f_p(\vec x,\w,\w&#39;)L(\vec x,\w&#39;)d\w&#39; \\T(\vec x, \vec y) = exp(-\int_y^x \sigma_t(s) d_s)\]</span> 上面比较重要的东西是 <spanclass="math inline">\(T\)</span>，被称为衰减项（attenuation，或transmittance），表示光线在介质中行进一段距离产生的衰减比例，因此也被称为光学厚度。</p><p>考虑最简单的均匀各向同性介质情况，$_t $ 是一个常数：</p><p>我们知道在 <span class="math inline">\(dx\)</span> 处的衰减为： <spanclass="math display">\[\frac{dL}{dx} = -\sigma_tL\]</span> 求解这个微分方程，我们抄来结果： <span class="math display">\[L = L_0e^{-\sigma_tx}\]</span> <span class="math inline">\(e^{-\sigma_t x}\)</span> 即为经过<span class="math inline">\(x\)</span>距离产生的衰减，对于更广义的非均匀的情况，有： <spanclass="math display">\[T(t) = exp(-\int_0^t\sigma_t(x)dx)\]</span> <span class="math inline">\(T(t)\)</span> 表示的是光线传播<span class="math inline">\(t\)</span> 距离之后，还剩下多少；<spanclass="math inline">\(1-T(t)\)</span> 即为在 <spanclass="math inline">\(t\)</span> 以内发生碰撞的概率，或者说是碰撞概率的<span class="math inline">\(CDF\)</span></p><p>那么可以计算恰好在 <span class="math inline">\(t\)</span>点发生碰撞的概率 <span class="math inline">\(pdf(t)\)</span>： <spanclass="math display">\[pdf(t) = \frac{CDF(t)}{dt} = \sigma_t(t)T(t)\]</span> 回到VRE上： <span class="math display">\[L(\vec x, \w) = \int_0^z T(\vec x, \vec y)[\sigma_a L_e(\vec y,\w) +\sigma_s L_s(\vec x, \w)]d\vec y \\\]</span>用蒙特卡洛法求解VRE，也就是需要对距离和方向进行采样，方向我们暂且不提（可以根据phasefunction采样）。</p><h4 id="sample-distance">Sample distance</h4><p><strong>均匀情况</strong>下，我们已经有了 <spanclass="math inline">\(pdf\)</span> 表达式，可以轻松用逆变换方法采样<span class="math display">\[CDF^{-1}(t) = \frac{ln(1-\xi)}{-\sigma_t}\]</span> <span class="math inline">\(\xi\)</span>为0-1之间的随机数。</p><p>若发生散射，则再对phase function作重要性采样决定散射方向。</p><p><strong>非均匀情况</strong>下，有一些手段。</p><p>这里的几种方法都是先根据随机数，决定 <spanclass="math inline">\(CDF(t) = \xi\)</span>，然后再去找这样的 <spanclass="math inline">\(t\)</span> 的位置（包括raymarching法），它们并没有改变按 transmittance 采样的本质。</p><ul><li>若介质在光线路径上可以分为几段（例如常见的网格表示的体数据），则可以分段采样。</li><li>Raymarching方法，均匀步长。它并不是指每一步采样距离都相等，还是先决定 <spanclass="math inline">\(CDF(t) = \xi\)</span>，然后用均匀步长去找这个<spanclass="math inline">\(t\)</span>（感觉很呆），而且也是有偏的，它将每一步内的介质都近似为均匀。</li><li>Woodcocktracking，虚点法，可以认为是一种拒绝采样策略。它首先将介质每一处的衰减项都放大为<span class="math inline">\(\sigma_t^{max}\)</span>，构成均匀介质，然后在采样到一点 <span class="math inline">\(t\)</span>时，以 <spanclass="math inline">\(\frac{\sigma_t(t)}{\sigma_t^{max}}\)</span>的概率接受，否则拒绝。数学上可以证明它是无偏的。</li></ul><p>非均匀介质的另一个问题是给定起始点位置，计算 <spanclass="math inline">\(T(x,y)\)</span>。它的解法和Sampledistance非常类似，同时还可以直接蒙特卡洛解。</p><h4 id="phase-function">Phase function</h4><p>重复一下，Phase function <spanclass="math inline">\(f_p(w_i\rightarrow w_o)\)</span>定义为<strong>散射到 <span class="math inline">\(w_o\)</span>的能量与所有散射能量</strong>的比值，它是归一化的。 <spanclass="math display">\[\int_{S^2} f_p(w_i\rightarrow w_o) dw_i = 1\]</span></p><p>另外，<strong>散射到 <span class="math inline">\(w_o\)</span>的能量与所有入射能量</strong>的比值定义为 <spanclass="math inline">\(f_a(w_i\leftrightarroww_o)\)</span>，它不是归一化的，但具有可逆性。 <spanclass="math display">\[f_a(w_i\leftrightarrow w_o) = f_p(w_i\rightarrow w_o) \cdot\sigma_s(w_i)\]</span> 在均匀的各项同性介质中，<spanclass="math inline">\(f_p\)</span> 与位置和方向无关，只与 <spanclass="math inline">\(w_i,w_o\)</span> 之间的夹角有关，可以视为一维函数<spanclass="math inline">\(f_p(\theta)\)</span>，更简单地，相函数也是各项同性的情况：<spanclass="math inline">\(f_p(\theta) =  \frac{1}{4\pi}\)</span></p><h4 id="microflake-model">Microflake model</h4><p>这是一种各项异性的体积模型，将参与介质看做由无数微小的，随机朝向的薄片组成，类似微表面模型，使用<span class="math inline">\(D(m)\)</span> 表示朝向 <spanclass="math inline">\(m\)</span> 的微薄片分布。</p><p>我们可以具体将 <span class="math inline">\(D(m)\)</span>定义为<strong>朝向 <span class="math inline">\(m\)</span>的微薄片面积与宏截面的比例</strong>，这种定义与微表面类似，但它不是归一化的（和微表面不同，薄片间存在间隙），不能直接用作pdf。</p><p>注意，一个微薄片可以有很多个方向的法线，取决于具体的形状。</p><p>单个微薄片在 <span class="math inline">\(w_i\)</span>方向的投影面积定义为 <span class="math display">\[\sigma(w_i) = \int_{S^2} D(m) &lt;w_i\cdot m&gt; d_m\]</span> 这里的 <span class="math inline">\(\sigma\)</span>没有下标，为单个薄片的投影面积，和前文中表示光线比例的 <spanclass="math inline">\(\sigma_t\)</span>等区分（许多经典文献中的符号都是这样，因此尽管容易混淆还是不作更改。）</p><p>归一化到投影面上： <span class="math display">\[D_{w_i}(m) = \frac{D(m)&lt;w_i\cdot m&gt;}{\sigma(w_i)} \\\int_{S^2} D_{wi}(m)dm = 1\]</span> 这里的 <span class="math inline">\(D_{w_i}(m)\)</span>被称为Visible normal。</p><p>广义上，微薄片不一定要是镜面，它可以有一个小的BRDF，我们定义micro-phasefunction：<span class="math inline">\(p(m,w_i\rightarroww_o)\)</span>，指特定方向微薄片的phase function，那么有： <spanclass="math display">\[f_p(w_i\rightarrow w_o) = \int_{S^2} p(m,w_i\rightarrow w_o) \cdotD_{w_i}(m)d_m\]</span> 如果认为所有微薄片都是镜面，推导Specular phase function：</p><p>仅当 <span class="math inline">\(h=m\)</span> 时有： <spanclass="math display">\[p(m,w_i\rightarrow w_o) = \frac{1}{4|w_i\cdot w_h|}\]</span> 代入得到： <span class="math display">\[f^{spec}_p(w_i\rightarrow w_o) = \frac{D(h)}{4\sigma(w_i)}\]</span></p><p>另外，<span class="math inline">\(w_i\)</span>方向的光线撞击到粒子的比例有： <span class="math display">\[\sigma_t(w_i) = \rho \sigma(w_i)\]</span></p><h4 id="spongecake">SpongeCake</h4><p>SpongeCake其实是表面材质，但他是基于Volume推导得到的。</p><p>使用Microflake模型表达Volume，简化地认为所有flake都是镜面，不考虑吸收和漫反射，可以直接使用上述<span class="math inline">\(f_p=f_p^{spec}\)</span> 的形式</p><p>上面提到过，定义为<strong>散射光与入射光比值</strong>的phasefunction具有可逆性，我们再额外考虑菲涅尔效应，得： <spanclass="math display">\[f_a(w_i\rightarrow w_o) = f_p(w_i\rightarrow w_o)F(h) \sigma_t(w_i) =\frac{D(h)F(h)\sigma_t(w_i)}{4\sigma(w_i)}\]</span> 由于 <span class="math inline">\(\sigma_t(w_i) =\rho\sigma(w_i)\)</span> <span class="math display">\[f_a(w_i \rightarrow w_o) = \frac{\rho D(h)F(h)}{4}\]</span></p><blockquote><p>注意：菲涅尔项的含义是：反射光的比例，另一部分是折射（被吸收）了，而不是穿过去了！</p><p>SpongeCake是一个表面模型，下文要考虑的Transmission也只是穿过这个表面的光线，而不是被折射的光线。故可以发现下面用的还是F(h) 而非1 - F(h)</p></blockquote><p><img src="http://lxtyin.ac.cn/img/Gemo/spongcake1.png" /></p><p>考虑整个部分的贡献，可以写出下面的积分式： <spanclass="math display">\[f_r(w_i \rightarrow w_o) = \int_o^T \frac{f_a(w_i \rightarroww_o)}{cos(w_i)cos(w_o)} \cdot att(w_i,t)\cdot  att(w_o,t) \cdot d_t \\att(w,t) = exp\left(-\frac{t}{cos(w)} \sigma_t(w)\right)\]</span> 其中 <span class="math inline">\(att\)</span>指的是一个方向上的衰减，使用上文体渲染中推导出的式子，分母项的 <spanclass="math inline">\(cos(w_i)\)</span> 来自于brdf的定义，<spanclass="math inline">\(cos(w_o)\)</span>是因为体渲染积分本身是在出射光线上积的，要将积分域转换到深度上。</p><p>由此代入，我们得到了下面形式： <span class="math display">\[f_r(w_i \rightarrow w_o) &amp;=&amp; \frac{\rhoD(h)F(h)}{4cos(w_i)cos(w_o)}  \int_o^T att(w_i,t)\cdot  att(w_o,t) \cdotd_t \\&amp;=&amp;...\\&amp;=&amp; \frac{D(h)F(h)G(w_i, w_o)}{4cos(w_i)cos(w_o)}\]</span> 其中： <span class="math display">\[G(w_i, w_o) &amp;=&amp; \frac{1 - exp(T\rho(\Lambda(w_i) +\Lambda(w_o)))}{\Lambda(w_i) + \Lambda(w_o)}\\\Lambda(w) &amp;=&amp; \frac{\sigma(w)}{cos(w)}\]</span> 推导过程中套入了 <span class="math inline">\(\sigma_t = \sigma\rho\)</span>，中间不难就不想码了）</p><p>这样就有了一个类似传统BRDF的形式，只需要更改法线分布和 <spanclass="math inline">\(G\)</span> 项。</p><p><img src="http://lxtyin.ac.cn/img/Gemo/spongcake2.png" /></p><p>考虑透射，也非常简单：只需更改上述积分的一段长度，推导容易得到：<span class="math display">\[G(w_i, w_o) = \frac{1 - exp(T\rho(\Lambda(w_i) +\Lambda(w_o)))}{\Lambda(w_i) + \Lambda(w_o)} \cdotexp(T\rho\Lambda(w_o))\]</span> 其中 <span class="math inline">\(cos(w_o \lt0)\)</span>，已经考虑到。</p><h4 id="sggx">SGGX</h4><p>https://dl.acm.org/doi/abs/10.1145/2766988</p><p>这篇文章提出了一种可以自由控制的Microflake分布，使用一个3x3的正定对称矩阵<span class="math inline">\(S\)</span> 控制一个椭球微片的形态。</p><p><span class="math display">\[S = (w_1, w_2, w_3)\left(\begin{matrix}S_{11} &amp; 0 &amp; 0\\0 &amp; S_{22} &amp; 0\\0 &amp; 0 &amp; S_{33}\end{matrix}\right)(w_1, w_2, w_3) ^T\]</span> <span class="math inline">\(w_1, w_2, w_3\)</span>是椭圆的三个轴，这里看似是用一个transform矩阵定义椭球。但文章用了另一种定义。</p><p>用二次型来定义椭球，椭球上的点 <span class="math inline">\(P\)</span>有 <span class="math display">\[P^TSP = \frac{\sqrt{|S|}}{\pi}\]</span> 因此说矩阵 <span class="math inline">\(S\)</span>是正定对称的。不过需要注意式子右边并不是常见的1，它相当于为椭圆的三个轴添加了同一个缩放，可能是为了让椭球在某方向的投影面积更易于表示？</p><p>椭球长这样：</p><p><img src="http://lxtyin.ac.cn/img/Gemo/sggx1.png" /></p><p>如果仅考虑 <span class="math inline">\(P^TSP\)</span>对应的标准型（即忽略旋转），我们得到椭球的表达式： <spanclass="math display">\[S_{11}x^2 + S_{22}y^2 + S_{33}z^2 = \frac{\sqrt{|S|}}{\pi}\]</span> 先推导这个椭球在x轴（即旋转后的 <spanclass="math inline">\(w_1\)</span> 轴）的投影 <spanclass="math inline">\(A_x\)</span>，在 <span class="math inline">\(x =0\)</span> 时： <span class="math display">\[\frac{S_{22}\pi}{\sqrt{|S|}}y^2 + \frac{S_{33}\pi}{\sqrt{|S|}}z^2 = 1 \\A_x = \sqrt{S_{11}}\]</span> 任意方向 <span class="math inline">\(w_i\)</span>的投影：（推导跳了先（ <span class="math display">\[\sigma(w_i) = \sqrt{w_i^TSw_i}\]</span> 表面法线（unnormalized）： <span class="math display">\[\frac{\partial P^TSP}{\partial P} = 2SP\]</span> 法线分布：（推导跳了（ <span class="math display">\[D(w_m) = \frac{1}{\pi \sqrt{|S|}(w_m^TS^{-1}w_m)^2}\]</span>应用举例：在SpongeCake模型中，用SGGX来做fiber的分布，fiber是条状的，我们可以更简单地使用一个<span class="math inline">\(\alpha\)</span> 参数控制fiber形状。 <spanclass="math display">\[S = (w_1, w_2, w_3)\left(\begin{matrix}1 &amp; 0 &amp; 0\\0 &amp; 1 &amp; 0\\0 &amp; 0 &amp; \alpha^2\end{matrix}\right)(w_1, w_2, w_3) ^T\]</span></p><h4 id="梳理">梳理</h4><p>VolumeRendering是基于RTE进行渲染，可以代入任意介质，而一个介质由PhaseFunction以及 <span class="math inline">\(\sigma_t,albedo\)</span>（也可以等效为 <span class="math inline">\(\sigma_a,\sigma_s\)</span>）定义，其中Phase function影响散射，各种 <spanclass="math inline">\(\sigma\)</span> 系数影响传播，Phasefunction与medium的sample distance, transmittance均无关。</p><p>Microflake是一种介质模型，可以代入任意形式的微薄片，密度 <spanclass="math inline">\(\rho\)</span>是微薄片的属性，而非任意介质都有的。SGGX是Microflake的一种具体实现，通过正定矩阵定义了微薄片的<span class="math inline">\(D(h), \sigma\)</span> ，通过他们以及 <spanclass="math inline">\(\rho\)</span> 推导Phase Function和 <spanclass="math inline">\(\sigma_t\)</span></p><p>Microflake也有一些不同的实现模型，它仅仅只是一种描述微薄片的思想。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>Volume Rendering</tag>
      
      <tag>Microflake</tag>
      
      <tag>SpongeCake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵微积分</title>
    <link href="/2024/08/19/%E7%AC%94%E8%AE%B0/%E5%BC%A0%E9%87%8F%E5%88%86%E6%9E%90%EF%BC%88%E7%9F%A9%E9%98%B5%E5%BE%AE%E7%A7%AF%E5%88%86%EF%BC%89/"/>
    <url>/2024/08/19/%E7%AC%94%E8%AE%B0/%E5%BC%A0%E9%87%8F%E5%88%86%E6%9E%90%EF%BC%88%E7%9F%A9%E9%98%B5%E5%BE%AE%E7%A7%AF%E5%88%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><span class="math display">\[\newcommand{\vec}{\bold}\]</span></p><h4 id="约定">约定</h4><ul><li>矩阵大写，向量小写，标量不加粗，如 <span class="math inline">\(\vecA, \vec b, c\)</span></li><li>一般的方向等向量都按照列向量处理，书写上 <spanclass="math inline">\([x_1,x_2,..x_n]\)</span>按照直观理解为横向量，列向量需要加转置 <spanclass="math inline">\([...]^T\)</span>。</li><li>矩阵乘法直接忽略符号，<span class="math inline">\(\times\)</span>表示叉乘，<span class="math inline">\(\cdot\)</span> 表示点乘。</li></ul><h5 id="jacobin矩阵">Jacobin矩阵</h5><p>考虑一个 <span class="math inline">\(n\)</span> 元输入（<spanclass="math inline">\(\vec x = x_1,...x_n\)</span>），<spanclass="math inline">\(m\)</span> 元输出（<spanclass="math inline">\(\vec y = y_1,...y_m\)</span>）的函数 <spanclass="math inline">\(\vec y = f(\vec x)\)</span>，我们定义： $$ J = =<span class="math display">\[该矩阵即为Jacobin矩阵，为什么定义成这样？如果我们令 $\vec {dx} = [dx_1,dx_2..dx_n]^T, \vec {dy} = [dy_1, dy_2..dy_m]^T$，由于\]</span> dy_i = _{j=1}^n dx_j <span class="math display">\[会得到：\]</span> J = $$这就是Jacobin矩阵的物理意义，它是偏导数，也可以认为是从参数空间 <spanclass="math inline">\(\vec{dx}\)</span> 到 <spanclass="math inline">\(\vec{dy}\)</span>的变换矩阵，其行列式就对应了这一变换的缩放比例。</p><p>在积分域转换时，积分变量变化，需要乘上对应的 <spanclass="math inline">\(|\vec J|\)</span>，以确保积分正确。</p><p>另一个常见的定义是梯度 <span class="math inline">\(\nabla f(\vec x) =[\frac{\part f}{\part x_1}, \frac{\part f}{\part x_2}... \frac{\partf}{\part x_n}]^T\)</span>，对于任意方向 <span class="math inline">\(\vecv = [v_1, v_2,...v_n]^T\)</span>，实值函数在该方向上的导数（方向导数）为<span class="math inline">\(\vec v \cdot \nablaf\)</span>，即方向与梯度的点乘。因此梯度就是函数值下降最快的方向。</p><p><span class="math inline">\(\vec J\)</span>可以看作是非实值函数的“梯度”，同样的，<span class="math inline">\(\vec J\vec v\)</span> 即为函数在 <span class="math inline">\(\vec v\)</span>方向上的导数。</p><p>实值函数对向量的求导，导数结果认为和自变量同维度，例如 <spanclass="math display">\[\frac{\part(\vec x^T\vec x)}{\part{\vec x}} = 2\vec x\]</span> 此时 <span class="math inline">\(\vec x\)</span>为列向量，结果也为列向量。</p><h5 id="divergence-curl-laplacian">Divergence &amp; Curl &amp;Laplacian</h5><p>散度、旋度和拉普拉斯，都从 <span class="math inline">\(\vec J, \vecH\)</span> 中获得，具体意义等用到了再来理解。</p><h5 id="hessian矩阵">Hessian矩阵</h5><p>实值函数 <span class="math inline">\(f(\vec x)\)</span> 的二阶导： $$H = = J(f(x)) = $$</p><p><span class="math inline">\(\vec H\vec v = \vec J(\nabla f(\vecx))\vecv\)</span>，事实上表示梯度在特定方向上的导数；也就是可以将Hessian矩阵看做方向向量<span class="math inline">\(\vec v\)</span>到梯度导数的映射；因此，<span class="math inline">\(\vec H\)</span>的几个特征向量代表了曲面的主曲率方向，特征值则反映了凹凸性。</p><p><span class="math inline">\(\vec v^T \vec H \vec v\)</span>即为实值函数的方向二阶导；注意这是一个实数，而上面的 <spanclass="math inline">\(\vec H\vec v\)</span> 是一个向量。</p><p>若任意方向的二阶导都大于0，即任意 <span class="math inline">\(\vecv^T \vec H \vec v &gt; 0\)</span>（<span class="math inline">\(\vecH\)</span> 矩阵正定），且任意方向一阶导为0（等价于梯度 <spanclass="math inline">\([\frac{\part f}{\part x}, \frac{\part f}{\party}]^T = \vec0\)</span>），则函数在这一点处是一个极小值点；极大值点同理。</p><h5 id="一些容易证明的式子">一些容易证明的式子</h5><p>张量微积分其实就是在考虑输入变量和输出变量两两之间的偏导数，下面列出一些常见的式子的导数，记住这些结论会方便很多。</p><p>1）<span class="math inline">\(\vec x\)</span> 与 <spanclass="math inline">\(\vec A\)</span> 无关 <span class="math display">\[\vec y = \vec A \vec x \\\frac{\part \vec y}{\part \vec x} = \vec A\]</span> 2）<span class="math inline">\(\vec x, \vec y\)</span> 均与<span class="math inline">\(\vec A\)</span> 无关 <spanclass="math display">\[\alpha = \vec y^T\vec A \vec x \\\frac{\part \alpha}{\part \vec x} = \vec y^T \vec A \\\frac{\part \alpha}{\part \vec y} = \vec x^T \vec A^T \\\]</span> 注意这里将 <span class="math inline">\(\vec A \vec x\)</span>转置了一下。不写成 <span class="math inline">\(\frac{\part \alpha}{\part\vec y} = \vec A \vec x\)</span>，是因为根据 <spanclass="math inline">\(\vec J\)</span>的定义，我们希望标量对向量的偏导是一个横向量。</p><p>3）<span class="math inline">\(\alpha\)</span> 用二次型定义，<spanclass="math inline">\(\vec x\)</span> 与 <spanclass="math inline">\(\vec A\)</span> 无关 <span class="math display">\[\alpha = \vec x^T\vec A\vec x \\\frac{\part\alpha}{\part \vec x} = \vec x^T (\vec A+\vec A^T)\]</span></p><p>4）特别的，在上一条的基础上，<span class="math inline">\(\vecA\)</span> 为对称矩阵时 <span class="math display">\[\alpha = \vec x^T\vec A\vec x \\\frac{\part\alpha}{\part \vec x} = 2\vec x^T \vec A\]</span> 5）类似经典公式： <span class="math inline">\(y = f(x)g(x),y&#39; = g(x)f&#39;(x) +f(x)g&#39;(x)\)</span> <spanclass="math display">\[\alpha = \vec y^T \vec x \\\frac{\part \alpha}{\part\vec z} = \vec x^T \frac{\part\vec y}{\part\vecz} + \vec y^T \frac{\part\vec x}{\part\vec z}\]</span> 此处 <span class="math inline">\(\vec x \vec y\)</span> 都是<span class="math inline">\(\vec z\)</span> 的函数。</p><p><strong>注意：求导的乘法法则用在向量上时，不能改变顺序，即必须是<span class="math inline">\(g(\vec x)f&#39;(\vec x)\)</span>，不能是<span class="math inline">\(f&#39;(\vec x)g(\vecx)\)</span></strong>（TOBE CHECK）</p><p>6）特别地，在上一条的基础上： <span class="math display">\[\alpha = \vec x^T \vec x \\\frac{\part \alpha}{\part\vec z} = 2\vec x^T \frac{\part\vecx}{\part\vec z}\]</span> 7）特别地，在第5条的基础上： <span class="math display">\[\alpha = \vec y^T \vec A\vec x \\\frac{\part \alpha}{\part\vec z} = \vec x^T \vec A^T \frac{\part\vecy}{\part\vec z} + \vec y^T\vec A \frac{\part\vec x}{\part\vec z}\]</span> 将与 <span class="math inline">\(\vec z\)</span> 无关的 <spanclass="math inline">\(\vec A\)</span> 和 <spanclass="math inline">\(\vec x\)</span> 视为一个整体即可。</p><h4 id="矩阵求导">矩阵求导</h4><p>矩阵和向量实质都是多元变量，矩阵之间的求导需要将矩阵拆成向量来做。</p><p>关键词：向量化、Kronecker积、交换矩阵相关的恒等式</p><p>$$ \</p><p> \ 2x $$</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数理基础</tag>
      
      <tag>张量分析</tag>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24届计算机推免 四非0科研图形学菜狗的经验贴（北航vr、南开cs）</title>
    <link href="/2023/09/29/%E6%9D%82%E8%B0%88/24%E5%B1%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A8%E5%85%8D%20%E5%9B%9B%E9%9D%9E0%E7%A7%91%E7%A0%94%E5%9B%BE%E5%BD%A2%E5%AD%A6%E8%8F%9C%E7%8B%97%E7%9A%84%E7%BB%8F%E9%AA%8C%E8%B4%B4%EF%BC%88%E5%8C%97%E8%88%AAvr%E3%80%81%E5%8D%97%E5%BC%80cs%EF%BC%89/"/>
    <url>/2023/09/29/%E6%9D%82%E8%B0%88/24%E5%B1%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A8%E5%85%8D%20%E5%9B%9B%E9%9D%9E0%E7%A7%91%E7%A0%94%E5%9B%BE%E5%BD%A2%E5%AD%A6%E8%8F%9C%E7%8B%97%E7%9A%84%E7%BB%8F%E9%AA%8C%E8%B4%B4%EF%BC%88%E5%8C%97%E8%88%AAvr%E3%80%81%E5%8D%97%E5%BC%80cs%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><img src="http://lxtyin.ac.cn/img/baoyan/nku.png" /></p><h2 id="个人情况">个人情况</h2><p>本科：四非rk1或2</p><p>科研：null</p><p>竞赛：acm区域金（非银川）</p><p>项目：一个图形学lab，一个实时光追渲染器，还有一些乱七八糟的小东西</p><p>意向：cg方向，不考虑直博，学硕专硕无所谓</p><p>不考虑直博主要还是因为没做过科研，风险太大，打算读硕期间根据情况再考虑要不要读博。</p><p>本人一开始是头铁的非图形不走，中途经历了各种人间疾苦后也考虑了别的方向，最后认识到：<strong>在自己主攻的方向都没老师要的话，别的方向就更别想了</strong>，于是又回归到了头铁图形的路子上。</p><p>图形学方向窄，我又想做渲染相关的，可选项其实已经非常少了。</p><h2 id="前期">前期</h2><p>3月份开始准备保研，这时acm已经退役，一边做项目一边联系导师。</p><p>此时我最希望的是能找个组进去打工，即使最后没去成，也能丰富一下科研经历。然而结果非常惨淡，联系导师大多官回，最后也没能进行一段科研实习。这段时间对自己的定位一直摇摆不定，不断自我怀疑，把期待值拉到了一个很低的程度。现在回顾一下，<strong>陶瓷阶段发挥主要作用的还是科研经历</strong>，而这块算是我最大的短板，其实没有必要因此妄自菲薄的。</p><p>不过这段时间积累的一些东西在后面发挥了很大作用：</p><p>一个浙大老师（当时唯一加上的老师）给了两个作业做（包括一个图形学Lab，后面写进简历），花了挺多时间，但因为后面觉得浙计CAD进不去，浙软不太想去，老师又不再浙工招生，就没联系了。</p><p>撸了一个实时光追，当时觉得很nb，每封陶瓷信都附一份渲染图，现在感觉这个行为有点憨，，，，不过通过这个项目算是把图形学基础打牢了，应该也是南开进面的关键。</p><p>因为提前了解到北航比较倾向ACMer，就早早准备，在3月份去考了个CSP，它也的确救回了我稀烂的北航面试（虽然最后没去）。</p><p>期间还心不在焉地去EC和CCFinal打了两块铁，，，，（?</p><h2 id="夏令营">夏令营</h2><table><thead><tr><th>学校/院</th><th>结果</th></tr></thead><tbody><tr><td>中山计算机</td><td>寄</td></tr><tr><td>华师计算机</td><td>寄</td></tr><tr><td>北航计算机</td><td>优营（未签约）</td></tr><tr><td>山大软件</td><td>寄</td></tr><tr><td>深圳大学计算机</td><td>入营放弃</td></tr><tr><td>南开计算机</td><td>offer</td></tr><tr><td>浙大工程师</td><td>寄</td></tr></tbody></table><p>报夏令营突出一个普信，要填科研经历的地方全是空着的，还到处报学硕</p><p>我怎么敢的</p><p>中山寄了情理之中（报学硕、无科研）</p><p>华师寄了情理之中（报学硕、似乎要陶瓷，我没套）</p><p>山大寄了有点没想到</p><p>浙工程师今年貌似bar特别离谱（某fducs优营、预推免冲进贵系的hdu佬都没进）</p><p>北航报名的时候没区分学专且看重ACM，南开cs自己联系导师考核就行了。最后夏令营就是这两个。</p><p>深大VCC图形学非常强，且钱多补助高，地域也好，但我还是做不到彻底丢下title不管，夏令营又和南开的考核重叠，就放弃了。</p><h5 id="北航cs">北航cs</h5><p>预期，北航看中ACM且机试分差大，可以说是鼠鼠唯一有优势的地方了。</p><p>入营不歧视双非，看ACM奖项（但不绝对，rk1还是有用），拼住宿的时候一间三个双非，形成鼠窝（三人最后两优营一个wl第7），群里也看到了好几个别的双非。面试也是考基础知识，客观分，不看背景，对双非还是比较友好的。</p><blockquote><p>这里稍微多提一下：据我观察，真正歧视双非的学校（点名不要的那种）并没有那么多，北航这种放你进来，但是基础知识你就是没打过92学生的话，就不要说自己被歧视了...</p><p>鼠鼠群里经常看到群友说自己又被歧视了，我觉得大家还是多从自己身上找原因吧，这样才有的提升。</p></blockquote><p>机试可以CSP抵分，且按CSP的累计排名抵分（具体规则b站可搜），众所周知CSP百分比排名虚高很严重，抵分大概率是赚的。我CSP440分，估计了一下大概率能抵满，就直接抵了（现场机试oi赛制，有风险）</p><p>虽然最后，很多机考爆0的也进了面试（群友说是人工阅卷了），但机试拉分非常多，机考爆0就很难优营了。</p><p>面试的具体细节就不说了，拷打线代高数概率论+408以及你成绩单上任何一个科目，基本都是基础问题，但我很多记不清了，直接被问穿。事后拿这些题去给考研的同学看，他们都没绷住</p><p>面试寄+机试大概满分，最后是优营rk70+（基本是专硕）</p><p>签约环节，每个老师只能签一个人，竞争非常激烈，vr国重里面几个做渲染的老师都没签成。另一位年轻导师给了我很高评价（感动），但考虑到方向不是很match，后续也还有很多机会，也不太想海这位老师，就和老师开诚布公了。最后没有签约。</p><h5 id="南开cs">南开cs</h5><p>南开cs纯弱com，直接联系导师，完全由课题组安排考核，导师要就等于offer。</p><p>很早在绿裙加的一个学长就跟我强推wbb老师，wbb老师在yj组里，34岁的教授，非常好交流且尊重学生，产出很多Siggraph，在渲染这块做的不错。</p><p>我早期联系了一次，6月份再去联系的时候，仅2分钟就得到了回信，当天中午做了个简单的ppt，下午马上电话交流，是我整个保研过程中最通畅丝滑的一天。电话交流的时候问了几个和我的项目相关的问题，当时的直观感受就是：老师是了解技术细节的，能够给我实质性的帮助（可能我见的主打一个管理的老师太多了）。</p><p>鼠鼠本科学校还出息了一次，承办了一个学术会议，wbb老师来报告，我直接线下陶瓷</p><p>后面认真做了老师的考核（大半个月），8月初答辩当天就得到了准确、无歧义的回复：给我保留一个学硕名额。</p><p>南开的title+学硕+强组好导+match方向，对此我已经不需要犹豫了，南开cs没有鸽人历史，因此我也决定相信老师，给出了一定会去的承诺，预推免开摆了。</p><p>后续到南开线下面试，大老板请了组里所有人一顿饭，感觉大伙水平都很高！我不出意外地是组里本科最差的，好在有块牌还不至于自卑哈哈哈（X</p><h2 id="预推免">预推免</h2><p>驾校，启动！</p><h2 id="关于去向">关于去向</h2><p>平心而论，对于这个去向自己是否足够满意：我想是满意的，好于我最初的预期。但的确因为更好的都没有去尝试，略有遗憾。在投递的时候还是因为种种因素给自己设限了。</p><p>不知道北航预推免有没有机会拿到vr强导offer，也不知道自己是否有一丝可能冲进浙计硕、南计学硕、清深imdt之类的地方。如果试过，即使收个拒信，现在应该也会少纠结一点。</p><p>最大的遗憾就是——我不敢说自己尽力了。之前和群友聊的时候我曾表达过类似的观点：选择最适合自己的就好，不一定非得搏“上限”。</p><p>然而，三年苦读下来了，真的不想看看自己能到什么地步吗？</p><h2 id="最后">最后</h2><p>给下一届的一点小建议：</p><p>不要给自己设限，211把你拒了不代表华五一定不要你，一切皆有可能。</p><p>除了纸面上的title、排名、科研、竞赛、英语等指标，大伙也要注重软实力（面试、心态、表达能力等等），影响很大，群里一位与我bg相似的佬，一路从fdu学硕杀到rw强组直博，了解后发现他的软实力要远远强于我，不得不服。</p><p>关于鸽与被鸽，我衷心希望大家都能真诚一点，让保研别那么累。当然这点我没办法要求大家都做到，环境如此。</p><p>广告时间：</p><p><img src="http://lxtyin.ac.cn/img/baoyan/green.jpg" style="zoom: 50%;" /></p><p>全国最大非商业用爱交流计算机保研群，在绿群一年，不管怎么说，它是一个打破信息壁垒的地方，在里面也认识了很多很nb的学长<del>（可惜没有学姐）</del>和同僚，包括向我力荐wbb老师的Xu学长；四非出生的选手往往有很重的title情结，然而经过绿群的洗礼，我越发觉得觉得：导师、方向、地域等等因素，要比你是所谓的中九还是次九重要的多。</p><p><img src="http://lxtyin.ac.cn/img/baoyan/green_mouse.jpg" style="zoom: 50%;" /></p><p>绿群双非鼠鼠联盟，群里常出现的院校档次会低一些，对于目标是211到普通985的同学，这个群里的有效信息密度会高一点，当然里面也藏着各种巨佬。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>推免</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图形学杂记</title>
    <link href="/2023/09/22/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%9D%82%E8%AE%B0/"/>
    <url>/2023/09/22/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%9D%82%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="简介">简介</h3><p>这是一个图形学杂记，从光栅化到RT的诸多东西都乱记在里面，大多数只在这里记录了基本思想（有些暂时理解不深的也简记在这里），具体的一些东西可能会另开一贴来记录。</p><h3 id="投影">投影</h3><p>“投影”直观上容易被理解为将三维空间物体变换到二维屏幕的过程（可以有这样一种降维的线性变换），但如果直接用矩阵来做这样一件事，不方便处理深度信息（遮挡效果）。</p><p>故实际上我们说的投影矩阵，是将三维空间中的一个长方体或平头截体（观察区域）映射到标准立方体（CanonicalCube，<span class="math inline">\([-1,1]^3\)</span>）的过程，这个空间也叫<strong>裁剪空间</strong>。映射到这里的好处是方便进行后续操作。</p><h4 id="正交投影">正交投影</h4><p>将一个长方体映射到 <spanclass="math inline">\([-1,1]^3\)</span>，比较简单</p><p>很多时候我们会在正交投影时把 <span class="math inline">\(z\)</span>倒过来，这样摄像机朝 <span class="math inline">\(-z\)</span>方向，而深度缓冲中的 <span class="math inline">\(z\)</span>越小表示离摄像机越近。</p><h4 id="透视投影">透视投影</h4><p>透视投影的观察区域是一个平头截体，我们希望也使用一种（四维矩阵可表示的）线性变换将它映射到<span class="math inline">\([-1,1]^3\)</span>。</p><p>思路：首先进行的是一个“压扁”的缩放过程，令远处的平面缩放幅度更大，近平面不变，使得平头截体变成一个长方体，随后进行正交投影。</p><p>最简单的想法：让一条观察射线（朝-z方向）上所有 <spanclass="math inline">\(x,y\)</span> 坐标缩放后都相同，先假定 <spanclass="math inline">\(z\)</span> 轴不变。</p><p>通过相似三角形容易计算出新坐标应该为 <spanclass="math inline">\((n/z\times x,n/z\times y,z)\)</span></p><p>编出一个变换矩阵，其中参数 <span class="math inline">\(n\)</span>为近平面的 <span class="math inline">\(z\)</span> 坐标（负值！） <spanclass="math display">\[\begin{bmatrix}n&amp;0&amp;0&amp;0\\0&amp;n&amp;0&amp;0\\?&amp;?&amp;?&amp;?\\0&amp;0&amp;1&amp;0\\\end{bmatrix}\times\begin{bmatrix}x\\y\\z\\1\\\end{bmatrix}=\begin{bmatrix}n/z\times x\\n/z\times y\\z\\1\\\end{bmatrix}\rightarrow\begin{bmatrix}nx\\ny\\z^2\\z\\\end{bmatrix}\]</span></p><p>我们发现1，2，4行的参数都很容易确定，但是第三行似乎没法搞？</p><p>问题出现了，这样的变换似乎不是一个线性变换（即使在四维下）</p><p>那么只能放弃追求 <span class="math inline">\(z\)</span>轴不变了。</p><p>实际的投影矩阵要求只有：近平面坐标不变，以及远平面的z轴（<spanclass="math inline">\(f\)</span>）不变</p><p><span class="math display">\[\begin{bmatrix}n&amp;0&amp;0&amp;0\\0&amp;n&amp;0&amp;0\\0&amp;0&amp;A&amp;B\\0&amp;0&amp;1&amp;0\\\end{bmatrix}\times\begin{bmatrix}x\\y\\n\\1\\\end{bmatrix}=\begin{bmatrix}nx\\ny\\n^2\\n\\\end{bmatrix}\]</span></p><p><span class="math display">\[\begin{bmatrix}n&amp;0&amp;0&amp;0\\0&amp;n&amp;0&amp;0\\0&amp;0&amp;A&amp;B\\0&amp;0&amp;1&amp;0\\\end{bmatrix}\times\begin{bmatrix}x\\y\\f\\1\\\end{bmatrix}=\begin{bmatrix}nx\\ny\\f^2\\f\\\end{bmatrix}\]</span> <span class="math display">\[An+B=n^2\\Af+B=f^2\\A = n + f\\B = -nf\]</span></p><p>由此得到了这个压缩矩阵： <span class="math display">\[\begin{bmatrix}n&amp;0&amp;0&amp;0\\0&amp;n&amp;0&amp;0\\0&amp;0&amp;n+f&amp;-nf\\0&amp;0&amp;1&amp;0\\\end{bmatrix}\]</span></p><p>现在得到需要的矩阵了，它满足变换后<strong>近平面不变，远平面 <spanclass="math inline">\(z\)</span> 不变，且中间的 <spanclass="math inline">\(z\)</span> 坐标依旧保持顺序</strong>的性质，变换到<span class="math inline">\([-1,1]^3\)</span> 之后大概长这样：</p><figure><img src="http://lxtyin.ac.cn/img/Gemo/projection.png"alt="projection" /><figcaption aria-hidden="true">projection</figcaption></figure><p>（图源网络且魔改）</p><p>可以看到，虽然它让中间部分保持了顺序，深度测试不会出错，但是不均匀地拉伸会让三角形内部的<strong>插值</strong>有很大问题，需要进行下一节所说的透视插值矫正。</p><p>但这样的不均匀也不是没有好处：它将深度测试中我们所说的“非均匀精度分配”直接实现了！</p><blockquote><p>LearnOpenGL：</p><p>可以看到，深度值很大一部分是由很小的z值所决定的，这给了近处的物体很大的深度精度。这个（从观察者的视角）变换z值的方程是嵌入在投影矩阵中的，所以当我们想将一个顶点坐标从观察空间至裁剪空间的时候这个非线性方程就被应用了。</p></blockquote><p>再次体会到投影矩阵的强大</p><p>手动推导一下这个深度变换式子：</p><p>“压扁”后：<span class="math inline">\(z_1 = n+f-nf/z\)</span></p><p>标准坐标系内：<span class="math inline">\(z_2=-1+2\times(n-z_1)/(n-f)\)</span></p><p>如果深度值范围是0-1：<span class="math inline">\(z_3 = (z_2+1)/2 =(n-z_1) / (n - f) = \frac{(1/z-1/n)}{(1/f-1/n)}\)</span></p><p>和LearnOpenGL上给出的式子完全一致！简洁优雅</p><h5 id="透视插值矫正">透视插值矫正</h5><p>图不想画了，二维情况下的计算不难，推广到三维也很合理，直接给出结论：</p><p>设屏幕空间下，某点的重心坐标为 <spanclass="math inline">\(a,b,c\)</span>，则该点的实际深度值 <spanclass="math inline">\(w_0\)</span> <span class="math display">\[\frac{1}{w_0}=\frac{a}{w_1}+\frac{b}{w_2}+\frac{c}{w_3}\]</span> 插值结果（假设对 <span class="math inline">\(p\)</span>这个属性插值）： <span class="math display">\[p_0 = w_0\times(\frac{ap_1}{w_1}+\frac{bp_2}{w_2}+\frac{cp_3}{w_3})\]</span> <ahref="https://zhuanlan.zhihu.com/p/403259571">推导链接</a></p><p><strong>注意</strong>：这里用 <span class="math inline">\(w\)</span>表示顶点在<strong>透视投影变换前</strong>的 <spanclass="math inline">\(z\)</span>坐标，为顶点的实际深度，要和变换到标准设备坐标下之后的 <spanclass="math inline">\(z\)</span> 坐标作区分。</p><p>这个 <span class="math inline">\(w_{123}\)</span>是怎么留下来的呢？还记得投影矩阵变换后的 <spanclass="math inline">\(w\)</span> 分量吗，它恰恰等于原先的 <spanclass="math inline">\(z\)</span>。我们通常会在齐次除法中保留它不变（因为后面也不会用到线性变换了，留着也没关系（视口变换可以直接操作）。</p><p>最后，深度测试使用的深度值并不是 <spanclass="math inline">\(w\)</span>（如果用 <spanclass="math inline">\(w\)</span> 就做不到非均匀分配精度了），而是NDC下的<span class="math inline">\(z\)</span> 坐标。我们可以用三个顶点的 <spanclass="math inline">\(z\)</span> 坐标按照上述方式插值到单点的 <spanclass="math inline">\(z\)</span>坐标，它早在投影时便完成了精度的分配。</p><h3 id="反走样">反走样</h3><p>可以采用先模糊，再采样的方法。</p><p>理解走样的来源是：采样频率跟不上信号变化的速率，两个采样点之间信号可能发生了很多未被采集到的变化。</p><p>模糊操作本身是对信号做了一个均值处理，此时一个像素上包含了其附近像素的信息，故模糊后采样能非常有效地缓解锯齿。</p><p>另一个角度：模糊操作相当于一个低通滤波，除去了高频部分。而锯齿现象本质是源于对高频信号采样时的信息缺失。</p><p>从这两个角度都可以理解：为什么先采样，后模糊不行。</p><p>模糊的一种办法是对连续图像取平均得到离散结果。具体到三角形上，可以在每个像素处根据覆盖三角形的面积来改变颜色，再具体的，可以在每个像素中设多个采样点（4个，9个..），看几个在三角形内来粗略计算面积（MSAA方法）。</p><h3 id="着色">着色</h3><ul><li>FlatShading，逐三角形着色，每个三角形的法线都完全一样，适用于有锐利转折的平面。</li><li>GouraudShading，逐顶点着色，在顶点处计算出颜色，将颜色/光强插值到各个片元。<ul><li>双线性光强插值指的也是这个</li></ul></li><li>PhongShading，逐像素着色，将顶点法线插值到像素上后逐像素计算颜色。效果最平滑，也比较常用。<ul><li>双线性法向插值指的也是这个</li></ul></li></ul><p>顶点法向量：近似地由各个相邻面的法向量平均得出。</p><h4 id="具体插值方法">具体插值方法</h4><h5 id="重心坐标">重心坐标</h5><p>重心坐标（Barycentric Coordinates）定理：即三角形中任意一点 <spanclass="math inline">\(X\)</span>，都可以表示成 <spanclass="math inline">\(X=aA+bB+cC\)</span>，其中 <spanclass="math inline">\(ABC\)</span> 为三个顶点的坐标向量，<spanclass="math inline">\(abc\)</span> 为系数且满足 <spanclass="math inline">\(a+b+c=1\)</span>。</p><p>一个顶点的重心坐标可以用这样的 <spanclass="math inline">\((a,b,c)\)</span>来表示，实际上，可以根据顶点对面的三角形面积占比来快速计算 <spanclass="math inline">\(abc\)</span>（具体图去百度找一下）</p><p>重心坐标本身就代表了三个顶点在此点所占的权重，故可以轻松得到插值比例。</p><h5 id="双线性插值">双线性插值</h5><p>具体思路：先插值一次得到每条线上的值，再插值得到每个位置上的值。</p><p>可以利用扫描线算法，进行增量插值。</p><h4 id="图像放大方法">图像放大方法</h4><p>高分辨率对象上应用低分辨率图像时常用算法：</p><ul><li>Nearest：取最近像素</li><li>Linear：线性插值，按距离分配权重，取周边像素均值<ul><li>BiLinear：对于图像而言的双线性插值，按水平和垂直线性插值两趟</li></ul></li><li>Bicubic：双三次插值，效果更好，原理涉及信号系统（暂略）</li></ul><h4 id="图像缩小方法">图像缩小方法</h4><p>低分辨率对象上应用高分辨率图像（渲染远处物体上常见这种情况），一个屏幕像素对应了多个纹理像素，采样时理应取均值。</p><p>但按原本的采样方式，会仅取到中心处的纹理像素，它显然无法代表这一片区域的像素值。也就是说我们需要进行区间查询操作，实际进行的是单点查询。</p><p>于是有了<strong>mipmap</strong>（多级渐远纹理），其本质是预处理的思路，有点类似线段树。</p><h4 id="mipmap">Mipmap</h4><p>即对于一张纹理，事先将其缩放为一半、1/4、1/8...（缩放时计算了区间均值），将这些缩小的纹理全都存放起来。这些全部存放的空间仅为原先的<span class="math inline">\(4/3\)</span> 倍。</p><p>具体渲染时，对于一个即将渲染的像素（已经知道了其uv），可根据它与相邻像素uv的差值，估算出它覆盖了多大的纹理（<code>pixel footprint</code>）。</p><p>注意这是一种粗略的近似，<strong>像素实际覆盖的纹理区域不一定是矩形</strong>，而mipmap方法根本上是对一个矩形区域求了均值，故这里并不完全准确。</p><p>假设现在这个像素需要覆盖一个宽为 <spanclass="math inline">\(L\)</span>（个纹理像素）的正方形，那么实际如何利用多级渐远纹理取样？</p><ul><li>Trilinear：三线性插值，计算 <span class="math inline">\(D=log_2L\)</span>，即要在第 <span class="math inline">\(D\)</span>层纹理上取样比较合理，<span class="math inline">\(D\)</span>为浮点数时就，在 <span class="math inline">\(\lfloor D\rfloor\)</span>和 <span class="math inline">\(\lfloor D\rfloor +1\)</span>层分别进行双线性插值，然后再依据 <span class="math inline">\(D\)</span>插值一次得到实际颜色。</li></ul><h4 id="ray-differential">Ray differential</h4><p>上述计算footprint的方式只在光栅化框架中可行，在路径追踪中，我们需要追踪纹理uv对屏幕像素xy的偏导，如<span class="math inline">\(\frac{\partial u}{\partialx}\)</span>，即屏幕像素偏移1单位时，uv偏移了多少，它可以用于估计pixelfootprint。</p><p>具体而言，我们可以记录当前光线对屏幕像素的偏导 <spanclass="math inline">\(\frac{\partial \bold R}{ \partialxy}\)</span>，其中 <span class="math inline">\(\bold R = \vec O + t\vecD\)</span>，在光线传播过程中分别维护 <spanclass="math inline">\(\frac{\partial \vec O}{\partial x}\)</span>，<spanclass="math inline">\(\frac{\partial \vec D}{\partialx}\)</span>....等等信息。</p><p>具体更新方式可查原论文，在大多渲染器框架中此功能都已经实现。</p><h4 id="各向异性过滤">各向异性过滤</h4><p>Mipmap只能求正方形区域的均值，故在覆盖斜着的、长的纹理时会出现overblur（过度模糊）的现象。</p><p>各向异性过滤额外预处理了一些不等比缩放的纹理（具体图百度），空间翻到了3倍，能很好地处理覆盖区域为长方形的情况，但对于斜长的情况还是会overblur。</p><p>EWA filtering是一种更复杂的方法，具体略过。</p><h3 id="纹理应用">纹理应用</h3><h4 id="环境贴图">环境贴图</h4><p>可以用来做天空盒、环境光等<strong>全景贴图</strong>。</p><p>一种方式是使用六个张纹理做立方体贴图，另一种方式是使用球面的展开图。</p><p>两种方式都能用三维向量来采样纹理，球面展开方式是将球面坐标作为展开图的xy坐标。</p><p>通常，将矩形贴图转换到球面坐标的环绕方式是这样的：</p><figure><img src="http://lxtyin.ac.cn/img/Gemo/envmap.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><h4 id="法线贴图">法线贴图</h4><p>字面意思很好理解，用纹理来直接指定每一个像素上的法线，能在平面上做到丰富的光照细节。</p><p>但直接在模型空间下指定法线，不是太好。例如当一个立方体的六个面都使用相同的纹理时，我们却不得不为它分配六张不同的法线贴图。</p><p>一个更好的坐标系是切线空间，在切线空间下表示法线，可以只关注平面，而不关心其方向。</p><h5 id="切线空间">切线空间</h5><figure><img src="http://lxtyin.ac.cn/img/Gemo/tangent.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>对于一个表面而言，法线是唯一的，而切线可能有很多种，通常会将uv展开的方向定义为切线。</p><p>具体如图所示，绿色为空间中任一个三角形，灰色部分为将这个三角形的纹理（uv）直接贴上去的样子，我们定义沿纹理<span class="math inline">\(x\)</span> 轴方向的单位向量为切线 <spanclass="math inline">\(T\)</span>（Tangent），同时沿纹理 <spanclass="math inline">\(y\)</span> 轴方向的单位向量为 <spanclass="math inline">\(B\)</span>（bitangent），三角形的法线朝向 <spanclass="math inline">\(+z\)</span> 方向，这样的空间叫做切线空间。</p><p>切线 <span class="math inline">\(T\)</span>通常作为顶点数据的一部分，会在模型中给定，如果希望自己算，也可以通过上图中三角形的另外两点的顶点坐标和uv列式计算得到。</p><p>具体式子可以来这边找到https://learnopengl.com/Advanced-Lighting/Normal-Mapping</p><p>使用切线空间来应用法线贴图的流程大概是这样的：</p><ul><li>将 Normal、Tangent以及MVP这类的矩阵传入顶点着色器，也可以预先将法线矩阵（3x3的逆的转置的那个）计算好传入。</li><li>叉乘得到Bitangent，将三个轴都变换到世界坐标系下（同法线变换方法），得到 TBN矩阵</li><li>把 TBN 矩阵传入片段着色器</li><li>在片段着色器中，从 Normal map 中采样法线，然后让这个法线左乘 TBN矩阵即可得到世界坐标系下的法线。<ul><li>TBN是一个仅有旋转的3x3矩阵，故不需要再进行法线变换。</li></ul></li></ul><p>如果在观察坐标系下计算光照，也是同理。</p><p>我们通常看到的法线贴图偏蓝色，正是因为切线空间下法线大多朝向 <spanclass="math inline">\(+z\)</span> 方向（0, 0,1），仅对一部分细节有所扰动。</p><p>在多个三角面共享顶点时，我们用类似法线的处理思路：如果希望有平滑的效果，就平均一下，如果要锐利就把公共顶点拆开。</p><h5 id="细节">细节</h5><p>normalmap会导致某些角度的入射/出射光，在宏观表面的上方，但却在normal所示的表面下方（反之一样），这种情况下进行光照计算会有歧义。</p><p>参照mitsuba中的法线贴图实现，若光源方向遇到了这种情况，直接舍弃；而若观察方向遇到这种情况，不舍弃，按照normal所示的新表面计算（可能由反射变成透射）</p><p><img src="http://lxtyin.ac.cn/img/Gemo/normal_problem.png" /></p><p>这个地方究竟应该如何舍弃，目前我还没找到什么逻辑严谨的定论，暂且按照mitsuba来。</p><p>upd:最新发现，这个特性通常在几何项中被处理（包括mitsuba中），也即两个方向都会产生这样的遮挡。</p><h4 id="凹凸贴图">凹凸贴图</h4><p>更直观的做法：不是直接指定每个像素的法线，而是指定每个像素的高度偏移，然后自行计算法线。</p><p>计算法线同样在切线空间下进行，假设原法线朝向 <spanclass="math inline">\((0, 0,1)\)</span>，可以在凹凸贴图上做个差分来计算新法线。 <spanclass="math display">\[dp/du=c_1\times (h(u+1)-h(u))\\dp/dv = c_2\times (h(v+1)-h(v))\\n=(-dp/du,-dp/dv,1)\]</span></p><h4 id="阴影贴图">阴影贴图</h4><p>实现阴影的经典办法，但是有非常多弊端。</p><p>思路：首先在光源位置观察场景，走一遍光栅化流程（但不着色），渲染出一张阴影贴图，每个像素上记录深度。</p><p>然后再正常渲染场景，对于每个片段，我们再将这个片段变换到光源的观察坐标系下，做一次投影，找出这个片段在阴影贴图上对应的位置。然后对比深度值，以判断这个像素是否能被光源看到。</p><p>上述是最简单的阴影贴图逻辑，它只能处理平行光，只考虑了单光源，只能产生硬阴影，且依赖阴影贴图的分别率，容易产生锯齿。</p><h5 id="多光源">多光源</h5><p>本身我们在着色时，多光源就是分别着色后叠加的。因此阴影只对每个光源分开考虑就好。</p><h5 id="软阴影">软阴影</h5><p>麻烦 跳过</p><h3 id="hdr与色调映射">HDR与色调映射</h3><p>HDR <code>High Dynamic Range</code>高动态范围，指使用不限制的范围（超过 <spanclass="math inline">\([0,1.0]\)</span>）来表达场景亮度，在需要显示时（显示器只能显示<span class="math inline">\([0,1.0]\)</span>之间的亮度）再转换到低动态范围<code>LDR</code>。转换的方式叫色调映射（Tonemapping），一般不是简单的线性转换，而是通过特殊手段尽可能保留场景细节。</p><h5 id="reinhard色调映射">Reinhard色调映射</h5><p><span class="math inline">\(f(x) = \frac{1}{x+1}\)</span></p><p>简单好用，偏向亮色</p><h3 id="gamma矫正">Gamma矫正</h3><p><strong>物理亮度</strong>是正比于能量（光子数量）的，人眼看到的<strong>感知亮度</strong>实际为<span class="math inline">\(物理亮度^{1/gamma}\)</span></p><p>如果我们不进行任何处理，图片直接按物理亮度存储，显示器按物理亮度发射光线，我们人眼看到的颜色也是对的（和拍摄时的颜色相同）；但这样，图片的存储密度<strong>对于物理亮度而言是均匀的，但对于感知亮度就不均匀了</strong>。</p><p>对于人眼而言，信息利用率没有做到最好，直观的感受就是，调颜色会发现颜色的变化不均匀。</p><p>因此，现在绝大多数电脑图片都存储在sRGB空间下，也即按感知亮度存储。</p><p><imgsrc="https://pic1.zhimg.com/80/v2-0d2434c806b4a76436db481f822e9d28_1440w.webp" /></p><p>对于大多数使用者，不需要关注到gamma矫正的存在，因为他们始终在感知亮度空间下工作。而我们在进行光照运算时，必须转换到物理空间下进行。</p><p>通常说的线性工作流，指的就是在物理空间下进行计算，<strong>线性空间通常指物理亮度空间</strong>。</p><p>常用到的一些知识：</p><ul><li>大多数图片（ <code>jpg, png</code>等）都存储在sRGB空间，线性工作流中应将他们变换到物理空间进行运算；<code>exr</code>文件存储在物理空间，不需要转换。</li><li>在线性空间下计算的渲染结果若要保存为 <code>jpg, png</code>等，应将输出颜色变换到感知空间。我们只需负责按sRGB格式保存正确的图像，显示器会自动完成sRGB的显示工作（变换到物理空间去决定发射多少光子）。</li><li>美术工具通常都是工作在sRGB上的，各种调色板调的通常都是sRGB。专业的显示器和软件（tev等）一定会考虑到线性空间和sRGB的不同，进行显示、格式转换时都会进行Gamma处理。</li><li><code>OpenCV</code>在读取图像时并不会进行处理，很多CV工作都是在LDR、感知空间下计算Loss的，这也合理，这样计算的Loss更符合人眼感受。需要注意的是如果我们要使用别人预训练的网络，最好也先将HDR值<strong>截断</strong>，再将图像转换为sRGB输入。<ul><li>这里我们说到截断。事实上在科研中Tonemapping大多数时候是不用的，它更多是一个游戏或者显示器中的功能，用于提升画面细节。我们也不希望读取图像时还要进行反向Tonemapping。</li><li>最近发现做CVCG科研的人好像都认为Gamma矫正也是一种Tonemapping，这个在CG的线性工作流中就是必须的了。</li></ul></li></ul><h3 id="sobol序列">Sobol序列</h3><p>Sobol序列是一种低差异序列，支持生成大量的 <spanclass="math inline">\(n\)</span> 维点集。我们用 <spanclass="math inline">\(x_{i,j}\)</span> 表示第 <spanclass="math inline">\(i\)</span> 个样本的第 <spanclass="math inline">\(j\)</span> 维。</p><p>其每一个维度 <span class="math inline">\(j\)</span>需要一个二进制生成矩阵 <spanclass="math inline">\(C_j\)</span>（有了生成矩阵后，Sobol可以通过index<span class="math inline">\(i\)</span> 计算出第 <spanclass="math inline">\(i\)</span>个数，计算过程很多地方都有，此处不赘述）</p><p>为了方便，通常会使用32x32或64x64的生成矩阵，这样可以将一行/列视为一个二进制表示，用一个整数存储。因此生成矩阵通常显示为一串整数。以32x32的生成矩阵为例，它可以支持<span class="math inline">\(2^{32}\)</span>个样本。当然，这并不是Sobol的理论上限，理论上只要我们愿意去实现更高维的生成矩阵，它支持的样本数量是无限的。</p><p><a href="https://web.maths.unsw.edu.au/~fkuo/sobol/">Sobol官网</a>给出了一些文件，这里重点讲一下这个文件的用法：</p><div class="code-wrapper"><pre><code class="hljs tap">d       s       a       m_i     2      <span class="hljs-number"> 1 </span>     <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 1 </span>3      <span class="hljs-number"> 2 </span>     <span class="hljs-number"> 1 </span>     <span class="hljs-number"> 1 </span>3 4      <span class="hljs-number"> 3 </span>     <span class="hljs-number"> 1 </span>     <span class="hljs-number"> 1 </span>3<span class="hljs-number"> 1 </span>5      <span class="hljs-number"> 3 </span>     <span class="hljs-number"> 2 </span>     <span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>6      <span class="hljs-number"> 4 </span>     <span class="hljs-number"> 1 </span>     <span class="hljs-number"> 1 </span>1<span class="hljs-number"> 3 </span>3 7      <span class="hljs-number"> 4 </span>     <span class="hljs-number"> 4 </span>     <span class="hljs-number"> 1 </span>3<span class="hljs-number"> 5 </span>13 ....21201  <span class="hljs-number"> 18 </span>    <span class="hljs-number"> 131059 </span><span class="hljs-number"> 1 </span>1<span class="hljs-number"> 7 </span>11<span class="hljs-number"> 15 </span>7<span class="hljs-number"> 37 </span>239<span class="hljs-number"> 337 </span>245<span class="hljs-number"> 1557 </span>3681<span class="hljs-number"> 7357 </span>9639<span class="hljs-number"> 27367 </span>26869<span class="hljs-number"> 114603 </span>86317</code></pre></div><p>这里的 <span class="math inline">\(d\)</span>指维度，可以看到这个文件支持生成最高21201维的点集，每行描述了一个维度的生成矩阵。但并没有直接给出，而是只给出了矩阵的前<span class="math inline">\(s\)</span>个数，后续需要我们根据公式自己推出来（具体就不细谈了，可以直接套官网的代码）。</p><p>最后再说一下Sobol在渲染中的应用。</p><p>例如，一次路径追踪中，要产生8个随机数，那么我们会使用一个8维样本来表达这<strong>一整个随机过程</strong>，而非使用8个一维样本。</p><h3 id="光场">光场</h3><p><code>Plenoptic Function</code>（全光函数）：<spanclass="math inline">\(P(\theta, \phi,\lambda,t,x,y,z)\)</span>，指任一个位置，任一时刻向任一方向看到的某波长的光强。一个抽象概念，可以描述整个世界。</p><p><code>Light Field</code>（光场）：全光函数的一个子集，对于一个物体，考虑其包围盒，光场表达从任一位置，向任一方向发出的光（4D，位置和方向都可以用球面坐标表示）</p><p>nerf即使用神经网络来拟合这样一个光场（辐射场），来实现重建。</p><h3 id="球面谐波函数">球面谐波函数</h3><p>基函数：使用一组函数 <spanclass="math inline">\(b_i(x)\)</span>，他们的线性组合可以近似任一其他函数：<spanclass="math inline">\(f(x)\approx \sum_i^n A_ib_i(x)\)</span></p><p>我倾向于将基函数理解成“无限维度的向量”，即每个 <spanclass="math inline">\(x\)</span> 都是一个维度。</p><p>类似于基向量，因为维度是无限的，故希望不是近似而是完全匹配任一函数的话，需要无限个基函数：<spanclass="math inline">\(f(x)=\sum_i^{\infty} A_ib_i(x)\)</span></p><p>函数的乘积积分(Product integral)类似于向量点乘，故基函数的正交性类似于：<span class="math inline">\(\intf(x)g(x)d_x=0\)</span> 对其中任两个基函数都成立。</p><p>回到球面谐波函数上来，它是一组定义在球面上的基函数 <spanclass="math inline">\(r=b_i(\theta, \phi)\)</span>，它是正交的。</p><p><imgsrc="http://lxtyin.ac.cn/img/Gemo/spherical_harmonics.png" /></p><p>如图所示，球谐函数可以使用若干阶，越高阶频率越高，越能表现函数细节，通常使用前3阶即可比较好的近似。</p><p>近似 <span class="math inline">\(f(w)\)</span>时，对于每个基函数前的系数，可以这样计算：<spanclass="math inline">\(c_i=\int_\Omega f(w)b_i(w)d_w\)</span></p><p>这称为“投影”，从上述基向量的角度来看非常显然。</p><p><strong>应用</strong></p><p>取低阶的SH可以拟合一个球面光照（如环境光），类似一种低通filter</p><p>对于漫反射材质，其反射的主要是低频光照信息，仅需使用3阶SH拟合环境光，就能取得极其近似的效果。</p><h3 id="球面高斯函数">球面高斯函数</h3><p>定义： <span class="math display">\[G(\vec n,\vec v, a, \lambda)=ae^{\lambda(\vec n \cdot \vec v - 1)}\]</span>高斯分布，即正态分布，距离轴线越远函数值越小。球面高斯函数（SG）将这种分布迁移到了三维球面上，用以表示一个波瓣。以<span class="math inline">\(\vec  n\)</span> 定义波瓣的中心方向，<spanclass="math inline">\(\lambda\)</span> 系数定义波瓣的”胖瘦“，<spanclass="math inline">\(a\)</span>对波瓣进行整体缩放。这些从上式中不难看出。</p><p>SG的特点：</p><ul><li>它的积分是封闭形式的</li><li>两个SG的乘积仍然是SG，因此两个SG的点积也是封闭形式</li><li>...</li></ul><p>我们也可以定义一组SG基函数，通过调整他们的参数和系数来混合成新的球面函数。但SG有两个问题：它是各项同性的，且随意的一组SGs很难正交。</p><p>一组SH基函数能够快速拟合一个任意函数（求出系数组），利用的是对正交基的“投影”。SGs没了正交性，这个过程的复杂度将不可接受。故SGs基函数的数量不能很多。</p><p><strong>ASG</strong></p><p><a href="https://dl.acm.org/doi/10.1145/2508363.2508386">Xu2009</a></p><p>各向异性的SG，定义为： <span class="math display">\[G(\vec v,[\vec x, \vec y, \vec z], [\lambda, u], c)=c\cdot max(v\cdot z,0) \cdot e^{-\lambda(v\cdot x)-u(v\cdot y)}\]</span> 定义也比较直观，波峰在 <span class="math inline">\(\vec v=\vecz\)</span> 处，其中 <span class="math inline">\(\vec x,\vec y, \vecz\)</span> 是一个三维空间下的正交基。</p><p>原SGs也可以拼出各向异性的球面函数，但需要非常多的SG，而使用ASGs则可以使用一组数量较少的基函数。</p><h3 id="颜色">颜色</h3><p><code>Spectral Power Distributions (SPD)</code>：各个波长上分布的光强，多个光叠加时，SPD也可以叠加（线性性质）。</p><p>同色异谱：不同分布的光谱，人看起来可能是一样的（三种视锥细胞各自感应的结果）</p><h3 id="irradiance-map">Irradiance map</h3><p>可以认为：环境贴图、面积光的数值单位都是irradiance，因为其描述的是一个微面发出的总的辐射（无方向性），取任意方向就是radiance</p><p>但irradiancemap说的irradiance并不是这个，它通常用来做间接光预积分。</p><p>由于漫反射部分BRDF通常与wo无关（Lambertain项），可以从积分中分离，那么剩下的部分仅与法线n有关。预积分出对于每个法线n而言的irradiance，存在一张贴图里，就是常说的irradiancemap。</p><h3 id="烘焙">烘焙</h3><p>烘焙操作，通常就是在贴图上保存irradiance信息。</p><p>烘焙需要先进行一波展UV，得到UV2，这个UV2它保证不重复，而原来的UV就不一定了。</p><p>烘焙，逐物体操作，每个mesh丢入管线，顶点着色器输出的裁剪坐标直接为UV2，而计算仍然在世界空间下进行，方便地得到纹理空间的烘焙结果。</p><h3 id="画饼">画饼</h3><p>B样条曲线</p><p>微分方程、RungeKutta方法</p><p>Spatial hash?</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数的本质</title>
    <link href="/2023/09/20/%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <url>/2023/09/20/%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<p><span class="math display">\[\newcommand{\vec}{\mathbf}\]</span></p><p>学习自 <ahref="https://www.bilibili.com/video/BV1ys411472E?p=7&amp;spm_id_from=pageDriver&amp;vd_source=f3bceb9b12c557f0a9cdb5ac0d26fee6">3b1b线性代数的本质</a>，感谢大佬</p><h5 id="向量">向量</h5><p>可看做点，这里统一竖着写（列向量）。</p><h5 id="线性变换">线性变换</h5><p>对空间中的每个点作变换后，轴保持平行等距，原点不变。</p><p>upd：更广义的说法是线性映射（离散数学中的映射）：空间 <spanclass="math inline">\(V\)</span> 变换到空间 <spanclass="math inline">\(W\)</span>（这里的空间可以是任何广义的空间）后，保持加法和数乘运算。</p><p>线性映射本身也具有加法、数乘和乘法性质： <spanclass="math display">\[S,T均为空间V到W的线性映射，K为U到V的映射 \\(S+T)(v) = S(v) +T(v) \\(\lambda T)(v) = \lambda(T(v))  \\SK(u) = S(K(u))\]</span> （线性映射不具有交换律，一定将零元映射到零元）</p><p>线性映射可能降维，但不可能升维。</p><p>线性映射 <span class="math inline">\(T\)</span> 可能将一些向量映射到0<span class="math inline">\(T(v) = 0\)</span>，这些向量被称为 <spanclass="math inline">\(T\)</span> 的零空间 <spanclass="math inline">\(\mathrm{null} T\)</span>。</p><p>线性映射若不降维（等价于 <span class="math inline">\(\mathrm{null} T=\{0\}\)</span>），则它必定是单射、满射、可逆（即线性变换），我们称之为<strong>同构</strong></p><p>我们说”从空间 <span class="math inline">\(V\)</span> 到 <spanclass="math inline">\(W\)</span> 的线性映射 <spanclass="math inline">\(T\)</span> “时，并不意味着 <spanclass="math inline">\(W\)</span>中的每个元素都能被映射到。能被映射到的部分称为值域 <spanclass="math inline">\(\mathrm{range}T\)</span>，它是 <spanclass="math inline">\(W\)</span> 的一个子空间。 <spanclass="math display">\[dim(V) = dim(\mathrm{range}T) + dim(\mathrm{null}T)\]</span></p><h5 id="矩阵">矩阵</h5><p>表达一种一种线性变换，这里我们统一将向量竖着写，向量左乘一个矩阵即应用一个变换。</p><p>矩阵中一列的意义是：一个基向量变换后的新位置，因为是线性变换，我们只需要指定变换后的基向量，写入矩阵即可构建一个这样的变换矩阵。</p><p>对空间中一点变换时，可以直接将基向量代换掉，即可计算向量变换后的位置。</p><h5 id="非方阵">非方阵</h5><p>非方阵同样代表着线性变换，但它还涉及维数的改变。</p><p>非方阵中的列同样代表着变换后的新基向量位置，但这些新的基向量可能少维或者多维。</p><p>回忆矩阵乘法中，<span class="math inline">\(n\times m\)</span>的矩阵只能和 <span class="math inline">\(m\)</span> 维的向量相乘，它将<span class="math inline">\(m\)</span> 维向量的每个基代换为一个新的<span class="math inline">\(n\)</span>维向量（系数不变），这样得到的新向量便从 <spanclass="math inline">\(m\)</span> 维变到了 <spanclass="math inline">\(n\)</span> 维。</p><p><span class="math inline">\(n\times m\)</span> 的矩阵将 <spanclass="math inline">\(m\)</span> 维标准基向量变换为了 <spanclass="math inline">\(m\)</span> 个 <spanclass="math inline">\(n\)</span> 维向量，这 <spanclass="math inline">\(m\)</span> 个 <spanclass="math inline">\(n\)</span>维向量也许会平行或重合，变换后空间的实际维度（矩阵的秩）等于这 <spanclass="math inline">\(m\)</span>个向量的极大线性无关组中向量的个数。</p><h5 id="行列式">行列式</h5><p>等于相应矩阵对应的变换下，<strong>空间内任意物体缩放的比例。</strong>若行列式为负，则空间发生翻转，行列式为0，则变换将压缩至少一个维度。</p><p>我们已经知道，将矩阵看做线性变换后，其每一列都可以看做一个基向量变换后的位置。故矩阵对应行列式的值，即该矩阵各列向量拼出来的空间大小(二维的平行四边形面积，三维的平行六面体体积等）。</p><h5 id="矩阵的秩">矩阵的秩</h5><p>按此矩阵变换后，空间的维度，不降维的变换矩阵（必须是方阵）满秩。</p><h5 id="逆矩阵">逆矩阵</h5><p>显然，只有不降维（满秩）的变换才可逆。</p><h5 id="线性方程组">线性方程组</h5><p>线性方程组可以看做对一个由未知量组成的向量 <spanclass="math inline">\(x\)</span>，施加以变换矩阵 <spanclass="math inline">\(A\)</span> 后得到一个已知向量 <spanclass="math inline">\(y\)</span>，即 <spanclass="math inline">\(Ax=y\)</span>。如果这个矩阵可逆，则可以反推出所有未知量，否则要么无解（变换降维了，<spanclass="math inline">\(y\)</span>在变化后的维度之外），要么有无穷多解（<spanclass="math inline">\(y\)</span> 恰好在变换后的维度之内）。</p><h5 id="列空间">列空间</h5><p>即变换后的空间，叫列空间即矩阵每一列（变换后每个基）的张成空间。<strong>秩精确定义为列空间的维数</strong>。<spanclass="math inline">\(y\)</span> 在列空间内，方程才有解。</p><h5 id="零空间">零空间</h5><p>使 <span class="math inline">\(Ax=0\)</span> 成立的 <spanclass="math inline">\(x\)</span>的集合，即变换后会变为零向量的向量集，对于满秩矩阵，零空间中只有零向量。</p><h5 id="点积">点积</h5><p>点积在数值上等于两个向量对应位相乘之和，几何上等于一个向量投影到另一个向量上之后模相乘。</p><p>这两者可以得以联系，是因为可以将点积的两个向量，一个看做向量 <spanclass="math inline">\([a,b]^T\)</span>，另一个转置后看做线性变换 <spanclass="math inline">\([x,y]\)</span>。这个显然这是一个将二维降至一维的线性变换，它的含义恰恰就是将向量投影到一维空间。</p><p>更进一步，我们会发现<strong>每一种二维到一维的线性变换都与一个某个向量一一对应</strong>（转置即可）。应用此变换等价于与该向量点乘。</p><h5 id="叉积">叉积</h5><p>通常在三维空间下讨论叉积，我们都知道的是：两个向量叉积得到一个与它们都垂直的向量，模长等于两向量张成的平行四边形面积，方向取决于右手定则，叉积公式即将<span class="math inline">\(i,j,k\)</span> 与两向量放入一个行列式。</p><p>叉积的几何意义很明朗，但问题在于为什么计算会和行列式相关。</p><p>考虑三个向量 <spanclass="math inline">\(u,v,m\)</span>，把它们放入一个三阶行列式，结果显然为张成的平行六面体体积。</p><p>如果我们固定其中两个，任选第三个，这就相当于是一个变换函数，输入向量<span class="math inline">\([x,y,z]^T\)</span>，得到一个标量输出： <spanclass="math display">\[f\begin{pmatrix}x\\y\\z\\\end{pmatrix}=\begin{vmatrix}x,v_1,m_1\\y,v_2,m_2\\z,v_3,m_3\end{vmatrix}\]</span>可以证明，这同样是一个三维到一维的<strong>线性变换</strong>。既然是线性变换，可以表示为矩阵<span class="math inline">\(P\times [x,y,z]^T\)</span>，其中 <spanclass="math inline">\(P\)</span> 为1x3的降维变换矩阵。</p><p>根据点积中提到的对偶性，这个变换等价于 <spanclass="math inline">\(P^T\cdot [x,y,z]^T\)</span></p><p>什么样的 <span class="math inline">\(P^T\)</span>点乘任意一个向量，都能得到它与 <span class="math inline">\(v,m\)</span>组成的平行六面体体积？</p><p>画图，根据点积的投影计算方式，容易发现，<spanclass="math inline">\(P^T\)</span> 模长为 <spanclass="math inline">\(v,m\)</span>平行四边形面积，方向与它们都垂直，正是我们需要叉积结果。</p><p>那么要计算这个 <spanclass="math inline">\(P^T\)</span>，可以用一点运算小技巧，取 <spanclass="math inline">\((x,y,z)\)</span> 为单位向量，并且把它们的方向<span class="math inline">\((i,j,k)\)</span>写出来，就能化标量为矢量了。 <span class="math display">\[P^T\cdot [i,j,k]^T=\begin{vmatrix}i,v_1,m_1\\j,v_2,m_2\\k,v_3,m_3\end{vmatrix}\]</span></p><h5 id="基变换">基变换</h5><p>基变换的逻辑容易理解，但方向很容易搞反，关键在于弄清<strong>向量的实际位置</strong>是否改变。</p><p>如：坐标系 <span class="math inline">\(A\)</span> 的基向量为 <spanclass="math inline">\([0,1],[1,0]\)</span>，坐标系 <spanclass="math inline">\(B\)</span> 的基向量为 <spanclass="math inline">\(b1,b2\)</span>，根据之前的知识，我们可以将其看做变换矩阵<spanclass="math inline">\([b1,b2]\)</span>，让向量乘上这个矩阵，即进行等同于<span class="math inline">\(B\)</span>的变换，向量的实际位置无疑改变了，变换后相对于 <spanclass="math inline">\(B\)</span> 的位移，即变换前相对于 <spanclass="math inline">\(A\)</span>的位移。这个矩阵可以进行局部坐标-全局坐标的转换。</p><p>其他情况下，我们知道了向量在 <span class="math inline">\(A\)</span>坐标系下的表示，希望知道这个向量在 <spanclass="math inline">\(B\)</span>下的表示如何（而非变换向量本身），其实就是上述过程的逆，让向量乘上上述矩阵逆矩阵即可</p><h5 id="相似矩阵">相似矩阵</h5><p>相似矩阵实际上表达的是相同的变换，只不过在不同的坐标系下表示。</p><p>理解相似矩阵实际上对空间的变换是一样的，我们就能轻易得出：</p><ul><li>相似矩阵具有相同的秩和行列式</li><li>相似矩阵具有相同的特征值，特征向量其实也是同样的向量，只不过在不同的坐标系下表示。</li></ul><h5 id="特征值特征向量">特征值/特征向量</h5><p>按某矩阵进行变换后，会发现有些向量只是缩放，并没有离开原来的直线</p><p>这些向量便是矩阵的特征向量，其缩放比例即为对应的特征值。</p><p>特征值和特征向量是方阵的概念，方阵有至多 <spanclass="math inline">\(n\)</span>个不同的特征值，每个特征值对应无数个特征向量。</p><p>不同特征值对应的特征向量线性无关，方阵至多有 <spanclass="math inline">\(n\)</span> 个线性无关的特征向量。</p><p>例如，零矩阵仅有0一个特征值，特征向量是 <spanclass="math inline">\(\R^n\)</span> 空间内的所有向量。</p><p>我们知道，矩阵是一种线性变换，在这种变换下，最大特征值对应变换速率最大的方向（可以想象一个单位球随着矩阵变换为一个椭圆），同理最小特征值对应变换速率最小（可能为负）的方向。</p><h5 id="相似对角化特征分解">相似对角化（特征分解）</h5><p>指矩阵 <span class="math inline">\(A\)</span> 能够相似与一个对角矩阵<span class="math inline">\(B\)</span>，在求幂时有意义：<spanclass="math inline">\(A^m =PB^mP^{-1}\)</span>，转化为对角矩阵的求幂。</p><p>矩阵可相似对角化的充要条件是，矩阵有 <spanclass="math inline">\(n\)</span> 个线性无关的特征向量。</p><p>我们知道相似矩阵实际上表达的是相同的变换，那么如果直接把<strong><span class="math inline">\(A\)</span>的特征向量构成的基作为新坐标系</strong>的话——</p><p>相似矩阵的特征向量一定都在坐标轴上！也就是说相似矩阵一定是对角矩阵了。</p><h5 id="二次型">二次型</h5><p>一个每项均为二次项的多元多项式（称为二次型）可以写为 <spanclass="math inline">\(f(x_1,x_2..x_n)=x^TAx\)</span>，对于原式中的项<span class="math inline">\(kx_ix_j\)</span>，有 <spanclass="math inline">\(A_{i,j} = A_{j,i} =\frac{k}{2}\)</span>​（对角线除外），也即 <spanclass="math inline">\(A\)</span> 是二次型唯一对应的实对称矩阵。</p><p>由于实对称矩阵的特征向量彼此正交，<spanclass="math inline">\(A\)</span> 一定可相似对角化，那么 <spanclass="math display">\[x^TAx &amp;=&amp; x^TQBQ^{-1}x\\      &amp;=&amp; x^TQBQ^Tx \\      &amp;=&amp; (Q^Tx)^TB(Q^Tx)\]</span> 其中 <span class="math inline">\(Q\)</span> 是 <spanclass="math inline">\(A\)</span> 的特征基，为正交矩阵，<spanclass="math inline">\(B\)</span> 为对角矩阵</p><p>也就是可以利用 <span class="math inline">\(y = Q^Tx\)</span>这个变化，将其变成一个标准型（只含有平方项的二次型）。</p><p>几何意义上：以三维空间为例，若 <span class="math inline">\(A\)</span>是一个对角矩阵，则这个标准型可写作 <spanclass="math inline">\(d_1x^2+d_2y^2+d_3z^3 =1\)</span>，它可以轻松地定义三维空间中的一个圆锥曲面（注意并非单位球按照<span class="math inline">\(A\)</span>直接变换得到的椭圆）；同样的，二次型也可以定义曲面，是相应标准型施加了变换<span class="math inline">\(Q^{-1}\)</span> 的效果。</p><p>当标准型的所有系数均大于0时，这是一个椭圆；当有系数小于0时，这是一个双曲面或者别的什么奇特曲面；正交变换<span class="math inline">\(Q\)</span>不会改变他们的形状，<strong>这样的能描述椭圆的二次型对应的实对称矩阵A称为正定矩阵。</strong></p><h5 id="正定矩阵">正定矩阵</h5><p>正定矩阵的定义是：对于任意非零向量 <spanclass="math inline">\(x\)</span>，有 <span class="math inline">\(x^TAx&gt;0\)</span>。</p><p>从二次型的角度来理解，它是描述椭圆的；从定义式的角度理解，任意向量<span class="math inline">\(x\)</span> 经过正定矩阵对应的变化后，与<span class="math inline">\(x\)</span> 的点乘仍然大于0（即仍然处于 <spanclass="math inline">\(x\)</span>指向的半无限空间内）。半正定矩阵即将条件改为 <spanclass="math inline">\(\ge\)</span></p><p>正定矩阵的特征值都大于0，行列式大于0。</p><p>一个正定矩阵判定的充分条件是：每一行（或列）的对角元素都大于这一行（或列）的其他元素之和（对角占优）。</p><h5 id="cholesky-factorization">Cholesky-factorization</h5><p>正定矩阵必然可以分解为 <span class="math inline">\(A =LL^T\)</span>，<span class="math inline">\(L\)</span>是一个下三角矩阵，对角线上元素均大于0。</p><p>不难发现 <span class="math inline">\(A_{uv} = \sum_{k=1}^{n}L_{uk}L_{vk}\)</span></p><p>我们可以从左到右、从上到下地计算 <spanclass="math inline">\(L\)</span> <span class="math display">\[L_{vv}^2 =A_{vv} - \sum_{k=1}^{v-1} L_{vk} \\L_{vv}L_{uv} = A_{vv} - \sum_{k=1}^{v-1} L_{uk} L_{vk},(u\ge v)\]</span></p><h5 id="奇异值分解">奇异值分解</h5><p>特征值和特征向量是方阵的概念，非方阵则可以求出奇异值。</p><p>有非方阵 <span class="math inline">\(A(m\timesn)\)</span>，它可以分解为 <span class="math inline">\(A = U\sumV^T\)</span></p><p><img src="http://lxtyin.ac.cn/img/math/svd.png" /></p><p><span class="math inline">\(A^TA\)</span> 是一个 <spanclass="math inline">\(n\times n\)</span>的对称矩阵，它可以特征分解，得到的特征向量张成的基为 <spanclass="math inline">\(V\)</span>；同理 <spanclass="math inline">\(AA^T\)</span> 为 <spanclass="math inline">\(m\times m\)</span> 的对称矩阵，特征向量张成为<span class="math inline">\(U\)</span>。<spanclass="math inline">\(U,V\)</span> 都为正交矩阵（一定），而 <spanclass="math inline">\(\sum\)</span>中主对角线元素为奇异值，其他都为0。</p><p>因此，可以将 <span class="math inline">\(A\)</span> 看做旋转 -按轴缩放 -旋转的一个变化，区别在于这里的缩放可能改变维度。奇异值的意义类似特征值，是特定轴上的缩放比例。</p><p>用特征向量张成为正交矩阵时，可以控制顺序，使得特征值（奇异值）有序。实际应用中，排序后往往前面少数几个奇异值就占据了99%以上的比例，那么我们可以仅取前<span class="math inline">\(k\)</span>个奇异值（以及相应部分左右矩阵，具体见下图）来近似原矩阵 <spanclass="math inline">\(A\)</span>，实现压缩。</p><p><img src="http://lxtyin.ac.cn/img/math/svd2.png" /></p><h5 id="协方差矩阵">协方差矩阵</h5><p>这个东西在很多地方都有应用，因此也在这里提及</p><p>协方差表达了两个随机变量的线性相关性，<spanclass="math inline">\(Cov(X,Y)=E((X-\overline X)(Y-\overlineY))\)</span></p><p>协方差可以为正或者负，两变量线性不相关时，协方差为0（注意不相关不等于独立，它们还可以有非线性的相关性）</p><p>协方差矩阵，即对于 <span class="math inline">\(n\)</span> 个随机变量<span class="math inline">\(X_1,..X_n\)</span>，<spanclass="math inline">\(\vec C_{i,j} = Cov(X_i,X_j)\)</span>，包含了所有随机变量的两两协方差，显然，协方差矩阵是一个实对称矩阵，它的特征向量彼此正交。</p><p>协方差矩阵的特征值和特征向量有重要的几何意义，考虑 <spanclass="math inline">\(m\)</span> 个 <spanclass="math inline">\(n\)</span> 维样本（每一维对应一个随机变量 <spanclass="math inline">\(X_i\)</span>）构成 <spanclass="math inline">\(m\times n\)</span> 的样本矩阵 <spanclass="math inline">\(\vecA\)</span>，不失一般性地，假设所有样本均值为0。</p><p>于是 <span class="math inline">\(\vec C = \frac{1}{m} \vec A^T\vecA\)</span>，考虑它的特征向量： <span class="math display">\[\vec Cx = \lambda x \\\vec A^T \vec A x = m \lambda x \\(\vec Ax)^T(\vec Ax) = m\lambda x^Tx = m\lambda\]</span> <span class="math inline">\(\vec Ax\)</span>实际上是所有样本点与 <span class="math inline">\(x\)</span>作点乘，<span class="math inline">\((\vec Ax)^T(\vec Ax)\)</span>表示所有点在 <span class="math inline">\(x\)</span>方向的投影的平方之和，也就是在 <span class="math inline">\(x\)</span>方向上的方差。</p><p>结论：协方差矩阵的最大特征值对应的特征向量即为点集分布方差最大的方向（点云朝向）；最小的方向即为法向。</p><h5 id="对偶基">对偶基</h5><p>由 <span class="math inline">\(n\)</span> 维线性空间 <spanclass="math inline">\(V\)</span> 到一维数域 <spanclass="math inline">\(F\)</span> 的映射称为线性泛函，它可以用一个 <spanclass="math inline">\(n\)</span> 维向量表示。所有的线性泛函构成了 <spanclass="math inline">\(n\)</span> 维空间 <spanclass="math inline">\(V&#39;\)</span>，它是 <spanclass="math inline">\(V\)</span> 的<strong>对偶空间</strong>。</p><p>设 <span class="math inline">\(v_1,..v_n\)</span> 是 <spanclass="math inline">\(V\)</span> 的一组基（不必正交），<spanclass="math inline">\(\phi_1,..\phi_n\)</span> 是 <spanclass="math inline">\(V&#39;\)</span> 中的向量组，满足 <spanclass="math inline">\(\phi_i(v_j) = \delta_{ij}\)</span>，则 <spanclass="math inline">\(\phi_1,..\phi_n\)</span> 是 <spanclass="math inline">\(v_1,..v_n\)</span>的<strong>对偶基</strong>。对偶基是对偶空间的基。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数理基础</tag>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReSTIR学习笔记</title>
    <link href="/2023/03/15/%E7%AC%94%E8%AE%B0/ReSTIR%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/15/%E7%AC%94%E8%AE%B0/ReSTIR%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>2024.2.18学到了一些新的关于IS和MIS的理解，故在学习ReSTIR前重新整理一遍。</p><p>参考：https://zhuanlan.zhihu.com/p/670309912</p><h5 id="重要性采样">重要性采样</h5><p>考虑随机变量 <spanclass="math inline">\(\frac{f(x)}{p(x)}\)</span>，<spanclass="math inline">\(p(x)\)</span>为我们选取的任意一个pdf。随机变量的期望为： <spanclass="math display">\[E(\frac{f(x)}{p(x)}) = \int \frac{f(x)}{p(x)}p(x) dx = \int f(x) dx\]</span>可以将<strong>求积分问题转为求随机变量的期望</strong>，估计此期望很简单：<span class="math display">\[I_{IS} = \frac{1}{N} \sum_{i=1}^N \frac{f(x_i)}{p(x_i)}\]</span> 这就是蒙特卡洛估计的原理，要使这个估计的方差尽可能小，即要求<span class="math inline">\(\frac{f(x)}{p(x)}\)</span>的期望尽可能小，故 <span class="math inline">\(p(x)\)</span>要尽可能接近 <span class="math inline">\(f(x)\)</span>。</p><h5 id="多重重要性采样">多重重要性采样</h5><p>被积函数很多时候很复杂，我们没办法用一个简单的 <spanclass="math inline">\(p(x)\)</span> 近似它，但存在多个pdf： <spanclass="math inline">\(p_1(x),p_2(x)...p_m(x)\)</span>，每个pdf和 <spanclass="math inline">\(f(x)\)</span>的一部分近似。MIS提供了一种多种采样策略结合的方案。</p><p>考虑随机变量 <spanclass="math inline">\(w_i(x)\frac{f(x)}{p_i(x)}\)</span>，这个随机变量的期望为：<span class="math display">\[E(w_i(x)\frac{f(x)}{p_i(x)}) = \int w_i(x)f(x) dx \\\]</span> 将M种随机变量对应的期望加起来，又变成了所求积分： <spanclass="math display">\[\sum_{i=1}^M E(w_i(x)\frac{f(x)}{p_i(x)}) = \int \left ( \sum_{i=0}^Mw_i(x) \right ) f(x) dx = \int f(x) dx\\\]</span> 于是我们得到了MIS的估计式： <span class="math display">\[I_{MIS} = \sum_{i=1}^M \frac{1}{N_i}\sum_{j=1}^{N_i} w_i(x)\frac{f(x)}{p_i(x)} \\\]</span> 通常的MIS要求 <span class="math inline">\(\sum_{i=0}^M w_i(x)=1\)</span>，这保证了结果是无偏的，同时隐含了这M种采样策略估计的结果，应当等权地相加；相应地在只有1样本情况下，应该等概率地选取这M种采样方式。我们如果启发式地控制采样方式出现的概率，例如，以0.25的概率取光源采样，0.75的概率取BSDF采样，那么就等价于BSDF采样出现了3次，光源采样出现了1次，必须有<span class="math inline">\(w_{光源采样}(x) +3 w_{BSDF采样}(x) =1\)</span></p><p>MIS是有条件的：1. 所有 <span class="math inline">\(f(x)\)</span>有值的区域，都必须有某个采样方式能采样到；2. 若 <spanclass="math inline">\(p_i(x) = 0\)</span> 则必须 <spanclass="math inline">\(w_i(x) =0\)</span>。第二个条件使用启发式权重时通常都是成立的，第一个条件其实相比重要性采样更宽松，它告诉我们：某些采样方式（例如光源采样）可以只关注一部分区域。</p><p>要令MIS的方差尽可能小，其实也就是令 <spanclass="math inline">\(p_i(x)\)</span> 与 <spanclass="math inline">\(w_i(x)f(x)\)</span>尽可能接近。按最开始的设定，每个 <spanclass="math inline">\(p_i(x)\)</span> 都只有一部分和 <spanclass="math inline">\(f(x)\)</span> 匹配较好，通常是用 <spanclass="math inline">\(p_i(x)\)</span> 的波峰来匹配 <spanclass="math inline">\(f(x)\)</span> 的一个波峰。我们希望在 <spanclass="math inline">\(p_i(x)\)</span> 较匹配处，<spanclass="math inline">\(w_i(x)\)</span> 取尽可能大值。在不匹配处，<spanclass="math inline">\(w_i(x)\)</span>取尽可能小值，来减小此处造成的方差。因此一个启发式地分配策略就是： <spanclass="math display">\[w_i(x) = \frac{p_i(x)}{\sum_{j=1}^M p_j(x)}\]</span>也有平方归一的和其他方式，但都比较感性，没有明显的优劣之分，随便取一种即可。</p><h6 id="实际应用">实际应用</h6><p>我们可以用MIS重新理解前面的提到的直接间接光划分：将他们也看做两种不同的采样策略的结合。</p><p><img src="http://lxtyin.ac.cn/img/Gemo/tracing1_2.png" /></p><p>如图所示，红色部分表示直接光采样策略和间接光采样策略，他们在不同区域上被赋予不同的权重（0或1），符合上述MIS要求。</p><p>在实际的采样中，我们只能使用一条光线，不可能对 <spanclass="math inline">\(M\)</span>种采样策略都采样一遍，那么就需要从概率上等分它们（注意必须是等分，不能想当然地用其他启发式的划分）。</p><p>此时，若我们按照 <span class="math inline">\(w_i(x) =\frac{p_i(x)}{\sum p(x)}\)</span>，并假设每个采样策略的 <spanclass="math inline">\(N_i\)</span> 相同，就会得到一个优美的性质： <spanclass="math display">\[I_{MIS} = \sum_{i=1}^M \frac{1}{N_i}\sum_{j=1}^{N_i} \frac{p_i(x)}{\sump(x)} \frac{f(x)} {p_i(x)} \\= \sum_{i=1}^M \frac{1}{N_i}\sum_{j=1}^{N_i} \frac{f(x)}{\sum p(x)} \\= \frac{1}{N}\sum_{j=1}^{N} \frac{f(x)}{\frac{1}{M}\sum p(x)}  \\\]</span> 即，我们可以将多个采样策略合成为一个采样策略，合成的pdf为<span class="math inline">\(p_{sum}(x) = \frac{1}{M} \sump(x)\)</span>，也就是单纯的PDF平均。</p><p>注意PDF平均，和各自估计后的结果平均是不一样的，前者等价于MIS，后者是naive的，并无优化。为了区分，这里再写出后者的估计式：<spanclass="math inline">\(\frac{1}{M}\sum_{i=1}^M \frac{1}{N}\sum_{j=1}^{N}\frac{f(x)}{p_i(x)}\)</span>，它等价于MIS使用均匀权重。</p><p>更一般地，可以有 <span class="math inline">\(p_{sum}(x) = \sum p_i(x)m_i(x)\)</span>，只要满足 <span class="math inline">\(\sum m_i(x) =1\)</span> 即可。这里的 <span class="math inline">\(m_i(x)\)</span>是我们选取采样方式 <span class="math inline">\(i\)</span> 的概率，与<span class="math inline">\(w_i(x)\)</span> 不同。</p><h5 id="ir-importance-resampling"><strong>IR</strong> (ImportanceResampling)</h5><p>设已有目标PDF为 <span class="math inline">\(\hatp(x)\)</span>，可以用另一个简单可快速采样的提议PDF <spanclass="math inline">\(p(x)\)</span> 来生成接近 <spanclass="math inline">\(\hat p\)</span> 分布的样本。</p><ol type="1"><li>从 <span class="math inline">\(p(x)\)</span> 中抽取 <spanclass="math inline">\(M\)</span> 个候选样本 <spanclass="math inline">\(x_1,x_2...x_M\)</span></li><li>样本的初始权重设为：<span class="math inline">\(w(x_i) = \frac{\hatp(x_i)}{p(x_i)}\)</span></li><li>用归一化后的权重作为概率 <spanclass="math inline">\(p_{SIR}=\frac{w(x_i)}{\sumw}\)</span>，从样本集中重新抽取。为了叙述方便，这里将重新抽取的概率分布称为<code>SIRPDF</code> 。在 <span class="math inline">\(M\rarr\infty\)</span> 时，SIRPDF符合目标分布 <span class="math inline">\(\hatp(x)\)</span></li></ol><p><span class="math inline">\(M=1\)</span> 时，SIRPDF等于提议分布 <spanclass="math inline">\(p(x)\)</span>，<spanclass="math inline">\(M\)</span> 越大，SIRPDF越贴近 <spanclass="math inline">\(\hatp(x)\)</span>，但不完全相等。不难想到，这种性质很方便我们用来做蒙特卡洛估计，但还有一个问题：我们只知道如何采样SIRPDF，而不知道它的pdf到底是多少。所以需要新的估计式，后文提及。</p><p>重采样的优势在于，我们不需要知道 <span class="math inline">\(\hatp(x)\)</span> 的解析式，甚至不需要 <span class="math inline">\(\hatp(x)\)</span>归一化，因为归一化操作隐含在归一化权重中了。或者说，我们可以将任何未归一的分布作为目标，自动得到接近它归一后版本的样本集。</p><p>我们可以直接以完整的渲染方程被积项作为 <spanclass="math inline">\(\hatp\)</span>，不过后面会说明，实际并不会这样。</p><p>（SIR即Sample Importance Resampling，指代IR采集的样本）</p><h5 id="ris-resampled-importance-sampling"><strong>RIS</strong>(Resampled Importance Sampling)</h5><p>为什么SIRPDF不能直接用于蒙特卡洛呢？因为pdf没法算，我们根本不知道重采样出来的是啥分布。</p><p>RIS提供了一个新的无偏估计公式： <span class="math display">\[I_{RIS} = \frac{1}{N} \sum_{i=1}^N \frac{f(y_i)}{\hatp(y_i)}\frac{\sum_{j=1}^M w(x_j) }{M}\\\]</span> 其中 <span class="math inline">\(f(x)\)</span>是渲染方程的被积项， <span class="math inline">\(M\)</span>是提议样本个数，<span class="math inline">\(N\)</span>是估计时用的样本个数。无偏性的证明放在后面，可以和RIS+MIS一起理解。</p><p>如果令 <span class="math inline">\(\hat p(x) =f(x)\)</span>，我们会发现这个式子又变回蒙特卡洛了，方差取决于提议分布<span class="math inline">\(p(x)\)</span> 的选取。</p><p>那么RIS真正的优势在哪里呢？</p><p>看一下RIS在Direct light中的应用就明白了：<ahref="https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=1662&amp;context=etd">论文原文</a>选取的<span class="math inline">\(\hat p\)</span> 为： <spanclass="math display">\[\hat p = f_s\cdot G\cdot Le\]</span> 是去掉了可见项后的被积项，这个 <spanclass="math inline">\(\hat p\)</span>函数的特点是：接近被积项，计算开销小（因为去掉了最昂贵的遮挡项），同时又不可直接采样（没法直接蒙特卡洛）。</p><p>用RIS来处理的话，在 <span class="math inline">\(M\)</span>够大，重采样分布能够接近 <span class="math inline">\(\hat p\)</span>的情况下，所需的样本数 <span class="math inline">\(N\)</span>相比传统IS是有优势的。我们选取计算开销小的 <spanclass="math inline">\(\hat p\)</span> 也是为了初始的 <spanclass="math inline">\(M\)</span> 个样本权重计算更快。</p><p>总结一下的话，最初的RIS其实是一个tradeoff的方法，通过<strong>提高提议数 <span class="math inline">\(M\)</span>来减小所需的样本数 <spanclass="math inline">\(N\)</span></strong>。效果上也只能说和IS互有优劣。后续提出的<strong>复用提议样本</strong>的方法，才真正让RIS得以发光发热。</p><p>这里偷一个方差公式： <span class="math display">\[V = \frac{1}{M} V(\frac{f(X)}{p(X)}) +(1-\frac{1}{M})\frac{1}{N}V(\frac{f(Y)}{\hat p(Y)})\]</span> 为了简化，这里假设 <span class="math inline">\(\hat p\)</span>是归一化的，如果不是，式子中应为归一化的 <spanclass="math inline">\(\hat p\)</span>。</p><p>可见，<span class="math inline">\(M\)</span> 越大，提议分布 <spanclass="math inline">\(p\)</span> 越不重要，方差越接近直接用 <spanclass="math inline">\(\hat p\)</span> 做蒙特卡洛的结果。，</p><p><span class="math inline">\(p\)</span> 会影响SIRPDF收敛到 <spanclass="math inline">\(\hat p\)</span>的速度，因此也不能乱取，通常可能会取BSDF之类的好采样的分布。</p><p>回忆一下，<span class="math inline">\(p\)</span>是一个简单易采样的提议分布，<span class="math inline">\(\hat p\)</span>是一个不易采样，但非常接近目标积分的分布。显然我们需要 <spanclass="math display">\[V(\frac{f(X)}{p(X)}) &gt; V(\frac{f(Y)}{\hat p(Y)})\]</span> 否则进行重采样没有任何意义；其次，<spanclass="math inline">\(\hat p(x)\)</span> 的计算开销也需要显著小于 <spanclass="math inline">\(f(x)\)</span>，否则不如直接进行蒙特卡洛采样。</p><p>从另一个角度理解，RIS相较于IS其实是提供了一个额外的控制自由度，<spanclass="math inline">\(M\)</span>。</p><h5 id="ris的无偏性证明">RIS的无偏性证明</h5><p>我们直接考虑最广义的情况：每个提议样本 <spanclass="math inline">\(x_i\)</span> 各自使用单独的提议分布 <spanclass="math inline">\(p_i\)</span> 采样，<spanclass="math inline">\(w_i(x_i) = \frac{\hatp(x_i)}{p_i(x_i)}\)</span>。先说结论：这样取提议样本也是正确的，并且有一个更加广义的形式。下面一起证明：</p><p>这一小节我们用 <span class="math inline">\(p_i\)</span>表示提议PDF，<span class="math inline">\(p\)</span> 为通用的概率符号</p><p>这里需要先弄清楚几个概率： <span class="math display">\[p(\bold x) = \prod_{i=1}^M p_i(x_i),样本集恰为\bold x的概率 \\p(z|\bold x) = \frac{w(x_z)}{\sum w}, 已知样本集为\boldx的情况下,重抽样到第z个元素的的概率 \\p(\bold x, z) = p(\bold x) \cdot p(z|\bold x), 样本集为\bold x且重抽样到第z个元素的概率\]</span> 注意，SIRPDF <span class="math inline">\(p_{SIR}(x_z)\)</span>并不等于 <span class="math inline">\(p(\boldx,z)\)</span>，因为可以有多种 <span class="math inline">\(\bold x,z\)</span> 的组合可以产生 <spanclass="math inline">\(x_z\)</span>，如果我们写出 <spanclass="math inline">\(p_{SIR}\)</span> 的形式： <spanclass="math display">\[p_{SIR}(y) = \sum_{i\in Z(y)} \int_{\bold x|x_i=y} p(\bold x, i) d\boldx\]</span> 其中 <span class="math inline">\(Z(y) = \{i|1\le i\le M \andp_i(y)\gt 0 \}\)</span>，积分域是所有满足 <spanclass="math inline">\(x_i=y\)</span> 样本集（相当于限制第 <spanclass="math inline">\(i\)</span>的样本的值，其余样本均自由）。这个式子枚举了所有能够重抽样产生 <spanclass="math inline">\(y\)</span>的情况，并将其概率相加。这才是SIRPDF的完整表达，它没有一个闭合解。</p><p>我们需要证明的是估计式无偏， <span class="math display">\[\left&lt; I_{RIS}^{1,M} \right&gt; = \frac{f(y)}{\hatp(y)}\frac{\sum_{j=1}^M w_j(x_j) }{M} = f(y)W(\bold x,z),其中\\y=x_z\\W(\bold x,z) = \frac{1}{\hat p(x_z)}\frac{\sum_{j=1}^M w_j(x_j) }{M} \\\]</span> 这里，<span class="math inline">\(W(\bold x,z)\)</span>是一个随机变量，虽然此时已知 <spanclass="math inline">\(x_z=y\)</span>，但仍有有多种组合能够满足这一约束，并且每一种组合下<span class="math inline">\(W(\bold x, z)\)</span>的值都不一样。如果我们能够证明： <span class="math display">\[\mathbb E_{x_z=y}(W(\bold x, z)) = \frac{1}{p_{SIR}(y)}\]</span> 就相当于将估计式变成了蒙特卡洛估计，结果自然是无偏的。</p><p>至于为何期望能拿来替换pdf，我觉得可以感性理解，也许不是太严谨，<ahref="https://agraphicsguynotes.com/posts/understanding_the_math_behind_restir_di/#restir-di-introduction">UnderstandingThe Math Behind ReStir DI</a> 给出了证明。</p><p>继续证明，用类似描述SIRPDF的思路写出上面这个 <spanclass="math inline">\(\mathbb E\)</span>： <span class="math display">\[\mathbb E_{x_z=y}(W(\bold x, z)) = \sum_{i\in Z(y)} \int_{\bold x|x_i=y} W(\bold x, i)\frac{p(\bold x,i)}{p_{SIR}(y)} d\bold x\]</span> 这是一个条件期望，上式中，<span class="math inline">\(p(\boldx,i)\)</span> 是采样到这样一个样本集，并重采样到index <spanclass="math inline">\(i\)</span> 的概率，还需 要除以 <spanclass="math inline">\(p_{SIR}(y)\)</span> 才是已知结果为 <spanclass="math inline">\(y\)</span> 时的条件概率。继续展开： $$E_{x_z=y}(W(x, z)) &amp;=&amp; <em>{iZ(y)} </em>{x| x_i=y} dx \</p><p>&amp;=&amp; <em>{iZ(y)} </em>{x| x_i=y} _{j=1}^M p_j(x_j) dx \</p><p>&amp;=&amp; <em>{iZ(y)} </em>{x| x_i=y} _{j=1}^M p_j(x_j) dx \</p><p>&amp;=&amp; <em>{iZ(y)} </em>{x| x_i=y} _{x_j x-x_i } p_j(x_j) dx\</p><p>&amp;=&amp; $$ 最后一步，被积项即为 <spanclass="math inline">\(\{\bold x |x_i=y\}\)</span>中所有样本集的出现概率的积分，即为1。</p><p>于是，当 <span class="math inline">\(Z(y)=M\)</span> 时，<spanclass="math inline">\(W(\bold x, z)\)</span> 的期望为 <spanclass="math inline">\(1/p_{SIR}(x_z)\)</span>，估计是无偏的。</p><p>实际情况中，若提议分布并不能保证处处 <spanclass="math inline">\(&gt;0\)</span>，则估计是有偏的。我们可以修改：<span class="math display">\[W(\bold x,z) = \frac{1}{\hat p(x_z)}\frac{\sum_{j=1}^M w_j(x_j)}{Z(x_z)} \\\]</span> 达成无偏。不过这样并不是最好的，可以使用类似MIS的方式加权：<span class="math display">\[W(\bold x,z) = \frac{1}{\hat p(x_z)} m_z(x_z)\sum_{j=1}^M w_j(x_j) \\\]</span> 满足 <span class="math inline">\(\sum_i^M m_i(x) = 1\)</span>对于任意 <span class="math inline">\(x\)</span>均成立即可，一种启发式平衡策略为 <span class="math inline">\(m_i(x) =\frac{p_i(x)}{\sum_{j=1}^M p_j(x)}\)</span></p><p>可以将该式代入上面的证明过程，很容易证明。</p><p>总结一下，这一节我们证明了 <span class="math inline">\(\mathbbE_{x_z=y}(W(\bold x, z)) =\frac{1}{p_{SIR}(x_z)}\)</span>，可以在估计中使用 <spanclass="math inline">\(W\)</span> 替代 <spanclass="math inline">\(p_{SIR}\)</span>的作用。另外还还说明了RIS支持使用不同的提议分布。</p><h5 id="加权蓄水池采样wrs">加权蓄水池采样（WRS）</h5><p>考虑流式地处理提议样本，即已有 <span class="math inline">\(M\)</span>个提议样本 <span class="math inline">\(x_1,..x_M\)</span> 和SIR样本<span class="math inline">\(y\)</span>（可以为 <spanclass="math inline">\(N\)</span>个重采样样本，此处仅考虑一个的情况），现需要加入第 <spanclass="math inline">\(M+1\)</span> 个提议样本 <spanclass="math inline">\(x_{M+1}\)</span>，要维护SIR样本的概率正确。</p><p>用 <span class="math inline">\(w_{sum}\)</span> 来表示此前 <spanclass="math inline">\(M\)</span> 个样本的权重和 <spanclass="math inline">\(\sum w_i\)</span>，<spanclass="math inline">\(w_{M+1}\)</span> 可以直接算，那么样本 <spanclass="math inline">\(x_{M+1}\)</span> 被采样的概率理应为 <spanclass="math inline">\(\frac{w_{M+1}}{w_{sum}+w_{M+1}}\)</span></p><p>此前所有样本 <span class="math inline">\(x_j,j\le M\)</span>被采样到的概率应当变为原来的 <spanclass="math inline">\(\frac{w_{sum}}{w_{sum}+w_{M+1}}\)</span> 倍。</p><p>那么，策略就是以 <spanclass="math inline">\(\frac{w_{M+1}}{w_{sum}+w_{M+1}}\)</span>的概率替换原样本 <span class="math inline">\(y\)</span> 。</p><p>WRS还支持两个蓄水池的合并：</p><p><span class="math inline">\(w_{sum1}, y_1\)</span> 合并 <spanclass="math inline">\(w_{sum2}, y_2\)</span>，则 <spanclass="math inline">\(y_2\)</span> 以 <spanclass="math inline">\(\frac{w_{sum2}}{w_{sum1} +w_{sum2}}\)</span>的概率替换 <span class="math inline">\(y_1\)</span>，证明比较简单。</p><p>注意合并的时候维护 <span class="math inline">\(w_{sum}\)</span></p><h5 id="不同目标分布的蓄水池合并">不同目标分布的蓄水池合并</h5><p>在上面，我们已经证明了RIS可以使用各不相同的提议分布，现在利用这一点，实现两个连目标分布都不同的蓄水池合并。这也是所有时空复用的基础。</p><p>首先，这种策略仅适合两个蓄水池的目标分布接近的情况（相邻像素或相邻帧），若相差较远，此方法同样是无偏的，但合并不会让采样质量更高。</p><p>以合并相邻像素的蓄水池为例，设当前像素为 <spanclass="math inline">\(q\)</span>，蓄水池为 <spanclass="math inline">\(s\)</span>，待合并像素为 <spanclass="math inline">\(q&#39;\)</span>，蓄水池为 <spanclass="math inline">\(r\)</span>，蓄水池各自存储了 <spanclass="math inline">\(\left&lt;w_{sum},y,M,W\right&gt;\)</span>，两个蓄水池中的目标分布 <spanclass="math inline">\(\hat p_q\)</span> 和 <spanclass="math inline">\(\hat p_q&#39;\)</span> 不同，无法直接合并。</p><p>事实上，我们可以将相邻蓄水池的SIRPDF视为一个高质量的提议分布，<spanclass="math inline">\(r.y\)</span> 即为该SIRPDF的一个样本，要将其加入<span class="math inline">\(s\)</span>，这就比较容易了。</p><p>下面是 <ahref="https://agraphicsguynotes.com/posts/understanding_the_math_behind_restir_di/#restir-di-introduction">UnderstandingThe Math Behind ReStir DI</a> 中给出的图。</p><p><imgsrc="https://agraphicsguynotes.com/img/posts/understanding_the_math_behind_restir_di/ReStir_3.png" /></p><p>我们在先前已经证明了提议分布可以各不相同，且有了一个 <spanclass="math inline">\(W\)</span> 用于代替 <spanclass="math inline">\(p_{SIR}\)</span> 的作用。</p><p>要加入的样本权重为： <span class="math display">\[w = \frac{\hat p_q(r.y)}{p_{SIR}(r.y)} \Rarr \hat p_q(r.y) r.W =\frac{\hat p_q(r.y)}{\hat p_q&#39;(r.y)} \frac{r.w_{sum}}{r.M}\]</span> 中间再次利用了 <span class="math inline">\(W\)</span> 的期望和<span class="math inline">\(p_{SIR}\)</span> 的关系，故没有写等号。</p><h6 id="扩大sir样本的影响">扩大SIR样本的影响</h6><p>容易想到，<span class="math inline">\(r.y\)</span>应当是一个质量非常高的样本，代表了相邻像素的 <spanclass="math inline">\(r.M\)</span>个样本，仅仅将其视为一个提议样本有些浪费。考虑到它的重要程度和 <spanclass="math inline">\(r.M\)</span>相关，我们可以<strong>视为这个样本插入了 <spanclass="math inline">\(r.M\)</span>次</strong>，等价于插入一次，但权重乘了 <spanclass="math inline">\(r.M\)</span>倍（如果不理解为什么等价，可以算一下全部插入之后，<spanclass="math inline">\(r.y\)</span> 替代上位的概率）。</p><p>于是最终的权重为： <span class="math display">\[\frac{\hat p_q(r.y)}{\hat p_q&#39;(r.y)} r.w_{sum}\]</span> 同样，<span class="math inline">\(s.M\)</span> 也需要加上<span class="math inline">\(r.M\)</span>，而不是简单地+1。</p><p>这种权重也可以理解为一种MIS，不过由于后面计算 <spanclass="math inline">\(Z(y)\)</span>时还用到了这种思想，我更倾向于将其理解为插入 <spanclass="math inline">\(M\)</span> 次，私以为更加容易理解。</p><p>注意：这种重用<strong>和真的把 <spanclass="math inline">\(s.M+r.M\)</span>个样本拿来重采样一次是不等价的</strong>，但同样能反映采样质量随着提议样本数<span class="math inline">\(M\)</span> 的提高而提高。</p><h5 id="restir-di">ReSTIR DI</h5><p>最关键的蓄水池合并问题已经解决了，空间样本重用方法见上，时域样本重用也只是合并来自上一帧的蓄水池，寻找上一帧的对应也是利用MotionVector。</p><p>TAA是有偏的，我们需要头疼上一帧和这一帧在各种情况下的不同，并且通常很难做到尽善尽美。而ReSTIR的时域重用是无偏的，因为我们的重用策略本身就支持合并目标分布不同的蓄水池，将另一个蓄水池并过来后，仍然是对当前目标分布的无偏估计，可以放心大胆的合并。</p><h6 id="可见性重用">可见性重用</h6><p>ReSTIR DI的目标分布是去掉可见性项后的直接光照 <spanclass="math inline">\(\rho L_eG\)</span>，这样的好处是在计算 <spanclass="math inline">\(\hat p\)</span>时无需进行场景求交，但这也带来了一定的噪声。</p><p><ahref="https://agraphicsguynotes.com/posts/understanding_the_math_behind_restir_di/#restir-di-introduction">UnderstandingThe Math Behind ReStir DI</a>指出的方案是在目标分布中带上可见性项，这里似乎和原文的思路不同。原文将其策略称为VisibilityReuse，并没有提及要改变目标分布，下面按照原文的思路来：</p><p>原文方法非常简单：在蓄水池合并时，检测SIR样本 <spanclass="math inline">\(y\)</span> 是否可见，若不可见，则直接将该蓄水池的<span class="math inline">\(W\)</span>设为0，相当于丢弃了这一蓄水池。这阻止了被遮挡的样本向外传播，使得最终使用的样本大概率是不被遮挡的。</p><h5 id="无偏版本实现">无偏版本实现</h5><p>回忆一下，无偏版本需要修改 <span class="math inline">\(W\)</span>：<span class="math display">\[W(\bold x,z) = \frac{1}{\hat p(y)}\frac{\sum_{j=1}^M w_j(x_j) }{Z(y)},y=x_z\]</span></p><p>考虑如何计算这个 <span class="math inline">\(Z(y)\)</span>，它表示<span class="math inline">\(M\)</span> 个样本（来自于 <spanclass="math inline">\(M\)</span> 个提议分布）中，有多少提议分布满足<span class="math inline">\(p_i(y) &gt; 0\)</span>。</p><p>有两个问题：1. 提议分布可能来自相邻的SIRPDF，它没有闭合解；2.我们不可能追踪所有Proposal PDF。</p><p>对于第一个问题，由于 <span class="math inline">\(\hat p(x)\)</span>与SIRPDF在同样的区域成为0（参照SIRPDF的定义式），可以用 <spanclass="math inline">\(\hat p(x)\)</span> 来代替SIRPDF来计算 <spanclass="math inline">\(Z\)</span>。</p><p>对于第二个问题，我们需要再次强调插入 <spanclass="math inline">\(M\)</span> 次的思想：在合并一个蓄水池 <spanclass="math inline">\(r\)</span>的时候，我们并不是合并这个蓄水池的所有历史样本，而是视为当前的SIRPDF样本<span class="math inline">\(r.y\)</span> 插入了 <spanclass="math inline">\(r.M\)</span> 次，这 <spanclass="math inline">\(r.M\)</span> 个样本全部来自于该SIRPDF。于是只要<span class="math inline">\(p_{SIR}(y) &gt; 0\)</span>，就可以直接令<span class="math inline">\(Z += r.M\)</span> 。</p><p>计算过程可以看论文中的伪代码。</p><p>至于MIS版本的 <span class="math inline">\(W\)</span>： <spanclass="math display">\[W(\bold x,z) = \frac{1}{\hat p(x_z)} \frac{p_z(x_z)}{\sum_{j=1}^Mp_j(x_z)} \sum_{j=1}^M w_j(x_j) \\\]</span>这个版本的无偏公式在论文中没有实现，我也不知道具体要怎么实现。</p><h5 id="problem">Problem</h5><ul><li>为什么去掉可见性项，计算 $p $就不需要光线求交了？如何从给定位置+方向找到光源？</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>Sampling</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenGL入门</title>
    <link href="/2023/02/26/%E7%AC%94%E8%AE%B0/openGL%E5%85%A5%E9%97%A8/"/>
    <url>/2023/02/26/%E7%AC%94%E8%AE%B0/openGL%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>https://learnopengl-cn.github.io/</p><p>基本是跟着这个网站来的，感谢大佬们提供了这么好的资源</p><h4 id="opengl-状态机">OpenGL 状态机</h4><p>熟悉这种状态机的模式非常有帮助。</p><p>openGL中的各种对象通常通过 <code>glGenXXX</code>来生成，对象用一个uint来标识，openGL内部会记录这个uint对应的对象内容，我们只需把这个数看做一个对象即可。</p><p>绑定，openGL中常需要进行 <code>glBindxxx</code>操作，这是将对象绑定到一个<strong>上下文</strong>，如<code>glBindBuffer(GL_ARRAY_BUFFER, VBO)</code>，可以认为<code>GL_ARRAY_BUFFER</code> 是一个上下文，有时也称<code>Target</code>，绑定后，接下来对 <code>GL_ARRAY_BUFFER</code>的操作就是对 <code>VBO</code> 的操作。</p><h4 id="vbovao">VBO，VAO</h4><p>首先关注他们的名字：</p><ul><li>顶点缓冲对象：Vertex Buffer Object，<strong>VBO</strong></li><li>顶点数组对象：Vertex Array Object，<strong>VAO</strong></li></ul><p>每个顶点可能会包含一堆数据（常见的有坐标，颜色等），CPU需要把这些数据发送给显卡，为了一次性发送大量数据，会使用一个缓冲来暂存顶点数据，这就是VBO，它仅仅只是一堆本质上没区别的数据，具体如何访问这些数据，就是VAO决定的。</p><p>可以认为，VAO对VBO的数据定义了一种分类，组装的方式，将一堆数据拼成了有意义的一个数组，VAO就是把这种访问方式保存下来。</p><p>具体而言，我们可以创建一个VBO来保存东西：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO;<span class="hljs-comment">//glGenXXX就是创建一个对象，为其分配空间</span><span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;VBO);<span class="hljs-comment">//将VBO绑定上缓冲GL_ARRAY_BUFFER，可以理解为设置状态：当前存储顶点的位置是VBO</span><span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<span class="hljs-comment">//往一个缓冲中塞数据，这时的VBO已经绑定GL_ARRAY_BUFFER，这样就能保存在这个VBO当中</span><span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(dataSource), dataSource, GL_STATIC_DRAW);</code></pre></div><p>这样就有一块纯纯的数据了，可以用下面两行东西来指定这块东西的解读方式：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//设置对数据的解读方式</span><span class="hljs-comment">//首先，每个顶点属性有一个属性值（标号）（即vertexShader中的layout）</span><span class="hljs-comment">//这里的意思是：对于属性值为0的属性，它要读取3个float，不需要标准化，下一个顶点的对应属性在3个步长之后，从0开始读。</span><span class="hljs-comment">//然后设置：将属性值为0的顶点属性启用（默认是禁用的）</span><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);</code></pre></div><p>然后就能一行完成渲染啦！第一个参数为图元装配方式，指定为三角形，也就是说会把我们输入的顶点，每三个组成一个三角形传入片元着色器。从0位置开始，一共读3个顶点</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);</code></pre></div><p>因为openGL是一个大状态机，在渲染不同物体时，必须绑定对应的VBO，更改对应的解读方式才行。这样换起来太麻烦了，于是有了VAO：它能把这些都保存起来，然后直接绑定VAO就能自动绑定上VBO和切换glVertexAttribPointer。为什么它叫<strong>顶点数组对象</strong>呢？我理解为，它获取到一块数据和对应的解读方式，就直接将顶点分类包装成数组了。它具体存储的是什么，目前理解比较浅。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VAO;<span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>, &amp;VAO);<span class="hljs-built_in">glBindVertexArray</span>(VAO);...<span class="hljs-built_in">glBindVertexArray</span>(<span class="hljs-number">0</span>);</code></pre></div><p>VAO是工作在bind和unbind之间的，也就是说，在glVertexAttribPointer之前，先将VAO绑定，然后VAO将记录你执行的glVertexAttribPointer，保存这一解读方式（同时也保存了当前绑定的VBO），记录完成后解绑VAO即可。渲染时如果要调用这组数据，直接绑定这个VAO就可以了，将自动设置glVertexAttribPointer和VBO，非常方便。</p><p><imgsrc="https://learnopengl-cn.github.io/img/01/04/vertex_array_objects.png" /></p><h5 id="更多顶点属性">更多顶点属性</h5><p>如果顶点包含两个属性：位置和颜色，在顶点着色器中分别将属性值设置为0和1</p><p>属性值只是一种标号，和内存地址无关</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#version 330 core</span><span class="hljs-built_in">layout</span> (location = <span class="hljs-number">0</span>) in vec3 aPos;   <span class="hljs-comment">// 位置变量的属性位置值为 0 </span><span class="hljs-built_in">layout</span> (location = <span class="hljs-number">1</span>) in vec3 aColor; <span class="hljs-comment">// 颜色变量的属性位置值为 1</span></code></pre></div><p>然后是VBO中的数据，里面有三个顶点：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">float</span> vertices[] = &#123;    <span class="hljs-comment">// 位置              // 颜色</span>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// 右下</span>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// 左下</span>     <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>    <span class="hljs-comment">// 顶部</span>&#125;;</code></pre></div><p>对于这样的情况，解读方式应该是：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//位置属性</span><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">6</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//颜色属性</span><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">6</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)(<span class="hljs-number">3</span>* <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">1</span>);</code></pre></div><p>注意：属性长度仍然是3，两个属性都只需要读3float的数据，步长是6，因为一个位置属性和下一个位置属性间隔6float，颜色属性的偏移为3，即起始点从3开始，6格6格跳</p><h5 id="ebo-索引缓冲">EBO 索引缓冲</h5><p>实际绘制物体时，可以用一个个小三角拼成，比如要拼一个正方形，顶点数组可以这样：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">float</span> dataSource2[] = &#123;        <span class="hljs-number">0.9f</span>, <span class="hljs-number">0.9f</span>, <span class="hljs-number">0.0f</span>,        <span class="hljs-number">0.9f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,        <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,        <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,        <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.9f</span>, <span class="hljs-number">0.0f</span>,        <span class="hljs-number">0.9f</span>, <span class="hljs-number">0.9f</span>, <span class="hljs-number">0.0f</span>&#125;;</code></pre></div><p>图元装配时指定装配6个顶点，可以轻松得到一个正方形，它是两个三角形拼起来的</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);</code></pre></div><p>但是这样显然有大量冗余，所谓索引缓冲对象，就是指定了遍历顶点的方式，默认是从0..n这样遍历的，</p><p>我们可以指定遍历顺序。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> indices[] = &#123; <span class="hljs-comment">// 注意索引从0开始!</span>        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-comment">// 第一个三角形</span>        <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>  <span class="hljs-comment">// 第二个三角形</span>&#125;;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> EBO;<span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;EBO);<span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);<span class="hljs-built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</code></pre></div><p>这里用和VBO相似的方式，配置了一个EBO，同样地，这个信息可以被VAO存储，只需要写在VAO的bind和unbind之间即可。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES, <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);</code></pre></div><p>把绘图函数改成这个，即可按照当前绑定在GL_ELEMENT_ARRAY_BUFFER上的索引表来遍历。</p><h4 id="着色器">着色器</h4><p>主要编写的是顶点着色器和片段着色器</p><p>顶点着色器必须给出一个<code>gl_Position</code>，它表示这个顶点所在的位置（在<strong>标准化设备坐标</strong>下的，实际参与渲染的位置，不是什么局部坐标世界坐标之类的）</p><p>顶点着色器的其他各种输出信息在光栅化阶段会被各种“插值”，变成大量片元输出到片元着色器。比如经典的：用三个顶点坐标显示一个宏观的三角形，实际上片元着色器接受到的片段有成百上千个，但我们仅输入了三个顶点，每一个片段的具体位置均是根据插值得到的。</p><p>同时，各种其他顶点输出的信息也都会被插值，比如颜色等等。</p><p>片段着色器负责计算一个像素的最终颜色，它可能需要从顶点着色器中接收一些</p><h5 id="uniform">uniform</h5><p>着色器中可以使用uniform定义一个唯一的变量，在外部通过一些操作更改（实现外部直接把值传入shader任意一个阶段）</p><div class="code-wrapper"><pre><code class="hljs glsl"><span class="hljs-keyword">uniform</span> <span class="hljs-type">float</span> offX = <span class="hljs-number">0</span>, offY = <span class="hljs-number">0</span>;</code></pre></div><p>外部，传入名称和值即可，glUniform后+数字+类型，如3f表示更改的是一个3维float向量类型</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">glUniform1i</span>(<span class="hljs-built_in">glGetUniformLocation</span>(shaderProgram, name), value);</code></pre></div><p>外部获取这个值？没有找到资料，可能从外部获取它的值本就不合逻辑</p><p>uniform不能在shader内部赋值，但可以初始化（设置缺省值）</p><h5 id="特殊的uniform">特殊的uniform</h5><div class="code-wrapper"><pre><code class="hljs c++">uniform sampler2D texture1;</code></pre></div><p>用于获取纹理，它的值可以用int方式更改，如果它为2，那么它就表示GL_TEXTURE2这个纹理单元上的纹理图片，在shader中使用<code>texture(texture1, Texpos)</code>获得这张纹理具体位置上的颜色。</p><p><code>sampler2D</code>是一种“不透明类型”，它不能被实例化，只能定义为uniform。</p><p>包含有不透明类型的结构体、类同样为不透明类型。</p><p><strong>注意：</strong>虽然 <code>glUseProgram</code>指明了shaderprogram，但仍必须use着色器之后才能对其设置！</p><h4 id="纹理">纹理</h4><p><code>Texture unit</code>（<code>GL_TEXTUREi</code>） 包含了多种Target，但规范明确表示了，每个sampler必须使用不同的unit，即便它们的类型不同。</p><h4 id="完整管线">完整管线</h4><p>顶点进入顶点着色器，经历局部坐标 - 世界坐标 -观察坐标，变换到观察空间</p><p>随后通过一个投影矩阵，这个投影矩阵定义了空间中一块能看见的区域（长方体、平头截体），投影矩阵将这片区域映射到<span class="math inline">\([-1,1]^3\)</span>这个小立方体中，我们最终只绘制这个小立方体内的物体。</p><p>这个小立方体就是裁剪空间，也叫<strong>标准设备坐标系，NDC</strong>。后续操作在这个坐标系中进行。</p><p>我们在上面的变换中一直认为 <spanclass="math inline">\((a,b,c,1)\)</span> 和 <spanclass="math inline">\((aw,bw,cw,w)\)</span>是同一个坐标，转换到NDC之后该归一化一下了，这一步也叫透视除法，就是让每个顶点的<span class="math inline">\(x,y,z\)</span> 都除以它的 <spanclass="math inline">\(w\)</span> 分量，<spanclass="math inline">\(w\)</span>分量本身保持不变，是为了保留其深度信息以做矫正。</p><p>然后进行一个简单的视口变换，在 <spanclass="math inline">\(xy\)</span> 方向拉伸平移一下，不去动 <spanclass="math inline">\(z\)</span>。</p><p>在此之前我们一直对顶点操作，接下来进行图元装配，经过几何着色器我们得到了三角形（或者其他形状）</p><p>对三角形进行光栅化，随后每个像素（片段）进入片段着色器，用插值后的数据来计算这个像素的最终颜色并输出。</p><p>随后进行深度测试，丢弃一些片段，通常也可以在着色一个像素前就测试并丢弃。</p><p>上述视口变换和图元装配，顺序应该无所谓。</p><h4 id="理清变换">理清变换</h4><p>理清的关键点：</p><ul><li>使用四阶矩阵，不仅能表达一种变换，也能表达一种<strong>坐标系</strong>。左上三维为三个基向量，右列三个数为原点位置，右下角为<span class="math inline">\(w\)</span> 分量<ul><li>可以视为先进行了左上3x3矩阵所示的线性变换，再进行了一个平移</li></ul></li><li>对于每个物体，用一个<strong>Transform</strong>矩阵表达其坐标系，它也相当于物体从和世界坐标系重合（单位矩阵）开始，到当前状态经历的变换。对物体的变换都是对整个坐标系的变换<ul><li>这个变换看起来不是线性变换（移动了原点），但在四维空间下，它是线性变换。</li><li>如果想让物体参照世界坐标系变换，就直接在其矩阵左侧乘即可。</li><li>如果想让物体参考自身坐标系变换，可以运用相似矩阵（相当于矩阵右侧乘）</li></ul></li><li>对于单个顶点，才用向量表示，它在物体坐标系下是一个固定的量。</li><li>相机可以认为是一个物体，它有一个坐标系，它的朝向是一个向量，相对于相机坐标系也固定的，在openGL中应为<span class="math inline">\((0,0,-1)\)</span>（朝 <spanclass="math inline">\(z\)</span> 轴负方向）<ul><li>因此也可以用一个简单的矩阵来描述相机，不必关心其朝向，因为我们直接记录了相机坐标系，朝向固定为<span class="math inline">\((0,0-1)\)</span></li></ul></li></ul><h4 id="光照">光照</h4><p>当我们把一个光照施加到一个物体上时，输出光照颜色和物体颜色的乘积（各个分量各自相乘）即可，注意这里的颜色量值域为(0,1)，而非(0, 255)</p><p>冯氏光照模型主要分三部分：环境光照，漫反射，镜面反射</p><p><strong>环境光照</strong>：始终使物体接受到某个光照，例如(0.1, 0.1,0.1)</p><p><strong>漫反射</strong>：对于每个片元，取其法向量和光照方向的点积（二者都标准化到模为1）作为光照强度，即正对光照的亮度高，背对的亮度低。（这个阶段我们一般不考虑阻挡、距离等因素）</p><p><strong>镜面反射</strong>：对每个片元，取其光照反射方向（通过法向量计算）和玩家视觉方向的点积，作为光照强度，意义是玩家在某个片元反射方向附近时，能看到它上面的高光。</p><p>点积的两个向量都为标准化向量，故结果不大于1，为了更加凸显高光可以对这个值取幂，一般取32次幂为宜，越大则说明高光越集中，反射能力越强。</p><p>注意镜面反射仅与观察者位置有关，与观察者视角无关</p><h4 id="法线">法线</h4><p>直观上来讲，一个三角形的法线可以直接由三条边计算出来，但openGL并不会直接帮我们算这个，是有原因的。</p><p>法线信息一般放在顶点上，若模型没给定，可以由面法线均值计算得到。</p><p>片元法线如果由插值得到，可以获得平滑的光照效果，而如果三个顶点法线都一样，则可以有锐利边缘。</p><h5 id="法线变换">法线变换</h5><p>物体变换时法线也应该跟着变，法线和一般的顶点位置向量不同，在不等比缩放时，它应当保持<strong>垂直</strong>关系而非进行相同变换；它也不应受位移影响。</p><p>简单数理推导可得出，法线变换矩阵应当是<code>变换矩阵左上3x3矩阵的逆矩阵的转置</code></p><p>逆矩阵运算对于GPU来说非常慢，故最好在CPU中计算好直接传入。</p><h4 id="材质和光照贴图">材质和光照贴图</h4><p>材质即物体的贴图+上述光照模型中的参数，通过更改三种光的强度以及反光度可以模拟不同物体的反射效果。</p><p>并不是每一个参数都值得更改，一般的材质：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Material</span>&#123;    sampler2D diffuse;    vec3 specular;    <span class="hljs-type">float</span> spininess;&#125;;</code></pre></div><ul><li>环境光颜色与漫反射颜色 =物体自身颜色，通常没必要更改，强度差别取决于光照设定</li><li>镜面光颜色 = 白 * 一定系数，这个系数决定了镜面光的亮度。<ul><li>也可以用物体自身颜色，这会使高光更接近物体自身颜色，使用白色则高光更接近光源颜色。</li></ul></li><li>反光度/镜面反射率决定了表面反光能力，越大则反光越强，高光越集中，越适用于金属玻璃等材质。</li></ul><p>材质参考：http://devernay.free.fr/cours/opengl/materials.html</p><p>光照材质：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Light</span>&#123;    vec3 position;    vec3 ambient;    vec3 diffuse;    vec3 specular;&#125;;</code></pre></div><p>环境光、漫反射、镜面反射的配比取决于我们对光照的设定。通常镜面颜色设置为光源本身颜色，漫反射和环境光设置为光源颜色的0.6,0.2倍左右。</p><h5 id="光照贴图">光照贴图</h5><p>可以给物体附上多张贴图，在漫反射部分使用漫反射贴图，镜面反射部分使用高光反射贴图，实现同一个物体表面不同部分的不同效果。</p><h4 id="网格与模型">网格与模型</h4><p>网格这个名词一开始让我有点搞不明白，后来我意识到一件事情：3d模型是十分复杂的，除了基本的顶点数据之外，还可能包含多张贴图、动画、多种材质乃至场景信息，不同部分可能应用不同贴图。</p><p>“网格”就是一组三角面片，包含一个顶点数组和相应贴图，即先前我们理解中最简单的模型，一个实际的模型包含许多网格。</p><p>模型除了用网格表示外，还有点云、体素等多种方式。本项目只考虑网格。</p><p>模型文件格式众多，可以使用工具库assimp读取，需要了解的是大多数模型存储的逻辑：使用一个模型文件记录网格信息，在旁边放贴图等资源文件，模型文件中包含了<strong>贴图相对路径</strong>等信息。故通常不能将下载到的模型和资源文件拆开。</p><h4 id="缓冲与测试">缓冲与测试</h4><p>openGL提供了若干种缓冲（临时数组），我们通常在每一帧绘制前使用<code>glClear</code> 清空这些缓冲。</p><p>深度测试和模板测试可以根据缓冲内容选择性地抛弃一些片元，可以用<code>glEnable</code>启用测试，也有各自的函数来配置筛选方法、写入掩码等等。</p><p>深度缓冲和模板缓冲都以屏幕位置为索引，它们在每一次绘制前被清空，绘制内容时被更新，从而影响接下来的绘制。简而言之它们是面向整个场景而非单个物体的。</p><h5 id="深度测试">深度测试</h5><p>记录屏幕坐标下每个位置上的片元深度（<spanclass="math inline">\(z\)</span>坐标），一般情况下，仅当新片元深度更小时才会绘制并更新。可以用<code>glglDepthFunc</code> 配置其他的筛选方式。</p><p>关于深度：强大的裁剪矩阵已经帮我们计算好了每个片元的 <spanclass="math inline">\(x,y\)</span>位置以及深度，深度测试其实就是记录每个位置的最大深度以及颜色。它使用的缓冲我们需要手动清空<code>glClear(GL_DEPTH_BUFFER_BIT);</code>，记得 <code>glClear</code>是用bitmask的，可以把 <code>GL_DEPTH_BUFFER_BIT</code>和其他东西或起来。</p><p>裁剪矩阵对 <span class="math inline">\(z\)</span>轴的映射也不是线性的，越远的地方粒度越大，精度越低。</p><p>具体而言，映射后的深度值（也叫深度精度值？）是与 <spanclass="math inline">\(1/z\)</span>正相关的，如近平面距离为2，远平面距离为10，则深度值0.5实际对应了 <spanclass="math inline">\(\frac{1}{1/2+1/10}\)</span> 即距离2.5的地方。</p><p>片段着色器中，<code>gl_FragCoord</code>这个内建变量存储了该片段的深度信息，<spanclass="math inline">\(x,y,z\)</span> 分别表示片段的位置和深度。</p><h5 id="深度冲突">深度冲突</h5><p>如果两个平面恰好重叠在一起，就很难说明谁上谁下了，常常会导致闪烁，实际渲染中应当尽量避免此类情况。</p><h5 id="模板测试">模板测试</h5><h4 id="面剔除">面剔除</h4><p>一种非常聪明的技巧。</p><p>试想：在我们观察一个<strong>封闭几何体</strong>的时候，总有几个面是永远看不到的（是指背面，而非里面），对于这几个面，虽然用深度缓冲能覆盖他们，但还不够优秀，我们有办法把它更早一步剔除掉。</p><p>如果我们在定义一个面的顶点顺序时，始终假设我们面向它（从封闭几何体的外部），然后逆时针写下这三个顶点。</p><p>那么在三角形变换到裁剪空间下后，如果它还是面向我们，三个顶点就一定是逆时针的，否则就一定是顺时针，可以直接将其剔除。</p><p>判断顺逆时针是个运算量很小的活，所以面剔除能非常有效地提升性能。</p><p>面剔除的结果：在封闭几何体的内部观察时，它透明了。如果我们对一个单独的三角形进行面剔除，会发现只能从一个方向上看到它，这些特性有时也会被利用到。</p><p>它可能很像是剔除了一个面的<em>里面</em>，但我们都知道图形学本身没有什么内外双面的概念，只是剔除了背面而已。</p><h4 id="透明与混合">透明与混合</h4><p>将半透明的物体绘制到原有颜色缓冲上，需要进行混合。</p><p>通常将颜色缓冲中原有的内容叫目标，即将绘制的半透明颜色叫源，将源绘制到目标上。</p><p>问题：深度测试，处于前方的透明物体先绘制之后，后面的内容将不会绘制。</p><p>解决：透明物体最后绘制，且按到视点的距离排序，由远到近绘制。</p><p>问题：距离不好排序，通常采取近似方法，适用于大部分场合。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>openGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>光线追踪入门</title>
    <link href="/2023/02/26/%E7%AC%94%E8%AE%B0/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%85%A5%E9%97%A8/"/>
    <url>/2023/02/26/%E7%AC%94%E8%AE%B0/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="光线与平面求交">光线与平面求交</h4><p>光线可以表示为 <span class="math inline">\(r=o+td\)</span>，其中<span class="math inline">\(o\)</span> 为原点，<spanclass="math inline">\(d\)</span> 为方向。</p><h5 id="隐式表面">隐式表面</h5><p>隐式表面定义为 <span class="math inline">\(f(p)=0\)</span></p><p>则求解 <span class="math inline">\(f(o+td)=0\)</span> 即可，取 <spanclass="math inline">\(t\)</span> 最小值（<spanclass="math inline">\(t&gt;0\)</span>）对应处作为交点。</p><h5 id="显示表面">显示表面</h5><p>光线与三角形求交：</p><p>首先计算光线与三角形所在平面的交点，然后计算点是否在三角形内。</p><p>平面的方程：<span class="math inline">\(f(p)=(p-p&#39;)\cdotN=0\)</span>，<span class="math inline">\(p&#39;\)</span>为平面上任意点，<span class="math inline">\(N\)</span>为平面的任意垂线，而从三角形得出这样的平面参数很简单。</p><p>另一种方式：列出三角形面的方程（重心坐标），得到 <spanclass="math inline">\(O+tD=(1-u-v)P_0+uP_1+vP_2\)</span>，它可以写作一个线性方程组，解得<span class="math inline">\(t,u,v\)</span>，然后判断重心坐标是否都在<span class="math inline">\([0,1]\)</span> 内。</p><p>此处碰撞得到的 <span class="math inline">\(u,v\)</span>可以记录下来，之后用这个坐标获取表面材质信息。</p><h4 id="aabb">AABB</h4><p>轴对齐包围盒（Axis-Aligened Bounding Box）</p><p>求光线与包围盒是否相交：包围盒有三个对面，计算光线与每对面相交的两个<span class="math inline">\(t\)</span> 值（<spanclass="math inline">\(t_{min}\)</span> 和 <spanclass="math inline">\(t_{max}\)</span>），得到三组 <spanclass="math inline">\(t\)</span>的区间，这三组的区间的交集即为光线在盒子中的时间。</p><h4 id="grid方法">Grid方法</h4><p>旧方法</p><p>将区域划分为很多个格子，计算每个格子中是否有物体，光线进入时可以采用类似Bresenham的方法计算接触的格子（很快），若格子中有物体再检测。</p><h4 id="空间划分方法">空间划分方法</h4><h5 id="八叉树">八叉树</h5><p>每次划分都划分为8块，直到区域不包含内容或者足够小</p><h5 id="kd-tree">KD-Tree</h5><p>每次仅将区域划分为2块，采用某种策略选取最优的划分位置和方向。</p><p>划分的方向还是平行的</p><p>中间节点都是包围盒，物体都存在叶子节点中。</p><p>一个图元可能被划分到多个空间中，此时这个图元就需要在多个空间中都进行求交。</p><h5 id="bsp-tree">BSP-Tree</h5><p>在KD-tree的基础上，划分方向可以是斜的，划分效果可能更好，但抛弃了AABB，计算效率并不优秀。</p><h5 id="bvh">BVH</h5><p>Bounding Volume Hierarchy</p><p>基于物体的划分，而非基于空间的划分。</p><p>和KD-Tree差不多，但是划分时不再是将空间一刀划开，而是将其中物体分为两个部分，两个部分各自形成一棵子树，两个子树的包围盒<strong>可以重叠</strong>，这使得每个图元可以仅属于一棵子树。</p><p>实现起来非常容易，可以直接根据父包围盒三维的长度，在最长的一维上，按三角形个数划分（一半划到左一半划到右，<spanclass="math inline">\(O(n)\)</span> 找出中位数即可）。</p><p>递归求交时，严格意义上来说两个子空间是没有先后顺序的，即使在一个空间内找到了交点，另一个必须求交计算，这使得朴素BVH求交效率会低于kd-tree。我们很容易想到一些剪枝：根据包围盒的交点决定顺序，若在第一个空间中已经得到交点，且在第二个空间的包围盒交点之前，则跳过。</p><h6 id="sah优化">SAH优化</h6><p>按三角形个数进行的划分有显而易见的问题，当出现特别大时三角形时，划分不那么均匀，重叠部分也可能非常大。</p><p>SAH (Surface Area Heuristic)优化即按照包围表盒面积来确定一个最优的划分方案。粗略认为，一个包围盒被击中的概率与其面积成<span class="math inline">\(S\)</span>正比，而击中这个包围盒之后的开销，又可以粗略认为和其中的物体数 <spanclass="math inline">\(N\)</span> 成正比。于是SAH策略要求我们找到 <spanclass="math inline">\(S_1N_1+S_2N_2\)</span> 最小的划分策略。</p><p>需要排序，前后各扫一遍预处理出包围盒之后，尝试所有划分点即可（三个轴各自来一次）。</p><h4 id="radiometry">Radiometry</h4><h5 id="立体角">立体角</h5><p><code>steradians</code></p><p>二维角度的标准定义（弧度）：<spanclass="math inline">\(\theta=\frac{l}{r}\)</span>，弧长/半径</p><p>三维立体角的定义：<span class="math inline">\(w =\frac{A}{r^2}\)</span>，弧面面积/半径方</p><p>单位立体角：</p><p>在球面上 <span class="math inline">\((\theta,\phi)\)</span> （通常<span class="math inline">\(\theta\)</span> 指与z轴的夹角，<spanclass="math inline">\(\phi\)</span>指在xy平面上投影的经典一维角度）处，画图容易计算弧面的微分 <spanclass="math display">\[d_A=(rd_\theta)(rsin_\theta d_\phi)\]</span> 则有单位立体角（微分立体角） <span class="math display">\[d_w=\frac{d_A}{r^2}=sin_\theta d_\theta d_\phi\]</span> 立体角积分： <span class="math display">\[\theta\leq \pi,\phi\leq 2\pi\\\int_{\Omega^+}d_w=\int_0^{2\pi}\int_0^{\pi} sin_\theta d_\thetad_\phi=4\pi\]</span></p><p>这里具体要看球面坐标怎么定义，知道原理即可。</p><h5 id="辐射度量学">辐射度量学</h5><p><spanclass="math inline">\(\phi\)</span>：辐射通量，单位时间发出的能量 <spanclass="math inline">\(\phi=\frac{dQ}{dt}\)</span>，类似功率。通量也可以理解为单位时间通过的光子数量。单位有流明<code>lumen</code></p><ul><li>渲染中我们通常不会用到 <spanclass="math inline">\(Q\)</span>，通常都是以 <spanclass="math inline">\(\phi\)</span> 来衡量能量。</li></ul><p><spanclass="math inline">\(I\)</span>：Intensity，点光源发出的，在单位立体角上的Power，<spanclass="math inline">\(I=\frac{d\phi}{dw}\)</span>，或 <spanclass="math inline">\(I=\frac{\phi}{4\pi}\)</span></p><p><spanclass="math inline">\(E\)</span>：Irradiance，每单位面积接受到的Power，<spanclass="math inline">\(E=\frac{d\phi}{dA}\)</span>，这个量仅用来衡量单位面积上接收到的通量，并关心光是从什么方向入射的。</p><ul><li>点光源自由发散时，随距离增大，Intensity不变（单位立体角上的光强没变），接受方的Irradiance按<span class="math inline">\(r^2\)</span> 衰减。</li></ul><p><spanclass="math inline">\(L\)</span>：Radiance，单位面积在单位立体角上的辐射Power<spanclass="math inline">\(L=\frac{d^2\phi}{d_wd_Acos_\theta}\)</span></p><ul><li><span class="math inline">\(E = \int_{\Omega^+} Lcos_\thetad_w\)</span>，这里看出，<span class="math inline">\(E\)</span>是从表面角度来考虑的，而 <span class="math inline">\(L\)</span>是从光线角度考虑的。</li></ul><p>关于Radiance，我在很长一段时间里没能理解它的本质，从而对无法自己推导出BRDF的公式。另一件事情也同样困惑了我很久：直接光照下，光源距离物体越远，照明效果越差；而在路径追踪中，我们计算来自下一次反射的<span class="math inline">\(L_i\)</span>时，却根本不考虑下一个Bounce距离我们有多远。更进一步，人眼无论距离物体多远，看到的颜色都一样，应该怎么解释？</p><p><img src="http://lxtyin.ac.cn/img/Gemo/radiance.png" /></p><p>如果只看前两幅图，会觉得计算 <span class="math inline">\(L_i\)</span>必然要考虑到双方之间的距离，并且处理起来很困难。同时还面临着“发射方的L和接收方的L是一个东西吗？”的疑问。</p><p>但当微分立体角无限小，<span class="math inline">\(dA\)</span>无限小时，<span class="math inline">\(L\)</span><strong>就是</strong>一根光线（不存在近似，这是一个 <spanclass="math inline">\(\frac{x}{\infty}\)</span>的问题）。它无论传输到近处还是远处，只要距离是有限的，都一样。</p><p>有了这个想法，一切都迎刃而解了：<spanclass="math inline">\(L\)</span>是衡量光线的一个物理量，它<strong>不会随着传输距离而损耗</strong>。那么，发射方的Radiance和接收方的Radiance得以统一，Radiance成为了我们路径追踪中，最适合用于衡量光线能量的物理量。</p><p>人眼看到物体的颜色与距离无关，也可以用上述理论阐述：视网膜上任意微面<span class="math inline">\(dA\)</span>接收到的Radiance没有变，变了的只是物体在视网膜上成像的面积。</p><p><strong>错误认识</strong>：物体发出很多根光线，随着距离增大，光线会变稀疏（Radiance变小）。</p><p>在 <span class="math inline">\(d_w\)</span>无限细分的情况下，光线有无数根，在有限的距离下，Radiance不变。这是一个<span class="math inline">\(\frac{\infty}{x}\)</span> 的问题。</p><h4 id="渲染方程">渲染方程</h4><p><span class="math display">\[L_o(p,w_o)=L_e(p,w_o)+\int_{\Omega^+}L_i(p,w_i)f_r(p,w_i\rightarroww_o)cos\theta_idw_i\]</span> 其中，<span class="math inline">\(w\)</span>表示一个方向，<span class="math inline">\(dw\)</span>为这个方向上的微分立体角。</p><p><span class="math inline">\(w_r\)</span>方向上的辐射，等于自身在这个方向的发光（辐射）加上所有其他方向 <spanclass="math inline">\(w_i\)</span> 入射的光反射对 <spanclass="math inline">\(w_r\)</span> 的贡献。<spanclass="math inline">\(f_r(p,w_i\rightarrow w_r)\)</span>是一个BRDF方程，定义了一个方向的入射光对另一个方向出射光的贡献，通过定义不同的BRDF方程可以实现不同的材质。</p><p>渲染方程是递归定义的，是<strong>正确的</strong>，这里的正确指它完全符合现实世界，但我们实现时还是需要用到一点近似，或者说仅仅实现“<strong>期望上正确</strong>”。</p><h4 id="蒙特卡洛方法">蒙特卡洛方法</h4><p>随机采样。</p><p>通用形式（使用任何分布的概率来采样），近似地求 <spanclass="math inline">\(f(x)\)</span> 的定积分，定积分域蕴含在随机变量<span class="math inline">\(X\)</span> 中。 <spanclass="math display">\[\frac{1}{N}\sum_{i=1}^N \frac{f(X_i)}{p(X_i)}\]</span> 渲染方程应用蒙特卡洛方法之后（这里暂时忽略了自发光）： <spanclass="math display">\[L_o(p,w_o)=\frac{1}{N}\sum_{i=1}^N \frac{L_i(p,w_i)f_r(p,w_i\rightarroww_o)(n\cdot w_i)}{p(w_i)}\]</span></p><p>注意：上式考虑到了 <span class="math inline">\(X\)</span>的概率密度，故一定要按照 <span class="math inline">\(X\)</span>的分布来抽样，而不能人为干预，否则结果的期望就不正确了。</p><h5 id="多种策略下应用蒙特卡洛方法">多种策略下应用蒙特卡洛方法</h5><p>采样蒙特卡洛方法可以使用任何分布的概率，都正确，而使用特殊的分布可以加速收敛（准确来说，能够降低采样结果的方差）。重要性采样即对贡献较大的方向以更高的概率采样。</p><p>还可以将直接光与间接光的贡献分开统计，但这里要注意期望的正确性，不能违背蒙特卡洛方法的概率性原则，否则会收敛于一个错误结果。</p><ul><li>对于面积光源的采样，具体见下</li><li>对于点光源的采样，很麻烦，一般使用一个小面片代表点光源。<ul><li>一种错误的思路是直接加上点光源方向的贡献（设pdf=1），因为随机的间接光方向击中光源点的概率为0</li><li>这种思路下，点光源距离物体的距离不影响点光源的贡献，显然是错误的。根本在于点光源在半球上的占比没有随着距离的增大而缩小。</li></ul></li><li>对于环境光源，一种想法是将其单纯作为背景色，另一种策略是对其进行重要性采样，某种意义上相当于对直接光照单独考虑。</li></ul><h5 id="蒙特卡洛方法的要求">蒙特卡洛方法的要求</h5><p>虽然概率分布可以随意，但也要注意一点：</p><ul><li>所有 <span class="math inline">\(f(x)\gt 0\)</span> 的地方，需要有<span class="math inline">\(p(x)\gt 0\)</span>。<ul><li>（我并没有找到这个定义，但自己想想是显然的）</li></ul></li></ul><p>可以随便举个极端例子，如只在前半段有概率，后半段无，那么结果的期望当然是不正确的。这本质是因为出现了未定义的<span class="math inline">\(\frac{0}{0}\)</span>，被当做了0处理。</p><p>不过，在 <span class="math inline">\(f(x)=0\)</span> 的地方，是可以有<span class="math inline">\(p(x)=0\)</span> 的。</p><h4 id="路径追踪">路径追踪</h4><p>问题：即使随机采样，还是会出现指数爆炸的问题</p><ul><li>N = 1，仅反射一次，这样得到的图像会有大量噪声。<ul><li>每个像素发出多根光线以平均</li><li>后期去噪</li></ul></li></ul><p>问题：无限递归</p><ul><li>当然可以简单设置反弹次数，但不够好</li><li>轮盘赌法：设置一个概率 <spanclass="math inline">\(p\)</span>，以概率 <spanclass="math inline">\(p\)</span> 往外反弹一次，得到的结果再除以 <spanclass="math inline">\(p\)</span>，这样可以维护期望不变，场景亮度是真实的。</li></ul><p>优化：直接光照、间接光照划分</p><ul><li><p>思路：将直接光照和间接光照分开计算（分别划分到球面上的一块区域，各应用用蒙特卡洛方式积分）</p></li><li><p>因直接光照贡献较大，随机一条直线很可能碰不到直接光，故单独计算。</p><ul><li><p>面光源：在立体角上的采样改为<strong>在光源面上</strong>的采样。我们将光源面投影到立体角，得到映射关系<span class="math inline">\(dw =\frac{cos\theta&#39;}{\|x&#39;-p\|^2}dA\)</span>，其中 <spanclass="math inline">\(x&#39;\)</span> 是在光源面上的抽样，<spanclass="math inline">\(\theta&#39;\)</span> 是 <spanclass="math inline">\(xx&#39;\)</span>连线与光源面法线的夹角，直接光照的贡献为： <span class="math display">\[L_o&#39;=AL_i(p,w_i)f_r(p,w_i\rightarroww_o)cos\theta\frac{cos\theta&#39;}{\|x&#39;-x\|^2}\]</span></p></li><li><p>这是在光源面上均匀抽样了一个点，概率为 <spanclass="math inline">\(1/A\)</span>，然后将对 <spanclass="math inline">\(w\)</span> 的积分改为对 <spanclass="math inline">\(A\)</span> 的积分。可以发现，这里实际上还蕴含了<span class="math inline">\(r^2\)</span> 的距离衰减。</p></li><li><p><span class="math inline">\(xx&#39;\)</span>连线若中间撞到其他物体，则直接光贡献为0</p></li><li><p>点光源很难处理，一般可以使用微小的面光源代替</p></li></ul></li><li><p>计算间接光照，若随机到的方向撞上了光源，则贡献为0</p></li></ul><p><img src="http://lxtyin.ac.cn/img/Gemo/tracing1_1.png" /></p><p>这里我将球面看做ABC三部分，直接光照求B+C段的蒙特卡洛积分，但将C段贡献视为0；间接光照求A+B+C段的蒙特卡洛积分，但将B段贡献视为0，故直接光照与间接光照相加，恰好为整个球面上的积分。至此，路径追踪仍然保持了<strong>期望上的正确性</strong>。</p><p>这种每个交点都求一次直接光照贡献的方法其实就是所谓的NEE (Next EventEstimation)。</p><h5 id="调试策略">调试策略</h5><p>单纯的蒙特卡洛方法无疑是正确的，但在加上<strong>影响概率</strong>的各种操作后（如主动向光源、折射方向采样）时，就比较难保持正确性。</p><p>我曾在应用多光源时采用了错误的办法，然后调了很久都调不出想要的效果...最后发现是概率在不经意间被我改变了，，，错误的方法可能导致收敛于一个错误的结果。</p><p>个人经验：想要快速判断自己的策略在期望上是否正确，可以简单地用最朴素的蒙特卡洛方法渲染一次（均匀采样，不加任何trick），只要渲染久一点，就能看到正确的效果是什么样的。</p><h4 id="点光源">点光源</h4><p>我们已经知道怎么在蒙特卡洛路径追踪中对面积光源进行采样，并且体现出“光源的照明效果与距离相关”这件事，对于点光源，如果我们之间加上特定方向的一根光线采样，点光源的距离不会影响照明，结果显然是不对的。</p><p>在mitsuba中，面积光源的强度单位是 Radiance，而点光源的单位是Intensity，显然这不是随意命名的。这是辐射度量学的命名。点光源没有面积，无法用Radiance衡量表面亮度，因此用Intensity，相应的，在计算点光源贡献时，到达的Radiance = Intensity / dis ^ 2</p><h4 id="降噪">降噪</h4><h5 id="当前帧滤波">当前帧滤波</h5><ul><li>模糊操作：高斯滤波</li><li>保留一些高频的，边缘信息：双边滤波<ul><li>将颜色距离因素加入到滤波中去，如果两像素颜色差距较大，则减小贡献。</li></ul></li><li>如何分辨边缘与噪声？额外信息：<strong>G-Buffer！</strong></li></ul><p>既然我们掌握了渲染的全过程，很容易得到一些如法线图、Albedo图，<strong>它们完全没有噪声</strong>。</p><p>类似双边滤波，我们可以将各种其他G-BufferFeature添加到滤波中来加以指导，它们能非常有效地区分噪声和图像边缘，非常有效。</p><p>于是我们得到了<strong>联合双边滤波</strong><code>Joint Bilateral Filtering</code></p><p>outlier/firefly：蒙特卡洛方法容易产生一些过亮的点，也许要非常多sample才能将其平均下来；通常为了提速（并不物理正确），可以将其clamp掉。在滤波时，常将过高的颜色值clamp到<span class="math inline">\([u-k\sigma,u+k\sigma]\)</span>上，同理Tempora中，也可以这么做。</p><h5 id="taa">TAA</h5><p>https://zhuanlan.zhihu.com/p/425233743 这篇讲得很好</p><p>求一个<code>Motion Vector</code>，即当前帧的像素，在上一帧的屏幕中的位置，以此混合历史像素。</p><p>混合时，可能有种种情况使得相同位置在当前帧与上一帧颜色不同（动态光源、动态物体、阴影变化等），可以利用GBuffer进行一些简单的判断来排除一些情况，但很难完全避免（例如阴影变化，就没什么很好办法能解决）。UE4的策略是利用当前帧像素的周围九个像素，计算出当前帧色彩的大致范围（可以计算颜色空间（通常转移到YCgCo下进行）的AABB来实现），混合历史帧时，clamp/clip在该范围外的信息。</p><p>另一种策略也是使用周围九宫格像素，但不直接计算包围盒，而是计算均值与方差，使用以均值为中心、若干个方差为宽度的AABB。</p><p>方差在降噪中是一个很重要的信息，降噪很多时候就是在噪声与overblur之间权衡，而方差可以指导我们动态地进行这种权衡，在噪声更严重的区域进行激进的降噪。</p><h4 id="todo">TODO</h4><p><code>pixel reconstruction filter</code></p><p><code>Metropolis Light Transport</code></p><p><code>Photon Mapping</code></p><p><code>Radiosity Matrix</code></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>Raytracing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几何杂记</title>
    <link href="/2023/02/26/%E7%AC%94%E8%AE%B0/%E5%87%A0%E4%BD%95%E6%9D%82%E8%AE%B0/"/>
    <url>/2023/02/26/%E7%AC%94%E8%AE%B0/%E5%87%A0%E4%BD%95%E6%9D%82%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="隐式几何表示">隐式几何表示</h3><p>往往通过一个方程来定义，不够直观，但存储量小，运算简单。</p><h3 id="显示几何表示">显示几何表示</h3><p>要么直接定义，要么通过一些参数来定义。</p><h4 id="点云">点云</h4><p>一堆点，要构成面需要极大的密度。</p><p>通常用于三维扫描，后续再通过其他方法将点云转化为其他表示方法。</p><h4 id="多边形网格">多边形网格</h4><p>使用三角形或其他多边形表示（最常用）</p><h4 id="贝塞尔曲线">贝塞尔曲线</h4><p>通过参数来显示表示几何的实例</p><p>几何意义：很好理解但不太好描述，百度找图（</p><p>代数表示（用参数 <span class="math inline">\(t\)</span>来表示时间/比例，<span class="math inline">\(t\in [0,1]\)</span>）推导：</p><ul><li>有 <span class="math inline">\(n+1\)</span> 个控制点 <spanclass="math inline">\(b_{0..n}\)</span>，控制一条 <spanclass="math inline">\(n\)</span> 次贝塞尔曲线。</li><li>首先对于任意点 <spanclass="math inline">\(A\)</span>（非两边的点），在一次取点过后，会将<span class="math inline">\(tA\)</span> 分配到一边，<spanclass="math inline">\((1-t)A\)</span> 分配到另一边。</li><li>那么一个点 <span class="math inline">\(A\)</span>最终能分配到答案中多少，可以看做是一个金字塔状的路径选取的问题。</li><li>然后就不难从中发现二项式了。</li><li>最终结论为：<span class="math inline">\(ans =\sum_{i=0}^{n}C_n^ib_it^i(1-t)^{n-i}\)</span></li></ul><p>贝塞尔曲线性质：</p><ul><li>仿射变换不变性：对贝塞尔曲线仿射变换，等价于对几个控制点仿射变换后再生成贝塞尔曲线</li><li>贝塞尔曲线始终在控制点的凸包内</li><li>贝塞尔曲线的阶次等于控制点数-1，曲线的起点/终点与第一个/最后一个控制点重合。</li></ul><p>分段贝塞尔曲线</p><p>贝塞尔曲线的一大缺点是没有局部控制能力，任一控制点的变化都会影响到整个曲线（B样条曲线能解决这个问题），有时也会用分段贝塞尔曲线解决。</p><p>如PS的钢笔工具就是每段使用四个控制点，每段画三次贝塞尔曲线（CubicBezier Curve）</p><p>两端段贝塞尔曲线交接的部分，相交处的控制点连线若平行，即可平滑连接，若连线长度也相同，就能使二阶导数也连续。</p><p>显然，曲线应当可以表示成关于 <span class="math inline">\(t\)</span>的 <span class="math inline">\(n\)</span> 阶多项式 <spanclass="math inline">\(G(t)\)</span></p><p>例如对于 <span class="math inline">\(n = 3\)</span>，<spanclass="math inline">\(G(t)=(1-t)^3b_0+3t(1-t)^2b_1+3t^2(1-t)b_2+t^3b_3\)</span><span class="math display">\[\begin{bmatrix}-1&amp;3&amp;-3&amp;1\\3&amp;-6&amp;3&amp;0\\-3&amp;3&amp;0&amp;0\\1&amp;0&amp;0&amp;0\end{bmatrix}\times\begin{bmatrix}b_0\\b_1\\b_2\\b_3\end{bmatrix}=\begin{bmatrix}p_3\\p_2\\p_1\\p_0\end{bmatrix}\]</span> 我们可以用矩阵计算得出各次系数 <spanclass="math inline">\(p\)</span>，<spanclass="math inline">\(G(t)=p_3t^3+p_2t^2+p_1t+p_0\)</span>，此处的系数为一个vec2。</p><p>后面我们可以把其他形式的曲线（如B样条）也写成这种矩阵形式，然后轻松在两者之间转化。</p><h4 id="b样条曲线">B样条曲线</h4><p>三次B样条曲线的矩阵表达如下： <span class="math display">\[\frac1{6}\begin{bmatrix}-1&amp;3&amp;-3&amp;1\\3&amp;-6&amp;3&amp;0\\-3&amp;0&amp;3&amp;0\\1&amp;4&amp;1&amp;0\end{bmatrix}\times\begin{bmatrix}b_0\\b_1\\b_2\\b_3\end{bmatrix}=\begin{bmatrix}p_3\\p_2\\p_1\\p_0\end{bmatrix}\]</span></p><h4 id="贝塞尔曲面">贝塞尔曲面</h4><p>以4x4控制点为例：先将四列分别画出贝塞尔曲线，然后每一行取出四个点作为新贝塞尔曲线的控制点，得到一行贝塞尔曲线，扫出一个曲面。</p><p>贝塞尔曲面可以用参数 <span class="math inline">\(u,v\)</span>来表示。</p><h4 id="网格细分">网格细分</h4><p>用于将网格变得更平滑，本质上是一种模糊操作，并没有更多的信息量。在已有网格能大致表示物体轮廓时，用网格细分使得它更平滑。</p><h5 id="loop-细分">Loop 细分</h5><p>Loop是人名</p><p>细分：在每条三角形边上取一个新的顶点，形成 4 倍顶点。</p><p>调整：对顶点位置进行一个“模糊”，思路如下：</p><p>对于新顶点，它在两个三角形的重边上，设重边上的两个点为 <spanclass="math inline">\(A,B\)</span>，重边对的两个点为 <spanclass="math inline">\(C,D\)</span>，新顶点的位置为 <spanclass="math inline">\(3/8\times (A+B)+1/8 \times (C+D)\)</span></p><p>系数取决于调参经验，总之就是加权平均。</p><p>对于原顶点，它由相邻的原顶点和自身加权平均得来，具体设 <spanclass="math inline">\(n\)</span> 为度数，<spanclass="math inline">\(u\)</span> 为相邻顶点的比例系数，通常设 <spanclass="math inline">\(u = 3/(8n)\)</span>，特别当 <spanclass="math inline">\(n=3\)</span> 时设 <spanclass="math inline">\(u=3/16\)</span></p><p>最终位置为 <span class="math inline">\((1-nu)ori+u\sumadj\)</span></p><h5 id="catmull-clark细分">Catmull-Clark细分</h5><p>多边形网格的细分</p><p>每轮细分在每条线上产生一个点，每个面上也产生一个点。</p><p>以一定的权值来调整新点的位置。</p><p>其特点是：经过一轮变换后，所有面都会变成四边形。</p><h4 id="网格简化">网格简化</h4><p>在尽可能保留信息的前提下简化网格，常用于LOD。</p><h5 id="边坍缩">边坍缩</h5>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>样条</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉角、顺规、旋转矩阵、四元数</title>
    <link href="/2022/11/16/%E7%AC%94%E8%AE%B0/%E6%AC%A7%E6%8B%89%E8%A7%92%E3%80%81%E9%A1%BA%E8%A7%84%E3%80%81%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%E3%80%81%E5%9B%9B%E5%85%83%E6%95%B0/"/>
    <url>/2022/11/16/%E7%AC%94%E8%AE%B0/%E6%AC%A7%E6%8B%89%E8%A7%92%E3%80%81%E9%A1%BA%E8%A7%84%E3%80%81%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%E3%80%81%E5%9B%9B%E5%85%83%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>最早接触四元数是unity3d里面的旋转，当时不太理解使用四元数的意义（在此时的我看来欧拉角已经可以完全表示一个朝向了），后来在旋转时出了很多莫名其妙的问题，发现有必要remake一下。</p><p>参考资料，感谢大佬们</p><p>https://krasjet.github.io/quaternion/quaternion.pdf</p><p>https://www.bilibili.com/video/BV1SW411y7W1?spm_id_from=333.999.0.0</p><h4id="为什么直接改欧拉角效果经常与预期不符">为什么直接改欧拉角，效果经常与预期不符</h4><p>现在考虑一个问题：在你修改欧拉角时，意味的到底是“<strong>绕自身坐标轴旋转</strong>”，还是“<strong>绕世界坐标轴旋转</strong>”？</p><p>在unity里面测试，多测测就会发现：既不是按自身也不是按世界，而是有时按自身有时按世界？？</p><p>如果你随便拿一支笔（不要用unity），用手先绕X轴旋转90度，再绕Y轴旋转90度；再反过来试一下，会发现得到的位置不一样了。</p><p>这是因为<strong>旋转不具有交换律</strong>，相应的矩阵乘法也不具有交换律。</p><h4 id="欧拉角">欧拉角</h4><p>欧拉角需要区分为两种：动态欧拉角和静态欧拉角，他们都需要定义顺规。</p><p>静态欧拉角即绕世界静止坐标系旋转，动态欧拉角即绕自身坐标系旋转，前一个轴的旋转会影响下一个轴。</p><p>这里只分析动态欧拉角（我认为更好用）</p><h4 id="顺规">顺规</h4><p>考虑这么一个问题：如何实现一个可以自由旋转的飞机（假设面向+Z轴，要求Yaw-Pitch-Roll）？</p><p>可以用三个嵌套（做父物体）的箱子，最里面的箱子可以直接用飞机本身，所有物体的坐标都是相对父物体的；</p><p>第一个箱子仅绕自身y轴旋转（实现Yaw），第二个仅绕自身x轴旋转（Pitch），第三个仅绕自身z轴旋转（Roll）</p><p>通过控制这三个箱子，我们可以用比较好理解的方式合理、正确地旋转飞机。</p><p>这样的箱子便是动态欧拉角中的<strong>万向节</strong>，上述例子其实就是一个顺规为<strong>YXZ</strong>的动态欧拉角。</p><p>注意：这个顺规如果改变的话，飞机的旋转就很奇怪了，这并不是因为其他顺规错了（在数学上都没错）</p><p>而是因为我们对飞机的自然直觉就是符合动态欧拉角下的Yaw-Pitch-Roll顺规的。</p><p>在遇到其他复杂旋转问题时也可以使用箱子嵌套的方式思考，然后得出一个理想的顺规。</p><p>至于万向节锁，个人认为并不是什么大问题（飞机头垂直向上时，Roll和Yaw结果相同），依旧符合我们的自然直觉，且可以通过Pitch化解。</p><h4 id="旋转矩阵表示">旋转矩阵表示</h4><p>这里使用<strong>列向量</strong>。</p><p>我们通常用一个transform矩阵来表达一个物体的位置，大小，朝向信息。</p><ul><li>它表示的是物体从世界坐标的原点（没有缩放、平移、旋转）到当前状态经历的变换。</li><li>它能表示物体的<strong>坐标系</strong>。</li><li>更一般地，它是物体顶点从局部坐标变换到世界坐标时需要乘上的矩阵。</li></ul><h5 id="直接维护transform">直接维护Transform</h5><p>单独的旋转、平移、缩放矩阵形式在此不再多提及，它们直接应用在一个向量（点）上的意义非常明确。</p><p>假设有了一个物体，它的Transform为 <spanclass="math inline">\(T\)</span>（已经经过了一些复杂变换），现要让这个物体继续进行某种位移，位移矩阵为<span class="math inline">\(V\)</span></p><p>假如我们直接令 <span class="math inline">\(T =V\timesT\)</span>，即在左侧乘，效果是怎么样的？</p><p>可以想象 <span class="math inline">\(T\)</span> 的右边还有个向量<span class="math inline">\(v\)</span>，考虑这单个 <spanclass="math inline">\(v\)</span> 的变换，它先变换 <spanclass="math inline">\(T\)</span>，然后再位移 <spanclass="math inline">\(V\)</span>，即最终效果为在世界坐标系下位移了 <spanclass="math inline">\(V\)</span>，很好理解。</p><p>如果 <span class="math inline">\(T=T\times V\)</span> 呢？</p><p>这个 <span class="math inline">\(v\)</span>在所有原先的变换前，先进行了位移，然后再变换 <spanclass="math inline">\(T\)</span>，相应的，这个<strong>位移本身</strong>也会被变换<span class="math inline">\(T\)</span>。</p><p>如果把变换前的 <span class="math inline">\(T\)</span>看做一个坐标系，就可以说，这是在物体自身坐标系下位移了 <spanclass="math inline">\(V\)</span>。</p><p>另一个角度，如果要在自身坐标系下位移，可以利用相似矩阵 <spanclass="math inline">\(TVT^{-1}\)</span>，乘上原有的矩阵就变成 <spanclass="math inline">\(TV\)</span> 了。</p><p>总结：</p><ul><li>左边乘变换矩阵，相当于在世界（父）坐标系下变换</li><li>右边乘变换矩阵，相当于在自身坐标系下变换</li></ul><p>用旋转矩阵表示旋转不会遇到歧义、死锁的问题，缺点是占用空间大，运算量大（欧拉角使用3个数，四元数使用4个数，而旋转矩阵使用了16个数），另外不太直观。</p><h5 id="从transform中看">从Transform中看</h5><p>如果把Transform矩阵看成一个仿射变换和一个位移的组合（世界坐标下位移），通常我们说它是<strong>先仿射再位移</strong>得到的。</p><p>为什么？不是因为先位移不对，而是先位移的话，位移的量就不再是矩阵第四列的三个值了。我们说先仿射再位移，是基于位移量直接等于第四列的值来说的。</p><p>而从仿射矩阵中分解出缩放和旋转，需要另做一些计算。</p><p>我更喜欢用基向量、坐标系的方式来考虑矩阵，它的前三列分别表示了这个坐标系的三个基向量，最后一列表示这个坐标系原点的位置。</p><h4 id="四元数表示">四元数表示</h4><p><span class="math display">\[\newcommand{\vec}{\bold}\]</span></p><p>https://krasjet.github.io/quaternion/quaternion.pdf 推导的非常好</p><p>四元数表示为 <span class="math inline">\(q=[s, \vec v], \vecv=[x,y,z]\)</span>，<span class="math inline">\(q =a+bi+cj+dk\)</span></p><p>有三个虚部，满足关系： <span class="math display">\[i^2 = j^2 = k^2 = ijk = -1\]</span> 可以推得 <span class="math inline">\(jk=i, ij=k\)</span>等等关系</p><p>四元数乘法也按照多项式相乘规则，展开化简后可得： <spanclass="math display">\[q_1 = [s, \vec v], q_2 = [t, \vec u]\\q_1 q_2 = [st-\vec v\cdot \vec u, s\vec u+t\vec v + \vec v \times \vecu]\]</span> 如果两个四元数的实部都为0（纯四元数），则会得到： <spanclass="math display">\[q_1q_2 = [-\vec v\cdot \vec u, \vec v \times \vec u]\]</span> 四元数的逆为： <span class="math display">\[q^{-1} = \frac{q^*}{|q|^2}\]</span> 其中 <span class="math inline">\(q^*\)</span>为共轭四元数，即将虚部取反，实部不变。</p><p>下面直接给出结论：</p><p>对任意向量 <span class="math inline">\(\vec v\)</span>，沿着轴 <spanclass="math inline">\(\vec u\)</span> 旋转 <spanclass="math inline">\(\theta\)</span> 度得到 <spanclass="math inline">\(\vec v&#39;\)</span></p><p>可以构造四元数：<span class="math inline">\(v = [0, \vec v], q =[cos(\frac{1}{2}\theta), sin(\frac{1}{2}\theta) \vec u]\)</span>，<spanclass="math inline">\(q\)</span> 为单位四元数。</p><p>旋转可以用四元数乘法表示： <span class="math display">\[[0, \vec v&#39;] = qvq^{*}\]</span> 同样的，给定一个四元数，也可以轻松得到对应的旋转轴和角度。</p><p>连续进行两次旋转，等价于四元数累乘。 <span class="math display">\[pqvq^*p^* = (pq)v(pq)^*\]</span></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数理基础</tag>
      
      <tag>四元数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XCPC退役记</title>
    <link href="/2022/11/14/%E6%9D%82%E8%B0%88/XCPC%E9%80%80%E5%BD%B9%E8%AE%B0/"/>
    <url>/2022/11/14/%E6%9D%82%E8%B0%88/XCPC%E9%80%80%E5%BD%B9%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>有关我大学算法竞赛生涯的一点回顾（流水账）</p><p>and 一点关于XCPC的感想&amp;入坑建议</p><hr /><h4 id="大一2020-2021">大一（2020-2021）</h4><h5 id="入坑">入坑</h5><p>进商专之后唯一确定的要做是转专业，没什么其他规划</p><p>去面了一堆组织部门啥的，面科协的时候我提到高中有打过noip，马上就被一个学长拐来了集训队（</p><p>不久后的新生赛，靠啃老本拿了rk1，还记得当时写站神的防ak题的时候提交了这么一份代码：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    cout &lt;&lt; <span class="hljs-string">&quot;不会真的是ec最后一题吧，不会吧不会吧&quot;</span> &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>果然学长们在后台看见了，被群里爆破，节目效果拉满</p><p>然后经理（当时的大四学长）就拉我跟何大老（另一大一巨佬）组了个临时队去打ICPC济南（当时是名额多出来了用不完？怎么会事呢）果不其然被锤烂了</p><ul><li>ICPC 济南 铁</li></ul><p>经理随之退役，我也从那个时候开始认识到了差距</p><p>原来我那点破noip基础不值一提</p><p>​</p><h5 id="拜师">拜师</h5><p>之后是集训队的一些活动，拜师啥的</p><p>我选了老会长（the胡）</p><blockquote><p>特别感谢the胡</p><p>大一我问他：XXX和XXX+比赛要参加不</p><p>他：没卵用</p><p>简单粗暴地帮我把弯路堵死，大学也因此少了很多迷茫</p><p>现在我成了大三，但新生问类似问题的时候，我也只会在那高情商，做不到像他那样直接</p><p>（另外胡是真的强orz</p></blockquote><p><ahref="https://hukeqing.github.io/2020/12/21/acm/myACM/">胡kq两年前的退役记</a></p><p>​</p><h5 id="组队">组队</h5><p>寒假跟何大佬用一个号打牛客寒假训练营</p><p>学长都建议我们早点抓来第三个人组队，并推荐了几个综合能力很强，GPA很猛的同学</p><p>我觉得这不行，然后抓来了洋神</p><p>事实已经证明了此次决策的正确性.jpg</p><p>​</p><h5 id="比赛">比赛</h5><p>三个人想了半天确定了个比较无聊的队名：键盘滚脸 / asdfghjkl</p><p>继续比赛</p><ul><li>校赛二等奖（被学长乱杀）</li><li>浙江省赛 铜</li><li>ICPC 银川 铜（偷鸡）</li></ul><p>银川第一次公费旅游，全程吃瓜看戏看宁理表演（具体瓜不在这边赘述了，搜一搜都有）</p><p>拿了铜，还蹭到了缪少他们金牌（校史首金）的庆功宴</p><p><img src="http://lxtyin.ac.cn/img/xcpc_retire/4.png" /></p><p>当时自我感觉还挺良好，后来才意识到银川是究极偷鸡场，只偷到铜实在是有点浪费了</p><p>​</p><p>然后学长又说沈阳站多了一个名额没人去，问我们要不要去（？当时怎么名额这么富足）</p><p>于是又公费出游了，因为不太抱拿牌的希望，不好意思报销太多，就体验了一下22h的绿皮（</p><p><img src="http://lxtyin.ac.cn/img/xcpc_retire/3.png" /></p><p>到了沈阳发现原来ICPC每年只能打两场，我们已经打了济南+银川了，于是临时变成打星</p><p>结果符合预期：</p><ul><li>ICPC 沈阳（打星） 铁</li></ul><p>纯铁牌变成了打星铁，赢！</p><p>滚榜滚到宁理TS1队 银牌的时候，全场爆发鼓掌，太乐了</p><p><ahref="https://www.bilibili.com/video/BV13q4y1p7M1/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f3bceb9b12c557f0a9cdb5ac0d26fee6">当时的录像</a></p><p>​</p><p>回来后被隔离，在隔离点连麦打牛客多校</p><p>当时没意识到一点是：未来两年可能都没有那么多公费出游的机会了</p><p>​</p><hr /><h4 id="大二2021-2022">大二（2021-2022）</h4><h5 id="令人嫉妒的学弟2.0">令人嫉妒的学弟2.0</h5><p>招新的时候拉我去讲旅游经历，给新生画大饼</p><p>然后招着招着发现21届新生有点强的离谱，各路oi爷层出不穷，2 * zj1= + 1* ah1=，还有2=和初中oi爷若干</p><p>更是有个进来就cf1800的（威神），那时候我还在1700上下横跳</p><p>然后加紧开卷，开学一个月后赶在大一佬之前上了紫，随后发了一个<code>晚节保住.jpg</code></p><ul><li>2021/09/30 —— codeforces紫</li></ul><p>然后他就一路上橙了，还上了两个号</p><p>晚节不保</p><p>​</p><h5 id="新生赛">2021新生赛</h5><p>鉴于这届太强，我们出题的时候决定往死里出。</p><p>我准备了几个预估在 <code>mid-hard</code> 到 <code>hard</code>的题，其中一道俄罗斯方块出完之后发现自己不会做（</p><p>跟老会长（胡）一起研究了几天才把它搞出来，那时候就觉得新生赛上不可能有人做出来了。</p><p>"不错的毒瘤题，要了。"</p><p>结果组题的时候貌似选了不止一道<code>very-hard</code>，新生赛最终结果是威神做出来n -3题rk1，最后三个题都0AC</p><p>另外，那个俄罗斯方块至今为止，除了我跟老会长无人ac（555你们快去做很好做的</p><p>赛后：我们出了很多简单题的，组题人只选了最毒瘤的，别找我们.jpg</p><p>​</p><h5 id="比赛-1">比赛</h5><p>大二的比赛是要准备冲好一点的奖牌了，然而赛前出了一点意外我直接进医院躺了两周。</p><p>回来后一周就开始连着打比赛了：</p><ul><li>CCPC 桂林 铁</li><li>ICPC 上海 铁（寄）</li><li>ICPC 南京 铜</li></ul><p>连着打出两把铁是真的感觉要废了，那会就是生涯低谷吧。</p><p>甚至去重新做了一遍NOIP2018，想看看相比高中到底有无进步。</p><p>再输下去要输大一，然后没得输了。</p><p>之后的南京站卷成诸神黄昏（群友称之为小EC），卷到一块铜牌也算回了点信心。</p><p>​</p><p>另外，这些比赛全都变成了线上进行，再无公费出游（nmdyqsmsh414</p><p>​</p><h5 id="训练">训练</h5><p>之后的寒假训练营，全实验室的大二大三被威神乱杀，校赛被威神压两题乱杀。</p><p>被打麻了之后开始改变训练策略了，开始刷cf当前分数+1000的题，经常一下午写一道；</p><p>开始追求补完div2，AKdiv3，因为要写能力范围外的题，经常会硬啃题解、曲线救国、看jly代码。</p><p>现在看来这种策略也不是非常的科学，但那会可以说是提升速度最快的一段时间了。</p><p>大二下省赛前状态极佳：</p><ul><li>浙江省赛 金</li></ul><p>是我校第一块省赛金牌，<del>省金也算金</del></p><p>ECF的名额从老会长给到涛哥，然后又让给了我们。非常感谢学长们，然而我们还是太菜了</p><p>​</p><h5 id="ec-final">EC Final</h5><p>EC硬是拖到了2022.7才办，但是线下，又能公费出游了。</p><p>见到了jly，dls本人还有一堆群友。</p><p>然而大秦办的真的不是一般的烂，具体大伙可以自信知乎，同样不赘述</p><p><ahref="https://www.zhihu.com/question/543699999/answer/2584755503">如何评价2021ICPC EC-Final？</a></p><p>我队三次出游分别见证了西部枢纽、东北枢纽和大秦枢纽的诞生，乐</p><p>说回比赛本身：</p><ul><li>ICPC EC Final 铁（菜）</li></ul><p>纯菜，心态和实力都不太足吧。</p><p>座位对面是南大-虚幻黄昏，赛时对面疯狂拿气球，一度冲到rk2，而我队三线卡题；</p><p>心态没能调整过来，三边一起乱wa的时候就感觉没戏了，但赛后发现其实只要过其中一个就有铜了。</p><p>反思：比赛策略出错，心态不稳，受旁边队伍影响比较大。如果找清定位allin一题的话，拿个铜还是有机会的。</p><p>​</p><p>不得不感叹ec里面巨佬是真的多，各种企业的宣讲、抽奖啥的也真的多，这就是含金量吗。</p><p>华为晚会抽到一个手环，蹭到巨佬们的光了</p><p>​</p><h5 id="cf实况">CF实况</h5><p>之前就看到很多人在b站发cf的实况或者讲题，各种水平段的选手都有，强如dls也会发比赛实况。</p><p>于是我也趁着暑假寝室没人，开始打cf的时候录屏，比赛完了之后简短讲一下写出来的题然后发b站。</p><p>感觉录播的时候上分非常顺畅，不清楚什么原理，暑假很顺利地把两个号都打上橙了。</p><ul><li>2022/08/06 —— codeforces橙</li></ul><p><img src="http://lxtyin.ac.cn/img/xcpc_retire/5.png" /></p><p><img src="http://lxtyin.ac.cn/img/xcpc_retire/6.png" /></p><hr /><h4 id="大三2022-2023">大三（2022-2023）</h4><h5 id="招新新生赛">招新&amp;新生赛</h5><p>虽然但是，今年还是拉我去给新生画旅游的大饼（因为大伙这一年都没机会出去）</p><p>甚至用的还是同一套银川的图</p><p>​</p><p>22届新生明显没有21届那么夸张了，于是我们出题温和了不少，</p><p>我出了一个签到 + 一个去年没用上的MC题。</p><p>今年尝试把新生赛提前到了10月，结果是大家都被语法卡麻了</p><p>最后cc做出7题rk1，另外有足足5个题没人过（</p><p>MC题还是没人过（（（（悲</p><h5 id="比赛退役">比赛&amp;退役</h5><p>今年是和去年一样的ICPC和CCPC全撞上的形势，也是同样的全线上形势（</p><p>基本最后一个赛季了，赛前把能拖的事情全都拖到了比赛结束后，作业能不写的就不写，疯狂鸽组员and 画大饼（比赛完了我就来肝）</p><p>​</p><p>经过一番虚空赛站博弈之后，我们无脑选了前四场（桂林、威海、西安、合肥）</p><p>究其原因，还是想早点打完退役，然后该考研的考研该保研的保研该做项目的做项目了吧。</p><p>毕竟我们已经在算法竞赛上面投入了太多的时间。</p><blockquote><p>说白了打算法竞赛就是网瘾少年，该电电了</p><p>​ ——何逊</p></blockquote><p>​</p><p>顺着XCPC的猫猫热潮，我们把队名改成了：<strong>猫猫滚脸 / Power OverFace</strong></p><p>英文队名致敬了一下老会长（胡）那队（能力突出 / Power Over Flow）</p><p>比赛结果：</p><ul><li>CCPC 桂林 银</li><li>CCPC 威海 铜</li><li>ICPC 西安 金</li><li>ICPC 合肥 ？</li></ul><p>桂林上来就开到原题（几乎原，一模一样的换根dp，还是最近做的），然后就跟队友说要抢首A，虽然没抢到</p><p>最后发现这是道银牌线上的题，运气非常好。</p><p>威海虽6但铜不谈。</p><p>西安网络流板子第一次发挥作用，封榜后三个人合力拱掉了金牌线上的数据结构题</p><p>封榜前37名，大致推测了一下最终是34名左右，非常悬</p><p>滚榜滚到我们后面几个队的时候一直在喊：给爷WA！WA！</p><p>最终停在了rank34，金牌倒数第二。</p><p><img src="http://lxtyin.ac.cn/img/xcpc_retire/7.png" /></p><p>我直接原地宣布退役，合肥？合肥是什么</p><p>（当然打还是会去打的（</p><p>现在是第二天，我退役记已经快写完了</p><blockquote><p>upd：合肥rank38银，这下金尾银首都有了</p></blockquote><hr /><h4 id="总结">总结</h4><p>这块地方不定期更新（退役了但没完全退（</p><table style="width:100%;"><thead><tr><th></th><th>ICPC</th><th>CCPC</th><th>浙江省赛</th></tr></thead><tbody><tr><td>大一</td><td>济南铁 + 银川铜</td><td>/</td><td>铜</td></tr><tr><td>大二</td><td>上海铁 + 南京铜 + Final铁</td><td>桂林铁</td><td>金</td></tr><tr><td>大三</td><td>西安金 + 合肥银 + Final铁</td><td>桂林银 + 威海铜 + Final铁</td><td>金</td></tr><tr><td>大四</td><td>/</td><td>秦皇岛？</td><td>/</td></tr></tbody></table><p>总计：省1铜1金，国4铁3铜2银1金</p><p>之后也许还会去打一些比赛（如果有名额给我们），给学院多打几个牌子，有的话再更新；</p><p>两个dream：区域赛金牌和Codeforces红名</p><p>第一个已经达成，第二个进度 <code>2216/2400</code></p><p>在非训练状态下，CF想继续上分有点难了，不知道什么时候能够达成。</p><blockquote><p>upd：2023/10/10，没想到退役后又被教练抓去打了两把final，这下final三铁了（555</p></blockquote><p>​</p><hr /><h4 id="感想建议">感想&amp;建议</h4><h5 id="关于xcpc">关于XCPC</h5><p>这是一个含金量高、难度大、性价比低、纯粹、超纲的竞赛。</p><p>关于XCPC含金量降低的说法我是不认可的，在前几年银川乱发牌的时候，含金量的确有所下降，但如今银川赛站已经不复存在。</p><p>现在的情况反而是一年比一年卷，往年的金银算法如今已经变成铜牌分界线了，</p><p>在竞技的角度看来，含金量只增不降。</p><p>从组织的角度来看emmm，看看银川、沈阳和大秦吧xdm</p><p>​</p><p>性价比低则是伴随着含金量提高而来的，你需要花几倍的时间才能拿到同级别的奖项，而在校内各项加分上却没有优势，也要承担付出很多却拿不到牌的风险。</p><p>当然，这只是校内的评价体系。</p><p>对于计算机专业的学生来说，出去之后，ACM的认可度会远超其他竞赛。因为它客观、纯粹，ACM奖牌能够直接反映你的算法水平和编码能力，其他大多所谓的“综合类”竞赛则不然。</p><p>这部分大家可以参考<ahref="https://hukeqing.github.io/2020/12/21/acm/myACM/">胡kq的退役记</a>，他的评价比我更加详细，也更加锐气。</p><p>​</p><p>超纲即，ACM中的许多知识，在工业界看来是用不到的“屠龙术”</p><p>因为这是一项竞赛，要冲击高处，必然意味着一定程度上的脱离实际，这很正常。</p><p>会枚举数组就能写程序了吗？大部分情况下没错，就跟买菜不会用到微积分一样没错。</p><p>但当复杂算法和数据结构被需要时，你的“屠龙术”被用上了，就能体现你的竞争力。</p><p>退一万步讲，学会这些屠龙术也能让你对算法/数据结构有更深层的理解，对STL也会有更深的理解。</p><blockquote><p>知识很难没用 ——群友</p></blockquote><p>拿最近一次大作业，仿制git为例，我能很快理解版本管理的实质是一棵主席树，变更文件发现的原理是哈希，能想到文本修改历史推测只需要跑个LCS。经过算法竞赛的磨练，这些算法和数据结构用在此处，在我看来就十分直观、显然了。</p><p>​</p><h5 id="xcpc给我带来什么">XCPC给我带来什么</h5><p>代码实现能力（最直观、最直接的）</p><p>对算法、数据结构的理解和熟练运用能力</p><p>自学能力</p><p>抗压能力</p><p>团队合作能力</p><p>一些屠龙术</p><p>​</p><h5 id="xcpc没给我带来什么">XCPC没给我带来什么</h5><p>对实际工程结构、体系的了解</p><p>需求分析/市场营销技能</p><p>文档撰写/ppt制作能力</p><p>规范的代码/注释</p><p>软件工程/项目开发流程的了解</p><p>​</p><p>写上面这些主要是想说明，ACM太纯粹了，然而现实的项目，解决实际问题会遇到很多其他乱起八糟的东西，不是一个cpp就能解决的——尽管它用到的算法可能只有二分</p><p>退役后要多多和现实项目接轨了。</p><p>​</p><h5 id="关于xcpc选手">关于XCPC选手</h5><p>XCPC选手这一群体（主要指各种群友）是我见过最锐气的一批人。</p><p>20-21年的银川乱象，沈阳乱象，最近的大秦酒店风波，CCPC禁赛事件。</p><p>群友貌似天天塔塔开，一直在冲，一直不停。</p><p>他们冲到银川办不了regional，冲到ECFinal变到上海，冲到CCPC撤销禁赛...</p><p>这个破烂比赛的含金量，真的是靠这些参赛选手们对作弊、藏私、暗箱操作零容忍的态度维护的，而不是靠哪一个主办方组织者。</p><p>希望群友们保持风骨，把冲塔风范传承下去。</p><p>​</p><h5 id="建议打acm吗">建议打ACM吗</h5><p>ACM能让你学到很多东西，我建议每个人都可以试试。</p><p>但如果以奖牌为目标的话，你需要认清自己的天赋和愿意付出的努力，再做权衡；</p><p>不可忽略的是：这个圈子里所有人都很卷，不能太高估自己的努力程度。</p><p>在付出大量时间和心血之前考虑清楚，自己到底合不合适。</p><p>如果你是零基础，要打，想拿牌，并且自认天赋不算太好的话，我建议不要再双开其他竞赛/科研/项目了，不然很难有一个理想的结果。</p><p>​</p><p><strong>那么放弃其他东西 All in acm，真的值得吗？</strong></p><p>贴一个回答：</p><p><img src="http://lxtyin.ac.cn/img/xcpc_retire/2.png" /></p><p>​</p><p>它很适合我。</p><p>我知道其他比赛拿奖更快;</p><p>我知道学院挑战杯互联网+1.8倍加分;</p><p>我也知道导师眼里 成绩 &gt;&gt; 科研 &gt; 项目 &gt; 竞赛;</p><p>但我懒，单纯不想做那么多麻烦事，只想敲代码。</p><p>A题很爽，打比赛很爽，被锤烂了也很服气。</p><p><img src="http://lxtyin.ac.cn/img/xcpc_retire/1.jpg" /></p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>退役记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高质量补题记录集</title>
    <link href="/2022/09/28/%E9%A2%98%E8%A7%A3/%E9%AB%98%E8%B4%A8%E9%87%8F%E8%A1%A5%E9%A2%98%E8%AE%B0%E5%BD%95%E9%9B%86/"/>
    <url>/2022/09/28/%E9%A2%98%E8%A7%A3/%E9%AB%98%E8%B4%A8%E9%87%8F%E8%A1%A5%E9%A2%98%E8%AE%B0%E5%BD%95%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h4 id="牛客第一场-j">2022牛客第一场 J</h4><p><a href="https://ac.nowcoder.com/acm/contest/33186/J">Serval andEssay</a></p><p>一道不错的图论题</p><p>比较有价值的部分是图的合并，类似并查集，合并两点时可以使用其中一个点编号作为合并后的点集编号。</p><p>用启发式合并思想，让小集合向大集合合并，合并时将小集合上的连边转移到大集合上。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<span class="hljs-type">int</span> fa[maxn], siz[maxn], cnt[maxn];set&lt;<span class="hljs-type">int</span>&gt; nt[maxn], fm[maxn];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    <span class="hljs-keyword">if</span>(fa[x] == x) <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> fa[x] = <span class="hljs-built_in">find</span>(fa[x]);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cnt[i] = <span class="hljs-number">0</span>;        nt[i].<span class="hljs-built_in">clear</span>(), fm[i].<span class="hljs-built_in">clear</span>();        fa[i] = i, siz[i] = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> k; cin &gt;&gt; k;        cnt[i] = k;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)&#123;            <span class="hljs-type">int</span> x; cin &gt;&gt; x;            nt[x].<span class="hljs-built_in">insert</span>(i);            fm[i].<span class="hljs-built_in">insert</span>(x);        &#125;    &#125;    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q; <span class="hljs-comment">//存要合并的两个集合</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(cnt[i] == <span class="hljs-number">1</span>)&#123;            q.<span class="hljs-built_in">emplace</span>(i, *fm[i].<span class="hljs-built_in">begin</span>());        &#125;    &#125;    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;        <span class="hljs-keyword">auto</span> [x, y] = q.<span class="hljs-built_in">front</span>();        q.<span class="hljs-built_in">pop</span>();        <span class="hljs-comment">//merge</span>        x = <span class="hljs-built_in">find</span>(x), y = <span class="hljs-built_in">find</span>(y);        <span class="hljs-keyword">if</span>(x == y) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span>(siz[x] &gt; siz[y]) <span class="hljs-built_in">swap</span>(x, y);        fa[x] = y;        siz[y] += siz[x];        ans = <span class="hljs-built_in">max</span>(ans, siz[y]);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: nt[x])&#123;            <span class="hljs-keyword">if</span>(nt[y].<span class="hljs-built_in">count</span>(v))&#123;                cnt[v]--;                <span class="hljs-keyword">if</span>(cnt[v] == <span class="hljs-number">1</span>) q.<span class="hljs-built_in">emplace</span>(v, y);            nt[y].<span class="hljs-built_in">insert</span>(v);        &#125;    &#125;    <span class="hljs-type">static</span> <span class="hljs-type">int</span> cas = <span class="hljs-number">0</span>;    cout &lt;&lt; <span class="hljs-string">&quot;Case #&quot;</span> &lt;&lt; ++cas &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="牛客第三场b">2022牛客第三场B</h4><p><a href="https://ac.nowcoder.com/acm/contest/33188/B">Boss</a></p><p>学到一个可删除堆的奇技淫巧，但这还不是关键</p><p>这里的最短路类似二分图和网络流中的“增广路”，路径代表的是一种<strong>转移方案</strong>，<spanclass="math inline">\(a-b-c-d\)</span>这样的一条路径，实际上指将当前的人放到 <spanclass="math inline">\(a\)</span> 处，<spanclass="math inline">\(a\)</span> 中选取一个代价最小的人移到 <spanclass="math inline">\(b\)</span> 处...最后 <spanclass="math inline">\(d\)</span> 处多出一个人，最短路径即为将 <spanclass="math inline">\(i\)</span> 塞入的最小代价。</p><p>可以用一个set记录每个节点上已经有哪些人，记 <spanclass="math inline">\(u,v\)</span> 间的转移方案 <spanclass="math inline">\(\{dis,id\}\)</span>，表示将 <spanclass="math inline">\(id\)</span> 这个人从 <spanclass="math inline">\(u\)</span> 转移到 <spanclass="math inline">\(v\)</span> 的代价为 <spanclass="math inline">\(dis\)</span>，开 <spanclass="math inline">\(K^2\)</span>个堆记录任意两点间的所有转移方案，在人员变动时维护。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">heap</span>&#123; <span class="hljs-comment">//奇技淫巧：可删除堆 常数优秀</span>    priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt; &gt; q1, q2;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x)</span> </span>&#123;q1.<span class="hljs-built_in">push</span>(x);&#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x)</span> </span>&#123;q2.<span class="hljs-built_in">push</span>(x);&#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">while</span>(!q1.<span class="hljs-built_in">empty</span>() &amp;&amp; !q2.<span class="hljs-built_in">empty</span>() &amp;&amp; q1.<span class="hljs-built_in">top</span>() == q2.<span class="hljs-built_in">top</span>())&#123;            q1.<span class="hljs-built_in">pop</span>();            q2.<span class="hljs-built_in">pop</span>();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-built_in">release</span>();        <span class="hljs-keyword">return</span> q1.<span class="hljs-built_in">empty</span>();    &#125;    <span class="hljs-function">T <span class="hljs-title">top</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-built_in">release</span>();        <span class="hljs-keyword">return</span> q1.<span class="hljs-built_in">top</span>();    &#125;&#125;;<span class="hljs-type">int</span> n, m;heap&lt;pair&lt;ll, <span class="hljs-type">int</span>&gt;&gt; tr[<span class="hljs-number">12</span>][<span class="hljs-number">12</span>]; <span class="hljs-comment">//tr[x][y] 从x到y的所有可行路径，&#123;dis, id&#125;</span>set&lt;<span class="hljs-type">int</span>&gt; nodes[<span class="hljs-number">12</span>]; <span class="hljs-comment">//存每个节点上所有的人</span>ll vol[maxn];ll cost[maxn][<span class="hljs-number">12</span>]; <span class="hljs-comment">//基础花费：cost[x][k] x这个人匹配第k个城市的代价</span><span class="hljs-function">ll <span class="hljs-title">move_dis</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123; <span class="hljs-comment">//转移代价：u这个人从x城切换到y城的代价</span>    <span class="hljs-keyword">return</span> cost[u][y] - cost[u][x];&#125;<span class="hljs-function">pair&lt;ll, <span class="hljs-type">int</span>&gt; <span class="hljs-title">min_dis</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123; <span class="hljs-comment">//获取当前从x转移到y代价最小的路径</span>    <span class="hljs-keyword">if</span>(tr[x][y].<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;INF, <span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">return</span> tr[x][y].<span class="hljs-built_in">top</span>();&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span>&#123; <span class="hljs-comment">//在k城添加一个人p，维护</span>    nodes[k].<span class="hljs-built_in">insert</span>(p);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-keyword">if</span>(i == k) <span class="hljs-keyword">continue</span>;        tr[k][i].<span class="hljs-built_in">push</span>(&#123;<span class="hljs-built_in">move_dis</span>(p, k, i), p&#125;);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span>&#123; <span class="hljs-comment">//从k城移除一个人p，维护</span>    nodes[k].<span class="hljs-built_in">erase</span>(p);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-keyword">if</span>(i == k) <span class="hljs-keyword">continue</span>;        tr[k][i].<span class="hljs-built_in">erase</span>(&#123;<span class="hljs-built_in">move_dis</span>(p, k, i), p&#125;);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) cin &gt;&gt; vol[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;            cin &gt;&gt; cost[i][j];        &#125;    &#125;    ll ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-comment">//先跑最短路，即最小的将当前i塞进去的代价</span>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(m+<span class="hljs-number">1</span>)</span></span>;        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">frm</span>(m+<span class="hljs-number">1</span>, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">inq</span><span class="hljs-params">(m+<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++) q.<span class="hljs-built_in">push</span>(j), d[j] = cost[i][j];        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;            <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();            q.<span class="hljs-built_in">pop</span>();            inq[u] = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">1</span>;v&lt;=m;v++)&#123;                <span class="hljs-keyword">if</span>(v == u) <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">auto</span> [dis, id] = <span class="hljs-built_in">min_dis</span>(u, v);                <span class="hljs-keyword">if</span>(d[v] &gt; d[u] + dis)&#123;                    d[v] = d[u] + dis;                    frm[v] = &#123;u, id&#125;;                    <span class="hljs-keyword">if</span>(!inq[v]) q.<span class="hljs-built_in">push</span>(v), inq[v] = <span class="hljs-literal">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-type">int</span> ed = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;            <span class="hljs-keyword">if</span>(nodes[j].<span class="hljs-built_in">size</span>() &gt;= vol[j]) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span>(!ed || d[j] &lt; d[ed]) ed = j;        &#125;        <span class="hljs-built_in">assert</span>(ed);        ans += d[ed];   <span class="hljs-comment">//记录将i这个人塞进去的转移路径，沿着路径每个节点的状态，同时维护堆</span>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;            <span class="hljs-keyword">auto</span> [fa, id] = frm[ed];            <span class="hljs-keyword">if</span>(!fa)&#123;                <span class="hljs-built_in">add</span>(ed, i);                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-built_in">remove</span>(fa, id);            <span class="hljs-built_in">add</span>(ed, id);            ed = fa;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="杭电第四场1002">2022杭电第四场1002</h4><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7175">Link withRunning</a></p><p>边权有两种：距离和价值，要求一条距离最短前提下的价值最大的路。（距离可以为0）</p><p>因为距离为0，一条无距离有价值的路实际上相当于一条负权边，无法用传统dijkstra解决。</p><p>解法：先仅按照距离dij跑出到每个点的最短距离，<strong>得到最短路径图</strong>，在最短路径图上，tarjian缩点去除可能存在的环，变成一个DAG，再在DAG上跑最长路即可。</p><ul><li><p>最短路径图即图上所有最短路径构成的图，可以从终点开始往前逆向跑，对于所有<span class="math inline">\(dis_v=dis_u+w\)</span>的路径加入最短路径图，也可以直接顺着跑，得到的点数会更多（包含了到所有点的最短路）。</p></li><li><p>DAG上的最长路可以按拓扑序更新（即一个点需要在前驱都遍历后更新），也可以直接spfa。</p></li></ul><p>思路很简单，但是几层图换来换去代码属实调了很久，最后整出来这么一份非常结构化的代码，但还是很难直接拿去当图论模板..</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;    <span class="hljs-type">int</span> t, w, val;&#125;;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> E&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-type">int</span> n;    vector&lt;vector&lt;E&gt;&gt; vp;    <span class="hljs-built_in">Graph</span>(<span class="hljs-type">int</span> n): <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">vp</span>(n+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;E&gt;())&#123;&#125;;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">const</span> E &amp;e)</span></span>&#123; vp[x].<span class="hljs-built_in">push_back</span>(e);&#125;&#125;;<span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">dijkstra</span><span class="hljs-params">(Graph&lt;Edge&gt; &amp;g, <span class="hljs-type">int</span> st)</span></span>&#123;    <span class="hljs-keyword">using</span> pii = pair&lt;ll, <span class="hljs-type">int</span>&gt;;    <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">dis</span><span class="hljs-params">(g.n+<span class="hljs-number">1</span>, INF)</span></span>;    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; q;    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, st&#125;); dis[st] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;        pii uq = q.<span class="hljs-built_in">top</span>();        ll ud = uq.first, u = uq.second;        q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">if</span>(ud &gt; dis[u]) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">for</span>(Edge &amp;e: g.vp[u])&#123;            <span class="hljs-type">int</span> v = e.t;            <span class="hljs-keyword">if</span>(dis[v] &gt; dis[u] + e.w)&#123;                dis[v] = dis[u] + e.w;                q.<span class="hljs-built_in">push</span>(&#123;dis[v], v&#125;);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dis;&#125;<span class="hljs-comment">//获取最短路径图</span>Graph&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; <span class="hljs-built_in">pathGraph</span>(Graph&lt;Edge&gt; &amp;g, <span class="hljs-type">int</span> st)&#123;    <span class="hljs-keyword">auto</span> dis = <span class="hljs-built_in">dijkstra</span>(g, <span class="hljs-number">1</span>); <span class="hljs-comment">//计算最短路</span>    Graph&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; <span class="hljs-built_in">res</span>(g.n);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=g.n;i++)&#123;        <span class="hljs-keyword">for</span>(Edge &amp;e: g.vp[i])&#123;            <span class="hljs-type">int</span> v = e.t;            <span class="hljs-keyword">if</span>(dis[v] == dis[i] + e.w)&#123;                res.<span class="hljs-built_in">addEdge</span>(i, &#123;v, e.val&#125;);            &#125;        &#125;    &#125;    cout &lt;&lt; dis[g.n] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">namespace</span> Connect&#123;    <span class="hljs-type">int</span> scc[maxn], stk[maxn], h, scn;    <span class="hljs-type">int</span> dfn[maxn], low[maxn], dfc;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjian</span><span class="hljs-params">(Graph&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; &amp;g,<span class="hljs-type">int</span> p)</span></span>&#123;        dfn[p] = low[p] = ++dfc;        stk[++h] = p;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e: g.vp[p])&#123;            <span class="hljs-type">int</span> v = e.first;            <span class="hljs-keyword">if</span>(!dfn[v]) &#123;                <span class="hljs-built_in">tarjian</span>(g, v);                low[p] = <span class="hljs-built_in">min</span>(low[p], low[v]);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!scc[v]) &#123;                low[p] = <span class="hljs-built_in">min</span>(low[p], dfn[v]);            &#125;        &#125;        <span class="hljs-keyword">if</span>(low[p] == dfn[p])&#123;            ++scn;            <span class="hljs-keyword">while</span>(stk[h] != p) scc[stk[h--]] = scn;            scc[stk[h--]] = scn;        &#125;    &#125;    Graph&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; <span class="hljs-built_in">getDag</span>(Graph&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; &amp;g)&#123;        h = scn = dfc = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=g.n;i++) dfn[i] = scc[i] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=g.n;i++) <span class="hljs-keyword">if</span>(!scc[i]) <span class="hljs-built_in">tarjian</span>(g, i);        Graph&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; <span class="hljs-built_in">res</span>(scn);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=g.n;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e: g.vp[i])&#123;                <span class="hljs-type">int</span> v = e.first;                <span class="hljs-keyword">if</span>(scc[i] != scc[v])&#123;                    res.<span class="hljs-built_in">addEdge</span>(scc[i], &#123;scc[v], e.second&#125;);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n, m;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-function">Graph&lt;Edge&gt; <span class="hljs-title">g</span><span class="hljs-params">(n)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-type">int</span> x, y, e, p;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; e &gt;&gt; p;        g.<span class="hljs-built_in">addEdge</span>(x, &#123;y, e, p&#125;);    &#125;    <span class="hljs-keyword">auto</span> spg = <span class="hljs-built_in">pathGraph</span>(g, <span class="hljs-number">1</span>);    <span class="hljs-keyword">auto</span> dag = Connect::<span class="hljs-built_in">getDag</span>(spg);    <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">f</span><span class="hljs-params">(dag.n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">du</span><span class="hljs-params">(dag.n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=dag.n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e: dag.vp[i])&#123;            du[e.first]++;        &#125;    &#125;    queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=dag.n;i++) <span class="hljs-keyword">if</span>(du[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();        q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e: dag.vp[u])&#123;            <span class="hljs-type">int</span> v = e.first;            f[v] = <span class="hljs-built_in">max</span>(f[v], f[u] + e.second);            <span class="hljs-keyword">if</span>(--du[v] &lt;= <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(v);        &#125;    &#125;    cout &lt;&lt; f[Connect::scc[n]] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="杭电第四场1005">2022杭电第四场1005</h4><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7178">Link withLevel Editor II</a></p><p>矩阵+神奇双指针（对顶栈）</p><p>首先这题可以用矩阵维护一段区间的方案数，但矩阵并非一定可逆，故没法用前缀和搞。</p><p>比较容易想到的是线段树暴力维护矩阵区间乘，常数很大但是卡卡能过。</p><p>另有神奇的<strong>无需删除</strong>的双指针尺取（题解叫对顶栈）：</p><p><img src="http://lxtyin.ac.cn/img/other/2.png" /></p><p>如图所示，双指针 <span class="math inline">\(l,r\)</span>即为两个栈顶，右指针移动时将新元素加入右栈中；左指针移动时将栈顶元素弹出，接触到中间点时，将右栈的所有元素一一弹出并加入左栈，将右端点作为新的中点。</p><p>左栈中加入元素时记录该元素到中点的后缀和，这样在左栈弹出后，仍可以得知左栈的总和，和右栈和相加得到区间和（此题中为积）。</p><p>如此便可以 <span class="math inline">\(O(n)\)</span>地做不带删除的尺取了！</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> lim;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">matrix</span>&#123;    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">21</span>, M = <span class="hljs-number">21</span>;    ll a[N][M];    <span class="hljs-built_in">matrix</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//单位矩阵</span>        <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a));        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++) a[i][i] = x;    &#125;    <span class="hljs-keyword">inline</span> matrix <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> matrix&amp; y) <span class="hljs-type">const</span>&#123;        matrix r = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; M; ++k) &#123;                ll t = a[i][k];                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; M; ++j)&#123;                    r.a[i][j] += t * y.a[k][j];                    <span class="hljs-keyword">if</span>(r.a[i][j] &gt; lim) r.a[i][j] = lim + <span class="hljs-number">1</span>;                &#125;            &#125;        <span class="hljs-keyword">return</span> r;    &#125;&#125;;matrix a[maxn], s[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n, m;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; lim;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> l; cin &gt;&gt; l;        a[i] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=l;j++)&#123;            <span class="hljs-type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;            a[i].a[x][y] = <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-function">matrix <span class="hljs-title">cur</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)&#123;        ll ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;            ans += s[l].a[<span class="hljs-number">1</span>][i] * cur.a[i][m];            <span class="hljs-keyword">if</span>(ans &gt; lim) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;;    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, mid = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">1</span>; r&lt;=n; r++)&#123;        cur = cur * a[r];        <span class="hljs-keyword">while</span>(l == <span class="hljs-number">0</span> || !<span class="hljs-built_in">check</span>(l, r))&#123;            l++;            <span class="hljs-keyword">if</span>(l &gt; mid)&#123;                s[r] = a[r];                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=r<span class="hljs-number">-1</span>;i&gt;mid;i--) s[i] = a[i] * s[i+<span class="hljs-number">1</span>];                mid = r;                cur = <span class="hljs-number">1</span>;            &#125;        &#125;        ans = <span class="hljs-built_in">max</span>(ans, r - l + <span class="hljs-number">1</span>);    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="杭电第八场1002">2022杭电第八场1002</h4><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7221">DarkmoonFaire</a></p><p>大力数据结构维护题。</p><p>从左往右推，设 <span class="math inline">\(f_i\)</span> 为前 <spanclass="math inline">\(i\)</span> 个位置划分好的方案数，接下来要转移到<span class="math inline">\(i+1\)</span>。</p><p>维护两个单调栈，一个递增一个递减，对于递增单调栈中相邻两个位置 <spanclass="math inline">\(x,y\)</span>，可以知道 <spanclass="math inline">\((x,y]\)</span> 这段作为起始位置时，最小值都为<spanclass="math inline">\(a_y\)</span>。那么就可以知道：这段区间中的所有奇数/偶数位置都能满足最小值条件。</p><p>对于最大值条件也是同理，可以用两个线段树分别维护奇偶位置上的tag（满足条件数），同时满足两个条件的位置即可进行转移。</p><p>线段树中，维护每个区间的最大满足条件的数量（tag），和具有最大条件数量的位置的<span class="math inline">\(f_i\)</span>之和。对线段树的操作包括单点添加新的dp值，区间tag加1和减1（在单调栈中元素被pop时减）。</p><p>因为我们的操作能保证合理（只对具有tag1区间的减tag1，tag2一样），所以不需要记录区间具有两种条件的哪一种，只需要记录数量即可。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, a[maxn];ll f[maxn];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">segTree</span> &#123;    function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; fp; <span class="hljs-comment">//自带离散映射的线段树</span>    ll sum[maxn &lt;&lt; <span class="hljs-number">2</span>], mx[maxn &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-type">int</span> add[maxn &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;        add[p] = sum[p] = mx[p] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span>;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-built_in">build</span>(p * <span class="hljs-number">2</span>, l, mid);        <span class="hljs-built_in">build</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        sum[p] = <span class="hljs-number">0</span>, mx[p] = <span class="hljs-built_in">max</span>(mx[p * <span class="hljs-number">2</span>], mx[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]);        <span class="hljs-keyword">if</span>(mx[p] == mx[p * <span class="hljs-number">2</span>]) (sum[p] += sum[p * <span class="hljs-number">2</span>]) %= mode;        <span class="hljs-keyword">if</span>(mx[p] == mx[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]) (sum[p] += sum[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]) %= mode;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_add</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> d)</span> </span>&#123;        mx[p] += d;        add[p] += d;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        <span class="hljs-keyword">if</span>(add[p]) &#123;            <span class="hljs-built_in">push_add</span>(p * <span class="hljs-number">2</span>, add[p]);            <span class="hljs-built_in">push_add</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, add[p]);            add[p] = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addvalue</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, ll val)</span> </span>&#123;        <span class="hljs-keyword">if</span>(l == r) &#123;            (sum[p] += val) %= mode;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-built_in">push_down</span>(p);        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(pos &lt;= <span class="hljs-built_in">fp</span>(mid)) <span class="hljs-built_in">addvalue</span>(p * <span class="hljs-number">2</span>, l, mid, pos, val);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">addvalue</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, pos, val);        <span class="hljs-built_in">push_up</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> d)</span> </span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fp</span>(l) &gt; R || L &gt; <span class="hljs-built_in">fp</span>(r)) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(L &lt;= <span class="hljs-built_in">fp</span>(l) &amp;&amp; <span class="hljs-built_in">fp</span>(r) &lt;= R) &#123;            <span class="hljs-built_in">push_add</span>(p, d);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-built_in">push_down</span>(p);        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-built_in">modify</span>(p * <span class="hljs-number">2</span>, l, mid, L, R, d);        <span class="hljs-built_in">modify</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R, d);        <span class="hljs-built_in">push_up</span>(p);    &#125;    <span class="hljs-function">ll <span class="hljs-title">queryTot</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(mx[<span class="hljs-number">1</span>] == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> sum[<span class="hljs-number">1</span>];        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;st[<span class="hljs-number">2</span>];<span class="hljs-type">int</span> stk[<span class="hljs-number">2</span>][maxn], h[<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) cin &gt;&gt; a[i];    st[<span class="hljs-number">0</span>].fp = [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x;&#125;;    st[<span class="hljs-number">1</span>].fp = [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x - <span class="hljs-number">1</span>;&#125;;    <span class="hljs-type">int</span> hn = (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;    st[<span class="hljs-number">0</span>].<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn);    st[<span class="hljs-number">1</span>].<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn);    h[<span class="hljs-number">0</span>] = h[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    stk[<span class="hljs-number">1</span>][++h[<span class="hljs-number">1</span>]] = stk[<span class="hljs-number">0</span>][++h[<span class="hljs-number">0</span>]] = <span class="hljs-number">0</span>;    f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        st[i &amp; <span class="hljs-number">1</span>].<span class="hljs-built_in">addvalue</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn, i, f[i - <span class="hljs-number">1</span>]);        <span class="hljs-keyword">while</span>(h[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span> &amp;&amp; a[stk[<span class="hljs-number">0</span>][h[<span class="hljs-number">0</span>]]] &gt; a[i]) &#123;            <span class="hljs-type">int</span> f = stk[<span class="hljs-number">0</span>][h[<span class="hljs-number">0</span>]] &amp; <span class="hljs-number">1</span>;            st[f ^ <span class="hljs-number">1</span>].<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn, stk[<span class="hljs-number">0</span>][h[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, stk[<span class="hljs-number">0</span>][h[<span class="hljs-number">0</span>]], <span class="hljs-number">-1</span>);            h[<span class="hljs-number">0</span>]--;        &#125;        st[(i &amp; <span class="hljs-number">1</span>) ^ <span class="hljs-number">1</span>].<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn, stk[<span class="hljs-number">0</span>][h[<span class="hljs-number">0</span>]] + <span class="hljs-number">1</span>, i, <span class="hljs-number">1</span>);        stk[<span class="hljs-number">0</span>][++h[<span class="hljs-number">0</span>]] = i;        <span class="hljs-keyword">while</span>(h[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span> &amp;&amp; a[stk[<span class="hljs-number">1</span>][h[<span class="hljs-number">1</span>]]] &lt; a[i]) &#123;            <span class="hljs-type">int</span> f = stk[<span class="hljs-number">1</span>][h[<span class="hljs-number">1</span>]] &amp; <span class="hljs-number">1</span>;            st[f].<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn, stk[<span class="hljs-number">1</span>][h[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, stk[<span class="hljs-number">1</span>][h[<span class="hljs-number">1</span>]], <span class="hljs-number">-1</span>);            h[<span class="hljs-number">1</span>]--;        &#125;        st[i &amp; <span class="hljs-number">1</span>].<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn, stk[<span class="hljs-number">1</span>][h[<span class="hljs-number">1</span>]] + <span class="hljs-number">1</span>, i, <span class="hljs-number">1</span>);        stk[<span class="hljs-number">1</span>][++h[<span class="hljs-number">1</span>]] = i;        f[i] = (st[<span class="hljs-number">0</span>].<span class="hljs-built_in">queryTot</span>() + st[<span class="hljs-number">1</span>].<span class="hljs-built_in">queryTot</span>()) % mode;    &#125;    cout &lt;&lt; f[n] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="杭电第八场1009">2022杭电第八场1009</h4><p><ahref="https://acm.hdu.edu.cn/showproblem.php?pid=7228">Gilneas</a></p><p>感觉挺妙的一个线段树上概率处理+线段树合并</p><p>对于每个点 <spanclass="math inline">\(u\)</span>，它连向子树的边中一定只存在一条有颜色。</p><p>考虑 <span class="math inline">\(u\)</span>的这个子树中的每个操作，将它们按照时间排序，一个操作能为 <spanclass="math inline">\(u\)</span>的连边作出贡献，当且仅当这个操作成功，且之后的操作都失败。</p><p>把操作按时间放到线段树上，区间维护 <spanclass="math inline">\(sxp\)</span> 表示区间内所有操作的 <spanclass="math inline">\(1-p\)</span> 乘积（全失败的概率），和 <spanclass="math inline">\(sum\)</span> 表示 <spanclass="math inline">\(c_i\timesp_i\times\prod_{j&gt;i}(1-p_{j})\)</span> 的总和。即期望贡献。</p><p>这两个信息很好push_up。</p><p>那么对于每个点 <spanclass="math inline">\(u\)</span>，将其子树的线段树合并起来之后取 <spanclass="math inline">\(sum\)</span>即可得到它连儿子边的总贡献，注意还要考虑 <spanclass="math inline">\(u\)</span>这个点本身的操作会将边权清空，计算sum时可以先将 <spanclass="math inline">\(u\)</span> 本身的操作的 <spanclass="math inline">\(c_i\)</span> 视为0加入线段树，处理贡献后再将 <spanclass="math inline">\(c_i\)</span> 改回来。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">segTree</span> &#123;    ll sum[maxn &lt;&lt; <span class="hljs-number">5</span>], sxp[maxn &lt;&lt; <span class="hljs-number">5</span>];    <span class="hljs-type">int</span> ls[maxn &lt;&lt; <span class="hljs-number">5</span>], rs[maxn &lt;&lt; <span class="hljs-number">5</span>];    <span class="hljs-type">int</span> tcnt = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newnode</span><span class="hljs-params">()</span> </span>&#123;        ++tcnt;        sum[tcnt] = <span class="hljs-number">0</span>;        sxp[tcnt] = <span class="hljs-number">1</span>;        ls[tcnt] = rs[tcnt] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> tcnt;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        sum[p] = (sum[ls[p]] * sxp[rs[p]] % mode + sum[rs[p]]) % mode;        sxp[p] = sxp[ls[p]] * sxp[rs[p]] % mode;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!x) <span class="hljs-keyword">return</span> y;        <span class="hljs-keyword">if</span>(!y) <span class="hljs-keyword">return</span> x;        <span class="hljs-built_in">assert</span>(l != r);        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        ls[x] = <span class="hljs-built_in">merge</span>(ls[x], ls[y], l, mid);        rs[x] = <span class="hljs-built_in">merge</span>(rs[x], rs[y], mid + <span class="hljs-number">1</span>, r);        <span class="hljs-built_in">push_up</span>(x);        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, ll pi, ll ci)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!p) p = <span class="hljs-built_in">newnode</span>();        <span class="hljs-keyword">if</span>(l == r) &#123;            sxp[p] = (<span class="hljs-number">1ll</span> - pi + mode) % mode;            sum[p] = pi * ci % mode;            <span class="hljs-keyword">return</span> p;        &#125;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(pos &lt;= mid) ls[p] = <span class="hljs-built_in">modify</span>(ls[p], l, mid, pos, pi, ci);        <span class="hljs-keyword">else</span> rs[p] = <span class="hljs-built_in">modify</span>(rs[p], mid + <span class="hljs-number">1</span>, r, pos, pi, ci);        <span class="hljs-built_in">push_up</span>(p);        <span class="hljs-keyword">return</span> p;    &#125;&#125;st;<span class="hljs-type">int</span> n, m;vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; opt[maxn];ll ans = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123; <span class="hljs-comment">//返回子树的线段树根节点</span>    <span class="hljs-type">int</span> rt = st.<span class="hljs-built_in">newnode</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> tup: opt[p]) &#123;        <span class="hljs-type">int</span> id = tup[<span class="hljs-number">0</span>], pi = tup[<span class="hljs-number">1</span>];        st.<span class="hljs-built_in">modify</span>(rt, <span class="hljs-number">1</span>, m, id, pi, <span class="hljs-number">0</span>);    &#125;     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : vp[p]) rt = st.<span class="hljs-built_in">merge</span>(rt, <span class="hljs-built_in">dfs</span>(v), <span class="hljs-number">1</span>, m);    (ans += st.sum[rt]) %= mode;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> tup : opt[p]) &#123;        <span class="hljs-type">int</span> id = tup[<span class="hljs-number">0</span>], pi = tup[<span class="hljs-number">1</span>], ci = tup[<span class="hljs-number">2</span>];        st.<span class="hljs-built_in">modify</span>(rt, <span class="hljs-number">1</span>, m, id, pi, ci);    &#125;    <span class="hljs-keyword">return</span> rt;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    st.tcnt = <span class="hljs-number">-1</span>;    st.<span class="hljs-built_in">newnode</span>(); <span class="hljs-comment">//初始化0点</span>    ans = <span class="hljs-number">0</span>;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        vp[i].<span class="hljs-built_in">clear</span>();        opt[i].<span class="hljs-built_in">clear</span>();    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++) &#123;        <span class="hljs-type">int</span> fa; cin &gt;&gt; fa;        vp[fa].<span class="hljs-built_in">push_back</span>(i);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++) &#123;        <span class="hljs-type">int</span> x, c, p;        cin &gt;&gt; x &gt;&gt; c &gt;&gt; p;        opt[x].<span class="hljs-built_in">push_back</span>(&#123;i, p, c&#125;);    &#125;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="杭电第九场1001">2022杭电第九场1001</h4><p><ahref="https://acm.dingbacode.com/showproblem.php?pid=7233">ArithmeticSubsequence</a></p><p>比较难想到是构造题</p><p>需要不包含任何等差数列，一个可以切入的思考点是：等差数列要么全是奇数/偶数，要么在奇偶之间来回切换</p><p>如果把奇数放到一边，偶数放到另一边，那么必然不存在跨两边的等差数列，就可以分治求解了。</p><p>奇数部分可以集体-1，偶数部分可以集体除2，都不影响等差数列的存在性。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, a[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cdq</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;    <span class="hljs-keyword">if</span>(l + <span class="hljs-number">1</span> &gt;= r) <span class="hljs-keyword">return</span>;    <span class="hljs-type">int</span> m = l;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l;i &lt;= r;i++) <span class="hljs-keyword">if</span>(a[i] &amp; <span class="hljs-number">1</span>) <span class="hljs-built_in">swap</span>(a[m++], a[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l;i &lt; m;i++) a[i]--;    <span class="hljs-built_in">cdq</span>(l, m - <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = m;i &lt;= r;i++) a[i] /= <span class="hljs-number">2</span>;    <span class="hljs-built_in">cdq</span>(m, r);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l;i &lt; m;i++) a[i]++;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = m;i &lt;= r;i++) a[i] *= <span class="hljs-number">2</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) cin &gt;&gt; a[i];    <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>;i &lt;= n;i++) <span class="hljs-keyword">if</span>(a[i] == a[i - <span class="hljs-number">1</span>] &amp;&amp; a[i] == a[i - <span class="hljs-number">2</span>]) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-built_in">cdq</span>(<span class="hljs-number">1</span>, n);    cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;</code></pre></div><h4 id="杭电第十场1008">2022杭电第十场1008</h4><p><a href="https://acm.dingbacode.com/showproblem.php?pid=7251">MinimumDiameter</a></p><p>对于静态森林，可以求出各个树的直径，将其他小直径的中点和最大直径的中点相连，答案易得。</p><p>所以问题转化为动态维护树上直径，操作只有连边</p><p>我们可以单开一个并查集记录每个树的直径以及直径两端点，合并两树时，只需考虑四个端点的两两组合，合并后的直径一定在它们当中。</p><p>使用LCT可以快速求出任意两点间距离，且支持森林连边操作。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LCT</span> &#123;    <span class="hljs-type">int</span> ch[maxn][<span class="hljs-number">2</span>], fa[maxn], siz[maxn], swp[maxn];    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">dir</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123; <span class="hljs-keyword">return</span> ch[fa[p]][<span class="hljs-number">1</span>] == p; &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123; siz[p] = <span class="hljs-number">1</span> + siz[ch[p][<span class="hljs-number">0</span>]] + siz[ch[p][<span class="hljs-number">1</span>]]; &#125;<span class="hljs-comment">//sum[p] = sum[ch[p][0]] ^ sum[ch[p][1]] ^ val[p]; &#125;</span>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">isroot</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123; <span class="hljs-keyword">return</span> fa[p] == <span class="hljs-number">0</span> || (ch[fa[p]][<span class="hljs-number">0</span>] != p &amp;&amp; ch[fa[p]][<span class="hljs-number">1</span>] != p); &#125; <span class="hljs-comment">//是否为splay的根（不是原树的根！）</span>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span>;        <span class="hljs-built_in">swap</span>(ch[p][<span class="hljs-number">0</span>], ch[p][<span class="hljs-number">1</span>]), swp[p] ^= <span class="hljs-number">1</span>;        <span class="hljs-comment">//        push_down(p);//调试用 立即下放所有懒标记</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        <span class="hljs-keyword">if</span>(swp[p]) &#123;            swp[p] = <span class="hljs-number">0</span>;            <span class="hljs-built_in">push_swap</span>(ch[p][<span class="hljs-number">0</span>]);            <span class="hljs-built_in">push_swap</span>(ch[p][<span class="hljs-number">1</span>]);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-comment">//出bug了必须首先来查rotate 注意变化前后顺序的问题 太麻了</span>        <span class="hljs-keyword">if</span>(fa[p] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-type">int</span> f = fa[p], ff = fa[f];        <span class="hljs-type">int</span> d = <span class="hljs-built_in">dir</span>(p), s = ch[p][d ^ <span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isroot</span>(f)) ch[ff][<span class="hljs-built_in">dir</span>(f)] = p;<span class="hljs-comment">//与普通splay不同之处：如果父亲节点已经是根节点，一定不能让ff认儿子</span>        fa[s] = f;        fa[p] = ff; ch[p][d ^ <span class="hljs-number">1</span>] = f;        fa[f] = p; ch[f][d] = s;        <span class="hljs-built_in">push_up</span>(f);<span class="hljs-comment">//最后一个节点的push_up在splay那</span>    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_all</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isroot</span>(p)) <span class="hljs-built_in">push_all</span>(fa[p]);        <span class="hljs-built_in">push_down</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-comment">//将p转到其所在splay（实链节点集合）的根节点</span>        <span class="hljs-built_in">push_all</span>(p);<span class="hljs-comment">//从顶向下push_down</span>        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isroot</span>(p)) &#123;            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isroot</span>(fa[p])) <span class="hljs-built_in">rotate</span>(<span class="hljs-built_in">dir</span>(p) == <span class="hljs-built_in">dir</span>(fa[p]) ? fa[p] : p);            <span class="hljs-built_in">rotate</span>(p);<span class="hljs-comment">//双旋，不管旋了父还是子，第二次旋转都要跟上，不然会假</span>        &#125;        <span class="hljs-built_in">push_up</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-comment">//打通p所在真实树的根节点到p的路径</span>        <span class="hljs-type">int</span> lst = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(p) &#123;            <span class="hljs-built_in">splay</span>(p);            ch[p][<span class="hljs-number">1</span>] = lst;            <span class="hljs-built_in">push_up</span>(p);            lst = p;            p = fa[p];        &#125;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeroot</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-comment">//p变为其所在真实树中的根节点（同时也是splay根）</span>        <span class="hljs-built_in">access</span>(p);        <span class="hljs-built_in">splay</span>(p);        <span class="hljs-built_in">push_swap</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findroot</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-comment">//查找所在真实树的根节点，注意这个也会改变p所在splay结构</span>        <span class="hljs-built_in">access</span>(p);        <span class="hljs-built_in">splay</span>(p);        <span class="hljs-keyword">while</span>(ch[p][<span class="hljs-number">0</span>]) <span class="hljs-built_in">push_down</span>(p), p = ch[p][<span class="hljs-number">0</span>];        <span class="hljs-keyword">return</span> p;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-comment">//将x,y之间的路径剖出来作为splay，然后x作为原树根，y作为splay根</span>        <span class="hljs-built_in">makeroot</span>(x);        <span class="hljs-built_in">access</span>(y);        <span class="hljs-built_in">splay</span>(y);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-comment">//连边（虚边）</span>        <span class="hljs-built_in">makeroot</span>(x);        <span class="hljs-keyword">if</span>(x != <span class="hljs-built_in">findroot</span>(y)) fa[x] = y;<span class="hljs-comment">//注意，连虚边一定要让所在splay的根节点的fa连出去，这里x已经是splay根节点了而y不一定</span>    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-comment">//删边</span>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">findroot</span>(x) != <span class="hljs-built_in">findroot</span>(y)) <span class="hljs-keyword">return</span>;        <span class="hljs-built_in">split</span>(x, y);<span class="hljs-comment">//记牢此时x为原树根，y为splay根，原树根仅仅是深度最小的节点，完全可以有fa</span>        <span class="hljs-keyword">if</span>(fa[x] != y || ch[x][<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//要x,y之间有连边，就要它们在splay的中序遍历上相邻</span>        ch[y][<span class="hljs-number">0</span>] = fa[x] = <span class="hljs-number">0</span>;        <span class="hljs-built_in">push_up</span>(y);    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dist</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;        <span class="hljs-built_in">split</span>(x, y);        <span class="hljs-keyword">return</span> siz[y];    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++) ch[i][<span class="hljs-number">0</span>] = ch[i][<span class="hljs-number">1</span>] = fa[i] = swp[i] = <span class="hljs-number">0</span>;    &#125;&#125;lct;<span class="hljs-type">int</span> a[maxn], f[maxn];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">diameter</span> &#123;    <span class="hljs-type">int</span> x, y, d;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> diameter&amp; t)<span class="hljs-type">const</span> &#123;        <span class="hljs-keyword">return</span> d &lt; t.d;    &#125;&#125;d[maxn];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x == f[x]) <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> f[x] = <span class="hljs-built_in">find</span>(f[x]);&#125;<span class="hljs-type">int</span> cnt[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n, m;    cin &gt;&gt; n &gt;&gt; m;    lct.<span class="hljs-built_in">init</span>(n);    cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        f[i] = i;        lct.siz[i] = <span class="hljs-number">1</span>;        d[i] = &#123;i, i, <span class="hljs-number">0</span>&#125;;        cnt[i] = <span class="hljs-number">0</span>;        cnt[<span class="hljs-number">0</span>]++;    &#125;    <span class="hljs-type">int</span> mxd = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++) &#123;        <span class="hljs-type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;        <span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(x), fy = <span class="hljs-built_in">find</span>(y);        cnt[d[fx].d]--;        cnt[d[fy].d]--;        lct.<span class="hljs-built_in">link</span>(x, y);        diameter tmp = <span class="hljs-built_in">max</span>(d[fx], d[fy]);        tmp = <span class="hljs-built_in">max</span>(tmp, &#123;d[fx].x, d[fy].x, lct.<span class="hljs-built_in">dist</span>(d[fx].x, d[fy].x) - <span class="hljs-number">1</span>&#125;);        tmp = <span class="hljs-built_in">max</span>(tmp, &#123;d[fx].x, d[fy].y, lct.<span class="hljs-built_in">dist</span>(d[fx].x, d[fy].y) - <span class="hljs-number">1</span>&#125;);        tmp = <span class="hljs-built_in">max</span>(tmp, &#123;d[fx].y, d[fy].x, lct.<span class="hljs-built_in">dist</span>(d[fx].y, d[fy].x) - <span class="hljs-number">1</span>&#125;);        tmp = <span class="hljs-built_in">max</span>(tmp, &#123;d[fx].y, d[fy].y, lct.<span class="hljs-built_in">dist</span>(d[fx].y, d[fy].y) - <span class="hljs-number">1</span>&#125;);        f[fx] = fy;        d[fy] = tmp;        cnt[tmp.d]++;        mxd = <span class="hljs-built_in">max</span>(mxd, tmp.d);        <span class="hljs-comment">// for(auto x : alld) cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;</span>        <span class="hljs-comment">// cout &lt;&lt; &#x27;\n&#x27;;</span>        <span class="hljs-type">int</span> mx[<span class="hljs-number">4</span>], h = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;h &lt; <span class="hljs-number">3</span> &amp;&amp; i &lt;= cnt[mxd];i++) mx[++h] = mxd;        <span class="hljs-keyword">if</span>(mxd &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;h &lt; <span class="hljs-number">3</span> &amp;&amp; i &lt;= cnt[mxd - <span class="hljs-number">1</span>];i++) mx[++h] = mxd - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(mxd &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;h &lt; <span class="hljs-number">3</span> &amp;&amp; i &lt;= cnt[mxd - <span class="hljs-number">2</span>];i++) mx[++h] = mxd - <span class="hljs-number">2</span>;        <span class="hljs-type">int</span> ans = mx[<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span>(h &gt; <span class="hljs-number">1</span>) ans = <span class="hljs-built_in">max</span>(ans, (mx[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span> + (mx[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);        <span class="hljs-keyword">if</span>(h &gt; <span class="hljs-number">2</span>) ans = <span class="hljs-built_in">max</span>(ans, (mx[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">2</span> + (mx[<span class="hljs-number">3</span>] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);        cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div><h4 id="compfest-14-j.-journey"><ahref="https://codeforces.com/contest/1725/problem/J">COMPFEST 14 J.Journey</a></h4><p>如果只有一个起点，答案即所有边权x2再减去树上的最长路径（直径）</p><p>现在可以取第二个起点，那么答案（要减去的部分）有两种情况：</p><ul><li>树上两条有单个点相交的路径</li><li>树上两条不相交的路径，再加上两路径之间的最大边x2</li></ul><p>对于第一种情况，考虑枚举交点，然后走四条链出去，这个比较好维护</p><p>第二种情况，枚举中间边，然后需要知道以这条边作为分割，上下两棵树的直径。</p><p>要维护这两个东西比较麻烦，具体如下：</p><div class="code-wrapper"><pre><code class="hljs C++">ll dia[maxn];   <span class="hljs-comment">// p这个子树的直径</span>ll dup[maxn];   <span class="hljs-comment">// 除去p子树的直径</span>ll dp[maxn][<span class="hljs-number">4</span>]; <span class="hljs-comment">// p向下最大的四条链</span>ll dp2[maxn][<span class="hljs-number">2</span>];<span class="hljs-comment">// p儿子中最大的两个直径</span>ll up[maxn];    <span class="hljs-comment">// p向上走的最长链</span></code></pre></div><p>首先一遍 dfs 求出 <code>dp, dp2, dia</code></p><p>然后再 dfs 第二遍，这一遍<strong>从上向下转移</strong></p><p>设当前跑到边 <span class="math inline">\(u\rightarrowv\)</span>，边权 <span class="math inline">\(w\)</span></p><p><code>up[v]</code> 可以由 <code>up[u] + w</code>，以及<code>u子树中除了v之外的最长链 + w</code> 转移来</p><p><code>dup[v]</code> 可以由 <code>dup[u]</code> 以及<code>u子树中除了v之外的最大直径</code> 和<code>u连出的链中除了v之外的最大两条链之和</code> 转移来</p><p>想到了这些就会发现题目可做了，然后就是分类讨论的事了（</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e6</span> + <span class="hljs-number">100</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> mode = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>; vector&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; vp[maxn];ll dia[maxn];   <span class="hljs-comment">// p子树的直径</span>ll dup[maxn];   <span class="hljs-comment">// 除去p子树的直径</span>ll dp[maxn][<span class="hljs-number">4</span>]; <span class="hljs-comment">// p向下最大的四条链</span>ll dp2[maxn][<span class="hljs-number">2</span>];<span class="hljs-comment">// p儿子中最大的两个直径</span>ll up[maxn];    <span class="hljs-comment">// 向上最长链</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add1to</span><span class="hljs-params">(<span class="hljs-type">int</span> p, ll val)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">4</span>;i++) &#123;        <span class="hljs-keyword">if</span>(dp[p][i] &lt; val) <span class="hljs-built_in">swap</span>(val, dp[p][i]);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add2to</span><span class="hljs-params">(<span class="hljs-type">int</span> p, ll val)</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">2</span>;i++) &#123;        <span class="hljs-keyword">if</span>(dp2[p][i] &lt; val) <span class="hljs-built_in">swap</span>(val, dp2[p][i]);    &#125;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span> </span>&#123;    dia[p] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [v, w] : vp[p]) &#123;        <span class="hljs-keyword">if</span>(v != fa) &#123;            <span class="hljs-built_in">dfs</span>(v, p);            <span class="hljs-built_in">add1to</span>(p, dp[v][<span class="hljs-number">0</span>] + w);            <span class="hljs-built_in">add2to</span>(p, dia[v]);            dia[p] = <span class="hljs-built_in">max</span>(dia[p], dia[v]);        &#125;    &#125;    dia[p] = <span class="hljs-built_in">max</span>(dia[p], dp[p][<span class="hljs-number">0</span>] + dp[p][<span class="hljs-number">1</span>]);&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa, ll&amp; res)</span> </span>&#123;    ll tmp;    <span class="hljs-built_in">add1to</span>(p, up[p]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [v, w] : vp[p]) &#123;        <span class="hljs-keyword">if</span>(v != fa) &#123;            up[v] = w + dp[p][dp[p][<span class="hljs-number">0</span>] == dp[v][<span class="hljs-number">0</span>] + w ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>];            ll mx1 = dp2[p][dp2[p][<span class="hljs-number">0</span>] == dia[v] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>];            ll mx2;            <span class="hljs-keyword">if</span>(dp[p][<span class="hljs-number">0</span>] == dp[v][<span class="hljs-number">0</span>] + w) mx2 = dp[p][<span class="hljs-number">1</span>] + dp[p][<span class="hljs-number">2</span>];            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[p][<span class="hljs-number">1</span>] == dp[v][<span class="hljs-number">0</span>] + w) mx2 = dp[p][<span class="hljs-number">0</span>] + dp[p][<span class="hljs-number">2</span>];            <span class="hljs-keyword">else</span> mx2 = dp[p][<span class="hljs-number">0</span>] + dp[p][<span class="hljs-number">1</span>];            dup[v] = <span class="hljs-built_in">max</span>(&#123;dup[p], mx1, mx2&#125;);             res = <span class="hljs-built_in">max</span>(res, dia[v] + dup[v] + <span class="hljs-number">2</span> * w);            <span class="hljs-built_in">dfs2</span>(v, p, res);        &#125;    &#125;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    ll ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++) &#123;        <span class="hljs-type">int</span> u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;        vp[u].<span class="hljs-built_in">emplace_back</span>(v, w);        vp[v].<span class="hljs-built_in">emplace_back</span>(u, w);        ans += w * <span class="hljs-number">2</span>;    &#125;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    ll res = <span class="hljs-number">0</span>;    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, res);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        <span class="hljs-keyword">if</span>(vp[i].<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">continue</span>;        res = <span class="hljs-built_in">max</span>(res, dp[i][<span class="hljs-number">0</span>] + dp[i][<span class="hljs-number">1</span>] + dp[i][<span class="hljs-number">2</span>] + dp[i][<span class="hljs-number">3</span>]);    &#125;    cout &lt;&lt; ans - res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; &#125;</code></pre></div><h4 id="icpc-网赛2-h"><ahref="https://pintia.cn/problem-sets/1574060137151397888/problems/1574060247893606407">2022ICPC 网赛2 H</a></h4><p>首先分别考虑贡献，因为这题中一个方案的贡献由所有 <spanclass="math inline">\(u,v\)</span> 间的路径长度（ <spanclass="math inline">\(u,v\)</span>之间没有其他选中点）组成，故去考虑<strong>每一条路径</strong>的贡献。</p><p>一条路径计入答案，当且仅当其两端点 <spanclass="math inline">\(u,v\)</span>都选中，且路径中其他点都不被选中（仅计算被直接选择时的贡献，作为子路径时不考虑，这样能做到不重复不遗漏），然后我们再去考虑这个路径会被计算多少次。</p><p>此时其他点可选可不选，对于任意一点 <spanclass="math inline">\(i\)</span>，它对这个路径产生贡献的次数都为 <spanclass="math inline">\(2^{n-d-2}\)</span>，那么这条路径的总贡献为：<spanclass="math inline">\(d(n-d+3)2^{n-d-2}\)</span></p><p>有了这个式子，只需要枚举图中所有的路径计算和即可，但这显然不现实。</p><p>考虑换根dp，对于每个点记录其向上走和向下走的所有路径贡献和，如何转移？</p><p>注意到每条路径的式子形式类似 <spanclass="math inline">\(xy2^y\)</span>，对于许多这样的式子和，要进行全体<code>x+1</code> 等类似操作并维护是很容易的，只需要维护 <spanclass="math inline">\(x2^y,y2^y,2^y\)</span> 和作为辅助即可。</p><p>同理进行 <code>y-1</code>等操作也不难，剩下的就是一个标准的换根dp了。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll x, ll p)</span> </span>&#123;    <span class="hljs-keyword">if</span>(p &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qpow</span>(<span class="hljs-built_in">qpow</span>(x, -p), mode - <span class="hljs-number">2</span>);    ll r = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(p &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span>(p &amp; <span class="hljs-number">1</span>) r = r * x % mode;        x = x * x % mode;        p /= <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> r;&#125;ll iv2 = <span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>, mode - <span class="hljs-number">2</span>);<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;    ll xxy, xy, yy, y;    <span class="hljs-built_in">node</span>() : <span class="hljs-built_in">xxy</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">xy</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">yy</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>) &#123;&#125;;    <span class="hljs-built_in">node</span>(ll a, ll b) &#123;        y = <span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>, b);        yy = b * y % mode;        xy = a * y % mode;        xxy = b * xy % mode;    &#125;    node <span class="hljs-keyword">operator</span> +(<span class="hljs-type">const</span> node&amp; t) &#123;        node r = *<span class="hljs-keyword">this</span>;        (r.xxy += t.xxy) %= mode;        (r.xy += t.xy) %= mode;        (r.yy += t.yy) %= mode;        (r.y += t.y) %= mode;        <span class="hljs-keyword">return</span> r;    &#125;    node <span class="hljs-keyword">operator</span> -(<span class="hljs-type">const</span> node&amp; t) &#123;        node r = *<span class="hljs-keyword">this</span>;        (r.xxy -= t.xxy) %= mode;        (r.xy -= t.xy) %= mode;        (r.yy -= t.yy) %= mode;        (r.y -= t.y) %= mode;        <span class="hljs-keyword">return</span> r;    &#125;    <span class="hljs-function">node <span class="hljs-title">add1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-function">node <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;        r.xxy = (xxy + yy - xy - y + <span class="hljs-number">2</span> * mode) % mode * iv2 % mode;        r.yy = (yy - y + mode) * iv2 % mode;        r.xy = (xy + y) * iv2 % mode;        r.y = y * iv2 % mode;        <span class="hljs-keyword">return</span> r;    &#125;&#125;;<span class="hljs-type">int</span> n;vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];node dw[maxn], up[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span> </span>&#123;    dw[p] = <span class="hljs-built_in">node</span>(<span class="hljs-number">0</span>, n + <span class="hljs-number">3</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : vp[p]) &#123;        <span class="hljs-keyword">if</span>(v != fa) &#123;            <span class="hljs-built_in">dfs1</span>(v, p);            dw[p] = dw[p] + dw[v].<span class="hljs-built_in">add1</span>();        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : vp[p]) &#123;        <span class="hljs-keyword">if</span>(v != fa) &#123;            up[v] = (up[p] + dw[p] - dw[v].<span class="hljs-built_in">add1</span>()).<span class="hljs-built_in">add1</span>();            <span class="hljs-built_in">dfs2</span>(v, p);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++) &#123;        <span class="hljs-type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;        vp[x].<span class="hljs-built_in">push_back</span>(y);        vp[y].<span class="hljs-built_in">push_back</span>(x);    &#125;    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    ll ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) ans = (ans + (up[i] + dw[i] - <span class="hljs-built_in">node</span>(<span class="hljs-number">0</span>, n + <span class="hljs-number">3</span>)).xxy) % mode;    cout &lt;&lt; <span class="hljs-function">ans * <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-number">64</span>, mode - <span class="hljs-number">2</span>)</span> % mode &lt;&lt; &#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="ccpc-威海-k"><ahref="https://codeforces.com/gym/104023/problem/K">2022 CCPC 威海K</a></h4><blockquote><p>题意：要求寻找区间 <span class="math inline">\([l, r](0&lt;l\ler)\)</span> 的个数，满足给出的 <span class="math inline">\(n\)</span>个条件，条件形式如下：</p><ul><li>1 <span class="math inline">\(k\)</span> <spanclass="math inline">\(x\)</span>：可以在 <spanclass="math inline">\([l,r]\)</span> 中找出 <spanclass="math inline">\(k\)</span> 个不同数，使得他们的和为 <spanclass="math inline">\(x\)</span></li><li>2 <span class="math inline">\(k\)</span> <spanclass="math inline">\(x\)</span>：无法在 <spanclass="math inline">\([l,r]\)</span> 中找出 <spanclass="math inline">\(k\)</span> 个不同数，使得他们的和为 <spanclass="math inline">\(x\)</span></li></ul></blockquote><p>首先注意到一点：对于任意区间 <spanclass="math inline">\([l,r]\)</span>，从中取 <spanclass="math inline">\(k\)</span> 个数的值域是连续的，最小值为 <spanclass="math inline">\(\frac{(l+l+k-1)\timesl}{2}\)</span>，最大值同理（式子不写了）</p><p>考虑第一种条件，我们可以找到这样一个区间： <spanclass="math inline">\([L,L+k-1]\)</span> 总和为 <spanclass="math inline">\(x\)</span>，或者 <spanclass="math inline">\([L,L+k]\)</span>，前 <spanclass="math inline">\(k\)</span> 个数和小于 <spanclass="math inline">\(x\)</span> 且后 <spanclass="math inline">\(k\)</span> 个数和大于 <spanclass="math inline">\(x\)</span>。</p><p>条件一转化为：<span class="math inline">\([l,r]\)</span>必须包括这个区间，可以合并所有条件一得到 <spanclass="math inline">\(l\)</span> 的最大值和 <spanclass="math inline">\(r\)</span> 的最小值。</p><p>同理，条件二转化为 <span class="math inline">\([l,r]\)</span>必须不包括这个区间，然而这个东西在线段上比较难处理，可以在 <spanclass="math inline">\(lOr\)</span> 平面上考虑。</p><p>画个图发现就是求个矩形面积并，可以扫描线或者单调栈处理。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n; cin &gt;&gt; n;    ll L = <span class="hljs-number">2e9</span>, R = <span class="hljs-number">0</span>;    vector&lt;pii&gt; ban;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        <span class="hljs-type">int</span> opt, k, x;        cin &gt;&gt; opt &gt;&gt; k &gt;&gt; x;        ll l = <span class="hljs-number">1</span>, r = <span class="hljs-number">2e9</span>;        <span class="hljs-keyword">while</span>(l &lt; r) &#123;            ll mid = (l + r) / <span class="hljs-number">2</span>;            ll val = (mid + mid + k - <span class="hljs-number">1</span>) * k / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(val &gt;= x) r = mid;            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;        &#125;        r = l + k - <span class="hljs-number">1</span>;        ll val = (l + l + k - <span class="hljs-number">1</span>) * k / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(val != x) l--;        <span class="hljs-keyword">if</span>(opt == <span class="hljs-number">1</span>) &#123;            L = <span class="hljs-built_in">min</span>(L, l);            R = <span class="hljs-built_in">max</span>(R, r);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span>(l == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;            ban.<span class="hljs-built_in">emplace_back</span>(l, r);        &#125;    &#125;    <span class="hljs-keyword">if</span>(L == <span class="hljs-number">0</span>) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(ban.<span class="hljs-built_in">empty</span>()) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; [x, y] : ban) &#123;        <span class="hljs-keyword">if</span>(x &gt; L) x = L;        <span class="hljs-keyword">if</span>(y &lt; R) y = R;    &#125;    <span class="hljs-built_in">sort</span>(ban.<span class="hljs-built_in">begin</span>(), ban.<span class="hljs-built_in">end</span>(), [&amp;](pii&amp; a, pii&amp; b) &#123; <span class="hljs-keyword">return</span> a.second &lt; b.second;&#125;);    stack&lt;pii&gt; stk;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; [x, y] : ban) &#123;        <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">empty</span>() || x &gt; stk.<span class="hljs-built_in">top</span>().first) &#123;            stk.<span class="hljs-built_in">emplace</span>(x, y);        &#125;    &#125;    <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">top</span>().first &lt; L) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    ll ans = <span class="hljs-number">0</span>;    ll lst = stk.<span class="hljs-built_in">top</span>().second;    stk.<span class="hljs-built_in">pop</span>();    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>()) &#123;        <span class="hljs-keyword">auto</span> [x, y] = stk.<span class="hljs-built_in">top</span>();        stk.<span class="hljs-built_in">pop</span>();        ans += (lst - y) * (L - x);        lst = y;    &#125;    ans += (lst - R) * L;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="ccpc-威海-f"><ahref="https://codeforces.com/gym/104023/problem/F">2022 CCPC 威海F</a></h4><blockquote><p>题意：给出一个有向图，每个点有颜色 <spanclass="math inline">\(c_i\)</span> 和费用 <spanclass="math inline">\(w_i\)</span>，走到一个未打标记的点时，需花费 <spanclass="math inline">\(w_i\)</span>并打标记，随后你可以选择任意个颜色不同的节点 <spanclass="math inline">\(j\)</span>，回收上面的标记并返还 <spanclass="math inline">\(w_j\)</span> 的费用。</p><p>问：对于每一对起点终点，初始需要多少钱才能抵达。 <spanclass="math inline">\(n \le 300\)</span></p></blockquote><p>显然当我们走到一个点时，会选择回收所有不同颜色的节点的费用，</p><p>那么对于一条路径，把它拆分为若干颜色段，走到每一段时都会回收前一段的费用，那么这段路径的代价就是<strong>MAX(每一段的费用和+下一段第一个点的费用，最后一段的费用)</strong></p><p>就变成了一个瓶颈路的问题。</p><p>具体做法：把原图划分为若干个同颜色的连通块，在每个连通块内部floyd求出两两间最短路，然后枚举块内的起点（<spanclass="math inline">\(s\)</span>）和终点（<spanclass="math inline">\(t\)</span>），再枚举终点向块外连的边（<spanclass="math inline">\(t\rightarrow j\)</span>），在新图上建一条 <spanclass="math inline">\(s\rightarrow j\)</span> 的边。</p><p>在新图上枚举起点，朴素prim跑最小瓶颈路（<spanclass="math inline">\(n^2\)</span>）</p><p>这样就将 "每一段的费用和+下一段第一个点的费用"考虑完了，还需要考虑最后一段的费用，这个不能直接在块内连边，因为我们要求最小瓶颈路，边权不能“合成”。（这个词用的比较抽象，自行理解一下）</p><p>只需要在最后输出前，用块内其他点+块内距离松弛一次即可，同样因为边不能“合成”，松弛后的结果不能更新到最短路中，而应当直接输出。</p><div class="code-wrapper"><pre><code class="hljs C++">ll dis[<span class="hljs-number">303</span>][<span class="hljs-number">303</span>];<span class="hljs-type">int</span> col[<span class="hljs-number">303</span>], w[<span class="hljs-number">303</span>];<span class="hljs-type">bool</span> vis[<span class="hljs-number">303</span>]; vector&lt;<span class="hljs-type">int</span>&gt; vp1[<span class="hljs-number">303</span>];ll dis2[<span class="hljs-number">303</span>][<span class="hljs-number">303</span>]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, vector&lt;<span class="hljs-type">int</span>&gt;&amp; ls)</span> </span>&#123; <span class="hljs-comment">//染色</span>    vis[p] = <span class="hljs-literal">true</span>;    ls.<span class="hljs-built_in">push_back</span>(p);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : vp1[p]) &#123;        <span class="hljs-keyword">if</span>(!vis[v] &amp;&amp; col[v] == col[p]) &#123;            <span class="hljs-built_in">dfs</span>(v, ls);        &#125;    &#125;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n, m;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-built_in">fill</span>(dis[<span class="hljs-number">0</span>], dis[<span class="hljs-number">0</span>] + <span class="hljs-number">303</span> * <span class="hljs-number">303</span>, <span class="hljs-number">1e18</span>);    <span class="hljs-built_in">fill</span>(dis2[<span class="hljs-number">0</span>], dis2[<span class="hljs-number">0</span>] + <span class="hljs-number">303</span> * <span class="hljs-number">303</span>, <span class="hljs-number">1e18</span>);    <span class="hljs-built_in">fill</span>(vis, vis + n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        vp1[i].<span class="hljs-built_in">clear</span>();    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) cin &gt;&gt; col[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) cin &gt;&gt; w[i], dis[i][i] = w[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++) &#123;        <span class="hljs-type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;        vp1[x].<span class="hljs-built_in">push_back</span>(y);        vp1[y].<span class="hljs-built_in">push_back</span>(x);        dis[x][y] = dis[y][x] = w[x] + w[y];    &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        <span class="hljs-keyword">if</span>(!vis[i]) &#123;            vector&lt;<span class="hljs-type">int</span>&gt; ls;            <span class="hljs-built_in">dfs</span>(i, ls);            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k : ls) &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : ls) &#123;                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j : ls) &#123;                        <span class="hljs-keyword">if</span>(dis[i][k] + dis[k][j] - w[k] &lt; dis[i][j]) &#123;                            dis[i][j] = dis[j][i] = dis[i][k] + dis[k][j] - w[k];                        &#125;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : ls) &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j : ls) &#123;                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : vp1[j]) &#123;                        <span class="hljs-keyword">if</span>(col[j] != col[v]) &#123;                            dis2[i][v] = <span class="hljs-built_in">min</span>(dis2[i][v], dis[i][j] + w[v]);                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;     <span class="hljs-function">vector <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;ll&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">1e18</span>))</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        ans[i][i] = w[i];        <span class="hljs-built_in">fill</span>(vis, vis + n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cc = <span class="hljs-number">1</span>;cc &lt;= n;cc++) &#123; <span class="hljs-comment">//prim</span>            <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>; ans[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1e18</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++) &#123;                <span class="hljs-keyword">if</span>(!vis[j] &amp;&amp; ans[i][j] &lt; ans[i][p]) p = j;            &#125;            vis[p] = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>;v &lt;= n;v++) &#123;                ans[i][v] = <span class="hljs-built_in">min</span>(ans[i][v], <span class="hljs-built_in">max</span>(ans[i][p], dis2[p][v]));            &#125;        &#125;    &#125;     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++) &#123;            ll opt = ans[i][j];            <span class="hljs-comment">// 最后一步可以使用dis</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k &lt;= n;k++) &#123;                opt = <span class="hljs-built_in">min</span>(opt, <span class="hljs-built_in">max</span>(ans[i][k], dis[k][j]));            &#125;            <span class="hljs-keyword">if</span>(i == j) opt = <span class="hljs-number">0</span>;            cout &lt;&lt; opt &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[j == n];        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>牛客多校</tag>
      
      <tag>杭电多校</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 814 div.1 ABC</title>
    <link href="/2022/08/18/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20814%20div1%20ABC/"/>
    <url>/2022/08/18/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20814%20div1%20ABC/</url>
    
    <content type="html"><![CDATA[<h4 id="录播讲解链接ab"><ahref="https://www.bilibili.com/video/BV1d14y147Ld?spm_id_from=333.999.0.0&amp;vd_source=f3bceb9b12c557f0a9cdb5ac0d26fee6">录播讲解链接(AB)</a></h4><h4 id="a2.-burenka-and-traditions-hard-version"><ahref="https://codeforces.com/contest/1718/problem/A2">A2. Burenka andTraditions (hard version)</a></h4><p>只会进行长度为2或1的区间操作，因为更大的可以分解成小的且不会更劣。</p><p>考虑从左到右依次两两进行异或操作，每次都使得左侧数变为0，那么总操作次数最多是<span class="math inline">\(n\)</span></p><p>如果其中包含一段异或和为0的区间，就可以省下一次操作，且仅有这种方式可以省操作，故目标变为划分出最多的异或为0的子段个数，异或前缀和+set即可。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-type">int</span> ans = n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    set&lt;<span class="hljs-type">int</span>&gt; pre;    pre.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>);    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        s ^= a[i];        <span class="hljs-keyword">if</span>(pre.<span class="hljs-built_in">count</span>(s))&#123;            pre.<span class="hljs-built_in">clear</span>();            s = <span class="hljs-number">0</span>;            ans--;        &#125;        pre.<span class="hljs-built_in">insert</span>(s);    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="b.-fibonacci-strings"><ahref="https://codeforces.com/contest/1718/problem/B">B. FibonacciStrings</a></h4><p>齐肯多夫定理：任意正整数都可以<strong>唯一</strong>分解成若干不连续的斐波那契数列项之和（不包括第一个1）。</p><p>分解方式也很简单，令 <span class="math inline">\(n\)</span>不断减去最大的比 <span class="math inline">\(n\)</span>小的斐波那契项即可。</p><p>这题我在写的时候还不知道这个定理，所以采用了一种贪心的方式诈胡了，即将所有的<span class="math inline">\(c_i\)</span>放入优先队列，从大到小枚举斐波那契项，每次取出最大的那个 <spanclass="math inline">\(c_i\)</span> 减去此项。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;ll f[<span class="hljs-number">75</span>], s[<span class="hljs-number">75</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    f[<span class="hljs-number">1</span>] = f[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;    s[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; s[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=<span class="hljs-number">70</span>;i++)&#123;        f[i] = f[i<span class="hljs-number">-1</span>] + f[i<span class="hljs-number">-2</span>];        s[i] = s[i<span class="hljs-number">-1</span>] + f[i];    &#125;    priority_queue&lt;pair&lt;ll, <span class="hljs-type">int</span>&gt;&gt; q;    cin &gt;&gt; n;    ll tot = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        ll x; cin &gt;&gt; x;        q.<span class="hljs-built_in">push</span>(&#123;x, i&#125;);        tot += x;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">70</span>;i++)&#123;        <span class="hljs-keyword">if</span>(s[i] &gt; tot) <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">if</span>(tot == s[i])&#123;            <span class="hljs-type">int</span> uid = <span class="hljs-number">-1</span>;            vector&lt;pair&lt;ll, <span class="hljs-type">int</span>&gt;&gt; tmp;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&gt;=<span class="hljs-number">1</span>;j--)&#123;                <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">empty</span>())&#123;                    cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;                    <span class="hljs-keyword">return</span>;                &#125;                <span class="hljs-keyword">auto</span> u = q.<span class="hljs-built_in">top</span>();                q.<span class="hljs-built_in">pop</span>();                <span class="hljs-keyword">if</span>(u.second == uid)&#123;                    tmp.<span class="hljs-built_in">push_back</span>(u);                    <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">empty</span>())&#123;                        cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;                        <span class="hljs-keyword">return</span>;                    &#125;                    u = q.<span class="hljs-built_in">top</span>();                    q.<span class="hljs-built_in">pop</span>();                &#125;                uid = u.second;                u.first -= f[j];                <span class="hljs-keyword">if</span>(u.first &lt; <span class="hljs-number">0</span>)&#123;                    cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;                    <span class="hljs-keyword">return</span>;                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(u.first != <span class="hljs-number">0</span>)&#123;                    q.<span class="hljs-built_in">push</span>(u);                &#125;                <span class="hljs-keyword">if</span>(!tmp.<span class="hljs-built_in">empty</span>())&#123;                    q.<span class="hljs-built_in">push</span>(tmp.<span class="hljs-built_in">back</span>());                    tmp.<span class="hljs-built_in">pop_back</span>();                &#125;            &#125;            cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;    <span class="hljs-keyword">return</span>;&#125;</code></pre></div><h4 id="c.-tonya-and-burenka-179"><ahref="https://codeforces.com/contest/1718/problem/C">C. Tonya andBurenka-179</a></h4><p>首先能想到，如果以 <span class="math inline">\(n\)</span> 的某个因数<span class="math inline">\(p\)</span>为步长去跳，会构成一个循环，每个数会重复 <spanclass="math inline">\(p\)</span>次，因为任选起点，重复的一定比不重复的好（可以选取较大的部分重复）。</p><p>若 <span class="math inline">\(kp\)</span> 仍为 <spanclass="math inline">\(n\)</span> 的因数，以 <spanclass="math inline">\(kp\)</span>为步长去跳显然会更好，因为涉及的元素严格为按 <spanclass="math inline">\(p\)</span>跳的子集，可以选取较大部分的子集来重复。</p><p>故最终可选取的步长仅有 <span class="math inline">\(n/p\)</span>，其中<span class="math inline">\(p\)</span> 为 <spanclass="math inline">\(n\)</span> 的质因数。</p><p>不同质因数的数量很少，就可以暴力set乱搞了。</p><div class="code-wrapper"><pre><code class="hljs C++">ll pri[<span class="hljs-number">30</span>];ll sum[<span class="hljs-number">30</span>][maxn], a[maxn]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n, q;    cin &gt;&gt; n &gt;&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) cin &gt;&gt; a[i];    ll tmp = n, h = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;tmp &gt; <span class="hljs-number">1</span>;i++) &#123;        <span class="hljs-keyword">if</span>(tmp % i == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">while</span>(tmp % i == <span class="hljs-number">0</span>) tmp /= i;            pri[++h] = i;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= n;j++) sum[h][j] = <span class="hljs-number">0</span>;            <span class="hljs-type">int</span> d = n / i;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++) &#123;                sum[h][j % d] += a[j];              &#125;        &#125;    &#125;    multiset&lt;ll&gt; st[h + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= h;i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n / pri[i];j++) &#123;            st[i].<span class="hljs-built_in">insert</span>(sum[i][j]);        &#125;    &#125;    ll ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= h;i++) ans = <span class="hljs-built_in">max</span>(ans, *(st[i].<span class="hljs-built_in">rbegin</span>()) * n / pri[i]);    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    <span class="hljs-keyword">while</span>(q-- &gt; <span class="hljs-number">0</span>) &#123;        ll x, y; cin &gt;&gt; x &gt;&gt; y;        ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= h;i++) &#123;            ll d = n / pri[i];            st[i].<span class="hljs-built_in">erase</span>(st[i].<span class="hljs-built_in">find</span>(sum[i][x % d]));            sum[i][x % d] += -a[x] + y;            st[i].<span class="hljs-built_in">insert</span>(sum[i][x % d]);            ans = <span class="hljs-built_in">max</span>(ans, *(st[i].<span class="hljs-built_in">rbegin</span>()) * d);        &#125;        a[x] = y;        cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简易对拍器</title>
    <link href="/2022/08/10/%E7%8E%A9%E5%85%B7/%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D%E5%99%A8/"/>
    <url>/2022/08/10/%E7%8E%A9%E5%85%B7/%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="github项目地址"><ahref="https://github.com/lxtyin/SimpleComparator">Github项目地址</a></h4><p>2021/9/23</p><h4 id="环境需求">环境需求</h4><ul><li><p>仅支持windows</p></li><li><p>装有MinGW并且添加到环境变量（使用g++编译）</p></li></ul><h4 id="用法">用法</h4><ol type="1"><li>将两份程序（一般是你的不知道哪错了的程序和标答/暴力解）扔进<code>program1.cpp</code>和<code>program2.cpp</code></li><li>在<code>generator.cpp</code>里写随机输入数据生成器，对应你的这道题目</li><li>双击<code>run.bat</code>运行，输入希望对拍的次数，等待对拍结果</li></ol><p>对拍结果完全一样显示 <strong>[Accepted]</strong></p><p>不同则会显示 <strong>[Wrong Answer]</strong></p><p>有不同时，会同时显示使两份程序结果不一样的数据，你就可以复制拿去debug了</p><p>同时所有结果都会保存在<code>result.txt</code>里，关掉控制台后仍然可以查看</p><p><img src="http://lxtyin.ac.cn/img/simplecomparator/1.png" /></p><h3 id="更新">2022/8/10更新</h3><ul><li><p>改了部分文件名，<code>constructor</code>被改成了<code>generator</code>，其他变更不影响使用</p></li><li><p>默认对比方式已忽略行末空格和回车。</p></li><li><p>现已支持special judge</p></li></ul><p>用法：同样方法放入程序和编写数据生成器之后，还需在<code>work/special_judge.cpp</code> 中编写spj</p><p>spj必须包含头文件<code>judge.h</code>，这个头文件提供了一些基础的api。</p><p>引用头文件后，你可以使用三个输入流，它们都为 ifstream。</p><p><code>inp</code> 从本组的输入数据中读取</p><p><code>ans1</code> 从 <code>program1</code> 的输出数据中读取</p><p><code>ans2</code> 从 <code>program2</code> 的输出数据中读取</p><p>判题之后，你需要给出评测结果，<code>judge.h</code>提供了以下api，建议使用：</p><ul><li><p><code>AC();</code> 给出正确提示</p></li><li><p><code>WA();</code> 给出错误提示</p></li><li><p><code>display();</code> 显示数据，建议在答案错误时显示</p></li><li><p><code>color(int x);</code> 更改字体颜色，具体颜色对应值如下：<imgsrc="https://ask.qcloudimg.com/http-save/yehe-7873581/mg9ppffbb6.png?imageView2/2/w/1620" /></p></li><li><p><code>hint(const string &amp;s);</code>以黄色字体给出提示信息</p></li><li><p><code>warn(const string &amp;s);</code>以红色字体给出提示信息</p></li></ul><p>当然你也可以自由使用 <code>cout/printf</code> 等方式输出。</p><p>例如，下面是一个判断精度是否在 <code>1e-6</code> 以内spj</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;judge.h&quot;</span></span><span class="hljs-comment">// sample spj for accuracy within 1e-6</span><span class="hljs-comment">// input data can be read by inp(ifstream)</span><span class="hljs-comment">// program1 output can be read by ans1(ifstream), so as ans2.</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">double</span> as1, as2;    ans1 &gt;&gt; as1;    ans2 &gt;&gt; as2;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(as1 - as2) / as2 &lt; <span class="hljs-number">1e-6</span>) <span class="hljs-built_in">AC</span>();    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">WA</span>();        <span class="hljs-built_in">display</span>();        <span class="hljs-built_in">color</span>(YELLOW);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The accuracy is %.10f\n&quot;</span>, <span class="hljs-built_in">abs</span>(as1 - as2) / as2);        <span class="hljs-built_in">color</span>(WHITE);    &#125;    inp.<span class="hljs-built_in">close</span>();    ans1.<span class="hljs-built_in">close</span>();    ans2.<span class="hljs-built_in">close</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>效果如下：</p><p><img src="http://lxtyin.ac.cn/img/simplecomparator/2.png" /></p>]]></content>
    
    
    <categories>
      
      <category>玩具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>小项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 810 div.1 ABC</title>
    <link href="/2022/07/26/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20810%20div1%20ABC/"/>
    <url>/2022/07/26/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20810%20div1%20ABC/</url>
    
    <content type="html"><![CDATA[<h4 id="a.-color-the-picture"><ahref="https://codeforces.com/contest/1710/problem/A">A. Color thePicture</a></h4><p>观察发现同一个颜色必须呈整行或整列才能满足条件，且至少需要连续两行，计算一下每个颜色最多可以涂几行/列即可，特判奇数行/列时，所有颜色都仅能涂2行/列的情况。</p><div class="code-wrapper"><pre><code class="hljs C++">ll n, m, k;ll a[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=k;i++) cin &gt;&gt; a[i];    ll s = <span class="hljs-number">0</span>;    <span class="hljs-type">bool</span> fg = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;        ll d = a[i] / n;        <span class="hljs-keyword">if</span>(d &gt; <span class="hljs-number">1</span>) s += d;        <span class="hljs-keyword">if</span>(d &gt; <span class="hljs-number">2</span>) fg = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">if</span>((fg || m % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &amp;&amp; s &gt;= m)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    s = <span class="hljs-number">0</span>;    fg = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;        ll d = a[i] / m;        <span class="hljs-keyword">if</span>(d &gt; <span class="hljs-number">1</span>) s += d;        <span class="hljs-keyword">if</span>(d &gt; <span class="hljs-number">2</span>) fg = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">if</span>((fg || n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &amp;&amp; s &gt;= n)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;&#125;</code></pre></div><h4 id="b.-rain"><ahref="https://codeforces.com/contest/1710/problem/B">B. Rain</a></h4><p>首先预处理出每个位置上降水量的总值（离散化差分或数据结构），然后将所有降水按照左端点排序，枚举每个位置<span class="math inline">\(x\)</span>，二分找出第一个删除之后，不能使得 <span class="math inline">\(x\)</span>处降水量少于m的位置，显然这个点右侧的全都不合法。</p><p>同理再按照右端点排序搞一次，就把所有不合法的点筛去了。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;    ll x, p;    ll id;    ll sum;&#125;a[maxn], b[maxn]; ll n, m;map&lt;ll, ll&gt; d2;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    d2.<span class="hljs-built_in">clear</span>();    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        a[i].id = i;        cin &gt;&gt; a[i].x &gt;&gt; a[i].p;        d2[a[i].x-a[i].p+<span class="hljs-number">1</span>] += <span class="hljs-number">1</span>;        d2[a[i].x+<span class="hljs-number">1</span>] -= <span class="hljs-number">2</span>;        d2[a[i].x+a[i].p+<span class="hljs-number">1</span>] += <span class="hljs-number">1</span>;    &#125;    ll sum = <span class="hljs-number">0</span>;    vector&lt;pair&lt;ll, ll&gt;&gt; d11;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [p, c]: d2)&#123;        sum += c;        d11.<span class="hljs-built_in">emplace_back</span>(p, sum);    &#125;    sum = <span class="hljs-number">0</span>;    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+n+<span class="hljs-number">1</span>, [](node x, node y)&#123;        <span class="hljs-keyword">return</span> x.x &lt; y.x;    &#125;);    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">0</span>, j=<span class="hljs-number">1</span>;i&lt;d11.<span class="hljs-built_in">size</span>();i++)&#123;        <span class="hljs-keyword">while</span>(j &lt;= n &amp;&amp; d11[i].first &gt; a[j].x)&#123;            a[j].sum = sum + d11[i<span class="hljs-number">-1</span>].second * (a[j].x - d11[i<span class="hljs-number">-1</span>].first);            j++;        &#125;        sum += d11[i].second;        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>) sum += d11[i<span class="hljs-number">-1</span>].second * (d11[i].first - d11[i<span class="hljs-number">-1</span>].first - <span class="hljs-number">1</span>);        <span class="hljs-keyword">while</span>(j &lt;= n &amp;&amp; d11[i].first == a[j].x)&#123;            a[j].sum = sum;            j++;        &#125;    &#125;     <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+n+<span class="hljs-number">1</span>, [](node x, node y)&#123;        <span class="hljs-keyword">return</span> x.x - x.p + <span class="hljs-number">1</span> &lt; y.x - y.p + <span class="hljs-number">1</span>;    &#125;);    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++) b[i] = a[i];    <span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>, b+n+<span class="hljs-number">1</span>, [](node x, node y)&#123;        <span class="hljs-keyword">return</span> x.x + x.p - <span class="hljs-number">1</span> &lt; y.x + y.p - <span class="hljs-number">1</span>;    &#125;);     <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;    ll midel = <span class="hljs-number">1e9</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(a[i].sum &lt;= m) <span class="hljs-keyword">continue</span>;        ll d = a[i].sum - m;        ll p = <span class="hljs-built_in">lower_bound</span>(a+<span class="hljs-number">1</span>, a+n+<span class="hljs-number">1</span>, a[i].x - d + <span class="hljs-number">1</span>, [&amp;](node a, ll pos)&#123;            <span class="hljs-keyword">return</span> a.x - a.p + <span class="hljs-number">1</span> &lt;= pos;        &#125;) - a;        midel = <span class="hljs-built_in">min</span>(midel, p);    &#125;    <span class="hljs-keyword">for</span>(ll i=midel;i&lt;=n;i++) ans[a[i].id] = <span class="hljs-number">0</span>;     ll mxdel = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(b[i].sum &lt;= m) <span class="hljs-keyword">continue</span>;        ll d = b[i].sum - m;        ll p = <span class="hljs-built_in">lower_bound</span>(b+<span class="hljs-number">1</span>, b+n+<span class="hljs-number">1</span>, b[i].x+d<span class="hljs-number">-1</span>, [&amp;](node a, ll pos)&#123;            <span class="hljs-keyword">return</span> a.x + a.p - <span class="hljs-number">1</span> &lt; pos;        &#125;) - b;        mxdel = <span class="hljs-built_in">max</span>(mxdel, p<span class="hljs-number">-1</span>);    &#125;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=mxdel;i++) ans[b[i].id] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout &lt;&lt; ans[i];    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="c.-xor-triangle"><ahref="https://codeforces.com/contest/1710/problem/C">C. XORTriangle</a></h4><p>新的一种bitmask技巧：</p><p>设 <spanclass="math inline">\(cnt_{i,j,k}\)</span>，定义是这样的：</p><p>当 <span class="math inline">\(a,b,c\)</span> 的第 <spanclass="math inline">\(x\)</span> 位分别为 <spanclass="math inline">\(i,j,k\)</span> 时，<spanclass="math inline">\(cnt_{i,j,k}\)</span> 就在 <spanclass="math inline">\(x\)</span> 位上为1，否则为0</p><p>例如对于下面的 <span class="math inline">\(a,b,c\)</span>，有如下<span class="math inline">\(cnt\)</span>： <span class="math display">\[cnt[011]:&amp;10000001\\a&amp;01010010\\b&amp;10010101\\c&amp;10111001\]</span> 即仅有 <span class="math inline">\(abc=011\)</span>的位置，<span class="math inline">\(cnt_{011}\)</span> 才为1</p><p>有了这种 <span class="math inline">\(cnt\)</span>数组，就可以推断出一些东西：</p><p><span class="math inline">\(a=\sum\sum cnt_{1jk}\)</span>（<spanclass="math inline">\(a\)</span> 中所有的 <spanclass="math inline">\(1\)</span> 不重复不遗漏的加起来）</p><p><span class="math inline">\(b=\sum\sum cnt_{i1k}\)</span></p><p><span class="math inline">\(a\bigoplus b=\sum cnt_{01k}+\sumcnt_{10k}\)</span></p><p>简单推断可得，题目的条件等价于：<spanclass="math inline">\(cnt_{001}+cnt_{110}&gt;0\)</span>，<spanclass="math inline">\(cnt_{011}+cnt_{100}&gt;0\)</span>，<spanclass="math inline">\(cnt_{010}+cnt_{101}&gt;0\)</span></p><p>设 <span class="math inline">\(dp[i][j][k]\)</span> 为前 <spanclass="math inline">\(i\)</span> 位，上限状态为 <spanclass="math inline">\(j\)</span>，<spanclass="math inline">\(cnt\)</span> 状态为 <spanclass="math inline">\(k\)</span> 的方案数</p><p><span class="math inline">\(j\)</span> 用三位表示 <spanclass="math inline">\(a,b,c\)</span> 三个数是否达到了上限，<spanclass="math inline">\(k\)</span> 用三位表示上述三组 <spanclass="math inline">\(cnt\)</span> 是否已经大于0，转移复杂度为 <spanclass="math inline">\(O(8^3n)\)</span></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">subset</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    <span class="hljs-type">int</span> k = x;    vector&lt;<span class="hljs-type">int</span>&gt; r;    <span class="hljs-keyword">while</span>(k &gt; <span class="hljs-number">0</span>)&#123;        r.<span class="hljs-built_in">push_back</span>(k);        k = (k - <span class="hljs-number">1</span>) &amp; x;    &#125;    r.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> r;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    string s;    cin &gt;&gt; s;    <span class="hljs-function">vector <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">8</span>, vector&lt;ll&gt;(<span class="hljs-number">8</span>, <span class="hljs-number">0</span>))</span></span>;    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: s)&#123;        <span class="hljs-type">int</span> curlim = (c == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">7</span>);        <span class="hljs-function">vector <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-number">8</span>, vector&lt;ll&gt;(<span class="hljs-number">8</span>, <span class="hljs-number">0</span>))</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> lim = <span class="hljs-number">0</span>; lim &lt; <span class="hljs-number">8</span>; lim++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> frm = <span class="hljs-number">0</span>; frm &lt; <span class="hljs-number">8</span>; frm++)&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> st: <span class="hljs-built_in">subset</span>(lim | curlim))&#123;                    <span class="hljs-type">int</span> nt = frm;                    <span class="hljs-keyword">if</span>(st == <span class="hljs-number">1</span> || st == <span class="hljs-number">6</span>)&#123;                        nt |= <span class="hljs-number">1</span>;                    &#125;                    <span class="hljs-keyword">if</span>(st == <span class="hljs-number">2</span> || st == <span class="hljs-number">5</span>)&#123;                        nt |= <span class="hljs-number">2</span>;                    &#125;                    <span class="hljs-keyword">if</span>(st == <span class="hljs-number">3</span> || st == <span class="hljs-number">4</span>)&#123;                        nt |= <span class="hljs-number">4</span>;                    &#125;                    (g[lim | (st ^ curlim)][nt] += f[lim][frm]) %= mode;                &#125;            &#125;        &#125;        f = g;    &#125;    ll ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) (ans += f[i][<span class="hljs-number">7</span>]) %= mode;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 131 D-F</title>
    <link href="/2022/07/09/%E9%A2%98%E8%A7%A3/Educational%20Codeforces%20Round%20131/"/>
    <url>/2022/07/09/%E9%A2%98%E8%A7%A3/Educational%20Codeforces%20Round%20131/</url>
    
    <content type="html"><![CDATA[<h4 id="d.-permutation-restoration">D. Permutation Restoration</h4><blockquote><p>题意：原先有一个排列 <spanclass="math inline">\(a(1...n)\)</span>，令 <spanclass="math inline">\(b_i=\lfloor i/a_i \rfloor\)</span>。现在给出序列<span class="math inline">\(b\)</span>，要恢复排列 <spanclass="math inline">\(a\)</span></p></blockquote><p>首先可以根据 <span class="math inline">\(b_i\)</span> 得出 <spanclass="math inline">\(a_i\)</span> 的范围是 <spanclass="math inline">\((i/(b_i+1), i/b_i]\)</span>，由此得到了每个 <spanclass="math inline">\(a_i\)</span> 的取值区间，接下来要将 <spanclass="math inline">\(1-n\)</span> 分配给他们。</p><p>可以先按照区间的右端排序，按右端从小到大依次去取<strong>尽可能小的数</strong>，正确性显然。</p><p>取尽可能小的数可以用并查集。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m, f[maxn], ans[maxn];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x == f[x]) <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> f[x] = <span class="hljs-built_in">find</span>(f[x]);&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;    <span class="hljs-type">int</span> l, r, id;&#125;a[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        <span class="hljs-type">int</span> x; cin &gt;&gt; x;        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>) &#123;            a[i] = &#123;i + <span class="hljs-number">1</span>, n, i&#125;;        &#125; <span class="hljs-keyword">else</span> &#123;            a[i] = &#123;i / (x + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>, i / x, i&#125;;        &#125;    &#125;    <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>, [](node i, node j) &#123;<span class="hljs-keyword">return</span> i.r &lt; j.r;&#125;);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) f[i] = i;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(a[i].l);        ans[a[i].id] = t;        f[t] = t + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;</code></pre></div><h4 id="e.-text-editor">E. Text Editor</h4><blockquote><p>题意：给出字符串 <span class="math inline">\(s_1\)</span> 和 <spanclass="math inline">\(s_2\)</span>，初始光标在 <spanclass="math inline">\(s_1\)</span>最后一个字符的右边，每次操作可以：</p><ul><li>将光标左移或右移一位</li><li>删除光标左侧字符</li><li>将光标移动到最前面（第一个字符左边）或最后面</li></ul><p>问最少多少次操作可以使 <span class="math inline">\(s_1\)</span> 变成<span class="math inline">\(s_2\)</span></p></blockquote><p>要将 <span class="math inline">\(s_1\)</span> 变成 <spanclass="math inline">\(s_2\)</span>只需要将多余字符删去即可，不难发现，从右往左边移动光标的同时可以顺带删除，而从左往右移动时，删除字符需要额外的一步操作。</p><p>显然我们不会反复进行操作3，可以将操作分为两段：先向左移删除一些字符，再跳到最前面向右移删除一些字符。</p><p>缩减操作次数主要靠两部分：尽量在左移时删除，和在中间保留一段无需访问的已经匹配上的子串。</p><p>解法：枚举从左向右移动的终点 <spanclass="math inline">\(i\)</span>，同时维护前 <spanclass="math inline">\(i\)</span> 个字符能匹配的最大长度 <spanclass="math inline">\(j\)</span>，那么前 <spanclass="math inline">\(i\)</span> 个字符可以任意选择匹配 <spanclass="math inline">\(s_2\)</span> 的前 <spanclass="math inline">\(1...j\)</span> 个字符。</p><p>假设选择匹配了前 <span class="math inline">\(x\)</span> 个，那么从<span class="math inline">\(s_2[x+1]\)</span> 和 <spanclass="math inline">\(s_1[i+1]\)</span>开始如果能匹配若干个字符，这些字符是无需访问的；剩下的就都是从右向左移动的部分了。</p><p>用 <span class="math inline">\(i + i - k + n - (i + f_{i+1, k+1}) +1\)</span> 更新答案，其中 <span class="math inline">\(f_{i, j}\)</span>表示 <span class="math inline">\(s_1[i..]\)</span> 和 <spanclass="math inline">\(s_2[j..]\)</span> 的最长公共前缀。</p><p>提前 <span class="math inline">\(dp\)</span> 预处理 <spanclass="math inline">\(f_{i,j}\)</span> 即可。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;string s1, s2;<span class="hljs-type">int</span> f[<span class="hljs-number">5003</span>][<span class="hljs-number">5003</span>]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n &gt;&gt; m;    cin &gt;&gt; s1 &gt;&gt; s2;    s1 = <span class="hljs-string">&#x27; &#x27;</span> + s1;    s2 = <span class="hljs-string">&#x27; &#x27;</span> + s2;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        <span class="hljs-keyword">if</span>(s1[i] == s2[j]) j++;        <span class="hljs-keyword">if</span>(i == n &amp;&amp; j &lt;= m) &#123;            cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= <span class="hljs-built_in">max</span>(n, m) + <span class="hljs-number">1</span>;i++) f[i][m + <span class="hljs-number">1</span>] = f[n + <span class="hljs-number">1</span>][i] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n;i &gt; <span class="hljs-number">0</span>;i--) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m;j &gt; <span class="hljs-number">0</span>;j--) &#123;            <span class="hljs-keyword">if</span>(s1[i] == s2[j]) f[i][j] = f[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> f[i][j] = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-type">int</span> ans = n - f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;i &lt;= n;i++) &#123;        <span class="hljs-keyword">if</span>(s1[i] == s2[j + <span class="hljs-number">1</span>]) j++;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k &lt;= j;k++) &#123;            ans = <span class="hljs-built_in">min</span>(ans, i + i - k + n - (i + f[i + <span class="hljs-number">1</span>][k + <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>);        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="f.-points">F. Points</h4><blockquote><p>题意：<span class="math inline">\(x\)</span>轴上有若干个点，任意三个点若满足 <spanclass="math inline">\(i&lt;j&lt;k\)</span> 且 <spanclass="math inline">\(k-i\le d\)</span>，则它是一个优美的元组。</p><p>接下来将在空数轴上进行若干次操作，每次选取一个整数位置 <spanclass="math inline">\(x\)</span>，若上面有点则将其删去，否则在此处添加点。</p><p>每次操作完成后要输出优美元组的总数，点的位置 <spanclass="math inline">\(\le2\times 10^5\)</span></p></blockquote><p>学习了t宝的神奇线段树。</p><p>不难想的部分：</p><p>每当在 <span class="math inline">\(x\)</span>这个位置上操作，就查找区间 <span class="math inline">\([x-d,x-1]\)</span> 和 <span class="math inline">\([x+1, x+d]\)</span>上点的个数，分别计算以 <span class="math inline">\(x\)</span>为左、右端点的元组个数。</p><p>比较麻烦的是 <span class="math inline">\(x\)</span>作为中间的元组数。</p><p>t宝的线段树维护了区间的这些内容：</p><ul><li>区间点个数（设为 <span class="math inline">\(cr\)</span>）</li><li>向左移 <span class="math inline">\(d\)</span> 的区间中点的个数（设为<span class="math inline">\(cl\)</span>）</li><li>跨这两段区间，距离在 <span class="math inline">\(d\)</span>以内的点对个数（设为 <span class="math inline">\(sp\)</span>）。</li></ul><p>第三个即我们需要的信息，维护它：</p><p>对单个点来说 <span class="math inline">\(sp=cl\times cr\)</span></p><p>合并 <span class="math inline">\(a,b\)</span> 两个区间（<spanclass="math inline">\(a\)</span> 在左）时，<spanclass="math inline">\(sp=sp_a+sp_b+cr_a\times cl_b\)</span></p><p>画图看一下就明白了：合并的时候新产生的 <spanclass="math inline">\(sp\)</span>只能是右边的左块和左边的右块之间的点对，其他的距离都在 <spanclass="math inline">\(d\)</span> 以上。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, d;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;    ll cr, cl, sp;    <span class="hljs-function">node <span class="hljs-title">merge</span><span class="hljs-params">(node x)</span> </span>&#123;        <span class="hljs-keyword">return</span> &#123;cr + x.cr, cl + x.cl, sp + x.sp + cr * x.cl&#125;;    &#125;&#125;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">segTree</span> &#123;    node t[maxn &lt;&lt; <span class="hljs-number">4</span>];    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        t[p] = t[p * <span class="hljs-number">2</span>].<span class="hljs-built_in">merge</span>(t[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> adl, <span class="hljs-type">int</span> adr)</span> </span>&#123;        <span class="hljs-keyword">if</span>(l == r) &#123;            t[p].cl += adl;            t[p].cr += adr;            t[p].sp = t[p].cl * t[p].cr;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(pos &lt;= mid) <span class="hljs-built_in">modify</span>(p * <span class="hljs-number">2</span>, l, mid, pos, adl, adr);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, pos, adl, adr);        <span class="hljs-built_in">push_up</span>(p);    &#125;    <span class="hljs-function">node <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;        <span class="hljs-keyword">if</span>(l &gt; R || L &gt; r) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;        <span class="hljs-keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> t[p];        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        node res = <span class="hljs-built_in">query</span>(p * <span class="hljs-number">2</span>, l, mid, L, R);        res = res.<span class="hljs-built_in">merge</span>(<span class="hljs-built_in">query</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R));        <span class="hljs-keyword">return</span> res;    &#125;    &#125;segt; <span class="hljs-type">int</span> st[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n &gt;&gt; d;    ll ans = <span class="hljs-number">0</span>, mx = <span class="hljs-number">400000</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        <span class="hljs-type">int</span> x; cin &gt;&gt; x;        <span class="hljs-type">int</span> f = st[x] ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;        st[x] ^= <span class="hljs-number">1</span>;        ll r = segt.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, mx, x + <span class="hljs-number">1</span>, x + d).cr;        ll l = segt.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, mx, x - d, x - <span class="hljs-number">1</span>).cr;        ans += (r * (r - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + l * (l - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) * f;        <span class="hljs-keyword">if</span>(d &gt; <span class="hljs-number">1</span>) ans += segt.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, mx, x + <span class="hljs-number">1</span>, x + d - <span class="hljs-number">1</span>).sp * f;        segt.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, mx, x, <span class="hljs-number">0</span>, f);        segt.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, mx, x + d, f, <span class="hljs-number">0</span>);        cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Global Round 20 A-F,H</title>
    <link href="/2022/04/23/%E9%A2%98%E8%A7%A3/Codeforces%20Global%20Round%2020%20A-F1,H/"/>
    <url>/2022/04/23/%E9%A2%98%E8%A7%A3/Codeforces%20Global%20Round%2020%20A-F1,H/</url>
    
    <content type="html"><![CDATA[<p>连续一个月掉小分，这把终于上大分了 好耶！</p><h4 id="a.-log-chopping">A. Log Chopping</h4><blockquote><p>题意：现在有 <span class="math inline">\(n\)</span> 个木棍，第 <spanclass="math inline">\(i\)</span> 根长度为 <spanclass="math inline">\(a_i\)</span>，Alice和Bob两人轮流操作，可以选择一根木棍将其切成两半，且两半的长度都需要是&gt;1的整数。最后无法操作的人失败，问谁获胜。</p></blockquote><p>虚假博弈，显然能切的次数是固定的，最终会全变成长度为1的木棍，判断能切的奇偶性即可。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> x; cin &gt;&gt; x;        sum += x - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-string">&quot;errorgorn\n&quot;</span>;    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;maomao90\n&quot;</span>;&#125;</code></pre></div><h4 id="b.-i-love-aaab">B. I love AAAB</h4><blockquote><p>题意：你有一个字符串（初始为空），操作：可以在其中任意位置插入一段形如"AA...AB"的字符串，A的数量至少为1。给定目标串b，问操作任意次，能否构造出串b。</p></blockquote><p>类似括号序，出现一个B时前面要至少找到一个A与其匹配，那么从左到右扫一遍，将A视为1，B视为-1，看有无前缀和小于0即可。注意特判：不存在B也是不行的。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    string s;    cin &gt;&gt; s;    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;A&#x27;</span>) sum++;        <span class="hljs-keyword">else</span> sum--;        <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>)&#123;            cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">back</span>() != <span class="hljs-string">&#x27;B&#x27;</span>)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;&#125;</code></pre></div><h4 id="c.-unequal-array">C. Unequal Array</h4><blockquote><p>题意：给出一个序列 <spanclass="math inline">\(a\)</span>，其质量定义为其中 <spanclass="math inline">\(a_i=a_{i+1}\)</span>的元素个数，现在你可以进行操作：选取两个相邻元素，将它们修改为任意的<spanclass="math inline">\(x\)</span>。问：最少多少次操作可以使得序列的"质量"小于等于1</p></blockquote><p>不难发现，执行这个操作只能改变本来满足的 <spanclass="math inline">\(a_i=a_{i+1}\)</span>的位置移动，而无法直接消除。那么我们找到原序列最早和最晚出现的相邻点，只有将这两对相邻点不断逼近后合为一对，才能满足条件。那么答案即为这两对相邻点之间的距离（注意边界和0）</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-type">int</span> mi = <span class="hljs-number">0</span>, mx = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-keyword">if</span>(a[i] == a[i+<span class="hljs-number">1</span>])&#123;            <span class="hljs-keyword">if</span>(!mi) mi = i;            mx = i;        &#125;    &#125;    <span class="hljs-keyword">if</span>(mx == mi) cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-built_in">max</span>(mx-mi<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="d.-cyclic-rotation">D. Cyclic Rotation</h4><blockquote><p>题意：给出一个序列 <span class="math inline">\(a\)</span>和它的重新排列 <spanclass="math inline">\(b\)</span>，有一种操作：选取两个相同元素，将左边的移动到另一个右边。问能否对序列<span class="math inline">\(a\)</span> 进行任意次操作，使其变为 <spanclass="math inline">\(b\)</span>？</p></blockquote><p>模拟，我们从最末端开始考虑，<span class="math inline">\(a\)</span> 和<span class="math inline">\(b\)</span>的末尾元素必须相同，设他们末尾都为 <spanclass="math inline">\(x\)</span>， <spanclass="math inline">\(a\)</span> 末尾连续的 <spanclass="math inline">\(x\)</span> 数量必须少于 <spanclass="math inline">\(b\)</span> 末尾连续 <spanclass="math inline">\(x\)</span> 的数量。这样才有可能从 <spanclass="math inline">\(a\)</span> 前面拿若干个 <spanclass="math inline">\(x\)</span>到末尾来使得他们末尾。记录每种数被拿的次数。考虑完后，将他们末尾的 <spanclass="math inline">\(x\)</span> 都删掉，继续处理下一个末尾。</p><p>遇到 <span class="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 末尾不相同时，如果 <spanclass="math inline">\(a\)</span> 的末尾恰好”被拿过“，就可以忽略 <spanclass="math inline">\(a\)</span>中这个末尾，记得让计数-1。如果没有被拿过，那么NO</p><p>还有一点：当 <span class="math inline">\(a\)</span> 的末尾连续 <spanclass="math inline">\(x\)</span> 长度大于 <spanclass="math inline">\(b\)</span> 末尾连续 <spanclass="math inline">\(x\)</span> 长度时，如果 <spanclass="math inline">\(x\)</span>可以被拿走一些也是可行的，不用直接NO。</p><p>这样模拟能执行到最后就是YES</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn], b[maxn];<span class="hljs-type">int</span> rem[maxn], del[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) rem[i] = del[i] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i], rem[a[i]]++;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; b[i], tmp[b[i]]++;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">if</span>(tmp[i] != rem[i])&#123;        cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-type">int</span> r1 = n, j = n;    <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">while</span>(a[r1] != b[j])&#123;            <span class="hljs-keyword">if</span>(r1&gt;<span class="hljs-number">0</span> &amp;&amp; del[a[r1]]) del[a[r1]]--, r1--;            <span class="hljs-keyword">else</span>&#123;                cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;        &#125;        <span class="hljs-type">int</span> lena = <span class="hljs-number">1</span>, lenb = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=r1<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;            <span class="hljs-keyword">if</span>(a[i] != a[r1])&#123;                lena = r1 - i;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=j<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;            <span class="hljs-keyword">if</span>(b[i] != b[j])&#123;                lenb = j - i;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(lena &gt; lenb)&#123;            <span class="hljs-keyword">if</span>(lena - del[a[r1]] &gt; lenb)&#123;                cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;            del[a[r1]] -= lena - lenb;            r1 -= lena;            j -= lenb;        &#125;<span class="hljs-keyword">else</span>&#123;            del[a[r1]] += lenb - lena;            r1 -= lena;            j -= lenb;        &#125;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;&#125;</code></pre></div><h4 id="e.-notepad.exe">E. notepad.exe</h4><blockquote><p>题意：交互题，有一台打字机和若干个字符串，这些字符串是未知的，你可以指定最大打印宽度<spanclass="math inline">\(w\)</span>，打印机将按顺序打印这些字符串，两串之间需要一个空格，当行宽度不够即会换行，最终会返回你打印的行数<span class="math inline">\(h\)</span>。你需要用至多 <spanclass="math inline">\(n+30\)</span>次询问，输出可能的最小打印面积（<span class="math inline">\(w\timesh\)</span>）</p></blockquote><p>首先容易想到的是，可以二分找到一行能打下所有字符串的最小宽度 <spanclass="math inline">\(w_1\)</span>，此时最小打印面积为<code>字符串总长+n-1个空格</code></p><p>然后去想，如果要打印两行使得答案更优，那么这个字符串必须差不多能正好分成等长的两半，这样就能贪一个空格。只需要尝试<span class="math inline">\(\lfloor w_1/2\rfloor\)</span>的宽度即可，宽度更大则不可能更优，更小则不可能两行打印完。</p><p>同理，尝试三行，四行...尝试第 <span class="math inline">\(i\)</span>行即询问宽度 <span class="math inline">\(\lfloorw_1/i\rfloor\)</span>，更新答案。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; x &lt;&lt; endl;    cout.<span class="hljs-built_in">flush</span>();    <span class="hljs-type">int</span> r; cin &gt;&gt; r;    <span class="hljs-keyword">return</span> r;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">4000000</span>;    <span class="hljs-keyword">while</span>(l &lt; r)&#123;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">query</span>(mid) == <span class="hljs-number">1</span>)&#123;            r = mid;        &#125;<span class="hljs-keyword">else</span>&#123;            l = mid+<span class="hljs-number">1</span>;        &#125;    &#125;    ll ans = l;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> h = <span class="hljs-built_in">query</span>(l / i);        <span class="hljs-keyword">if</span>(h == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;        ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-number">1ll</span> * h * (l / i));    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; ans &lt;&lt; endl;    cout.<span class="hljs-built_in">flush</span>();&#125;</code></pre></div><h4 id="f.-array-shuffling-checker-for-array-shuffling">F. ArrayShuffling &amp; Checker for Array Shuffling</h4><blockquote><p>题意：给出一个序列 <spanclass="math inline">\(a\)</span>，你需要将其打乱，使得其复原需要的最少交换次数尽可能多。</p><p>F1：构造一个打乱后的序列。</p><p>F2：给定打乱后的序列，判断其是否满足条件（写个spj）</p></blockquote><p>首先要将问题简化，注意到这题其实 <spanclass="math inline">\(a\)</span>的顺序是不影响打乱方案的（写代码的时候要管，但逻辑上不影响结果），我们可以将<span class="math inline">\(a\)</span> 中相同的元素都放在一起</p><p>再进一步，对于每一种元素，记录其出现的次数，将所有元素按照出现次数排序。每个元素都依次放到下一个元素的出现位置上（有空缺，先不管），最后一个元素去填补所有空缺。这样似乎能贪心地让序列尽可能乱。</p><p>严谨地考虑：假设我们有了打乱后的序列 <spanclass="math inline">\(b\)</span>，现在将每个 <spanclass="math inline">\(a_i\)</span> 向 <spanclass="math inline">\(b_i\)</span>连边，那么我们发现复原的过程其实是一个走环的过程（任何排列其实都构成若干个环，不过因为我们这里有重复元素，不是几个独立环的组合，但复原过程还是可以拆成走若干次环）</p><p>对于一个长度为 <span class="math inline">\(l\)</span>的环，将其复原到位需要 <span class="math inline">\(l-1\)</span>次，那么可以想到，环越少，复原需要的次数就越多。</p><p>假设出现次数最多的元素出现了 <span class="math inline">\(x\)</span>次，那么显然环不可能少于 <span class="math inline">\(x\)</span>个，上述构造方案恰恰可以令环数仅为 <spanclass="math inline">\(x\)</span>（即除了出现最多的那个元素涉及的环之外，不存在其他环）</p><p>F2就是这个结论，将最多的那个元素删去后，拓扑判断是否存在环即可。</p><p>F1：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">sss</span>&#123;    vector&lt;<span class="hljs-type">int</span>&gt; pos;    <span class="hljs-type">int</span> val;&#125;s[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) s[i].pos.<span class="hljs-built_in">clear</span>(), s[i].val = i;    <span class="hljs-type">int</span> mxa = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; a[i];        s[a[i]].pos.<span class="hljs-built_in">push_back</span>(i);    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;    <span class="hljs-built_in">sort</span>(s+<span class="hljs-number">1</span>, s+n+<span class="hljs-number">1</span>, [](sss x, sss y)&#123;        <span class="hljs-keyword">return</span> x.pos.<span class="hljs-built_in">size</span>() &lt; y.pos.<span class="hljs-built_in">size</span>();    &#125;);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-keyword">if</span>(s[i].pos.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;s[i].pos.<span class="hljs-built_in">size</span>();j++)&#123;            ans[s[i+<span class="hljs-number">1</span>].pos[j]] = s[i].val;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">if</span>(!ans[i]) ans[i] = s[n].val;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;</code></pre></div><p>F2：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn], b[maxn];<span class="hljs-type">int</span> cnt[maxn];<span class="hljs-type">int</span> mxp;vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cnt[i] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        vp[i].<span class="hljs-built_in">clear</span>();        cin &gt;&gt; a[i];        cnt[a[i]]++;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; b[i];    mxp = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">if</span>(cnt[i] &gt; cnt[mxp]) mxp = i;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">du</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(a[i] == mxp || b[i] == mxp) <span class="hljs-keyword">continue</span>;        vp[a[i]].<span class="hljs-built_in">push_back</span>(b[i]);        du[b[i]]++;    &#125;    queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">if</span>(du[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;        <span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>();        q.<span class="hljs-built_in">pop</span>();        ans++;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;            du[v]--;            <span class="hljs-keyword">if</span>(du[v] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(v);        &#125;    &#125;    <span class="hljs-keyword">if</span>(ans == n) cout &lt;&lt; <span class="hljs-string">&quot;AC\n&quot;</span>;    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;WA\n&quot;</span>;&#125;</code></pre></div><h4 id="h.-zigu-zagu">H. Zigu Zagu</h4><blockquote><p>题意：有一个01字符串，你可以操作：选择一段01交互出现的区间（不存在连续0或连续1），删去这个区间。有Q个询问，每次询问<span class="math inline">\(s[l..r]\)</span>这个子串需要最少几次操作使得其被删为空。</p></blockquote><p>贪心地考虑不难发现，一定删尽可能长的区间，我们可以首先把整串拆成几个可删的区间。</p><p>决策点在于：如果先删去中间的一个形如 <code>0...1</code> 或<code>1...0</code>的区间，就能使两端区间合并，从而减少删的次数。</p><p>我们用一个区间的结尾来标记（指代）这个区间，区间的开头即为上一个区间的结尾（不然上一个区间应该扩展）</p><p>比如我用 <code>01101</code>表示这样的一个整串：<code>..0 0..1 1..1 1..0 0..1</code></p><p>即当我删去一个1时，如果前一位为0，这个0会自动和下一位合并，相当于一同被删去。也就是说，我们有删1，删0，删01，删10这四种操作</p><p>那么删除需要的次数即为0和1中较多的那个数！</p><p>最后考虑一下边界即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> sum[maxn][<span class="hljs-number">2</span>];string s;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;    s = <span class="hljs-string">&#x27; &#x27;</span> + s;    s += s.<span class="hljs-built_in">back</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        sum[i][<span class="hljs-number">0</span>] = sum[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];        sum[i][<span class="hljs-number">1</span>] = sum[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span>(s[i] == s[i+<span class="hljs-number">1</span>]) sum[i][s[i]-<span class="hljs-string">&#x27;0&#x27;</span>]++;    &#125;    <span class="hljs-keyword">while</span>(m--)&#123;        <span class="hljs-type">int</span> l, r;        cin &gt;&gt; l &gt;&gt; r;        cout &lt;&lt; <span class="hljs-built_in">max</span>(sum[r<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]-sum[l<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], sum[r<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]-sum[l<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]) + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 783 div.1 ABC (div2.CDE)</title>
    <link href="/2022/04/20/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20783%20div1%20ABC/"/>
    <url>/2022/04/20/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20783%20div1%20ABC/</url>
    
    <content type="html"><![CDATA[<h4 id="a.-make-it-increasing">A. Make it Increasing</h4><blockquote><p>题意：给出一个整数序列 <spanclass="math inline">\(a\)</span>，现有另一个全为0的序列 <spanclass="math inline">\(b\)</span>，每次操作可以选取一个位置，使得 <spanclass="math inline">\(b_i\)</span> 加上或减去 <spanclass="math inline">\(a_i\)</span>，问最少多少次操作可以使得 <spanclass="math inline">\(b\)</span> 序列严格递增。数据范围 <spanclass="math inline">\(n\le10^3\)</span></p></blockquote><p>数据范围允许我们考虑 <spanclass="math inline">\(n^2\)</span>，首先可以贪心地想到，肯定会有一个位置保持为0，那么就可以枚举这个0的位置，然后往两边贪心即可。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;ll a[maxn], b[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    ll ans = <span class="hljs-number">1e18</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        ll sum = <span class="hljs-number">0</span>;        b[i] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">1</span>;j--)&#123;            ll k = <span class="hljs-built_in">abs</span>(b[j+<span class="hljs-number">1</span>]) / a[j] + <span class="hljs-number">1</span>;            sum += k;            b[j] = -k * a[j];        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;            ll k = <span class="hljs-built_in">abs</span>(b[j<span class="hljs-number">-1</span>]) / a[j] + <span class="hljs-number">1</span>;            sum += k;            b[j] = k * a[j];        &#125;        ans = <span class="hljs-built_in">min</span>(ans, sum);    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="b.-optimal-partition">B. Optimal Partition</h4><blockquote><p>题意：给出一个序列 <spanclass="math inline">\(a\)</span>，可以将其分成若干个连续的子区间，每个子区间的贡献是：</p><ul><li><span class="math inline">\(r−l+1\quad if s&gt;0,\)</span></li><li><span class="math inline">\(0\quad if s=0,\)</span></li><li><span class="math inline">\(−(r−l+1)\quad if s&lt;0.\)</span></li></ul><p>求总贡献的最小值</p></blockquote><p>考虑 <span class="math inline">\(dp\)</span>，<spanclass="math inline">\(dp_i\)</span> 表示前 <spanclass="math inline">\(i\)</span>个数的答案，它可以从几个方面转移过来：</p><ul><li>最后一段划分的区间和为负，它不优于将所有数单独拆出来，<spanclass="math inline">\(dp_i=dp_{i-1}+val_i\)</span></li><li>最后一段划分的区间和为0，其实仔细想一下会发现，肯定能把它拆成两半使得它更优：<ul><li>区间长度为偶数，划分为等长两段，一边大于0则另一边小于0，或者都等于0，显然不会更劣</li><li>区间长度为奇数，划分为左段（小一点）和右段，如果右段大于0则划分更优；如果右端小于0，则左段大于0，尝试将中间值挪到左段去，如果左段扔大于0则划分更优，否则左段小于0，则右端大于0，那么去掉中间值后，两边都大于0，显然还是更优的。</li><li>所以只需考虑单个数为0的情况，同样满足 <spanclass="math inline">\(dp_i=dp_{i-1}+val_i\)</span></li></ul></li><li>最后一段划分的区间和为正，那么 <spanclass="math inline">\(dp_i\)</span> 可以从若干个前面的 <spanclass="math inline">\(j\)</span> 转移过来，满足 <spanclass="math inline">\(val[j+1,i]\gt0\)</span>，有 <spanclass="math inline">\(dp_i=dp_j+i-j\)</span><ul><li>可以通过前缀和快速计算 <spanclass="math inline">\(val[j+1,i]\)</span>，我们用数据结构维护每个前缀和下的<span class="math inline">\(dp_j-j\)</span>的最大值，查询比当前前缀和小的所有前缀和下的 <spanclass="math inline">\(dp_j-j\)</span> 最大值即可转移</li><li>前缀和范围很大，可以提前预处理然后离散化</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn], f[maxn], rk[maxn];pair&lt;ll, <span class="hljs-type">int</span>&gt; sum[maxn];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">fwt</span>&#123;<span class="hljs-comment">//FenWick Tree</span>    <span class="hljs-type">int</span> t[maxn];    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> ad)</span></span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=p;i&lt;=n+<span class="hljs-number">1</span>;i+=i&amp;-i) t[i] = <span class="hljs-built_in">max</span>(t[i], ad);&#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mx</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;        <span class="hljs-type">int</span> r = <span class="hljs-number">-1e9</span>;        <span class="hljs-keyword">while</span>(p &gt; <span class="hljs-number">0</span>)&#123;            r = <span class="hljs-built_in">max</span>(r, t[p]);            p -= p &amp; -p;        &#125;        <span class="hljs-keyword">return</span> r;    &#125;&#125;bt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;i++) bt.t[i] = <span class="hljs-number">-1e9</span>;    sum[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; a[i];        sum[i] = &#123;sum[i<span class="hljs-number">-1</span>].first+a[i], i&#125;;    &#125;    <span class="hljs-built_in">sort</span>(sum, sum+n+<span class="hljs-number">1</span>);    <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || sum[i].first != sum[i<span class="hljs-number">-1</span>].first) ++tot;        rk[sum[i].second] = tot;    &#125;    bt.<span class="hljs-built_in">add</span>(rk[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        f[i] = f[i<span class="hljs-number">-1</span>] + (a[i] &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : a[i] &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);        f[i] = <span class="hljs-built_in">max</span>(f[i], bt.<span class="hljs-built_in">mx</span>(rk[i]<span class="hljs-number">-1</span>) + i);        bt.<span class="hljs-built_in">add</span>(rk[i], f[i] - i);    &#125;    cout &lt;&lt; f[n] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="c.-half-queen-cover">C. Half Queen Cover</h4><blockquote><p>题意：有一个 <span class="math inline">\(n\times n\)</span>的棋盘，棋子“半皇后”可以控制其同一排，同一列，同一左上-右下对角线上的所有格子，问最少多少个半皇后可以控制整个棋盘。</p></blockquote><p>构造题，单纯看结论会感到莫名其妙，不知思路从哪来</p><p>提供一种思考过程：想让棋子数量少，就需要尽可能减少棋子控制范围的重复，理想情况下应该有：每行仅有一个棋子，每列仅有一个棋子，每对角线也仅有一个棋子。即除了不可避免的交叉之外不重复。</p><p>接下来考虑这种理想情况能否实现，大概会摸出这样的图：</p><p><img src="img/bed/other/1.png" /></p><p>这里一共使用了5个棋子，发现中间区域还没能填满，那么就继续扩张，假设左上放置<span class="math inline">\(x\)</span> 个棋子，右下放置 <spanclass="math inline">\(y\)</span>个棋子，那么中间部分能占据的完整矩形范围为 <spanclass="math inline">\(max(x,y)\)</span>， 即 <spanclass="math inline">\(x+y+max(x,y)\ge n\)</span>，此时为最优解。</p><p>我们当然要让 <span class="math inline">\(x,y\)</span>之间差不超过1...</p><div class="code-wrapper"><pre><code class="hljs C++"></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022浙江省赛总结</title>
    <link href="/2022/04/16/%E6%9D%82%E8%B0%88/2022%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <url>/2022/04/16/%E6%9D%82%E8%B0%88/2022%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>好耶！</p><p><img src="http://lxtyin.ac.cn/img/other/gold.png" /></p><p>进大学第一把济南后 空间发了块铁锭，于是呼应一下</p><hr /><p>开局队友把三个签到题（ABC）都1A了，只有我写L先看假题愣了一会，又数组开小wa一发，然后忘记sort又wa一发，3A（或成为本场最高罚时）</p><p>这时榜上中间区域一片空白，于是开始找题做，先读D再读了E，跑过苦痛之路的我一眼读懂了E的题意，然而不会</p><p>然后队友喂了M题意，感觉是个恶心的模拟，但仔细一想发现其实只需要统计黑色块个数和白色块个数（中心的），然后列个方程解一下就可以了</p><p>G题第一眼是dp，仔细看了一下发现是个纯纯的最短路，但根本不记得朴素dij的存在，只知道<span class="math inline">\(mlogm\)</span>，感觉 <spanclass="math inline">\(10^6log10^6\)</span> + double运算 +1s时限有点顶，但是莽了一发就过了，赛后发现朴素dij可以非常稳的 <spanclass="math inline">\(n^2\)</span>，感觉是运气好数据造水了，这题应该能卡我们的。</p><p>然后两个人开始折磨I题，想了很多思路奇怪的思路，最后整合了一下发现偶数必败，那么只需要判一下初始为奇数时是否为回文串就可以了，多组询问，马拉车或者哈希预处理一下即可</p><p>最后是我和yfy啃F主席树磨细节，hty单挑J，轮流上机调/不会了打印/下机想，这个过程中我们采用了一个正确的策略：写伪代码。在纸上理清思路，上机的时候直接对着纸上写的抄，基本不卡，机时利用率很高。先后过掉这两个题，因为都卡了挺久，在纸上也造了一波数据，调出后都是1发A，最后9题收尾rk6</p><p>剩下十分钟时间在快乐的乱搞E题苦痛之路的随机化写法，当然没写过</p><hr /><p>去年省赛铜尾，差点没铜，被高中学弟暴打，今年有块金了，虽然只是省赛（而且zju放水），但看到了进步，还是很爽的</p><p>这场感受到了做题策略的重要性，如果还是之前那样，等一题a出来再写下一题，这场可能只有8题甚至7题。一来一个人占着机子一直调，未必比下来冷静一下想清楚再写快；二来避免了魔怔现象（前几场比赛我们都出现了一道题交十几发的现象，很大程度上是因为没有留充足的思考时间，写好了就交。如果是在纸上写伪代码的话，等队友写的过程中就很可能发现小bug，大大减小出错概率）</p><p>总结：团队acm竞赛当中想做到 1+1+1=4是基本不可能的，因为你们只有一台机器，事实上能做到1+1+1=2就已经相当不错，关键在于对机时的利用，一定要会写伪代码，等队友的时候把边界什么的想清楚，上机不浪费时间。然后写卡住了的时候迅速让出机位给队友写，同时自己下机去理清楚，争取下次上机一步到位。</p><p>然后在独立思考和讨论之间要做取舍，唯一的原则就是怎么清楚怎么来，大量讨论而少独立深思的话可能造成1+1+1=0.5的效果</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浙江省赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树剖/dsu on tree/线段树合并【雨天的尾巴】</title>
    <link href="/2022/04/13/%E9%A2%98%E8%A7%A3/%E9%9B%A8%E5%A4%A9%E7%9A%84%E5%B0%BE%E5%B7%B4/"/>
    <url>/2022/04/13/%E9%A2%98%E8%A7%A3/%E9%9B%A8%E5%A4%A9%E7%9A%84%E5%B0%BE%E5%B7%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="vani有约会雨天的尾巴">[Vani有约会]雨天的尾巴</h3><p><a href="https://www.luogu.com.cn/problem/P4556">题目链接</a></p><p>一道好板子 甚至能当三个板子（</p><h5 id="树链剖分">树链剖分</h5><div class="code-wrapper"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; add[maxn], del[maxn];vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];<span class="hljs-type">int</span> dep[maxn], siz[maxn], son[maxn];<span class="hljs-type">int</span> fat[maxn], top[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> dp)</span></span>&#123;    fat[p] = fa;    dep[p] = dp;    son[p] = <span class="hljs-number">0</span>;    siz[p] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">dfs1</span>(v, p, dp+<span class="hljs-number">1</span>);        siz[p] += siz[v];        <span class="hljs-keyword">if</span>(siz[v] &gt; siz[son[p]]) son[p] = v;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> _top)</span></span>&#123;    top[p] = _top;    <span class="hljs-keyword">if</span>(son[p]) <span class="hljs-built_in">dfs2</span>(son[p], p, _top);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v != fa &amp;&amp; v != son[p])&#123;            <span class="hljs-built_in">dfs2</span>(v, p, v);        &#125;    &#125;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">segTree</span>&#123;    <span class="hljs-type">int</span> mx[maxn &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;        mx[p] = <span class="hljs-built_in">max</span>(mx[p*<span class="hljs-number">2</span>], mx[p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> d)</span></span>&#123;        <span class="hljs-keyword">if</span>(l == r)&#123;            mx[p] += d;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(pos &lt;= mid) <span class="hljs-built_in">modify</span>(p*<span class="hljs-number">2</span>, l, mid, pos, d);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r, pos, d);        <span class="hljs-built_in">pushUp</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;        <span class="hljs-keyword">if</span>(mx[p] &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> l;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(mx[p*<span class="hljs-number">2</span>] &gt;= mx[p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(p*<span class="hljs-number">2</span>, l, mid);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r);    &#125;&#125;st;<span class="hljs-type">int</span> n, q;<span class="hljs-type">int</span> ans[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calcu</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w: add[p]) st.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>, w, <span class="hljs-number">1</span>);    ans[p] = st.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w: del[p]) st.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>, w, <span class="hljs-number">-1</span>);    <span class="hljs-keyword">if</span>(son[p]) <span class="hljs-built_in">calcu</span>(son[p], p);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v != fa &amp;&amp; v != son[p]) <span class="hljs-built_in">calcu</span>(v, p);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        vp[x].<span class="hljs-built_in">emplace_back</span>(y);        vp[y].<span class="hljs-built_in">emplace_back</span>(x);    &#125;    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;        <span class="hljs-type">int</span> x, y, w;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;        <span class="hljs-keyword">while</span>(top[x] != top[y])&#123;            <span class="hljs-keyword">if</span>(dep[top[x]] &gt; dep[top[y]])&#123;                add[top[x]].<span class="hljs-built_in">emplace_back</span>(w);                del[x].<span class="hljs-built_in">emplace_back</span>(w);                x = fat[top[x]];            &#125;<span class="hljs-keyword">else</span>&#123;                add[top[y]].<span class="hljs-built_in">emplace_back</span>(w);                del[y].<span class="hljs-built_in">emplace_back</span>(w);                y = fat[top[y]];            &#125;        &#125;        <span class="hljs-keyword">if</span>(dep[x] &gt; dep[y]) <span class="hljs-built_in">swap</span>(x, y);        add[x].<span class="hljs-built_in">emplace_back</span>(w);        del[y].<span class="hljs-built_in">emplace_back</span>(w);    &#125;    <span class="hljs-built_in">calcu</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h5 id="dsu-on-tree">dsu on tree</h5><div class="code-wrapper"><pre><code class="hljs c++">vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; tag[maxn];vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];<span class="hljs-type">int</span> f[maxn][<span class="hljs-number">23</span>], dep[maxn], siz[maxn], mxson[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span></span>&#123;    f[p][<span class="hljs-number">0</span>] = fa;    dep[p] = dep[fa] + <span class="hljs-number">1</span>;    mxson[p] = <span class="hljs-number">0</span>;    siz[p] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">dfs</span>(v, p);        siz[p] += siz[v];        <span class="hljs-keyword">if</span>(siz[v] &gt; siz[mxson[p]]) mxson[p] = v;    &#125;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">segTree</span>&#123;    <span class="hljs-type">int</span> mx[maxn &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;        mx[p] = <span class="hljs-built_in">max</span>(mx[p*<span class="hljs-number">2</span>], mx[p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> d)</span></span>&#123;        <span class="hljs-keyword">if</span>(l == r)&#123;            mx[p] += d;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(pos &lt;= mid) <span class="hljs-built_in">modify</span>(p*<span class="hljs-number">2</span>, l, mid, pos, d);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r, pos, d);        <span class="hljs-built_in">pushUp</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;        <span class="hljs-keyword">if</span>(mx[p] &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> l;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(mx[p*<span class="hljs-number">2</span>] &gt;= mx[p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(p*<span class="hljs-number">2</span>, l, mid);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r);    &#125;&#125;st;<span class="hljs-type">int</span> n, q;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calcu</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> d)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> pi: tag[p])&#123;        st.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>, pi.first, pi.second * d);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v != fa)&#123;            <span class="hljs-built_in">calcu</span>(v, p, d);        &#125;    &#125;&#125;<span class="hljs-type">int</span> ans[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> save)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v != fa &amp;&amp; v != mxson[p])&#123;            <span class="hljs-built_in">work</span>(v, p, <span class="hljs-number">0</span>);        &#125;    &#125;    <span class="hljs-keyword">if</span>(mxson[p]) <span class="hljs-built_in">work</span>(mxson[p], p, <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v != fa &amp;&amp; v != mxson[p])&#123;            <span class="hljs-built_in">calcu</span>(v, p, <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> pi: tag[p])&#123;        st.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>, pi.first, pi.second);    &#125;    ans[p] = st.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>);    <span class="hljs-keyword">if</span>(!save) <span class="hljs-built_in">calcu</span>(p, fa, <span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        vp[x].<span class="hljs-built_in">emplace_back</span>(y);        vp[y].<span class="hljs-built_in">emplace_back</span>(x);    &#125;    dep[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">20</span>;k++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;            f[i][k] = f[f[i][k<span class="hljs-number">-1</span>]][k<span class="hljs-number">-1</span>];        &#125;    &#125;    <span class="hljs-keyword">auto</span> lca = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)&#123;        <span class="hljs-keyword">if</span>(dep[x] &lt; dep[y]) <span class="hljs-built_in">swap</span>(x, y);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">20</span>;k&gt;=<span class="hljs-number">0</span>;k--)&#123;            <span class="hljs-keyword">if</span>(dep[f[x][k]] &gt;= dep[y]) x = f[x][k];        &#125;        <span class="hljs-keyword">if</span>(x == y) <span class="hljs-keyword">return</span> x;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">20</span>;k&gt;=<span class="hljs-number">0</span>;k--)&#123;            <span class="hljs-keyword">if</span>(f[x][k] != f[y][k])&#123;                x = f[x][k], y = f[y][k];            &#125;        &#125;        <span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];    &#125;;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;        <span class="hljs-type">int</span> x, y, w;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;        <span class="hljs-type">int</span> l = <span class="hljs-built_in">lca</span>(x, y);        tag[x].<span class="hljs-built_in">emplace_back</span>(w, <span class="hljs-number">1</span>);        tag[y].<span class="hljs-built_in">emplace_back</span>(w, <span class="hljs-number">1</span>);        tag[l].<span class="hljs-built_in">emplace_back</span>(w, <span class="hljs-number">-1</span>);        tag[f[l][<span class="hljs-number">0</span>]].<span class="hljs-built_in">emplace_back</span>(w, <span class="hljs-number">-1</span>);    &#125;    <span class="hljs-built_in">work</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;</code></pre></div><h5 id="线段树合并">线段树合并</h5><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegTree</span>&#123;    <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> mx[maxn &lt;&lt; <span class="hljs-number">5</span>], ls[maxn &lt;&lt; <span class="hljs-number">5</span>], rs[maxn &lt;&lt; <span class="hljs-number">5</span>], mxp[maxn &lt;&lt; <span class="hljs-number">5</span>];    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;        mx[<span class="hljs-number">0</span>] = <span class="hljs-number">-1e9</span>;<span class="hljs-comment">//注意可能pushup不存在的节点</span>        <span class="hljs-keyword">if</span>(mx[ls[p]] &gt;= mx[rs[p]])&#123;            mx[p] = mx[ls[p]];            mxp[p] = mxp[ls[p]];        &#125;<span class="hljs-keyword">else</span>&#123;            mx[p] = mx[rs[p]];            mxp[p] = mxp[rs[p]];        &#125;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> d)</span></span>&#123;        <span class="hljs-keyword">if</span>(!p) p = ++tot;        <span class="hljs-keyword">if</span>(l == r)&#123;            mx[p] += d;            mxp[p] = l;            <span class="hljs-keyword">return</span> p;        &#125;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(pos &lt;= mid) ls[p] = <span class="hljs-built_in">modify</span>(ls[p], l, mid, pos, d);        <span class="hljs-keyword">else</span> rs[p] = <span class="hljs-built_in">modify</span>(rs[p], mid+<span class="hljs-number">1</span>, r, pos, d);        <span class="hljs-built_in">push_up</span>(p);        <span class="hljs-keyword">return</span> p;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<span class="hljs-comment">//返回合并后的节点，替代式合并，合并后a这棵线段树就没用了</span>        <span class="hljs-keyword">if</span>(!x) <span class="hljs-keyword">return</span> y;        <span class="hljs-keyword">if</span>(!y) <span class="hljs-keyword">return</span> x;<span class="hljs-comment">//都没有同样return 0</span>        <span class="hljs-keyword">if</span>(l == r)&#123;            mx[x] += mx[y];            mxp[x] = l;            <span class="hljs-keyword">return</span> x;        &#125;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        ls[x] = <span class="hljs-built_in">merge</span>(ls[x], ls[y], l, mid);        rs[x] = <span class="hljs-built_in">merge</span>(rs[x], rs[y], mid+<span class="hljs-number">1</span>, r);        <span class="hljs-built_in">push_up</span>(x);        <span class="hljs-keyword">return</span> x;    &#125;&#125;st;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; tag[maxn];vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];<span class="hljs-type">int</span> f[maxn][<span class="hljs-number">23</span>], dep[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span></span>&#123;    f[p][<span class="hljs-number">0</span>] = fa;    dep[p] = dep[fa] + <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">dfs</span>(v, p);    &#125;&#125;<span class="hljs-type">int</span> ans[maxn];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span></span>&#123;    <span class="hljs-type">int</span> rt = ++st.tot;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> pi: tag[p]) st.<span class="hljs-built_in">modify</span>(rt, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>, pi.first, pi.second);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;        rt = st.<span class="hljs-built_in">merge</span>(rt, <span class="hljs-built_in">dfs2</span>(v, p), <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>);    &#125;    <span class="hljs-keyword">if</span>(st.mx[rt] == <span class="hljs-number">0</span>) ans[p] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">else</span> ans[p] = st.mxp[rt];    <span class="hljs-keyword">return</span> rt;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n, q;    cin &gt;&gt; n &gt;&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        vp[x].<span class="hljs-built_in">emplace_back</span>(y);        vp[y].<span class="hljs-built_in">emplace_back</span>(x);    &#125;    dep[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">20</span>;k++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;            f[i][k] = f[f[i][k<span class="hljs-number">-1</span>]][k<span class="hljs-number">-1</span>];        &#125;    &#125;    <span class="hljs-keyword">auto</span> lca = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)&#123;        <span class="hljs-keyword">if</span>(dep[x] &lt; dep[y]) <span class="hljs-built_in">swap</span>(x, y);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">20</span>;k&gt;=<span class="hljs-number">0</span>;k--)&#123;            <span class="hljs-keyword">if</span>(dep[f[x][k]] &gt;= dep[y]) x = f[x][k];        &#125;        <span class="hljs-keyword">if</span>(x == y) <span class="hljs-keyword">return</span> x;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">20</span>;k&gt;=<span class="hljs-number">0</span>;k--)&#123;            <span class="hljs-keyword">if</span>(f[x][k] != f[y][k])&#123;                x = f[x][k], y = f[y][k];            &#125;        &#125;        <span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];    &#125;;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;        <span class="hljs-type">int</span> x, y, w;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;        <span class="hljs-type">int</span> l = <span class="hljs-built_in">lca</span>(x, y);        tag[x].<span class="hljs-built_in">emplace_back</span>(w, <span class="hljs-number">1</span>);        tag[y].<span class="hljs-built_in">emplace_back</span>(w, <span class="hljs-number">1</span>);        tag[l].<span class="hljs-built_in">emplace_back</span>(w, <span class="hljs-number">-1</span>);        tag[f[l][<span class="hljs-number">0</span>]].<span class="hljs-built_in">emplace_back</span>(w, <span class="hljs-number">-1</span>);    &#125;    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Atcoder Beginner 246 EFG</title>
    <link href="/2022/04/11/%E9%A2%98%E8%A7%A3/Atcoder%20ABC%20247%20EFG/"/>
    <url>/2022/04/11/%E9%A2%98%E8%A7%A3/Atcoder%20ABC%20247%20EFG/</url>
    
    <content type="html"><![CDATA[<h4 id="e---max-min">E - Max Min</h4><blockquote><p>题意：给出一个序列，问有多少个子区间满足 <spanclass="math inline">\(max=X\)</span> 且 <spanclass="math inline">\(min=Y\)</span></p></blockquote><p>我的解法（下面还有另一种神仙解法：</p><p>枚举区间的左端点，然后二分区间的右端点，二分两次，分别找<strong>第一个使得区间max&gt;X或min&lt;Y</strong>的右端点，和<strong>第一个使得区间max&gt;=X且min&lt;=Y</strong>的右端点。简单来说就是找第一个达到要求的位置和第一个超出要求范围的位置。这两个位置相减即可得到合法右端点的数量。</p><p>求区间max和min自然是用st表</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, X, Y;<span class="hljs-type">int</span> mx[maxn][<span class="hljs-number">32</span>], mi[maxn][<span class="hljs-number">32</span>];<span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;    <span class="hljs-keyword">if</span>(r &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1e9</span>, <span class="hljs-number">-1e9</span>);    <span class="hljs-type">int</span> k = <span class="hljs-built_in">log</span>(r - l + <span class="hljs-number">1</span>) / <span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-built_in">max</span>(mx[l][k], mx[r-(<span class="hljs-number">1</span>&lt;&lt;k)+<span class="hljs-number">1</span>][k]), <span class="hljs-built_in">min</span>(mi[l][k], mi[r-(<span class="hljs-number">1</span>&lt;&lt;k)+<span class="hljs-number">1</span>][k]));&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; X &gt;&gt; Y;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; mx[i][<span class="hljs-number">0</span>];        mi[i][<span class="hljs-number">0</span>] = mx[i][<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">20</span>;k++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+(<span class="hljs-number">1</span>&lt;&lt;k)<span class="hljs-number">-1</span>&lt;=n;i++)&#123;            mi[i][k] = <span class="hljs-built_in">min</span>(mi[i][k<span class="hljs-number">-1</span>], mi[i+(<span class="hljs-number">1</span>&lt;&lt;(k<span class="hljs-number">-1</span>))][k<span class="hljs-number">-1</span>]);            mx[i][k] = <span class="hljs-built_in">max</span>(mx[i][k<span class="hljs-number">-1</span>], mx[i+(<span class="hljs-number">1</span>&lt;&lt;(k<span class="hljs-number">-1</span>))][k<span class="hljs-number">-1</span>]);        &#125;    &#125;    ll ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> l = i, r = n + <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(mi[i][<span class="hljs-number">0</span>] &gt; X || mi[i][<span class="hljs-number">0</span>] &lt; Y) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">while</span>(l &lt; r)&#123;            <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">get</span>(i, mid);            <span class="hljs-keyword">if</span>(p.first &gt; X || p.second &lt; Y)&#123;                r = mid;            &#125;<span class="hljs-keyword">else</span>&#123;                l = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-type">int</span> rp = l;        l = i, r = n + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(l &lt; r)&#123;            <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">get</span>(i, mid);            <span class="hljs-keyword">if</span>(p.first &gt;= X &amp;&amp; p.second &lt;= Y)&#123;                r = mid;            &#125;<span class="hljs-keyword">else</span>&#123;                l = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-type">int</span> lp = l;        ans += <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, rp - lp);    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><p>神仙解法：</p><p>我们可以很轻易的计算出 <span class="math inline">\(max\le X\)</span>且 <span class="math inline">\(min\ge Y\)</span>的区间个数，找到所有值在 <span class="math inline">\([X,Y]\)</span>范围内的数，把他们连成的区间计算一下就好，假设这样的区间个数为 <spanclass="math inline">\(g(X,Y)\)</span></p><p>容斥一下，答案即：<spanclass="math inline">\(g(X,Y)-g(X-1,Y)-g(X,Y-1)+g(X-1,Y-1)\)</span></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, a[maxn];<span class="hljs-function">ll <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;    ll cnt = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(y &lt;= a[i] &amp;&amp; a[i] &lt;= x)&#123;            cnt++;        &#125;<span class="hljs-keyword">else</span>&#123;            ans += (cnt * (cnt + <span class="hljs-number">1</span>)) / <span class="hljs-number">2</span>;            cnt = <span class="hljs-number">0</span>;        &#125;    &#125;    ans += (cnt * (cnt + <span class="hljs-number">1</span>)) / <span class="hljs-number">2</span>;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> x, y;    cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    cout &lt;&lt; <span class="hljs-built_in">g</span>(x, y) - <span class="hljs-built_in">g</span>(x<span class="hljs-number">-1</span>, y) - <span class="hljs-built_in">g</span>(x, y+<span class="hljs-number">1</span>) + <span class="hljs-built_in">g</span>(x<span class="hljs-number">-1</span>, y+<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="f---cards">F - Cards</h4><blockquote><p>题意：有 <span class="math inline">\(n\)</span>张卡片，每张卡片正面和背面各有一个数字，保证其中数字 <spanclass="math inline">\(1..n\)</span>各出现两次，问现在有多少种取卡片的方案，使得取到的卡片包含每一种数字。</p></blockquote><p>如果两个数字出现在同一张卡片上，我们就将它们连边，这样构造出来的图每个点的度数都为2，那就意味着这个图可以被分为若干个互不干涉的简单环。</p><p>那么问题就变成了：一个包含 <span class="math inline">\(x\)</span>个节点的环中，每条边可以选或不选，有多少中选法使得相邻两边至少有一条选中。</p><p>考虑一下递推这个问题：假设已经有 <spanclass="math inline">\(x-1\)</span>条边的环了，考虑在1,2号边之间插入新的边（哪里都一样），如果1,2都选，则这条新边可选可不选，否则新必边须选。除此之外，还需要加上1,2都不选（不包括在<span class="math inline">\(x-1\)</span> 的情况内），新边选的情况。</p><p>限制1,2都选或都不选的情况数，就等于 <spanclass="math inline">\(x-2\)</span>条边的环的情况数（1,2条可以看做同一条边）</p><p>那么就有：<spanclass="math inline">\(f_x=f_{x-1}+f_{x-2}\)</span>，容易递推</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, a[maxn], b[maxn];<span class="hljs-type">int</span> t[maxn], vis[maxn];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;    <span class="hljs-keyword">if</span>(vis[p]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    vis[p] = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(t[p]) + <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; b[i];        t[a[i]] = b[i];    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;    f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    f[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++) f[i] = (f[i<span class="hljs-number">-1</span>] + f[i<span class="hljs-number">-2</span>]) % mode;    ll ans = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(!vis[i])&#123;            <span class="hljs-type">int</span> cnt = <span class="hljs-built_in">dfs</span>(i);            ans = ans * f[cnt] % mode;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="g---dream-team">G - Dream Team</h4><blockquote><p>题意：有 <span class="math inline">\(n\)</span>个人，每个人有所在城市 <spanclass="math inline">\(A_i\)</span>，所选学科 <spanclass="math inline">\(B_i\)</span>，能力 <spanclass="math inline">\(C_i\)</span>，现要从中挑选 <spanclass="math inline">\(k\)</span>个人组成梦之队，要求所有选择的人城市各部相同，学科各不相同。问对于每一个可能的<spanclass="math inline">\(k\)</span>，梦之队的能力总和最大值是多少。</p><ul><li><span class="math inline">\(1≤N≤3×10^4\)</span></li><li><span class="math inline">\(1 \leq A_i,B_i \leq 150\)</span></li><li><span class="math inline">\(1 \leq C_i \leq 10^9\)</span></li></ul></blockquote><p><code>一眼150，鉴定为暴力</code></p><p>考虑费用流，从起点向每个 <span class="math inline">\(A\)</span>容量为1的边，从每个 <span class="math inline">\(B\)</span>向终点连容量为1的边，限制了每个城市和学科都只能选一次，然后对于每个人，将<span class="math inline">\(A_i\)</span> 和 <spanclass="math inline">\(B_i\)</span> 之间连一条费用为 <spanclass="math inline">\(C_i\)</span>，容量为1的边。然后跑费用流就可以了。</p><p>因为网络流是逐路径增广的，边流量又都为1，那么每次增广就相当于增加了一个人数，记录每次增广后的最小费用即可。</p><p>可以将费用改为 <spanclass="math inline">\(-C_i\)</span>，计算最小费用流后取反即可。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//板子</span><span class="hljs-keyword">namespace</span> Flow&#123;    <span class="hljs-type">int</span> n, st, ed;    ll dis[maxn], h[maxn], pre[maxn];<span class="hljs-comment">//记录最短路中连向它的边号</span>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;        <span class="hljs-type">int</span> fr, to, nt;        ll w, c;        <span class="hljs-function">ll <span class="hljs-title">dis</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123;<span class="hljs-comment">//获取修正后的边权</span>            <span class="hljs-keyword">return</span> c + h[fr] - h[to];        &#125;    &#125;e[maxn &lt;&lt; <span class="hljs-number">1</span>];    <span class="hljs-type">int</span> head[maxn], ecnt = <span class="hljs-number">1</span>;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> cnt)</span></span>&#123;        n = cnt, st = s, ed = t;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) head[i] = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, ll w, ll c)</span></span>&#123;        e[++ecnt] = &#123;x, y, head[x], w, c&#125;;        head[x] = ecnt;        e[++ecnt] = &#123;y, x, head[y], <span class="hljs-number">0</span>, -c&#125;;        head[y] = ecnt;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;        queue&lt;<span class="hljs-type">int</span>&gt; q; q.<span class="hljs-built_in">push</span>(st);        h[st] = <span class="hljs-number">0</span>; vis[st] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;            <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();            vis[u] = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].nt)&#123;                <span class="hljs-type">int</span> v = e[i].to;                <span class="hljs-keyword">if</span>(e[i].w &gt; <span class="hljs-number">0</span> &amp;&amp; h[v] &gt; h[u] + e[i].c)&#123;                    h[v] = h[u] + e[i].c;                    <span class="hljs-keyword">if</span>(!vis[v]) vis[v] = <span class="hljs-literal">true</span>, q.<span class="hljs-built_in">push</span>(v);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dij</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;            ll t, dis;            <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &gt;(<span class="hljs-type">const</span> node &amp;x)<span class="hljs-type">const</span>&#123;                <span class="hljs-keyword">return</span> dis &gt; x.dis;            &#125;        &#125;;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) dis[i] = INF;        dis[st] = <span class="hljs-number">0</span>;        priority_queue&lt;node, vector&lt;node&gt;, greater&lt;&gt; &gt; q;        q.<span class="hljs-built_in">push</span>(&#123;st, <span class="hljs-number">0</span>&#125;);        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;            node u = q.<span class="hljs-built_in">top</span>();            q.<span class="hljs-built_in">pop</span>();            <span class="hljs-keyword">if</span>(u.dis &gt; dis[u.t]) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u.t];i;i=e[i].nt)&#123;                <span class="hljs-type">int</span> v = e[i].to;                <span class="hljs-keyword">if</span>(e[i].w &gt; <span class="hljs-number">0</span> &amp;&amp; dis[v] &gt; dis[u.t] + e[i].<span class="hljs-built_in">dis</span>())&#123;                    dis[v] = dis[u.t] + e[i].<span class="hljs-built_in">dis</span>();                    pre[v] = i;                    q.<span class="hljs-built_in">push</span>(&#123;v, dis[v]&#125;);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dis[ed] &lt; INF;    &#125;    vector&lt;ll&gt; ans;    <span class="hljs-function">pair&lt;ll, ll&gt; <span class="hljs-title">calcu</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-built_in">spfa</span>();        ll answ = <span class="hljs-number">0</span>, ansc = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">dij</span>())&#123;            ll minf = INF;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=ed;i!=st;i=e[pre[i]].fr) minf = <span class="hljs-built_in">min</span>(minf, e[pre[i]].w);            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=ed;i!=st;i=e[pre[i]].fr)&#123;                e[pre[i]].w -= minf;                e[pre[i] ^ <span class="hljs-number">1</span>].w += minf;                ansc += e[pre[i]].c * minf;            &#125;            answ += minf;            ans.<span class="hljs-built_in">push_back</span>(-ansc);            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) h[i] += dis[i];        &#125;        <span class="hljs-keyword">return</span> &#123;answ, ansc&#125;;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;        cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;        <span class="hljs-keyword">for</span>(ll x: ans) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    Flow::<span class="hljs-built_in">init</span>(<span class="hljs-number">301</span>, <span class="hljs-number">302</span>, <span class="hljs-number">302</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">151</span>;i&lt;=<span class="hljs-number">300</span>;i++) Flow::<span class="hljs-built_in">add</span>(i, <span class="hljs-number">302</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">150</span>;i++) Flow::<span class="hljs-built_in">add</span>(<span class="hljs-number">301</span>, i, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        Flow::<span class="hljs-built_in">add</span>(a, <span class="hljs-number">150</span>+b, <span class="hljs-number">1</span>, -c);    &#125;    Flow::<span class="hljs-built_in">calcu</span>();    Flow::<span class="hljs-built_in">print</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Atcoder</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 126 A-F</title>
    <link href="/2022/04/10/%E9%A2%98%E8%A7%A3/Educational%20Codeforces%20Round%20126/"/>
    <url>/2022/04/10/%E9%A2%98%E8%A7%A3/Educational%20Codeforces%20Round%20126/</url>
    
    <content type="html"><![CDATA[<h4 id="a.-array-balancing">A. Array Balancing</h4><blockquote><p>题意：给出序列 <span class="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span>，可以任意交换相同位置的 <spanclass="math inline">\(a_i,b_i\)</span> ，求 <spanclass="math inline">\(\sum|a_i-a_{i-1}|+|b_i-b_{i-1}|\)</span>的最小值</p></blockquote><p>显然，把小的放一边，大的放另一边一定最优。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn], b[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; b[i];        <span class="hljs-keyword">if</span>(b[i] &gt; a[i]) <span class="hljs-built_in">swap</span>(b[i], a[i]);    &#125;    ll ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) &#123;        ans += <span class="hljs-built_in">abs</span>(a[i] - a[i+<span class="hljs-number">1</span>]);        ans += <span class="hljs-built_in">abs</span>(b[i] - b[i+<span class="hljs-number">1</span>]);    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="b.-getting-zero">B. Getting Zero</h4><blockquote><p>题意：给出一个数字，你可以对其进行下面的操作：</p><ul><li><span class="math inline">\(x=x\times2 \mod 32768\)</span></li><li><span class="math inline">\(x=x+1\mod 32768\)</span></li></ul><p>求最少多少次操作可以使 <span class="math inline">\(x\)</span>变成0</p></blockquote><p>第一个操作相当于二进制下右移一位并舍弃最高位，加法就是末尾+1，我们希望把所有1都舍弃掉，那么要么通过加1进位的方式消1，要么直接右移消1。不论如何，一定是先做加法再做乘法更优。</p><p><spanclass="math inline">\(32768=2^{15}\)</span>，所以15次内一定能够完成，那么只要暴力枚举做加法的次数即可。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calcu</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    x %= <span class="hljs-number">32768</span>;    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x != <span class="hljs-number">0</span>)&#123;        x = x * <span class="hljs-number">2</span> % <span class="hljs-number">32768</span>;        a++;    &#125;    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> x; cin &gt;&gt; x;        <span class="hljs-type">int</span> r = <span class="hljs-built_in">calcu</span>(x);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=r;k++)&#123;            r = <span class="hljs-built_in">min</span>(r, <span class="hljs-built_in">calcu</span>(x+k)+k);        &#125;        cout &lt;&lt; r &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[<span class="hljs-number">1</span> == n];    &#125;&#125;</code></pre></div><h4 id="c.-water-the-trees">C. Water the Trees</h4><blockquote><p>题意：现在有 <span class="math inline">\(n\)</span>棵树，每棵树有一个初始高度，接下来若干天，每天可以选择一棵树浇水使其增长<span class="math inline">\(x\)</span>，如果是奇数天则 <spanclass="math inline">\(x=1\)</span>，偶数天 <spanclass="math inline">\(x=2\)</span>。也可以不浇水。求最少多少天可以使得所有树一样高。</p></blockquote><p>万恶的模拟题</p><p>首先，要么使所有树都涨 <spanclass="math inline">\(max\)</span>，要么都涨到 <spanclass="math inline">\(max+1\)</span>，涨到 <spanclass="math inline">\(max+2\)</span>及以上一定不如前两种，分别计算一下</p><p>假设一共进行了 <span class="math inline">\(k\)</span>次偶数浇水，那么进行 <span class="math inline">\(sum-2\times k\)</span>次奇数浇水，则最大的天数是 <span class="math inline">\(max(2\timesk,2\times(sum-2\times k)-1)\)</span></p><p>画出这两个函数，交点差不多是 <span class="math inline">\((2\timessum+1)/6\)</span>，那么取 <span class="math inline">\(k\)</span>为这个值左右小范围内暴力计算即可。</p><p>注意还需要额外计算一下最多可以浇偶数水的次数，<spanclass="math inline">\(k\)</span> 不能超过这个值。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn], b[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i], mx = <span class="hljs-built_in">max</span>(mx, a[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        b[i] = mx - a[i] + <span class="hljs-number">1</span>;        a[i] = mx - a[i];    &#125;    ll mxk = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        mxk += a[i] / <span class="hljs-number">2</span>;        sum += a[i];    &#125;    ll ans = <span class="hljs-number">1e18</span>;    ll j = sum - <span class="hljs-number">2</span> * mxk;    ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">max</span>(<span class="hljs-number">2</span>*mxk, <span class="hljs-number">2</span>*j<span class="hljs-number">-1</span>));    <span class="hljs-keyword">for</span>(ll k = <span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>, sum/<span class="hljs-number">3</span><span class="hljs-number">-30</span>); k&lt;=<span class="hljs-built_in">min</span>(mxk, sum/<span class="hljs-number">3</span>+<span class="hljs-number">30</span>); k++)&#123;        j = sum - <span class="hljs-number">2</span> * k;        ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">max</span>(<span class="hljs-number">2</span>*k, <span class="hljs-number">2</span>*j<span class="hljs-number">-1</span>));    &#125;    mxk = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        mxk += b[i] / <span class="hljs-number">2</span>;        sum += b[i];    &#125;    j = sum - <span class="hljs-number">2</span> * mxk;    ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">max</span>(<span class="hljs-number">2</span>*mxk, <span class="hljs-number">2</span>*j<span class="hljs-number">-1</span>));    <span class="hljs-keyword">for</span>(ll k = <span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>, sum/<span class="hljs-number">3</span><span class="hljs-number">-30</span>); k&lt;=<span class="hljs-built_in">min</span>(mxk, sum/<span class="hljs-number">3</span>+<span class="hljs-number">30</span>); k++)&#123;        j = sum - <span class="hljs-number">2</span> * k;        ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">max</span>(<span class="hljs-number">2</span>*k, <span class="hljs-number">2</span>*j<span class="hljs-number">-1</span>));    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="d.-progressions-covering">D. Progressions Covering</h4><blockquote><p>题意：现有个序列 <spanclass="math inline">\(a\)</span>，你需要在另一个空序列上进行如下操作：</p><ul><li>选择一段长度为 <span class="math inline">\(m\)</span> 的 <spanclass="math inline">\([l,r]\)</span>，使得它们从 <spanclass="math inline">\(l\)</span> 到 <spanclass="math inline">\(r\)</span> 分别加上1,2,3...m</li><li>注意 <span class="math inline">\([l,r]\)</span> 不能超出边界</li></ul><p>问最少多少次操作可以使得你的序列每一个位置都大于 <spanclass="math inline">\(a\)</span> 序列</p></blockquote><p>首先可以想到两个端点上要操作的次数是确定的</p><p>如果正着考虑，会比较难判，比如下面这种：</p><div class="code-wrapper"><pre><code class="hljs c++">m = <span class="hljs-number">3</span>a = <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span></code></pre></div><p>处理6的时候，可以让左端点处于0这个位置（尽管这里不需要再增加），让6获得最大的增长速度，这种策略让正着做变得非常复杂。</p><p>所以倒着做就行了（</p><p>具体而言，我们可以维护一个二阶差分数组，在那上面做单点修改，思路应该不难，可能写起来有点细节，具体看代码。</p><p>注意跑到边界的时候要特判</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;ll a[maxn], dd[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n/<span class="hljs-number">2</span>;i++) <span class="hljs-built_in">swap</span>(a[i], a[n-i+<span class="hljs-number">1</span>]);    ll s = <span class="hljs-number">0</span>, d = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>, mxd = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        d += dd[i];        s += d;        ll k = <span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>, (a[i] - s + m - <span class="hljs-number">1</span>) / m);        <span class="hljs-keyword">if</span>(i+m &gt; n+<span class="hljs-number">1</span>)&#123;            mxd = <span class="hljs-built_in">max</span>((a[i] - s + n - i) / (n - i + <span class="hljs-number">1</span>), mxd);            <span class="hljs-keyword">continue</span>;        &#125;        ans += k;        dd[i+<span class="hljs-number">1</span>] -= (m + <span class="hljs-number">1</span>) * k;        dd[i+m+<span class="hljs-number">1</span>] += k;        d += m * k;        s += m * k;    &#125;    cout &lt;&lt; ans + mxd &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="e.-narrow-components">E. Narrow Components</h4><blockquote><p>题意：给出一个三行，<span class="math inline">\(n\)</span>列的矩阵，其中0表示不可走的地块，1表示可以走的地块，接下来有若干个询问，每次问<span class="math inline">\([l,r]\)</span>列组成的子矩阵中有多少个联通块。</p></blockquote><p>考虑前缀和，求 <span class="math inline">\([l,r]\)</span>上的联通块个数首先拿 <spanclass="math inline">\(sum_r-sum_{l-1}\)</span>，然后处理边界，左右两边<strong>每有一对不同的联通块相连</strong>，就将答案加上1</p><p>边界左边的点所属的联通块可以在搞前缀和的时候顺便处理出来，边界右边的点，只有<code>101</code> 的情况需要多考虑，可以先预处理出每一个 <code>101</code>的列往右走，到哪一列能够合并起来（或者无法合并），解决查询的时候如果它们合并的点在查询区间之内，则属于同一联通块，否则属于两个联通块。</p><p>预处理这个情况可以用并查集，每个 <code>101</code>的列指向它右边一列，<code>111</code>的列指向自身，其他列指向n+1。这一列的祖先即为其第一次合并的位置。</p><p>写起来也比较麻烦（最近的题怎么全都带点模拟），看代码吧..</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;string s[<span class="hljs-number">3</span>];<span class="hljs-type">int</span> f[maxn], st[<span class="hljs-number">3</span>][maxn];<span class="hljs-type">int</span> nxt[maxn];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    <span class="hljs-keyword">if</span>(nxt[x] == x) <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> nxt[x] = <span class="hljs-built_in">find</span>(nxt[x]);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    cin &gt;&gt; s[<span class="hljs-number">0</span>] &gt;&gt; s[<span class="hljs-number">1</span>] &gt;&gt; s[<span class="hljs-number">2</span>];    <span class="hljs-type">int</span> tag = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;        <span class="hljs-keyword">if</span>(s[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;            f[<span class="hljs-number">0</span>]++, st[i][<span class="hljs-number">0</span>] = ++tag;            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span> &amp;&amp; st[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]) st[i][<span class="hljs-number">0</span>] = st[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], f[<span class="hljs-number">0</span>]--;        &#125;    &#125;    nxt[n+<span class="hljs-number">1</span>] = n+<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; s[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;        <span class="hljs-keyword">if</span>(s[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) nxt[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">else</span> nxt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    &#125;<span class="hljs-keyword">else</span> nxt[<span class="hljs-number">0</span>] = n+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        f[i] = f[i<span class="hljs-number">-1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">3</span>;k++)&#123;            <span class="hljs-keyword">if</span>(s[k][i] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;                <span class="hljs-keyword">if</span>(s[k][i<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) st[k][i] = st[k][i<span class="hljs-number">-1</span>];                <span class="hljs-keyword">else</span>&#123;                    st[k][i] = ++tag;                    f[i]++;                &#125;            &#125;        &#125;        set&lt;<span class="hljs-type">int</span>&gt; cnt, caf;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">3</span>;k++)&#123;            <span class="hljs-keyword">if</span>(st[k][i])&#123;                cnt.<span class="hljs-built_in">insert</span>(st[k][i]);                <span class="hljs-keyword">if</span>(k != <span class="hljs-number">0</span> &amp;&amp; st[k<span class="hljs-number">-1</span>][i]) st[k][i] = st[k<span class="hljs-number">-1</span>][i];                caf.<span class="hljs-built_in">insert</span>(st[k][i]);            &#125;        &#125;        f[i] -= cnt.<span class="hljs-built_in">size</span>() - caf.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>][i] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; s[<span class="hljs-number">2</span>][i] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;            <span class="hljs-keyword">if</span>(s[<span class="hljs-number">1</span>][i] == <span class="hljs-string">&#x27;1&#x27;</span>) nxt[i] = i;            <span class="hljs-keyword">else</span> nxt[i] = i+<span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span> nxt[i] = n+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-type">int</span> Q;    cin &gt;&gt; Q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=Q;i++)&#123;        <span class="hljs-type">int</span> l, r;        cin &gt;&gt; l &gt;&gt; r;        l--, r--;        <span class="hljs-keyword">if</span>(l == <span class="hljs-number">0</span>)&#123;            cout &lt;&lt; f[r] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-type">int</span> ans = f[r] - f[l<span class="hljs-number">-1</span>];        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tg</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">3</span>;k++)&#123;            <span class="hljs-keyword">if</span>(s[k][l] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;                tg[k] = k+<span class="hljs-number">1</span>;                <span class="hljs-keyword">if</span>(k !=<span class="hljs-number">0</span> &amp;&amp; tg[k<span class="hljs-number">-1</span>]) tg[k] = tg[k<span class="hljs-number">-1</span>];            &#125;        &#125;        <span class="hljs-keyword">if</span>(tg[<span class="hljs-number">0</span>] &amp;&amp; tg[<span class="hljs-number">2</span>] &amp;&amp; <span class="hljs-built_in">find</span>(l) &lt;= r) tg[<span class="hljs-number">2</span>] = tg[<span class="hljs-number">0</span>];        set&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; cnt;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">3</span>;k++) <span class="hljs-keyword">if</span>(st[k][l<span class="hljs-number">-1</span>] &amp;&amp; tg[k])            cnt.<span class="hljs-built_in">insert</span>(&#123;st[k][l<span class="hljs-number">-1</span>], tg[k]&#125;);        ans += cnt.<span class="hljs-built_in">size</span>();        cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div><h4 id="f.-teleporters">F. Teleporters</h4><blockquote><p>题意：人在坐标轴0点处，x轴上有若干个点 <spanclass="math inline">\(a_1...a_n\)</span>，接下来每次可以走向一个点，消耗能量为<span class="math inline">\(len^2\)</span>，我希望用至多 <spanclass="math inline">\(m\)</span> 能量走到 <spanclass="math inline">\(a_n\)</span> ，问至少需要额外添加几个点。</p></blockquote><p>题目相当于给出若干个差值 <spanclass="math inline">\(d_i\)</span>，每次可以选择将一个差值拆开成两份，最少多少刀可以使得<span class="math inline">\(\sum d^2\)</span> 小于 <spanclass="math inline">\(m\)</span></p><p>首先需要注意的是：每一刀都将最大值切一半并不是最优的，如果选择对一个<span class="math inline">\(d\)</span> 切两刀，那么三等分是最优的。</p><p>设 <span class="math inline">\(cos(d,k)\)</span> 为将 <spanclass="math inline">\(d\)</span> 切成 <spanclass="math inline">\(k\)</span> 份的最小花费，那么如果要对这个 <spanclass="math inline">\(d\)</span> 多切一刀，收益应该是 <spanclass="math inline">\(cos(d,k)-cos(d,k+1)\)</span></p><p>唯一的策略是每次都选取收益最大的一刀去切，题目范围不允许我们暴力枚举每一刀，所以考虑二分。</p><p>二分刀数不好做，我们依然不知道每一刀切在哪。</p><p>观察注意到切每一刀的收益是递减的，那么可以考虑二分切的最小收益，假设最小收益为<span class="math inline">\(k\)</span>，那么所有收益大于等于 <spanclass="math inline">\(k\)</span> 的刀都要切。</p><p>那么继续对每一个西瓜再次二分，对其切第 <spanclass="math inline">\(m\)</span> 刀的收益为 <spanclass="math inline">\(cos(d,m-1)-cod(d,m)\)</span>，可以容易二分出每个西瓜切的次数，计算出切的总刀数和总花费。</p><p>这样我们就能得出切的最小收益（假设为 <spanclass="math inline">\(k\)</span>），此时总花费为 <spanclass="math inline">\(sum\)</span>，注意在这种意义下，所有收益大于等于<span class="math inline">\(k\)</span>的刀都要切，其中可能有若干收益恰好为 <spanclass="math inline">\(k\)</span> 的刀，默认是全切的。</p><p>这样二分只能得出：收益 <span class="math inline">\(\ge k\)</span>的刀全切能满足条件，且仅切收益 <span class="math inline">\(\gtk\)</span> 的无法满足条件，收益恰为 <spanclass="math inline">\(k\)</span> 的刀切几次，还需另外判断。</p><p>全切时总花费为 <span class="math inline">\(sum\)</span>，少切一刀增加<span class="math inline">\(k\)</span> 的花费，那么可以少切 <spanclass="math inline">\((m-sum)/k\)</span> 刀。</p><div class="code-wrapper"><pre><code class="hljs c++">ll n, m;ll a[maxn];<span class="hljs-function">ll <span class="hljs-title">cos</span><span class="hljs-params">(ll d, ll k)</span></span>&#123;    ll t = d / k;    ll md = d % k;    <span class="hljs-keyword">return</span> md * (t + <span class="hljs-number">1</span>) * (t + <span class="hljs-number">1</span>) + (k - md) * t * t;&#125;ll cnt;<span class="hljs-function">ll <span class="hljs-title">calcu</span><span class="hljs-params">(ll mi)</span></span>&#123;<span class="hljs-comment">//最小收益 只有收益&gt;=mi的刀才切</span>    ll res = <span class="hljs-number">0</span>;    cnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        ll l = <span class="hljs-number">1</span>, r = a[i];        <span class="hljs-keyword">while</span>(l &lt; r)&#123;            ll mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cos</span>(a[i], mid<span class="hljs-number">-1</span>) - <span class="hljs-built_in">cos</span>(a[i], mid) &gt;= mi)&#123;                l = mid;            &#125;<span class="hljs-keyword">else</span>&#123;                r = mid - <span class="hljs-number">1</span>;            &#125;        &#125;        cnt += l - <span class="hljs-number">1</span>;        res += <span class="hljs-built_in">cos</span>(a[i], l);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--) a[i] = a[i] - a[i<span class="hljs-number">-1</span>];    cin &gt;&gt; m;    ll l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e18</span>;    <span class="hljs-keyword">while</span>(l &lt; r)&#123;        ll mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">calcu</span>(mid) &lt;= m)&#123;            l = mid;        &#125;<span class="hljs-keyword">else</span>&#123;            r = mid - <span class="hljs-number">1</span>;        &#125;    &#125;    ll res = m - <span class="hljs-built_in">calcu</span>(l);    cout &lt;&lt; cnt - res / l &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 781 div.2 CDE</title>
    <link href="/2022/04/09/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20781%20div.2%20CDE/"/>
    <url>/2022/04/09/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20781%20div.2%20CDE/</url>
    
    <content type="html"><![CDATA[<h4 id="c.-tree-infection">C. Tree Infection</h4><p>题意：给定一棵树，一开始所有节点都是未传染的状态，接下来每一秒，可以手动传染一个新节点，同时已经被传染的节点会传染它的一个兄弟节点。问最短多少秒能够传染所有节点。</p><p>首先容易发现，这个树并没有什么用，我们可以把连同一个父节点的点分成一组，组与组之间是无关的。</p><p>看起来是个简单题了，<span class="math inline">\(n\)</span>秒内一定能传染完，那么模拟即可。然而这个模拟还是有点恶心的，不要想 <spanclass="math inline">\(O(n)\)</span>解法了，搞个优先队列暴力搞，每次选取剩余最大的一组感染就行了。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> du[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) du[i] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> x;        cin &gt;&gt; x;        du[x]++;    &#125;    du[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">sort</span>(du, du+n+<span class="hljs-number">1</span>, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;() );    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(!du[i]) <span class="hljs-keyword">break</span>;        k++;    &#125;    priority_queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(!du[i]) <span class="hljs-keyword">break</span>;        <span class="hljs-type">int</span> r = du[i] - (k - i);        <span class="hljs-keyword">if</span>(r &gt; <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(r);    &#125;    <span class="hljs-type">int</span> ad = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;        <span class="hljs-type">int</span> p = q.<span class="hljs-built_in">top</span>();        q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">if</span>(p &lt;= ad) <span class="hljs-keyword">break</span>;        p--;        ad++;        q.<span class="hljs-built_in">push</span>(p);    &#125;    cout &lt;&lt; k + ad &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="d.-gcd-guess">D. GCD Guess</h4><p>题意：交互题，需要去猜一个数字 <spanclass="math inline">\(x\)</span>，每次交互可以输入两个不同的正整数 <spanclass="math inline">\(a,b\)</span>，会得到 <spanclass="math inline">\(gcd(x+a,x+b)\)</span>的结果，需要在30次内猜出。</p><p>30次这个数字告诉我们，不是二分就是二进制...</p><p>解：按位考虑，假设我们已经知道 <span class="math inline">\(x\)</span>的前 <span class="math inline">\(i\)</span> 位的值了（假设为 <spanclass="math inline">\(pre_i\)</span>），现在猜第 <spanclass="math inline">\(i+1\)</span> 位的情况，我们可以先让前面 <spanclass="math inline">\(i\)</span> 位全部清零（在加 <spanclass="math inline">\(a,b\)</span> 时处理掉前面的影响），然后取 <spanclass="math inline">\(a,b\)</span> 分别为 <spanclass="math inline">\(2^{i}\)</span> 和 <spanclass="math inline">\(2^i+2^{i+1}\)</span>，这样如果 <spanclass="math inline">\(x\)</span> 第 <spanclass="math inline">\(i\)</span> 位为1，得到的结果即为 <spanclass="math inline">\(2^{i+1}\)</span></p><p>举例：</p><div class="code-wrapper"><pre><code class="hljs markdown">.....?0000<span class="hljs-bullet">+</span>    10000<span class="hljs-bullet">+</span>   110000如果?为1，则gcd结果必为：<span class="hljs-code">100000</span><span class="hljs-code">否则结果必为：</span><span class="hljs-code"> 10000</span></code></pre></div><p>构造方法应该不止这一种。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1000003</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;    cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl;    cout.<span class="hljs-built_in">flush</span>();    <span class="hljs-type">int</span> r; cin &gt;&gt; r;<span class="hljs-comment">//int r = __gcd(1000000000+x, 1000000000+y);</span>    <span class="hljs-comment">//交互题可以这样测试</span>    <span class="hljs-keyword">return</span> r;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, xf = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">30</span>;i++)&#123;        <span class="hljs-type">int</span> s = <span class="hljs-built_in">query</span>(xf + <span class="hljs-number">1</span>, xf + <span class="hljs-number">1</span> + (<span class="hljs-number">1</span>&lt;&lt;i));        <span class="hljs-keyword">if</span>(s == (<span class="hljs-number">1</span>&lt;&lt;i))&#123;            x |= (<span class="hljs-number">1</span> &lt;&lt; (i<span class="hljs-number">-1</span>));        &#125;<span class="hljs-keyword">else</span>&#123;            xf |= (<span class="hljs-number">1</span> &lt;&lt; (i<span class="hljs-number">-1</span>));        &#125;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="e.-minimizor">E. MinimizOR</h4><p>题意：给出一个数列，若干次询问，每次询问 <spanclass="math inline">\([l,r]\)</span>之间，两两或结果的最小值是多少。</p><p>结论：对于任意一个区间来说，只需要考虑最小的31个数两两或的结果即可（数字小于<span class="math inline">\(2^{30}\)</span>）。</p><p>思路：要算一个区间的两两或最小值，肯定是从高位到低位贪心地去考虑，高位能取0就取0，一定最优。</p><p>考虑当前最高位上1和0的个数：</p><ul><li>全是1：这个高位对后续抉择没有影响，这一位必定是1</li><li>至少2个0：之后必定在这些高位为0的数字中选择，也就是选取较小的那一部分</li><li>有一个0：这个高位必定是1，继续考虑下一位。但需注意：下次遇到情况二时，高位为0的部分就不一定是最小值了，假设已经出现了<span class="math inline">\(k\)</span> 次情况3，那么可能出现 <spanclass="math inline">\(k\)</span> 个比高位为0的还小的数。</li><li>显然，这个 <span class="math inline">\(k\)</span>至多为30，那么其实最终或最小的两个值一定出在前31小值内。</li></ul><p>写一写感受一下，可选范围是不断缩小的，每枚举一位，下边界最多会移动1，那么最终结果就在前31小内。</p><p>结论证明完了，处理这个就很暴力了：线段树维护区间前31小值，每次询问的时候计算31*31种结果，复杂度两个log，能过。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, a[maxn];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegTree</span>&#123;    vector&lt;<span class="hljs-type">int</span>&gt; mi[maxn &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;res, vector&lt;<span class="hljs-type">int</span>&gt; x, vector&lt;<span class="hljs-type">int</span>&gt; y)</span></span>&#123;        res.<span class="hljs-built_in">clear</span>();        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(l &lt; x.<span class="hljs-built_in">size</span>() &amp;&amp; r &lt; y.<span class="hljs-built_in">size</span>() &amp;&amp; res.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">31</span>)&#123;            <span class="hljs-keyword">if</span>(x[l] &lt; y[r]) res.<span class="hljs-built_in">push_back</span>(x[l++]);            <span class="hljs-keyword">else</span> res.<span class="hljs-built_in">push_back</span>(y[r++]);        &#125;        <span class="hljs-keyword">while</span>(l &lt; x.<span class="hljs-built_in">size</span>() &amp;&amp; res.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">31</span>) res.<span class="hljs-built_in">push_back</span>(x[l++]);        <span class="hljs-keyword">while</span>(r &lt; y.<span class="hljs-built_in">size</span>() &amp;&amp; res.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">31</span>) res.<span class="hljs-built_in">push_back</span>(y[r++]);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;        <span class="hljs-keyword">if</span>(l == r)&#123;            mi[p].<span class="hljs-built_in">clear</span>();            mi[p].<span class="hljs-built_in">push_back</span>(a[l]);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-built_in">build</span>(p*<span class="hljs-number">2</span>, l, mid);        <span class="hljs-built_in">build</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r);        <span class="hljs-built_in">merge</span>(mi[p], mi[p*<span class="hljs-number">2</span>], mi[p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span></span>&#123;        <span class="hljs-keyword">if</span>(l &gt; R || L &gt; r) <span class="hljs-keyword">return</span> &#123;&#125;;        <span class="hljs-keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> mi[p];        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        vector&lt;<span class="hljs-type">int</span>&gt; res;        <span class="hljs-built_in">merge</span>(res, <span class="hljs-built_in">query</span>(p*<span class="hljs-number">2</span>, l, mid, L, R), <span class="hljs-built_in">query</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r, L, R));        <span class="hljs-keyword">return</span> res;    &#125;&#125;st;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    st.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);    <span class="hljs-type">int</span> Q;    cin &gt;&gt; Q;    <span class="hljs-keyword">while</span>(Q--)&#123;        <span class="hljs-type">int</span> l, r;        cin &gt;&gt; l &gt;&gt; r;        <span class="hljs-keyword">auto</span> res = st.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r);        <span class="hljs-type">int</span> ans = <span class="hljs-number">2e9</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;res.<span class="hljs-built_in">size</span>();i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;res.<span class="hljs-built_in">size</span>();j++)&#123;                ans = <span class="hljs-built_in">min</span>(ans, res[i] | res[j]);            &#125;        &#125;        cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div><p>解法二：</p><p>更加直观一些，建立可持久化字典树，复杂度同样也是两个log</p><p>查询的时候，也是根据左右儿子的数量：如果0有多个，无脑走0；如果0恰好有1个，那么就走1，同时把这个0号节点记录下来。至多记录31个，最后把这31个节点重新拿过来暴力一下即可。</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Atcoder Beginner 246 FG EX</title>
    <link href="/2022/04/07/%E9%A2%98%E8%A7%A3/Atcoder%20ABC%20246%20FG%20EX%20-%20%E5%89%AF%E6%9C%AC/"/>
    <url>/2022/04/07/%E9%A2%98%E8%A7%A3/Atcoder%20ABC%20246%20FG%20EX%20-%20%E5%89%AF%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h4 id="f---typewriter">F - typewriter</h4><p>题意：给出 <span class="math inline">\(n\)</span> 个字符串和一个长度<spanclass="math inline">\(L\)</span>，接下来你可以任选一个字符串，并且只用这个串内有的字符来打字（不限制字符顺序，数量），问可以打出多少中长度为<span class="math inline">\(L\)</span> 的字符串。数据范围 <spanclass="math inline">\(N&lt;18\)</span>，<spanclass="math inline">\(L&lt;10^9\)</span></p><p><strong>第一种想法</strong>（没a）：可以暴力枚举所选的字符集，一共<span class="math inline">\(2^{26}\)</span>种情况，先预处理出每一种字符在哪些给定的串中出现（bitmask），把所选的字符集的出现位置与一下，如果与的结果不为0说明这一字符集是可选的，就加上使用这个字符集的答案。为了避免重复，还要求这个字符集内的每一个字符都必须用到。假设字符集有<span class="math inline">\(k\)</span> 个，那么答案就是将 <spanclass="math inline">\(L\)</span> 个位置分配给 <spanclass="math inline">\(k\)</span>个字符，每个字符必须分配到至少一个位置。</p><p>本以为这个应该是一个公式解决，但查了一下发现是第二类斯特林数，递推也要<span class="math inline">\(O(L)\)</span>，目前我没法记录这个值。</p><p><strong>第二种做法</strong>：暴力容斥，枚举选取了哪些串，计算使用同时被这些串所拥有的字符集的答案，如果选择了奇数个串答案就加上，否则答案就减去。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll x, ll p)</span></span>&#123;    ll r = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(p &gt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">if</span>(p &amp; <span class="hljs-number">1</span>) r = r * x % mode;        x = x * x % mode;        p /= <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> r;&#125;<span class="hljs-type">int</span> vis[<span class="hljs-number">27</span>];ll res[<span class="hljs-number">27</span>], ans = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n, l;    cin &gt;&gt; n &gt;&gt; l;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">26</span>;i++) res[i] = <span class="hljs-built_in">qpow</span>(i, l);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        string s;        cin &gt;&gt; s;        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: s) vis[i] |= (<span class="hljs-number">1</span> &lt;&lt; (c - <span class="hljs-string">&#x27;a&#x27;</span>));    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)&#123;        <span class="hljs-type">int</span> st = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">26</span>) - <span class="hljs-number">1</span>, f = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;            <span class="hljs-keyword">if</span>(i &amp; (<span class="hljs-number">1</span> &lt;&lt; (k<span class="hljs-number">-1</span>)))&#123;                st = st &amp; vis[k];                f *= <span class="hljs-number">-1</span>;            &#125;        &#125;        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">26</span>;k++) <span class="hljs-keyword">if</span>(st &amp; (<span class="hljs-number">1</span> &lt;&lt; k)) cnt++;        (ans += f * res[cnt]) %= mode;    &#125;    cout &lt;&lt; (ans % mode + mode) % mode &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="g---game-on-tree-3">G - Game on Tree 3</h4><p>题意：有一棵树，每个点有权值。Alice和Bob在玩游戏，一开始Bob在树根节点上，接下来轮流行动：</p><ul><li>Alice选择任意一个节点，将其权值清零</li><li>Bob选择一条相邻的边，移动到一棵子树上（不可返回）</li></ul><p>Bob可以随时结束游戏，问Bob能走到的最大点权是多少（Alice会让这个值尽可能小）</p><p>首先二分答案，假设答案为 <spanclass="math inline">\(k\)</span>，那么Alice就要在Bob走到任意大于 <spanclass="math inline">\(k\)</span> 的节点之前，清空这些节点。</p><p>再考虑树上dp，设 <span class="math inline">\(dp[i]\)</span>表示：当Bob走到 <span class="math inline">\(i\)</span>这个子树上后，Alice需要在这个子树上操作至少多少次才能阻止Bob</p><p>这么设置状态的原因是Alice可以提前处理一些比较远的点（在Bob目前没有威胁时）</p><p>转移时：<span class="math inline">\(dp[u] = \sumdp[v]-1+(val[v]&gt;k)\)</span></p><p>如果 <spanclass="math inline">\(dp[1]&gt;1\)</span>，说明Alice无法阻止Bob，继续二分调整答案。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, val[maxn];vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];<span class="hljs-type">int</span> f[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> lim)</span></span>&#123;    f[p] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v != fa)&#123;            <span class="hljs-built_in">dfs</span>(v, p, lim);            f[p] += <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, f[v]<span class="hljs-number">-1</span>) + (val[v] &gt; lim);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) cin &gt;&gt; val[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> u, v;        cin &gt;&gt; u &gt;&gt; v;        vp[u].<span class="hljs-built_in">push_back</span>(v);        vp[v].<span class="hljs-built_in">push_back</span>(u);    &#125;    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e9</span>;    <span class="hljs-keyword">while</span>(l &lt; r)&#123;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, mid);        <span class="hljs-keyword">if</span>(f[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span>)&#123;            l = mid + <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            r = mid;        &#125;    &#125;    cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="ex---01-queries">Ex - 01? Queries</h4><p>题意：给出一个长度为 <span class="math inline">\(n\)</span>的序列，仅包含 <code>0,1,?</code>，接下来有 <spanclass="math inline">\(Q\)</span>次操作，每次选择一个位置，将其修改为<code>0,1,?</code>中的一个，然后问你：当前序列包含多少种不同的子序列，<code>?</code>可以视为 <code>0</code> 或 <code>1</code></p><p>先不考虑修改，单独对一个序列如何求解：</p><p>设 <span class="math inline">\(dp[i][0/1]\)</span> 表示前 <spanclass="math inline">\(i\)</span> 位上，末尾为 <spanclass="math inline">\(0/1\)</span> 的子序列个数，转移时：</p><ul><li>若 <span class="math inline">\(s[i]=0\)</span>，则 <spanclass="math inline">\(dp[i][0]=dp[i-1][0]+dp[i-1][1]+1\)</span>，否则<span class="math inline">\(dp[i][0]=dp[i-1][0]\)</span></li><li>若 <span class="math inline">\(s[i]=1\)</span>，则 <spanclass="math inline">\(dp[i][1]=dp[i-1][0]+dp[i-1][1]+1\)</span>，否则<span class="math inline">\(dp[i][1]=dp[i-1][1]\)</span></li></ul><p><code>?</code> 则两者均成立</p><p>这种对子序列的dp没怎么见过，感觉挺玄妙的，以 <spanclass="math inline">\(dp[i][0]=dp[i-1][0]+dp[i-1][1]+1\)</span>为例，我的理解的思路是：</p><ul><li>先继承上一位的结果： <spanclass="math inline">\(dp[i-1][0]\)</span></li><li>然后对上一位的每一个子序列，都在末尾加上一个0，即加上：<spanclass="math inline">\(dp[i-1][0]+dp[i-1][1]+1\)</span>（包括空串加0）</li><li>然后减去重复部分，显然，上述第一部分是完全被第二部分包含的，那么直接把第一部分去掉即可。</li></ul><p>有了这个dp式子之后呢？怎么处理询问？</p><p>这个dp形式比较简单，可以考虑用矩阵来表示，还是以当前位为0举例： <spanclass="math display">\[\left[\begin{matrix}dp[i-1][0] &amp; dp[i-1][1] &amp; 1 \\\end{matrix}\right]\times\left[\begin{matrix}1 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 1\end{matrix}\right]=\left[\begin{matrix}dp[i][0] &amp; dp[i][1] &amp; 1 \\\end{matrix}\right]\]</span>同样可以把1和？表示成矩阵。我们要做单点修改矩阵值，查询整段矩阵乘积，可以用线段树维护。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mat</span>&#123;    <span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];    mat <span class="hljs-keyword">operator</span> *(<span class="hljs-type">const</span> mat &amp;t)<span class="hljs-type">const</span>&#123;        mat res = &#123;&#125;;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;j++)&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">3</span>;k++)&#123;                    (res.a[i][j] += <span class="hljs-number">1ll</span> * a[i][k] * t.a[k][j] % mode) %= mode;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;<span class="hljs-type">const</span> mat m[<span class="hljs-number">3</span>] = &#123;        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,         <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,         <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,         <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,         <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,         <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,         <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;;map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; fff&#123;&#123;<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-number">2</span>&#125;&#125;;string s;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">segTree</span>&#123;    mat sum[maxn &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;        sum[p] = sum[p*<span class="hljs-number">2</span>] * sum[p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>];    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> t)</span></span>&#123;        <span class="hljs-keyword">if</span>(l == r)&#123;            sum[p] = m[t];            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(pos &lt;= mid) <span class="hljs-built_in">modify</span>(p*<span class="hljs-number">2</span>, l, mid, pos, t);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r, pos, t);        <span class="hljs-built_in">push_up</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;        <span class="hljs-keyword">if</span>(l == r)&#123;            sum[p] = m[fff[s[l<span class="hljs-number">-1</span>]]];            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-built_in">build</span>(p*<span class="hljs-number">2</span>, l, mid);        <span class="hljs-built_in">build</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r);        <span class="hljs-built_in">push_up</span>(p);    &#125;&#125;segt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n, q;    cin &gt;&gt; n &gt;&gt; q;    cin &gt;&gt; s;    segt.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;        <span class="hljs-type">int</span> x; <span class="hljs-type">char</span> c;        cin &gt;&gt; x &gt;&gt; c;        segt.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, x, fff[c]);        mat res = mat&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,                      <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,                      <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125; * segt.sum[<span class="hljs-number">1</span>];        cout &lt;&lt; (<span class="hljs-number">1ll</span> * res.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + res.a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]) % mode &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Atcoder</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解后缀自动机</title>
    <link href="/2022/04/04/%E7%AC%94%E8%AE%B0/%E7%90%86%E8%A7%A3%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <url>/2022/04/04/%E7%AC%94%E8%AE%B0/%E7%90%86%E8%A7%A3%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h4 id="section">2022/4/4</h4><p>重新看了一遍</p><p>我确信此时此刻我已经完全看懂了 可惜这里地方太小写不下</p><hr /><p>专门对克隆节点这一地方做了一张图 希望未来的我还能看得懂<code>Orz</code></p><p><img src="http://lxtyin.ac.cn/img/other/string/SAM.png" /></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SAM</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git进阶</title>
    <link href="/2022/04/02/%E7%AC%94%E8%AE%B0/git%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/04/02/%E7%AC%94%E8%AE%B0/git%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="git存储原理">git存储原理</h4><p>git的存储比我想象的暴力的多（</p><p>自己尝试了一下发现，先提交一个10M的压缩包上去，<code>.git</code>文件的大小是10M多一点。</p><p>然后随便改这个压缩包的一点字符，再提交一次，<code>.git</code>变成20M了...</p><p>我曾一直以为它有什么神奇的办法可以记录任意类型文件的修改量，没想到它只是整个拷贝...</p><p>并且所有版本信息都存储在<code>.git</code>中，分支，提交节点什么的只是存储索引，因此git能够很快地创建和切换分支，我认为这也是一种空间换时间的做法。至少它在创新新分支时没有整个拷贝。</p><hr /><p>不过仔细一想，又发现这样存储文件，其实占用并不会特别大。git对每个文件单独暴力地存所有版本，在节点信息中，记录每个文件所在的版本号。上述例子中我用了一个压缩包作为单独的文件，但在实际工作中，其实很少会出现10M大小的单个文件，更多的是大量小文件的组合。修改一处，也只是会创建一个小文件的副本罢了。</p><h4 id="git存储实现">git存储实现</h4><p>粗略写一下大体概念，细节不重要（</p><p>首先，git对每个单独的文件暴力存储所有修改版本，每个版本有一ID（哈希生成的40位数），这些版本的实际数据存放在<code>.git/object</code>中，每个文件夹是一个两位数，里面有文件名38位的文件，存放实际数据。这些东西就是<strong>数据对象</strong>（blob）</p><p>每个文件夹作为一个<strong>树对象</strong>，树对象仅存储其目录下数据对象和子树对象的ID（当然是对应版本的），这样下来，最终的每个commit节点只需要存储一个树对象ID，和其父节点ID即可。</p><p>而分支仅仅只是指向commit节点的指针，因此git能很快地建立分支</p><h5 id="git如何发现你的修改">git如何发现你的修改</h5><p>这一点也比我想的暴力：直接对比当前工作区中的文件和commit节点中的文件是否一致。</p><p>当然也没那么暴力，还记得git存储的文件ID是通过哈希生成的吗，既然如此，只需要对比哈希值就可以了。</p><h5 id="追踪变更历史">追踪变更历史</h5><p>追踪变更历史这个东西，直观上来讲就是及其不严谨的...</p><p>试验了一下确实如此，<code>git log</code>这条命令，在<strong>文件重命名</strong>，<strong>文件移动路径</strong>，以及<strong>修改其路径上任意文件夹名</strong>时，都会导致其变更历史丢失。</p><p>由此可以简单猜测：git其实只是利用了树对象，记录了一个特定路径的文件的提交历史，在日常不频繁更改文件名和路径的情况下，这一命令才能正常追溯。</p><h4 id="git-diff原理">git Diff原理</h4><p>这里细化到一个问题：给你两段代码 <spanclass="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span>，如何仅根据这两串代码最后的样子推断出<span class="math inline">\(X\)</span> 是怎么修改到 <spanclass="math inline">\(Y\)</span> 的，当然方案有很多，gitDiff希望找出最优的，最优的原则基本有以下几条，按重要程度排序：</p><ul><li>修改量尽可能少，</li><li>同类修改（增加删除）尽可能多相邻</li><li>修改尽可能符合语法</li></ul><p>先不考虑最后一条，然后我们可以把问题想的简单点：假设程序员只会一行一行地修改代码，拿怕他只改了一个字符，我们也认为他修改了一行</p><p>这样把一片代码抽象成一个字符串，一行代表一个字符，我们要从S1通过删除字符，添加字符，变换到S2。</p><p>我直接贴：https://zhuanlan.zhihu.com/p/67024353建模很妙，可以n^2dp求解</p><p>至于第二条，我觉得不需要太过严谨，其实只需要简单规定一下优先级即可：优先删除，再是插入</p><p>第三条感觉严谨来说也很难搞，<del>不如不管了</del></p><h4 id="暂存区工作区">暂存区，工作区</h4><p>git add将工作区中的修改内容提交到暂存区，gitcommit将暂存区内容提交，保存为一个新的节点。</p><p>在切换分支，合并分支等过程中，必须要保证工作区clean，不然麻烦事很多</p><p>创建分支的话不影响（因为本地工作区不用动）</p><h4 id="git分支">git分支</h4><p>我的理解中，git是按照commit作为节点存放的，每个节点有其内容，父节点</p><p>所谓branch只是一个指向commit的指针。两个branch之间有祖孙关系，它们就很容易合并，否则需要进行一个三节点的合并：两个待合并的branch和它们的LCA</p><p>三节点合并成功之后，会产生一个新的节点，它有两个父亲</p><p>合并如果遇到冲突，暂不会产生节点，而是直接在你的工作区中修改，不冲突的部分合并完成，冲突的部分会在文件中打上特殊标记，长这样：</p><div class="code-wrapper"><pre><code class="hljs asciidoc">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<span class="hljs-section">b</span><span class="hljs-section">=======</span>a&gt;&gt;&gt;&gt;&gt;&gt;&gt; br1</code></pre></div><p>你可以手动地去文件中删除这些标记，改到你希望的样子，然后手动提交产生一个新节点。</p><h4 id="ssh">SSH</h4><p><code>ssh -T git@github.com</code> 中有哪些信息：</p><p>这条命令中的github.com即github网站的地址，它是一个git服务器</p><p>其中git是一个公用的用户，他记录了你的ssh公钥（我们写到github上的公钥）</p><p>我们连接时就是通过这个公用的用户git来传输的？</p><p>这条命令就是测试能否和github建立ssh连接</p><h4 id="git服务器">git服务器</h4><p>我们自己本地的git仓库和服务端的git仓库是不一样的，服务端的git仓库是一个裸仓库，仅保存了版本信息，没有工作区。</p><p>创建一个裸仓库：</p><div class="code-wrapper"><pre><code class="hljs bash">git init --bare</code></pre></div><p>裸仓库中无法查看提交的文件</p><p>向一个非裸仓库push会报错</p><p>如果想要搭建一个可以查看文件的git服务端，一个可行的办法是使用钩子(hook)，在接受到提交时，自动的转向另一个非裸仓库，再从这个裸库中pull一遍。现在这个页面就是通过这种方式部署的</p><h4 id="git实操">git实操</h4><p>这部分是实习的时候，发现自己实际操作非常手生，在公司记了一些</p><p><strong>fast-forward</strong>，即向前合并，跟进当前分支的最新提交，不会产生冲突，不会产生合并节点。</p><p><strong>git pull = git fetch + gitmerge</strong>，注意是merge而不是fast-forward，可以pull有分歧的分支（例如自己的开发分支完成后，主分支已经有新的东西了），然后在本地解决冲突。</p><p><strong>cherry pick</strong>单独提取一个commit的修改内容并应用。cherry-pick实际上是也是一个三路Merge，此时LCA视为目标commit的上一个commit。也就是说，以此LCA为基，我们的当前commit也视为是基于这个LCA修改的，这样来合并，当然也要解决冲突。再理一下：Base是目标commit的上一个commit，可能导致冲突的是当前commit和目标commit，各自相对Base的更改内容的不同之处。</p><p><strong>track</strong>，git的每个本地分支都追踪一个远程分支，在本地创建的分支，提交时需要推送上去形成一个新分支并追踪；远程的分支拉取到本地时，需要在本地创建一个分支并追踪。gitpull之类的操作默认拉取追踪的分支。</p><p><strong>HEAD</strong>，即当前分支，工作区所在的分支。</p><p>git通常都是在各个分支间进行切换操作，如果要切换到某个commit处，最好相应地创建一个分支（smartgit里的提示，基于commit的commit容易丢失。）</p><p><strong>submodule</strong>：子模块自己管自己的，主模块中，.gitmodules记录了子模块的本地路径和远程url，并在index中记录了子模块的状态（当前commitid），可以认为主模块git仅追踪了子模块的状态，而不追踪子模块的文件。子模块commitid发生变化时，主模块也会worktreenot clean（主模块中的记录与实际子模块id不一致）。 gitpull默认仅更新主模块，包括了主模块中记录的子模块id，而不会直接更新子模块，因此在主模块pull之后，可能仍然是worktreenot clean的状态，因为拉新后主模块记录id与子模块实际id不同了。</p><p>git pull支持递归拉新。</p><p>子模块中的远程分支，主模块是不知道的，子模块的远程有所更新并不会被主模块捕捉到，子模块需要自己去拉远程。</p><p>实际操作中会遇到更新了子模块，同时又要拉父模块的情况，此时可以先将子模块内容提交，然后回退（到父模块中记录的那个节点），使得父模块worktreeclean，然后拉父模块，再切换子模块到最新节点。父模块只是fast-forward时，似乎也可以在worktree not clean的情况下直接pull。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>版本控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Atcoder Beginner 245 G</title>
    <link href="/2022/03/31/%E9%A2%98%E8%A7%A3/Atcoder%20ABC%20245%20G/"/>
    <url>/2022/03/31/%E9%A2%98%E8%A7%A3/Atcoder%20ABC%20245%20G/</url>
    
    <content type="html"><![CDATA[<h4 id="g---foreign-friends">G - Foreign Friends</h4><p>题意：给出一个带边权的无向图，每个点有一个颜色，其中还有若干个特殊点。现在要求输出：每个点前往一个颜色与自己不同的特殊点的最短距离</p><p>解法：首先不考虑颜色，这个题就是一个魔改的dij，初始将所有特殊点加入队列跑一遍即可。</p><p>然后我们考虑颜色，可以将颜色按照二进制位拆开，枚举每一位，将所有<strong>在这一位上为0的特殊点</strong>加入队列跑一遍dij，并且更新<strong>在这一位上为1的点</strong>的答案。同样反过来也这么搞一遍</p><p>两个颜色不同，则它们至少有一位二进制是不同的（废话</p><p>所以任意点距离不同颜色的特殊点之间的最短路一定会被算到。</p><p>复杂度 <span class="math inline">\(O(logn*dij)\)</span></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m, K, L;<span class="hljs-type">int</span> a[maxn], b[maxn];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;    <span class="hljs-type">int</span> t;    ll dis;    <span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> x, ll y): <span class="hljs-built_in">t</span>(x), <span class="hljs-built_in">dis</span>(y)&#123;&#125;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &gt;(<span class="hljs-type">const</span> node &amp;p)<span class="hljs-type">const</span>&#123;        <span class="hljs-keyword">return</span> dis &gt; p.dis;    &#125;&#125;;vector&lt;node&gt; vp[maxn];ll dis[maxn], ans[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span></span>&#123;    priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt; &gt; q;    <span class="hljs-built_in">fill</span>(dis, dis+n+<span class="hljs-number">1</span>, <span class="hljs-number">1e18</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;L;i++)&#123;        <span class="hljs-keyword">if</span>((a[b[i]] &gt;&gt; k &amp; <span class="hljs-number">1</span>) == x)&#123;            q.<span class="hljs-built_in">push</span>(&#123;b[i], <span class="hljs-number">0</span>&#125;);            dis[b[i]] = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;        node u = q.<span class="hljs-built_in">top</span>();        q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">if</span>(dis[u.t] &lt; u.dis) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span>((a[u.t] &gt;&gt; k &amp; <span class="hljs-number">1</span>) == (x^<span class="hljs-number">1</span>)) ans[u.t] = <span class="hljs-built_in">min</span>(ans[u.t], dis[u.t]);        <span class="hljs-keyword">for</span>(node e: vp[u.t])&#123;            <span class="hljs-type">int</span> v = e.t;            <span class="hljs-keyword">if</span>(dis[v] &gt; dis[u.t] + e.dis)&#123;                dis[v] = dis[u.t] + e.dis;                q.<span class="hljs-built_in">emplace</span>(v, dis[v]);            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; K &gt;&gt; L;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;L;i++) cin &gt;&gt; b[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-type">int</span> u, v, d;        cin &gt;&gt; u &gt;&gt; v &gt;&gt; d;        vp[u].<span class="hljs-built_in">emplace_back</span>(v, d);        vp[v].<span class="hljs-built_in">emplace_back</span>(u, d);    &#125;    <span class="hljs-built_in">fill</span>(ans, ans+n+<span class="hljs-number">1</span>, <span class="hljs-number">1e18</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">17</span>;k&gt;=<span class="hljs-number">0</span>;k--)&#123;        <span class="hljs-built_in">dij</span>(k, <span class="hljs-number">0</span>);        <span class="hljs-built_in">dij</span>(k, <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout &lt;&lt; (ans[i] &gt; (ll)<span class="hljs-number">1e17</span> ? <span class="hljs-number">-1</span> : ans[i]) &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Atcoder</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 779 div.2 D2F</title>
    <link href="/2022/03/29/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20779%20div.2%20D2E/"/>
    <url>/2022/03/29/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20779%20div.2%20D2E/</url>
    
    <content type="html"><![CDATA[<h4 id="d2.-388535-hard-version">D2. 388535 (Hard Version)</h4><p>题意：给出两个数 <span class="math inline">\(l,r\)</span>和一个数字集合 <span class="math inline">\(a\)</span>，有某个 <spanclass="math inline">\(x\)</span>，使得 <spanclass="math inline">\([l,r]\)</span> 范围内的这些数分别异或上 <spanclass="math inline">\(x\)</span> 之后，结果恰好能组成序列 <spanclass="math inline">\(a\)</span>。要求找到一个合法的 <spanclass="math inline">\(x\)</span>，保证有解。</p><p>对于每一位去考虑：如果在某一个二进制位上，两边集合0和1的个数不相等，比如<span class="math inline">\(l...r\)</span> 中共有3个0，2个1；序列 <spanclass="math inline">\(a\)</span>中共有2个0，3个1，那么必须要让数量对调，可以直接得出 <spanclass="math inline">\(x\)</span>在这一二进制位上必为1。不能对调则这一位上必为0</p><p>从高位到低位依次进行，每次把 <span class="math inline">\(l,r\)</span>和 <span class="math inline">\(a\)</span>分别分为高位为0和1的四组，然后根据数量对应上，分开递归向下求解。</p><p><strong>但</strong>如果两边集合0和1的个数全部相等呢？那么在这一位上，无法确定取0还是取1，有没有可能都可以呢？</p><p>接下来证明：在<strong>最高位处</strong>，如果0和1的个数相等，不论怎么取，都不影响解的存在。</p><p>因为 <span class="math inline">\(l,r\)</span>是一个连续的区间，我们考虑最高位为1的分界线，其实也就是 <spanclass="math inline">\(l,r\)</span> 的中点（因为要0和1一样多）</p><p>随便举个例子：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">l</span>=<span class="hljs-number">5</span>   <span class="hljs-number">0101</span><span class="hljs-attribute">6</span>     <span class="hljs-number">0110</span><span class="hljs-attribute">7</span>     <span class="hljs-number">0111</span><span class="hljs-attribute">8</span>     <span class="hljs-number">1000</span><span class="hljs-attribute">9</span>     <span class="hljs-number">1001</span><span class="hljs-attribute">r</span>=<span class="hljs-number">10</span>  <span class="hljs-number">1010</span></code></pre></div><p>在最高位上，我们遇到了0和1个数相等的情况，将它们分为两组，我们发现后面的位置上数字恰好是相反的。</p><p>因为一个是从000开始加，另一个是从111开始减，当然是完全相反的。</p><p>也就是说，此时对调这两组分配给 <span class="math inline">\(a\)</span>的方式，仅仅只是让后续答案对调，该有解还是有解，不用担心此处取值的伏笔。另外，分配到<span class="math inline">\(a\)</span> 的子 <spanclass="math inline">\(l,r\)</span>仍然是连续的。我们只需要在最高位处做完之后把最高位抹去，后续仍然满足这个条件。</p><p>具体实现上，先将 <span class="math inline">\(a\)</span>插入字典树，然后递归向下求解会比较方便</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;    <span class="hljs-type">int</span> cnt;    <span class="hljs-type">int</span> ch[<span class="hljs-number">2</span>];&#125;t[maxn &lt;&lt; <span class="hljs-number">5</span>];<span class="hljs-type">int</span> tcnt = <span class="hljs-number">1</span>; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    <span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">17</span>;k&gt;=<span class="hljs-number">0</span>;k--)&#123;        <span class="hljs-type">int</span> v = (x &gt;&gt; k) &amp; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(!t[p].ch[v])&#123;            t[p].ch[v] = ++tcnt;            t[tcnt].cnt = <span class="hljs-number">0</span>;            t[tcnt].ch[<span class="hljs-number">0</span>] = t[tcnt].ch[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;        &#125;        p = t[p].ch[v];        t[p].cnt++;    &#125;&#125; <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> lv, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;    <span class="hljs-keyword">if</span>(lv &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-type">int</span> mid = r;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;i++)&#123;        <span class="hljs-keyword">if</span>((i &gt;&gt; lv) &amp; <span class="hljs-number">1</span>)&#123;            mid = i<span class="hljs-number">-1</span>;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span>(mid-l+<span class="hljs-number">1</span> == t[t[p].ch[<span class="hljs-number">0</span>]].cnt)&#123;        <span class="hljs-keyword">if</span>(mid &gt;= l) <span class="hljs-built_in">work</span>(t[p].ch[<span class="hljs-number">0</span>], lv<span class="hljs-number">-1</span>, l, mid);        <span class="hljs-keyword">if</span>(mid &lt; r) <span class="hljs-built_in">work</span>(t[p].ch[<span class="hljs-number">1</span>], lv<span class="hljs-number">-1</span>, (mid+<span class="hljs-number">1</span>)^(<span class="hljs-number">1</span>&lt;&lt;lv), r^(<span class="hljs-number">1</span>&lt;&lt;lv));    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">if</span>(mid &gt;= l) <span class="hljs-built_in">work</span>(t[p].ch[<span class="hljs-number">1</span>], lv<span class="hljs-number">-1</span>, l, mid);        <span class="hljs-keyword">if</span>(mid &lt; r) <span class="hljs-built_in">work</span>(t[p].ch[<span class="hljs-number">0</span>], lv<span class="hljs-number">-1</span>, (mid+<span class="hljs-number">1</span>)^(<span class="hljs-number">1</span>&lt;&lt;lv), r^(<span class="hljs-number">1</span>&lt;&lt;lv));        ans |= (<span class="hljs-number">1</span> &lt;&lt; lv);    &#125;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    tcnt = <span class="hljs-number">1</span>;    ans = <span class="hljs-number">0</span>;    t[<span class="hljs-number">1</span>].ch[<span class="hljs-number">0</span>] = t[<span class="hljs-number">1</span>].ch[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;     <span class="hljs-type">int</span> l, r;    cin &gt;&gt; l &gt;&gt; r;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;i++)&#123;        <span class="hljs-type">int</span> x; cin &gt;&gt; x;        <span class="hljs-built_in">insert</span>(x);    &#125;    <span class="hljs-built_in">work</span>(<span class="hljs-number">1</span>, <span class="hljs-number">17</span>, l, r);    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="e.-gojou-and-matrix-game">E. Gojou and Matrix Game</h4><p>题意：有一个 <span class="math inline">\(n\times n\)</span>的网格，每个格子上有一个分数 <spanclass="math inline">\(1...n^2\)</span>，不重复。接下来两个人玩游戏，第一名玩家首先占据<span class="math inline">\(sx, sy\)</span>格，随后轮流选择格子占据，要求满足以下条件：</p><ul><li>选取的格子距离另一名玩家上次占据的格子的曼哈顿距离不超过 <spanclass="math inline">\(k\)</span></li><li>可以重复占据，每次占据都能获得该格子上的分数（可重复获得）</li></ul><p>请问对于每个起始坐标 <span class="math inline">\(sx,sy\)</span>，玩<span class="math inline">\(10^{100}\)</span> 轮，谁能获胜？</p><p>首先不难发现，分数是不重复的，那么分数最高的格子只有一个，谁先占到谁就赢了。</p><p>游戏规则是不能选取距对方上次选取位置 <spanclass="math inline">\(k\)</span>格以内的，双方有可能互相僵持，都占不到最高分的点</p><p>那么再去考虑次高分的位置：如果次高分的控制范围内包括了最高分，那么这也是一个先手必胜点（即使对方跟你僵持都拿不到最高，但你拿的是次高，所以也是必胜）。否则这就是先手必败点。</p><p>如此考虑下去，我们发现：对于一个包含 <spanclass="math inline">\(x\)</span>分的点来说，只要它的掌控范围内包含了所有比 <spanclass="math inline">\(x\)</span> 大的必胜点，<spanclass="math inline">\(x\)</span> 就是必胜点。否则为必败点。</p><hr /><p>另外再给出一种博弈论常用的思路：如果我选择了分数为 <spanclass="math inline">\(x\)</span> 的点后，对方不得不选择分数小于 <spanclass="math inline">\(x\)</span>的点，那么我就是必胜的，因为我可以继续选择当前点，这个逻辑在双方都进行最优策略下是完全正确的。</p><hr /><p>那么问题就变成了如何判断。我们按照权值从大到小枚举，每遇到一个必胜点，都将它的位置丢进一个集合，只要集合中是否存在到当前枚举点距离<span class="math inline">\(\gt k\)</span> 的位置就可以了。</p><p>当然暴力判断怎么样都是 <span class="math inline">\(n^3\)</span>的，此处又有一个神奇的“放宽解空间”思想：</p><p>想判断 <span class="math inline">\(|i-i&#39;|+|j-j&#39;|\lek\)</span> ，它等价于 <spanclass="math inline">\(max(|i+j-(i&#39;+j&#39;)|,|i-j-(i&#39;-j&#39;)|)\)</span></p><p>然后就只需要记录 <span class="math inline">\(i+j\)</span>，<spanclass="math inline">\(i-j\)</span> 的最大最小值即可...</p><p>难想...</p><p>本质上是放宽了解空间，使得更容易维护</p><p>感觉这种东西都挺难发现的，记一下吧（</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 117</title>
    <link href="/2022/03/23/%E9%A2%98%E8%A7%A3/Educational%20Codeforces%20Round%20125/"/>
    <url>/2022/03/23/%E9%A2%98%E8%A7%A3/Educational%20Codeforces%20Round%20125/</url>
    
    <content type="html"><![CDATA[<h4 id="d.-for-gamers.-by-gamers.">D. For Gamers. By Gamers.</h4><p>题意：玩家有 <span class="math inline">\(C\)</span>块钱，可以从酒馆中招募随从，每个随从有攻击力 <spanclass="math inline">\(d_i\)</span>，生命 <spanclass="math inline">\(h_i\)</span>，花费 <spanclass="math inline">\(c_i\)</span>块钱。接下来有若干轮战斗，每轮战斗有一个敌人，攻击力 <spanclass="math inline">\(D_j\)</span>，生命 <spanclass="math inline">\(H_j\)</span>。每轮相互独立（钱也独立），玩家可以招募若干个<strong>相同</strong>随从来和怪物战斗，但要求己方没有随从会死亡。问每一轮战斗需要花费至少多少金币</p><p>战斗不是回合制的，双方连续攻击。</p><p>解：因为是双方连续攻击，所以两个怪物战斗，我放胜利的条件即 <spanclass="math inline">\(H/d\lt h/D\)</span>，换算一下即：<spanclass="math inline">\(H\times D\lt h\times d\)</span></p><p>那么每个怪物的战斗力都可以直接用其攻击乘上生命来衡量。</p><p>如果购买多个随从同时作战，因为要求不能死任何一个，所以相当于攻击力可叠加，但生命值不能叠加。其实战斗力是完全等比例增长的。</p><p>那么就变成了一个背包问题，但数据范围显然不允许 <spanclass="math inline">\(n^2\)</span>，这时发现题目又有一个条件：只能购买相同随从。</p><p>那么在背包转移时，只需要枚举每个随从花费金币的倍数去更新即可。复杂度是经典调和级数<span class="math inline">\(O(nlogn)\)</span></p><p>最后每轮询问二分找一下大于这个怪物战斗力的最小花费（</p><div class="code-wrapper"><pre><code class="hljs c++">ll n, m;ll mxc[maxn], f[maxn]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    ll C;    cin &gt;&gt; n &gt;&gt; C;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        ll c, x, y;        cin &gt;&gt; c &gt;&gt; x &gt;&gt; y;        f[c] = <span class="hljs-built_in">max</span>(f[c], x * y);    &#125;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=C;i++)&#123;        f[i] = <span class="hljs-built_in">max</span>(f[i], f[i<span class="hljs-number">-1</span>]);        <span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">2</span>;j*i&lt;=C;j++)&#123;            f[j*i] = <span class="hljs-built_in">max</span>(f[j*i], f[i] * j);        &#125;    &#125;     cin &gt;&gt; m;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        ll x, y;        cin &gt;&gt; x &gt;&gt; y;        <span class="hljs-keyword">if</span>(f[C] &lt;= x * y)&#123;            cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == m];            <span class="hljs-keyword">continue</span>;        &#125;        ll p = <span class="hljs-built_in">lower_bound</span>(f+<span class="hljs-number">1</span>, f+C+<span class="hljs-number">1</span>, x * y + <span class="hljs-number">1</span>) - f;        cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == m];    &#125;&#125;</code></pre></div><h4 id="e.-star-mst">E. Star MST</h4><p>题意：对于 <span class="math inline">\(n\)</span>个节点的完全图，每条边不超过 <spanclass="math inline">\(m\)</span>，如果所有和1相连的边能构成最小生成树，那么这个完全图是好的。请问一共有多少种好的完全图？</p><p>从kruskal角度考虑：在我们依次将边插入时，除了1以外不能存在其他联通块，否则即不是最小生成树。</p><p>设 <span class="math inline">\(dp[i][j]\)</span> 为已经将小于等于<span class="math inline">\(j\)</span> 的所有边插入，此时1的联通块大小为<span class="math inline">\(i\)</span> 的答案。</p><p>转移时，插入所有长度为 <span class="math inline">\(j+1\)</span>的边，枚举有多少个点因此并入联通块了（假设有 <spanclass="math inline">\(k\)</span> 个），那么一共有 <spanclass="math inline">\(C_{n-i}^{k}\)</span> 种取法，并入后新增的边数为<span class="math inline">\(k\times(k-1)/2+i\times k\)</span>，其中<span class="math inline">\(k\)</span> 条确定长度为 <spanclass="math inline">\(j+1\)</span> 了，另外的边长度可以在 <spanclass="math inline">\([j+1，m]\)</span> 之间任选。</p><p>转移：<span class="math inline">\(dp[i+k][j+1]+=dp[i][k]\timesC_{n-i}^k\times(m-j)^{k\times (k-1)/2+(i-1)\times k}\)</span></p><div class="code-wrapper"><pre><code class="hljs c++">ll n, m;ll f[<span class="hljs-number">300</span>][<span class="hljs-number">300</span>]; <span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll x, ll p)</span></span>&#123;    ll r = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(p &gt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">if</span>(p &amp; <span class="hljs-number">1</span>) r = r * x % mode;        x = x * x % mode;        p /= <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> r;&#125; <span class="hljs-function">ll <span class="hljs-title">inv</span><span class="hljs-params">(ll x)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">qpow</span>(x, mode<span class="hljs-number">-2</span>);&#125;ll jc[maxn];<span class="hljs-function">ll <span class="hljs-title">C</span><span class="hljs-params">(ll n, ll m)</span></span>&#123;    <span class="hljs-keyword">return</span> jc[n] * <span class="hljs-built_in">inv</span>(jc[m] * jc[n-m] % mode) % mode;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    jc[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1000</span>;i++) jc[i] = jc[i<span class="hljs-number">-1</span>] * i % mode;     cin &gt;&gt; n &gt;&gt; m;    f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;i+k&lt;=n;k++)&#123;                (f[i+k][j+<span class="hljs-number">1</span>] += f[i][j] * <span class="hljs-built_in">C</span>(n-i, k) % mode * <span class="hljs-built_in">qpow</span>(m-j, k*(k<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span> + (i<span class="hljs-number">-1</span>)*k) % mode) %= mode;            &#125;        &#125;    &#125;    cout &lt;&lt; f[n][m] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="f.-words-on-tree">F. Words on Tree</h4><p>写的稀碎，看看思路就好，代码别看了（</p><p>题意：现在有一棵树，每个点上有一个字符，给定了若干个限制条件，形如<span class="math inline">\(x,y,s\)</span>，表示树上 <spanclass="math inline">\(x\)</span> 到 <spanclass="math inline">\(y\)</span> 的路径上的字符连起来必须是 <spanclass="math inline">\(s\)</span> 或者 <spanclass="math inline">\(s\)</span>的反串。你需要填写树上的字符使得所有限制条件都被满足。</p><p>既然有限制条件，并且这个限制条件显然是二选一，我们肯定要往2-SAT方向去想</p><p>对每个限制条件建两个点，一个表示字符正着放，另一个表示反着放。问题是怎么连边，似乎怎么连都得<span class="math inline">\(n^2\)</span> 条边</p><p>这里的关键在于：并不需要把所有约束条件都表示出来，只要一个约束条件已经被已有约束包含，就可以忽略它</p><p>具体而言，我们在每一个节点处<strong>随便</strong>选取一个涉及这个节点的约束条件，那么可以确定这个节点一定是两种字符之一，我们称这个被选择的约束条件为哨兵。</p><p>对于任意两个有重复部分的约束条件，它们都去和哨兵建立联系，它们两个之间的约束关系也就通过哨兵建立了。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn], vp2[maxn];<span class="hljs-type">int</span> dep[maxn], fa[maxn], bin[maxn];<span class="hljs-type">char</span> chr[maxn][<span class="hljs-number">2</span>]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> f)</span></span>&#123;    fa[p] = f;    dep[p] = dep[f] + <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v != f) <span class="hljs-built_in">dfs</span>(v, p);    &#125;&#125; <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getPath</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;    vector&lt;<span class="hljs-type">int</span>&gt; r1, r2;    <span class="hljs-keyword">while</span>(u != v)&#123;        <span class="hljs-keyword">if</span>(dep[u] &gt; dep[v]) r1.<span class="hljs-built_in">push_back</span>(u), u = fa[u];        <span class="hljs-keyword">else</span> r2.<span class="hljs-built_in">push_back</span>(v), v = fa[v];    &#125;    r1.<span class="hljs-built_in">push_back</span>(u);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=(<span class="hljs-type">int</span>)r2.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) r1.<span class="hljs-built_in">push_back</span>(r2[i]);    <span class="hljs-keyword">return</span> r1;&#125; <span class="hljs-type">int</span> dfn[maxn], low[maxn], bel[maxn], dfcnt = <span class="hljs-number">0</span>;stack&lt;<span class="hljs-type">int</span>&gt; stk;<span class="hljs-type">int</span> belid = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjian</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;    dfn[p] = low[p] = ++dfcnt;    stk.<span class="hljs-built_in">push</span>(p);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp2[p])&#123;        <span class="hljs-keyword">if</span>(!dfn[v]) <span class="hljs-built_in">tarjian</span>(v);        <span class="hljs-keyword">if</span>(!bel[v]) low[p] = <span class="hljs-built_in">min</span>(low[p], low[v]);    &#125;    <span class="hljs-keyword">if</span>(dfn[p] == low[p])&#123;        bel[p] = ++belid;        <span class="hljs-keyword">while</span>(stk.<span class="hljs-built_in">top</span>() != p)&#123;            bel[stk.<span class="hljs-built_in">top</span>()] = belid;            stk.<span class="hljs-built_in">pop</span>();        &#125;        stk.<span class="hljs-built_in">pop</span>();    &#125;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        vp[x].<span class="hljs-built_in">push_back</span>(y);        vp[y].<span class="hljs-built_in">push_back</span>(x);    &#125;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">query</span>&#123;        <span class="hljs-type">int</span> x, y;        string s;    &#125;;    <span class="hljs-function">vector&lt;query&gt; <span class="hljs-title">qr</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-type">int</span> x, y;        string s;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; s;        qr[i] = &#123;x, y, s&#125;;        <span class="hljs-keyword">auto</span> l = <span class="hljs-built_in">getPath</span>(x, y);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;l.<span class="hljs-built_in">size</span>();j++)&#123;            <span class="hljs-keyword">if</span>(!bin[l[j]])&#123;                chr[l[j]][<span class="hljs-number">0</span>] = s[j];                chr[l[j]][<span class="hljs-number">1</span>] = s[s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>-j];                bin[l[j]] = i;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        string s = qr[i].s;        <span class="hljs-keyword">auto</span> l = <span class="hljs-built_in">getPath</span>(qr[i].x, qr[i].y);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;l.<span class="hljs-built_in">size</span>();j++)&#123;            <span class="hljs-type">char</span> mc[<span class="hljs-number">2</span>] = &#123;s[j], s[s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>-j]&#125;;            <span class="hljs-type">char</span> *yc = chr[l[j]];            <span class="hljs-type">int</span> yj = bin[l[j]];            <span class="hljs-keyword">if</span>(yj == i) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span>(yc[<span class="hljs-number">0</span>] == yc[<span class="hljs-number">1</span>] &amp;&amp; mc[<span class="hljs-number">0</span>] == mc[<span class="hljs-number">1</span>] &amp;&amp; yc[<span class="hljs-number">0</span>] == mc[<span class="hljs-number">0</span>]) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span>(yc[<span class="hljs-number">0</span>] == yc[<span class="hljs-number">1</span>])&#123;                <span class="hljs-keyword">if</span>(mc[<span class="hljs-number">0</span>] != yc[<span class="hljs-number">0</span>] &amp;&amp; mc[<span class="hljs-number">1</span>] != yc[<span class="hljs-number">0</span>])&#123;                    cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;                    <span class="hljs-keyword">return</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">if</span>(mc[<span class="hljs-number">0</span>] == yc[<span class="hljs-number">0</span>]) vp2[m+i].<span class="hljs-built_in">push_back</span>(i);                    <span class="hljs-keyword">else</span> vp2[i].<span class="hljs-built_in">push_back</span>(m+i);                &#125;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mc[<span class="hljs-number">0</span>] == mc[<span class="hljs-number">1</span>])&#123;                <span class="hljs-keyword">if</span>(mc[<span class="hljs-number">0</span>] != yc[<span class="hljs-number">0</span>] &amp;&amp; mc[<span class="hljs-number">0</span>] != yc[<span class="hljs-number">1</span>])&#123;                    cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;                    <span class="hljs-keyword">return</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">if</span>(mc[<span class="hljs-number">0</span>] == yc[<span class="hljs-number">0</span>]) vp2[yj+m].<span class="hljs-built_in">push_back</span>(yj);                    <span class="hljs-keyword">else</span> vp2[yj].<span class="hljs-built_in">push_back</span>(yj+m);                &#125;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-type">bool</span> fd = <span class="hljs-literal">false</span>;                 <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;<span class="hljs-number">2</span>;u++)&#123;                    <span class="hljs-keyword">if</span>(mc[u] != yc[<span class="hljs-number">0</span>] &amp;&amp; mc[u] != yc[<span class="hljs-number">1</span>])&#123;                        vp2[i+m*u].<span class="hljs-built_in">push_back</span>(i+m*(u^<span class="hljs-number">1</span>));                    &#125;                &#125;                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;<span class="hljs-number">2</span>;u++)&#123;                    <span class="hljs-keyword">if</span>(yc[u] != mc[<span class="hljs-number">0</span>] &amp;&amp; yc[u] != mc[<span class="hljs-number">1</span>])&#123;                        vp2[yj+m*u].<span class="hljs-built_in">push_back</span>(yj+m*(u^<span class="hljs-number">1</span>));                    &#125;                &#125;                 <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;<span class="hljs-number">2</span>;u++)&#123;                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;<span class="hljs-number">2</span>;v++)&#123;                        <span class="hljs-keyword">if</span>(mc[u] == yc[v])&#123;                            fd = <span class="hljs-literal">true</span>;                            vp2[i+m*u].<span class="hljs-built_in">push_back</span>(yj+m*v);                            vp2[yj+m*v].<span class="hljs-built_in">push_back</span>(i+m*u);                        &#125;                    &#125;                &#125;                <span class="hljs-keyword">if</span>(!fd)&#123;                    cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;                    <span class="hljs-keyword">return</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*m;i++) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjian</span>(i);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-keyword">if</span>(bel[i] == bel[i+m])&#123;            cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cs</span><span class="hljs-params">(m+<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-keyword">if</span>(bel[i] &lt; bel[i+m]) cs[i] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">else</span> cs[i] = <span class="hljs-number">1</span>;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(!bin[i]) cout &lt;&lt; <span class="hljs-string">&#x27;a&#x27;</span>;        <span class="hljs-keyword">else</span> cout &lt;&lt; chr[i][cs[bin[i]]];    &#125;    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022浙江工商大学acm校赛总结</title>
    <link href="/2022/03/14/%E6%9D%82%E8%B0%88/2022%E6%B5%99%E6%B1%9F%E5%B7%A5%E5%95%86%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <url>/2022/03/14/%E6%9D%82%E8%B0%88/2022%E6%B5%99%E6%B1%9F%E5%B7%A5%E5%95%86%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>开局首先乱开选到了炸弹题，快速想了个bfs搞法后就开始写了，连wa三发之后发现不对劲，仔细想了一下发现思路是假的，这个时候已经半个小时了，榜上两个签到题已经被过穿，我还只有一个-3，开局稀碎</p><p>然后选择先把代码存起来去写签到，回文子序列属于经典的那种cfA题，平时会打cf的新生写这个应该不需要5分钟（</p><p>质因数分解题 我还稍微卡了一会 数学属实是碰的太少了</p><p>搞完两个签到回去搞炸弹题，重新想了一下发现是个缩点，抄一波tarjian板子过掉</p><p>然后就开始了大寄特寄的0号题，一个sb最短路+路径计数，硬是找不到wa点，造的数据都过，交上去全是wa。再结合这个题目描述（直观看起来是无向图但是没有明说；边权只写了上限没有写下界；数据规模允许<spanclass="math inline">\(n^2\)</span>），总之存在诸多疑点，那么dij换成spfa试了试，无向图改有向图试试，同时改试试...于是对 <span class="math inline">\(n\)</span> 项疑点开始 <spanclass="math inline">\(2^n\)</span>爆搜式提交，然而都没有过（我现在还不知道为什么wa）</p><p>此时的情况非常不妙，这个0号题已经过了十几个人了，差不多是所有大二三 +一些新生，感觉非常危，但硬wa也没什么办法，于是弃题去搞别的了</p><p>很快发现取石子是个诈骗题，直接输出Alice，没关同步流还T一发</p><p>然后发现一棵刻入DNA的线段树，快速切掉没有什么压力</p><p>接着是那个函数题，看错题目绕了一会，回过神来发现其实开个优先队列乱搞就行了，<spanclass="math inline">\(nlogn\)</span> 没有什么问题</p><p>到这个时候差不多还有四十分钟，我做了个错误的决定：继续回去卡那个最短路...于是又是交了一堆wa，中途简单看了一下字符串题和dp题，字符串题面稀碎，没读明白；dp题想了个有点复杂的搞法，感觉时间来不及而且不一定对，就回去wa最短路了...一直wa到比赛结束，最后-19没搞出来，但场上一共过了差不多20个，快变成签到了。</p><p>最后6题rk3，没打过大一爷，非常不满意（寄，主要是该写出来的没写出来</p><p>总结一下，感觉心态还有点问题，一wa就容易乱交，另外弃题弃的不够彻底，dp题不一定能搞出来，但那个字符串，稍微花点时间读明白的话就会发现是个sb字典树，最后时间不重新回去卡最短路的话，这个也应该能出来（虽然出来了还是打不过大一爷，orz</p><h2 id="补题">补题：</h2><h4 id="dwendwen给大佬分组">Dwendwen给大佬分组</h4><p>众所周知，实验室的同学们都是大佬。现在实验室共有N位大佬，为了发挥大佬们的辐射能力，Dwendwen准备按座位将其分为k个学习小组。</p><p>为了简化问题，我们假设实验室的座位是一种长度为N（N个座位）的线状结构，坐在第i个位置的大佬有影响力ai。在不能调整座位的前提下，Dwendwen需要将大佬们分为k组，其中每个组内的大佬都是座位连续的。一个小组的战斗力为小组所有大佬中，最大影响力与最小影响力之差，即max(a)-min(a)。</p><p>现在Dwendwen希望让实验室k个小组的总战斗力最大化，你能帮帮他吗？</p><h5 id="input">Input:</h5><p>第一行为两个空格分割的整数N(1≤N≤10000)和k(1≤k≤N)，分别表示实验室人数和小组个数。</p><p>第二行为N个空格分割的正整数，第i个数字ai(1≤ai≤500000)为坐在第i个位置的大佬的影响力。</p><h5 id="output">Output:</h5><p>实验室所有小组的总战斗力的最大值。</p><h5 id="sample-input">Sample Input:</h5><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">1</span><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span></code></pre></div><h5 id="sample-output">Sample Output:</h5><div class="code-wrapper"><pre><code class="hljs">4</code></pre></div><p>先是朴素的 <span class="math inline">\(n^3\)</span> dp做法，<spanclass="math inline">\(dp[i][j]\)</span> 表示前 <spanclass="math inline">\(i\)</span> 个数，分成 <spanclass="math inline">\(j\)</span> 组的最大答案</p><p>转移有 <span class="math inline">\(dp[i][j] =dp[k][j-1]+max(a[k+1..i])-min(a[k+1..i])\)</span>，枚举这个 <spanclass="math inline">\(k\)</span></p><p>第一反应是拿某种单调队列来优化掉这一维 <spanclass="math inline">\(k\)</span>，但是比较难搞</p><p>题解给了个不错的思路：放宽解空间</p><p>也就是说，我们可以把题意转换一下，转换后多了一些无意义的解，并不影响答案，但是能让优化变得更简单</p><p>本题的权值是 <spanclass="math inline">\(max-min\)</span>，典中典，我们可以把它改成<strong>任意两数相减</strong>，显然最大的结果仍然是<span class="math inline">\(max-min\)</span></p><p>那么转移时，考虑新加进来的 <span class="math inline">\(a[i]\)</span>的成分：</p><ul><li>不参与加减运算，<span class="math inline">\(dp[i][j] =dp[i-1][j]\)</span></li><li>作为被减数，<span class="math inline">\(dp[i][j] =dp[k][j-1]+a[k+1]-a[i]\)</span>，这里相当于在枚举减数</li><li>作为减数，<spanclass="math inline">\(dp[i][j]=dp[k][j-1]+a[i]-a[k+1]\)</span>，相当于枚举被减数</li></ul><p>可以发现，我们只需要知道 <spanclass="math inline">\(dp[k][j-1]+a[k+1]\)</span> 的最大值，以及 <spanclass="math inline">\(dp[k][j-1]-a[k+1]\)</span> 的最大值，就能做到<span class="math inline">\(O(1)\)</span> 转移了</p><p>这两个值沿途记录一下即可，不难维护。</p><hr /><p>再写另一种理解方式：</p><p>原题中，一个区间的权值是 <spanclass="math inline">\(max-min\)</span>，那么可以发现，如果一个区间的边界元素不是其最大或最小值，那么把这个边界元素丢给隔壁区间一定不会更差。</p><p>所以最后我们其实是把整个数组分成了两种区间：两端分别是极大极小值的区间，和放哪都一样的区间（可以忽略的区间）</p><p>那么 <span class="math inline">\(dp\)</span>转移的思路也比较清晰了（dp含义和上文相同）：</p><ul><li>当前元素不是区间的边界（在区间内部或者被忽略），<spanclass="math inline">\(dp[i][j] = dp[i-1][j]\)</span></li><li>当前元素是区间边界，且是极小值，<span class="math inline">\(dp[i][j]= dp[k][j-1]+a[k+1]-a[i]\)</span></li><li>当前元素是区间边界，且是极大值，<spanclass="math inline">\(dp[i][j]=dp[k][j-1]+a[i]-a[k+1]\)</span></li></ul><p>就和上面的转移方程是一样的。</p><p>最后，这个题的数据范围是 <spanclass="math inline">\(10^4\)</span>，滚动数组优化一下空间。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn];ll f[<span class="hljs-number">10003</span>][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-type">int</span> mxa = a[<span class="hljs-number">1</span>], mia = a[<span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        mxa = <span class="hljs-built_in">max</span>(mxa, a[i]);        mia = <span class="hljs-built_in">min</span>(mia, a[i]);        f[i][<span class="hljs-number">1</span>] = mxa - mia;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">2</span>;k&lt;=m;k++)&#123;        <span class="hljs-type">int</span> nw = k % <span class="hljs-number">2</span>;        f[k<span class="hljs-number">-1</span>][nw] = <span class="hljs-number">0</span>;        ll mx = f[k<span class="hljs-number">-1</span>][nw^<span class="hljs-number">1</span>] + a[k], mi = a[k] - f[k<span class="hljs-number">-1</span>][nw^<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k;i&lt;=n;i++)&#123;            f[i][nw] = <span class="hljs-built_in">max</span>(&#123;f[i<span class="hljs-number">-1</span>][nw], mx - a[i], a[i] - mi&#125;);            mx = <span class="hljs-built_in">max</span>(mx, f[i][nw^<span class="hljs-number">1</span>] + a[i+<span class="hljs-number">1</span>]);            mi = <span class="hljs-built_in">min</span>(mi, a[i+<span class="hljs-number">1</span>] - f[i][nw^<span class="hljs-number">1</span>]);        &#125;    &#125;    cout &lt;&lt; f[n][m%<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zjgsu校赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 774 div.2 DEF</title>
    <link href="/2022/03/05/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20774%20div.2%20DEF/"/>
    <url>/2022/03/05/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20774%20div.2%20DEF/</url>
    
    <content type="html"><![CDATA[<h4 id="d.-weight-the-tree">D. Weight the Tree</h4><p>题意：给定一棵树，每个节点有一权重 <spanclass="math inline">\(w_i\)</span>，若一个节点的权值等于其相邻点的权值之和，则这个节点是好的。现在你可以为每个，使得好的点数量最多，在这基础上，还要使得总权值最小，输出赋值方案。</p><p>首先想到，除了 <span class="math inline">\(n=2\)</span>的情况，相邻两个点不可能都是好的</p><p>对于不好的点，肯定让它为1（<spanclass="math inline">\(w_i\ge1\)</span>），那么好的点的权值一定等于其度数，我们要选上一些不相邻的点使得它<strong>好</strong>。</p><p>考虑树上dp，<span class="math inline">\(dp[i,0/1]\)</span> 表示以<span class="math inline">\(i\)</span>为根节点的子树，选/不选根节点时的最优解。这里比较难想的一点在于，解居然包括了两个信息：好节点数量和总权值。似乎和通常的dp不太一样，但仔细想想是没问题的，因为两个解仍然可以排序：先按照好节点数，再按照总权值。</p><p>当前节点选，则其子节点都不能选，当前节点不选，则其子节点任意。</p><p>最后要输出方案，从上往下跑一遍就可以了：每个节点的 <spanclass="math inline">\(dp[i,1]\)</span> 和 <spanclass="math inline">\(dp[i, 0]\)</span>比较一下，确定当前点是否选，如果其父节点选了，则强制这个点不选，这样往下搜下去就能确定方案了，</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, du[maxn];vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];<span class="hljs-type">int</span> f[maxn][<span class="hljs-number">2</span>], g[maxn][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">chose</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    <span class="hljs-keyword">if</span>(f[x][<span class="hljs-number">1</span>] == f[x][<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> g[x][<span class="hljs-number">1</span>] &lt; g[x][<span class="hljs-number">0</span>];    <span class="hljs-keyword">return</span> f[x][<span class="hljs-number">1</span>] &gt; f[x][<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa = <span class="hljs-number">-1</span>)</span></span>&#123;    f[p][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, f[p][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    g[p][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, g[p][<span class="hljs-number">1</span>] = du[p];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v != fa)&#123;            <span class="hljs-built_in">dfs</span>(v, p);            f[p][<span class="hljs-number">1</span>] += f[v][<span class="hljs-number">0</span>];            g[p][<span class="hljs-number">1</span>] += g[v][<span class="hljs-number">0</span>];            <span class="hljs-type">int</span> cs = <span class="hljs-built_in">chose</span>(v);            f[p][<span class="hljs-number">0</span>] += f[v][cs];            g[p][<span class="hljs-number">0</span>] += g[v][cs];        &#125;    &#125;&#125;<span class="hljs-type">int</span> ans[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getans</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> cs)</span></span>&#123;    ans[p] = cs ? du[p] : <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v != fa)&#123;            <span class="hljs-keyword">if</span>(cs) <span class="hljs-built_in">getans</span>(v, p, <span class="hljs-number">0</span>);            <span class="hljs-keyword">else</span> <span class="hljs-built_in">getans</span>(v, p, <span class="hljs-built_in">chose</span>(v));        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;2 2\n1 1\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        du[x]++, du[y]++;        vp[x].<span class="hljs-built_in">emplace_back</span>(y);        vp[y].<span class="hljs-built_in">emplace_back</span>(x);    &#125;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);    <span class="hljs-type">int</span> cs = <span class="hljs-built_in">chose</span>(<span class="hljs-number">1</span>);    <span class="hljs-built_in">getans</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, cs);    cout &lt;&lt; f[<span class="hljs-number">1</span>][cs] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; g[<span class="hljs-number">1</span>][cs] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;</code></pre></div><h4 id="e.-power-board">E. Power Board</h4><p>题意：给出一个 <span class="math inline">\(n\times m\)</span>的图，<span class="math inline">\((i,j)\)</span> 点上的数字为 <spanclass="math inline">\(i^j\)</span>，请问这个图里有多少个不同的数字？</p><p><ahref="https://codeforces.com/blog/entry/100584">没法比题解写的更清楚了</a>（摆</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">bool</span> vis[maxn &lt;&lt; <span class="hljs-number">5</span>];<span class="hljs-type">int</span> cnt[<span class="hljs-number">32</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">23</span>;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;            <span class="hljs-keyword">if</span>(!vis[i * j])&#123;                vis[i * j] = <span class="hljs-literal">true</span>;                tot++;            &#125;        &#125;        cnt[i] = tot;    &#125;    <span class="hljs-built_in">fill</span>(vis, vis+n+<span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);    ll ans = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(!vis[i])&#123;            <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(ll j=i;j&lt;=n;j*=i)&#123;                vis[j] = <span class="hljs-literal">true</span>;                k++;            &#125;            ans += cnt[k];        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="f.-playing-around-the-table">F. Playing Around the Table</h4><p>题意：有 <span class="math inline">\(n\)</span>名玩家坐成一个环，一共有 <span class="math inline">\(n^2\)</span>张卡牌，<span class="math inline">\(1-n\)</span> 每种卡牌各 <spanclass="math inline">\(n\)</span> 张，开局每名玩家持有其中 <spanclass="math inline">\(n\)</span>张，接下来进行游戏：每轮中，每名玩家交给下一名玩家一张卡牌（所有人同时进行），如果玩家<span class="math inline">\(i\)</span> 的所有卡牌都为 <spanclass="math inline">\(i\)</span>，则其“牢固”。现要你构造一种游戏方案，至多<span class="math inline">\(n^2-n\)</span>轮，使得每名玩家都“牢固”。</p><p>一开始有个暴力的想法，每轮每个人都直接找一个不属于自己的卡牌传出去，然而这样显然会遇到死循环的情况。</p><p>全变成一样的不好搞，能不能先全变成不一样的呢？也就是让每个人都拥有1到n的所有卡牌。</p><p>这个比较好搞，每次每人都找一张自己有重复的卡牌交出去，如果自己没有重复的，就把上一个人传过来的交出去，这样最终一定能满足。</p><p>第一步能在可接受的步数内完成吗？对于每一种卡牌，考虑其最坏的情况：初始所有这张牌都在一个人手上，那么根据上述传递方案，这张牌一共会被传递<span class="math inline">\(1+2+...+n-1\)</span> 次，即 <spanclass="math inline">\(\frac{n\times(n-1)}{2}\)</span> 次，那么一共 <spanclass="math inline">\(n\)</span> 张牌，一轮能传递 <spanclass="math inline">\(n\)</span> 次，总轮次不会超过 <spanclass="math inline">\(\frac{n\times(n-1)}{2}\)</span>。</p><p>现在所有人的牌都是 <span class="math inline">\(1..n\)</span>了，下一步怎么搞都行</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<span class="hljs-type">int</span> cnt[<span class="hljs-number">103</span>][<span class="hljs-number">103</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;            <span class="hljs-type">int</span> x; cin &gt;&gt; x;            cnt[i][x]++;        &#125;    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pass</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;            pass[i] = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;                <span class="hljs-keyword">if</span>(cnt[i][j] &gt; <span class="hljs-number">1</span>)&#123;                    pass[i] = j;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">if</span>(pass[i] == <span class="hljs-number">0</span>) pass[i] = pass[(i<span class="hljs-number">-1</span>+n<span class="hljs-number">-1</span>)%n+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">if</span>(pass[i] == <span class="hljs-number">0</span>) pass[i] = pass[(i<span class="hljs-number">-1</span>+n<span class="hljs-number">-1</span>)%n+<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span>(pass[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;            cnt[i][pass[i]]--;            cnt[i%n+<span class="hljs-number">1</span>][pass[i]]++;        &#125;        ans.<span class="hljs-built_in">push_back</span>(pass);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;n;k++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d=k;d&gt;=<span class="hljs-number">1</span>;d--)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;                pass[i] = (i + d - <span class="hljs-number">1</span>) % n + <span class="hljs-number">1</span>;            &#125;            ans.<span class="hljs-built_in">push_back</span>(pass);        &#125;    &#125;    cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ps: ans)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;ps.<span class="hljs-built_in">size</span>();i++) cout &lt;&lt; ps[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == ps.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 773 div.2 F</title>
    <link href="/2022/02/23/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20773%20div.2%20F/"/>
    <url>/2022/02/23/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20773%20div.2%20F/</url>
    
    <content type="html"><![CDATA[<h4 id="f.-two-arrays">F. Two Arrays</h4><p>题意：给出 <span class="math inline">\(n\)</span>个数组，每个数组都有 <span class="math inline">\(m\)</span>个不同元素，有权值 <spanclass="math inline">\(w_i\)</span>，我们称两个不包含相同元素的数组<strong>是匹配的</strong>，要求匹配的数组对当中，<span class="math inline">\(w_i+w_j\)</span> 的最小值（<spanclass="math inline">\(n\le10^5,m\le5,a_i\le10^9\)</span>）</p><p><strong>奇技淫巧：</strong></p><p>哈希，我们可以把 <span class="math inline">\(w\)</span>映射到一个很小的范围上去（比如1000以内），可能会产生冲突，但要导致最终结果出错，当前仅当作为答案选取的两个数组<span class="math inline">\(i,j\)</span>中的至多10个不同元素映射产生了冲突，可以估计，产生冲突的概率是很小的。</p><p>这样我们就将 <span class="math inline">\(w\)</span>的值域压缩到了一个很小的范围。</p><p>这个冲突概率大概是1%左右，为了避免运气不好，可以卡个时多次跑，取最小ans</p><p><strong>解法一：</strong></p><p>首先考虑bitset的 <span class="math inline">\(n^2\)</span> 暴力</p><p>先将所有数组按照 <span class="math inline">\(w\)</span> 排序</p><p>对每个权值，用bitset记录它在哪些数组上出现过</p><p>然后暴力枚举每个数组，把它的元素出现过的位置或起来</p><p>然后取最早的从未出现的位置，更新答案。</p><p>复杂度 <spanclass="math inline">\(O(n^2m/64)\)</span>，值域压缩后，空间复杂度 <spanclass="math inline">\(10000\times n\)</span>（）</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;    <span class="hljs-type">int</span> v[<span class="hljs-number">6</span>];    <span class="hljs-type">int</span> w;&#125;a[maxn];bitset&lt;maxn&gt; t[<span class="hljs-number">13335</span>], p; <span class="hljs-type">int</span> n, m;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;            cin &gt;&gt; a[i].v[j];            a[i].v[j] %= <span class="hljs-number">13335</span>;        &#125;        cin &gt;&gt; a[i].w;    &#125;    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+n+<span class="hljs-number">1</span>, [](node x, node y)&#123; <span class="hljs-keyword">return</span> x.w &lt; y.w;&#125;);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++) t[a[i].v[j]][i<span class="hljs-number">-1</span>] = <span class="hljs-literal">true</span>;     ll ans = <span class="hljs-number">1e18</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        p = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++) p |= t[a[i].v[j]];        <span class="hljs-type">int</span> pos = <span class="hljs-number">1</span> + (~p)._Find_first();        <span class="hljs-keyword">if</span>(pos &lt; i &amp;&amp; pos &gt; <span class="hljs-number">0</span>) ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-number">1ll</span> * a[pos].w + a[i].w);    &#125;        <span class="hljs-keyword">if</span>(ans &gt; (ll)<span class="hljs-number">1e17</span>) ans = <span class="hljs-number">-1</span>;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><p><strong>解法二：</strong></p><p>同样压缩值域，狠一点直接压缩到20</p><p>这样我们就可以用一个int来表示一个数组</p><p>然后问题就转换为了：有 <span class="math inline">\(n\)</span>个数对： <span class="math inline">\(a_i,w_i\)</span> ，要求一个数对<span class="math inline">\(i,j\)</span>，满足 <spanclass="math inline">\(a_i\&amp;a_j\)</span> 为0，使 <spanclass="math inline">\(w_i+wj\)</span> 最大</p><p>然后似乎可以SOSDP？</p><p><strong>解法三（正解）：</strong></p><p>如果要无概率呢？</p><p>我们需要一个东西来快速<strong>判断一段区间内有无数组能和一个新数组匹配</strong></p><p>考虑两个数组 <spanclass="math inline">\(a,b\)</span>，如何判断它们能否匹配，当然可以简单地扫一遍，但这不能扩展</p><p>先说结论：我们把 <span class="math inline">\(a\)</span>的所有子集都存进一个set，然后对于 <span class="math inline">\(b\)</span>的每个子集，如果它在 <span class="math inline">\(a\)</span>中出现过：</p><ul><li>如果这个子集有奇数个元素，记1</li><li>如果这个子集有偶数个元素，记-1</li></ul><p>可以预想，假设 <span class="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span> 共有 <spanclass="math inline">\(k\)</span> 个相同元素，它们重复的子集个数则有<span class="math inline">\(2^k\)</span>个，去掉空集，奇数子集将比偶数子集多一个。</p><p>那么这么计数得到的结果一定是1，除非 <spanclass="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span><strong>完全不同</strong>，结果才为0</p><p>这样下来，如果我们要拿 <span class="math inline">\(b\)</span> 和<span class="math inline">\(a_1,a_2...a_t\)</span> 这 <spanclass="math inline">\(t\)</span> 个数组匹配，就只需要把这 <spanclass="math inline">\(m\)</span>个数组的所有子集加入集合（不去重），然后再拿 <spanclass="math inline">\(b\)</span> 去按上述方式计数，如果 <spanclass="math inline">\(b\)</span> 和所有 <spanclass="math inline">\(a\)</span> 都无法匹配，计数结果即为 <spanclass="math inline">\(t\)</span></p><p>不过如果这里我们用mutiset的话，复杂度为 <spanclass="math inline">\(O(n\times2^m\times log(n\times2^m))\)</span>，有点难以接受，可以用字典树来统计每个集合出现了多少次。</p><p>最后的解法：</p><p>先将数组们按照 <span class="math inline">\(w\)</span>排序，然后用双指针 <span class="math inline">\(l,r\)</span>，先不断将<span class="math inline">\(r\)</span> 右移，找到第一个可以和前 <spanclass="math inline">\(r-1\)</span> 个数匹配的位置，然后将 <spanclass="math inline">\(l\)</span> 从这个 <spanclass="math inline">\(r\)</span> 的位置不断左移，直到 <spanclass="math inline">\(r\)</span> 不能再和前 <spanclass="math inline">\(l\)</span> 个数组匹配为止。</p><p>这样我们就找到了第一组解，因为 <span class="math inline">\(w\)</span>是排序好的，后续 <span class="math inline">\(l\)</span>不需要再向右移动，右移 <span class="math inline">\(r\)</span>的过程中发现前 <span class="math inline">\(l\)</span> 个数组与 <spanclass="math inline">\(r\)</span> 不匹配了，就将 <spanclass="math inline">\(l\)</span> 左移，然后更新答案。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> Tire&#123;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tire</span>&#123;        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; ch;        <span class="hljs-type">int</span> num;    &#125;t[<span class="hljs-number">3200020</span>];    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> ad)</span></span>&#123;        <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:arr)&#123;            <span class="hljs-keyword">if</span>(!t[p].ch.<span class="hljs-built_in">count</span>(v)) t[p].ch[v] = ++cnt;            p = t[p].ch[v];        &#125;        t[p].num += ad;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span></span>&#123;        <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:arr)&#123;            <span class="hljs-keyword">if</span>(!t[p].ch.<span class="hljs-built_in">count</span>(v)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            p = t[p].ch[v];        &#125;        <span class="hljs-keyword">return</span> t[p].num;    &#125;&#125; <span class="hljs-type">int</span> n, m;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;    vector&lt;<span class="hljs-type">int</span>&gt; v;    <span class="hljs-type">int</span> w;&#125;a[maxn]; vector&lt;<span class="hljs-type">int</span>&gt; csd;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> p, vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> ad)</span></span>&#123;    <span class="hljs-keyword">if</span>(p &gt;= arr.<span class="hljs-built_in">size</span>())&#123;        <span class="hljs-keyword">if</span>(csd.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(ad &gt; <span class="hljs-number">0</span>) Tire::<span class="hljs-built_in">insert</span>(csd, <span class="hljs-number">1</span>);        <span class="hljs-keyword">else</span> Tire::<span class="hljs-built_in">insert</span>(csd, <span class="hljs-number">-1</span>);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-built_in">add</span>(p+<span class="hljs-number">1</span>, arr, ad);    csd.<span class="hljs-built_in">push_back</span>(arr[p]);    <span class="hljs-built_in">add</span>(p+<span class="hljs-number">1</span>, arr, ad);    csd.<span class="hljs-built_in">pop_back</span>();&#125; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calcu</span><span class="hljs-params">(<span class="hljs-type">int</span> p, vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span></span>&#123;    <span class="hljs-keyword">if</span>(p &gt;= arr.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> Tire::<span class="hljs-built_in">query</span>(csd) * ((csd.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>);    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;    res += <span class="hljs-built_in">calcu</span>(p+<span class="hljs-number">1</span>, arr);    csd.<span class="hljs-built_in">push_back</span>(arr[p]);    res += <span class="hljs-built_in">calcu</span>(p+<span class="hljs-number">1</span>, arr);    csd.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-keyword">return</span> res;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        a[i].v.<span class="hljs-built_in">resize</span>(m);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;            cin &gt;&gt; a[i].v[j<span class="hljs-number">-1</span>];        &#125;        <span class="hljs-built_in">sort</span>(a[i].v.<span class="hljs-built_in">begin</span>(), a[i].v.<span class="hljs-built_in">end</span>());        cin &gt;&gt; a[i].w;    &#125;    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+n+<span class="hljs-number">1</span>, [](node &amp;x, node &amp;y)&#123; <span class="hljs-keyword">return</span> x.w &lt; y.w;&#125;);    <span class="hljs-type">int</span> l, r = n + <span class="hljs-number">1</span>, ans = <span class="hljs-number">2e9</span> + <span class="hljs-number">1</span>;     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">calcu</span>(<span class="hljs-number">0</span>, a[i].v) == i<span class="hljs-number">-1</span>)&#123;            <span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, a[i].v, <span class="hljs-number">1</span>);        &#125;<span class="hljs-keyword">else</span>&#123;            l = i<span class="hljs-number">-1</span>, r = i+<span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">calcu</span>(<span class="hljs-number">0</span>, a[i].v) != l)&#123;                <span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, a[l].v, <span class="hljs-number">-1</span>);                ans = <span class="hljs-built_in">min</span>(ans, a[i].w + a[l].w);                l--;            &#125;            <span class="hljs-keyword">break</span>;        &#125;    &#125;     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=r;i&lt;=n &amp;&amp; l&gt;<span class="hljs-number">0</span>;i++)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">calcu</span>(<span class="hljs-number">0</span>, a[i].v) != l)&#123;            <span class="hljs-keyword">while</span>(l &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">calcu</span>(<span class="hljs-number">0</span>, a[i].v) != l)&#123;                <span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, a[l].v, <span class="hljs-number">-1</span>);                ans = <span class="hljs-built_in">min</span>(ans, a[i].w + a[l].w);                l--;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(ans &gt; (<span class="hljs-type">int</span>)<span class="hljs-number">2e9</span>) ans = <span class="hljs-number">-1</span>;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 772 div.2 A-F</title>
    <link href="/2022/02/20/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20772%20div.2/"/>
    <url>/2022/02/20/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20772%20div.2/</url>
    
    <content type="html"><![CDATA[<h4 id="a.-min-or-sum">A. Min Or Sum</h4><p>题意：有一个数组 <spanclass="math inline">\(a\)</span>，你可以进行任意次操作：取两个数 <spanclass="math inline">\(a_i,a_j\)</span>，将这两个数分别改为 <spanclass="math inline">\(x,y\)</span>，要求 <spanclass="math inline">\(a_i|a_j=x|y\)</span>问可能得到数组总和最小值。</p><p>我们显然可以把二进制中每一位上多余的部分全部删光，只留一个，答案即所有数或起来</p><div class="code-wrapper"><pre><code class="hljs c++">ll n, m;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    ll ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        ll x; cin &gt;&gt; x;        ans |= x;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="b.-avoid-local-maximums">B. Avoid Local Maximums</h4><p>题意：给一个数组 <spanclass="math inline">\(a\)</span>，每次操作将任一个数修改为任意其他数，问至少操作几次，使得数组中不存在山峰（“山峰”即<span class="math inline">\(a_i &gt;a_{i-1}\)</span> 且 <spanclass="math inline">\(a_i &gt; a_{i+1}\)</span> ）</p><p>我们可以把每个山峰都抹平，使之变成它两侧的较小值，但还有一种情况：两个山峰相邻（即下标相差2），那么可以把中间位置抬高到两山峰中的较大值，一次性消除两个山峰，模拟即可。</p><div class="code-wrapper"><pre><code class="hljs c++">ll n, m;<span class="hljs-type">int</span> a[maxn]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    vector&lt;<span class="hljs-type">int</span>&gt; f;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;i++)&#123;        <span class="hljs-keyword">if</span>(a[i] &gt; a[i<span class="hljs-number">-1</span>] &amp;&amp; a[i] &gt; a[i+<span class="hljs-number">1</span>]) f.<span class="hljs-built_in">push_back</span>(i);    &#125;    ll ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;f.<span class="hljs-built_in">size</span>();i++)&#123;        <span class="hljs-keyword">if</span>(i != f.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> &amp;&amp; f[i] == f[i+<span class="hljs-number">1</span>] - <span class="hljs-number">2</span>)&#123;            a[f[i] + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(a[f[i]], a[f[i] + <span class="hljs-number">2</span>]);            ans++, i++;        &#125;<span class="hljs-keyword">else</span>&#123;            a[f[i]] = <span class="hljs-built_in">max</span>(a[f[i]<span class="hljs-number">-1</span>], a[f[i]+<span class="hljs-number">1</span>]);            ans++;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;</code></pre></div><h4 id="c.-differential-sorting">C. Differential Sorting</h4><p>题意：给一个数组 <spanclass="math inline">\(a\)</span>，每次操作可以选择三个位置 <spanclass="math inline">\(x,y,z(x&lt;y&lt;z)\)</span>，使得 <spanclass="math inline">\(a_x\)</span> 变为 <spanclass="math inline">\(a_y-a_z\)</span>，要求构造一种操作方案，使得整个数组单调不降。</p><p>显然，最后两位是无法修改的，那么如果最后两位是递增的，一定不成立</p><p>排除这种情况后，此时 <span class="math inline">\(a_n\)</span>为最大值，如果 <span class="math inline">\(a_n&lt;0\)</span>，<spanclass="math inline">\(a_{n-2}\)</span> 必然比 <spanclass="math inline">\(a_{n-1}\)</span> 大，一定不行</p><p>现在有 <spanclass="math inline">\(a_n\ge0\)</span>，我们向前枚举，后面的部分已经有序，那么直接拿<span class="math inline">\(a_{i+1}-a_n\)</span> 得到 <spanclass="math inline">\(a_i\)</span>，就能使 <spanclass="math inline">\(a_i\)</span> 越来越小。</p><div class="code-wrapper"><pre><code class="hljs c++">ll n, m;ll a[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-type">bool</span> f = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-keyword">if</span>(a[i] &gt; a[i+<span class="hljs-number">1</span>])&#123;            f = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span>(f)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">max</span>(a[n], a[n<span class="hljs-number">-1</span>]) &lt; <span class="hljs-number">0</span> || a[n] &lt; a[n<span class="hljs-number">-1</span>])&#123;        cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;     cout &lt;&lt; n<span class="hljs-number">-2</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; i+<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div><h4 id="d.-infinite-set">D. Infinite Set</h4><p>题意：有一个集合 <spanclass="math inline">\(a\)</span>，初始有一些数，如果 <spanclass="math inline">\(x\)</span> 在集合中，那么 <spanclass="math inline">\(2x+1\)</span> 和 <spanclass="math inline">\(4x\)</span> 都在集合中，现在问集合中小于 <spanclass="math inline">\(2^p\)</span> 的数共有多少个？（<spanclass="math inline">\(p\le2\times10^5\)</span>）</p><p>首先我们把问题简化：<span class="math inline">\(2x+1\)</span>其实就是在 <span class="math inline">\(x\)</span>的二进制表示下添个1，<span class="math inline">\(4x\)</span>就是添两个0</p><p>对任一个 <span class="math inline">\(x\)</span>​而言，我们不断的对它进行上面两种操作，产生的新数字是不会重复的。</p><p>设 <span class="math inline">\(f_i\)</span> 表示二进制最高位为 <spanclass="math inline">\(i\)</span> 的数的个数，那么有递推式 <spanclass="math inline">\(f_i = f_{i-1}+f_{i-2}\)</span></p><p>为了方便处理，首先把本质相同的 <spanclass="math inline">\(a_i\)</span> 去掉（只保留一个），即如果 <spanclass="math inline">\(a_j\)</span> 的二进制可以表示为 <spanclass="math inline">\(a_i+00100..\)</span> 则 <spanclass="math inline">\(a_j\)</span> 和 <spanclass="math inline">\(a_i\)</span> 本质相同，后面的 <spanclass="math inline">\(00100\)</span> 要求是由 <spanclass="math inline">\(1\)</span> 和 <spanclass="math inline">\(00\)</span> 组成的串，判重可以用01字典树完成。</p><p>这样我们把本质不同的数先加入 <span class="math inline">\(f\)</span>数组，就得到了初值，随后dp即可。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn], cnt[maxn];ll f[maxn];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">tire</span>&#123;    <span class="hljs-type">int</span> ch[<span class="hljs-number">2</span>];    <span class="hljs-type">bool</span> end;&#125;t[maxn &lt;&lt; <span class="hljs-number">5</span>];<span class="hljs-type">int</span> tcnt = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mxk</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    <span class="hljs-type">int</span> mxk = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">0</span>)&#123;        x /= <span class="hljs-number">2</span>;        mxk++;    &#125;    <span class="hljs-keyword">return</span> mxk;&#125; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;    vector&lt;<span class="hljs-type">int</span>&gt; vp;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">mxk</span>(x);i&gt;=<span class="hljs-number">1</span>;i--)&#123;        <span class="hljs-type">int</span> v = (x &gt;&gt; (i<span class="hljs-number">-1</span>)) &amp; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(!t[p].ch[v]) t[p].ch[v] = ++tcnt;        p = t[p].ch[v];        vp.<span class="hljs-built_in">push_back</span>(p);    &#125;    <span class="hljs-keyword">if</span>(t[p].end) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    t[p].end = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">if</span>(vp.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=vp.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;        <span class="hljs-keyword">if</span>(i != vp.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> &amp;&amp; t[vp[i]].end) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-type">int</span> v = x % <span class="hljs-number">2</span>;        x /= <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(v) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">0</span> &amp;&amp; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) x /= <span class="hljs-number">2</span>, i--;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+n+<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">add</span>(a[i]))&#123;            cnt[<span class="hljs-built_in">mxk</span>(a[i])]++;        &#125;    &#125;    ll tot = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">1</span>) f[i] = (f[i<span class="hljs-number">-1</span>] + f[i<span class="hljs-number">-2</span>]) % mode;        (f[i] += cnt[i]) %= mode;        tot = (tot + f[i]) % mode;<span class="hljs-comment">//        cout &lt;&lt; f[i] &lt;&lt; &#x27;\n&#x27;;</span>    &#125;    cout &lt;&lt; tot &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="e.-cars">E. Cars</h4><p>题意：<span class="math inline">\(x\)</span> 轴上有 <spanclass="math inline">\(n\)</span>辆车，每辆车有位置和朝向，不知道他们的具体情况，但知道 <spanclass="math inline">\(m\)</span> 条信息：</p><ul><li><span class="math inline">\(i,j\)</span>两辆车方向相反，接下来会撞上</li><li><span class="math inline">\(i,j\)</span>两辆车方向相反，但是会越来越远</li></ul><p>要输出所有车的情况，或者输出-1表示不存在这种情况</p><p>方向和位置信息一起考虑比较复杂，我们分开考虑：</p><p>首先任意一对关系，都说明他们的方向相反，我们在 <spanclass="math inline">\(i,j\)</span>之间连一条边，得到一张图之后染色，判断方向是否存在冲突。</p><p>因为左右对称性，第一辆车的方向是无所谓的，我们假设第一辆车的方向是<spanclass="math inline">\(L\)</span>，然后再跑一次这张图，这次可以根据两个相邻点的方向和它们之间的关系，判断谁在谁左边。假设<span class="math inline">\(i\)</span> 在 <spanclass="math inline">\(j\)</span> 左边，那么在一个新的图中让 <spanclass="math inline">\(i\)</span> 向 <spanclass="math inline">\(j\)</span> 连一条有向边。</p><p>构成的这个新图中，如果存在环即不存在答案。</p><p>随后按照拓扑序给每个节点分配位置即可。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; vp[maxn];vector&lt;<span class="hljs-type">int</span>&gt; vp2[maxn];<span class="hljs-type">int</span> col[maxn]; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> c)</span></span>&#123;    col[p] = c;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:vp[p])&#123;        <span class="hljs-keyword">if</span>(col[v.first])&#123;            <span class="hljs-keyword">if</span>(col[v.first] == <span class="hljs-number">3</span> - c) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(v.first, <span class="hljs-number">3</span> - c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125; <span class="hljs-type">bool</span> vis[maxn];<span class="hljs-type">int</span> du[maxn], dir[maxn], pos[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> d)</span></span>&#123;    <span class="hljs-keyword">if</span>(vis[p]) <span class="hljs-keyword">return</span>;    dir[p] = d;    vis[p] = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:vp[p])&#123;        <span class="hljs-keyword">if</span>(v.second == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span>(d == <span class="hljs-number">1</span>) vp2[v.first].<span class="hljs-built_in">push_back</span>(p), du[p]++;            <span class="hljs-keyword">else</span> vp2[p].<span class="hljs-built_in">push_back</span>(v.first), du[v.first]++;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(d == <span class="hljs-number">0</span>) vp2[v.first].<span class="hljs-built_in">push_back</span>(p), du[p]++;            <span class="hljs-keyword">else</span> vp2[p].<span class="hljs-built_in">push_back</span>(v.first), du[v.first]++;        &#125;        <span class="hljs-built_in">dfs2</span>(v.first, d ^ <span class="hljs-number">1</span>);    &#125;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-type">int</span> t, x, y;        cin &gt;&gt; t &gt;&gt; x &gt;&gt; y;        vp[x].<span class="hljs-built_in">emplace_back</span>(y, t);        vp[y].<span class="hljs-built_in">emplace_back</span>(x, t);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(!col[i] &amp;&amp; !<span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">1</span>))&#123;            cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">dfs2</span>(i, <span class="hljs-number">1</span>);     queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">if</span>(!du[i]) q.<span class="hljs-built_in">push</span>(i);    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;        <span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        pos[p] = ++tot;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:vp2[p])&#123;            du[v]--;            <span class="hljs-keyword">if</span>(du[v] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(v);        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(!pos[i])&#123;            cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;LR&quot;</span>[dir[i]] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; pos[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div><h4 id="f.-closest-pair">F. Closest Pair</h4><p>题意：有 <span class="math inline">\(n\)</span> 个点，每个点有坐标<span class="math inline">\(x_i\)</span>（<spanclass="math inline">\(x_i\)</span> 保证有序） 和权值 <spanclass="math inline">\(w_i\)</span>，接下来有一堆询问，每次问 <spanclass="math inline">\([l, r]\)</span> 这段点中，点对 <spanclass="math inline">\(i,j\)</span> 的 <span class="math inline">\(|x_i-x_j|\times(w_i+w_j)\)</span> 的最小值。</p><p>这道题的思维比较巧妙</p><p>在一段区间中，如果 <span class="math inline">\(i,j\)</span>这个点对是值最小的点对，那么 <span class="math inline">\(i,j\)</span>之间一定不存在另一个 <span class="math inline">\(w_k\)</span> 介于 <spanclass="math inline">\(w_i, w_j\)</span> 之间（不然最小值就是 <spanclass="math inline">\(i,k\)</span> 了）</p><p>所以对于每个点 <spanclass="math inline">\(i\)</span>，取它左右两端第一个 <spanclass="math inline">\(w_j&lt;w_i\)</span> 的 <spanclass="math inline">\(j\)</span>，答案一定在这 <spanclass="math inline">\(2n\)</span> 个点对当中。</p><p>这样问题就转换为了：有 <span class="math inline">\(2n\)</span>条带权的线段，每次询问一个区间，问这个区间包含的线段的最大值是多少。</p><p>离线+线段树维护最小值即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegTree</span>&#123;    ll mi[maxn &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;        mi[p] = <span class="hljs-built_in">min</span>(mi[p*<span class="hljs-number">2</span>], mi[p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, ll to)</span></span>&#123;        <span class="hljs-keyword">if</span>(l == r)&#123;            mi[p] = <span class="hljs-built_in">min</span>(mi[p], to);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(pos &lt;= mid) <span class="hljs-built_in">modify</span>(p*<span class="hljs-number">2</span>, l, mid, pos, to);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r, pos, to);        <span class="hljs-built_in">push_up</span>(p);    &#125;    <span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span></span>&#123;        <span class="hljs-keyword">if</span>(R &lt; l || r &lt; L) <span class="hljs-keyword">return</span> <span class="hljs-number">4e18</span>;        <span class="hljs-keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> mi[p];        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">query</span>(p*<span class="hljs-number">2</span>, l, mid, L, R), <span class="hljs-built_in">query</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r, L, R));    &#125;&#125;segt; vector&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; seg[maxn];vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; qr[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n, q;    cin &gt;&gt; n &gt;&gt; q;    <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">x</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>, <span class="hljs-title">w</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; x[i] &gt;&gt; w[i];    &#125;    <span class="hljs-built_in">fill</span>(segt.mi, segt.mi + (maxn &lt;&lt; <span class="hljs-number">2</span>), <span class="hljs-number">4e18</span>);    stack&lt;<span class="hljs-type">int</span>&gt; st;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; w[i] &lt;= w[st.<span class="hljs-built_in">top</span>()])&#123;            seg[i].<span class="hljs-built_in">emplace_back</span>(st.<span class="hljs-built_in">top</span>(), (w[i] + w[st.<span class="hljs-built_in">top</span>()]) * (x[i] - x[st.<span class="hljs-built_in">top</span>()]));<span class="hljs-comment">//            cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; st.top() &lt;&lt; &#x27;\n&#x27;;</span>            st.<span class="hljs-built_in">pop</span>();        &#125;        <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">empty</span>())&#123;            seg[i].<span class="hljs-built_in">emplace_back</span>(st.<span class="hljs-built_in">top</span>(), (w[i] + w[st.<span class="hljs-built_in">top</span>()]) * (x[i] - x[st.<span class="hljs-built_in">top</span>()]));<span class="hljs-comment">//            cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; st.top() &lt;&lt; &#x27;\n&#x27;;</span>        &#125;        st.<span class="hljs-built_in">push</span>(i);    &#125;     <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">ans</span><span class="hljs-params">(q+<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;        <span class="hljs-type">int</span> l, r; cin &gt;&gt; l &gt;&gt; r;        qr[r].<span class="hljs-built_in">emplace_back</span>(l, i);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:seg[i])            segt.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, v.first, v.second);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:qr[i])&#123;            ans[v.second] = segt.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, v.first, n);        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 770 div.2 EF</title>
    <link href="/2022/02/06/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20770%20div.2%20EF/"/>
    <url>/2022/02/06/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20770%20div.2%20EF/</url>
    
    <content type="html"><![CDATA[<h4 id="e.-fair-share">E. Fair Share</h4><p>题意：有 <span class="math inline">\(n\)</span> 组物品，第 <spanclass="math inline">\(i\)</span> 组有 <spanclass="math inline">\(m_i\)</span>个，每个物品有一个编号，保证每种物品出现偶数次，每组物品有偶数个，要求将所有物品划分为两组，使得一组中有每种物品各一半，每组物品各一半。</p><p>首先将问题抽象出来，组别和物品类别其实没有什么区别，都是物品的属性；</p><p>建图：左边点表示组别，右边点表示类别，<spanclass="math inline">\(i\)</span> 组中包含物品 <spanclass="math inline">\(j\)</span>，则连边 <spanclass="math inline">\(i,j\)</span></p><p>因为保证了物品出现偶数次，一组也有偶数个物品，那么这张图必然存在若干条欧拉回路</p><p>寻找欧拉回路，对于每条欧拉回路，如果一条边是由左到右遍历，则分至<span class="math inline">\(L\)</span> 组，否则分至 <spanclass="math inline">\(R\)</span>组，由于欧拉回路的性质（一个点的入次数和出次数相等，这样一定能保证恰好均分）</p><p>然后我发现我好像从来没写过欧拉回路，想当然的写了一波TLE了一页（</p><p>关键在于，欧拉回路标记vis的是边而不是点，一个点可能遍历多次，如果还是每遍历到一个点就去遍历它的所有连边，即使有vis标记忽略已经走过的边，还是会变成<span class="math inline">\(n^2\)</span></p><p>需要记录每个店最后一次遍历的边是哪条，下次再跑直接从这开始即可。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;    <span class="hljs-type">int</span> x, y, pj, vis;&#125;e[maxn];<span class="hljs-type">int</span> ecnt = <span class="hljs-number">0</span>;vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];<span class="hljs-type">int</span> lst[maxn];string ans[maxn]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=lst[p];j&lt;vp[p].<span class="hljs-built_in">size</span>();j=lst[p])&#123;        <span class="hljs-type">int</span> i = vp[p][j];        lst[p] = j+<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(e[i].vis) <span class="hljs-keyword">continue</span>;        e[i].vis = <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(p &lt;= n)&#123;            ans[e[i].x][e[i].pj] = <span class="hljs-string">&#x27;L&#x27;</span>;            <span class="hljs-built_in">dfs</span>(e[i].y);        &#125;<span class="hljs-keyword">else</span>&#123;            ans[e[i].x][e[i].pj] = <span class="hljs-string">&#x27;R&#x27;</span>;            <span class="hljs-built_in">dfs</span>(e[i].x);        &#125;    &#125;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; lsh;    <span class="hljs-type">int</span> tot = n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; m;        ans[i] = <span class="hljs-built_in">string</span>(m, <span class="hljs-string">&#x27;\0&#x27;</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;            <span class="hljs-type">int</span> x; cin &gt;&gt; x;            <span class="hljs-keyword">if</span>(!lsh[x]) lsh[x] = ++tot;            e[++ecnt] = &#123;i, lsh[x], j, <span class="hljs-number">0</span>&#125;;            vp[lsh[x]].<span class="hljs-built_in">push_back</span>(ecnt);            vp[i].<span class="hljs-built_in">push_back</span>(ecnt);        &#125;    &#125;;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=tot;i++)&#123;        <span class="hljs-keyword">if</span>(vp[i].<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;            cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=tot;i++) <span class="hljs-keyword">if</span>(lst[i] &lt; vp[i].<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">dfs</span>(i);    cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="f.-fibonacci-additions">F. Fibonacci Additions</h4><p>一道差分好题</p><p>题意：有长度为 <span class="math inline">\(n\)</span> 的 <spanclass="math inline">\(a\)</span> 数组和 <spanclass="math inline">\(b\)</span> 数组，接下来有若干次修改：使 <spanclass="math inline">\(a\)</span> 或者 <spanclass="math inline">\(b\)</span> 数组的 <spanclass="math inline">\([l,r]\)</span> 段依次加上斐波那契数列，即 <spanclass="math inline">\(a_l+1\)</span>，<spanclass="math inline">\(a_{l+1}+1\)</span>，<spanclass="math inline">\(a_{l+3}+2\)</span>...</p><p>每次修改完成后，要求输出 <span class="math inline">\(a\)</span> 与<span class="math inline">\(b\)</span> 是否完全相等。</p><p>首先需要利用斐波那契数列的性质：<spanclass="math inline">\(f_i=f_{i-1}+f_{i-2}\)</span></p><p>在空数组上随便修改几段试一下就会发现，不论怎么修改，在修改量上，永远有<span class="math inline">\(d_i=d_{i-1}+d_{i-2}\)</span></p><p>既然如此，可以考虑对修改量差分（前缀和的形式改为斐波那契形式）</p><p>写个例子理解一下，比如要对3-6这段区间加斐波那契数列：</p><p>修改量：0 0 f1 f2 f3 f4 0 0 0</p><p>差分d： 0 0 f1 0 0 0 -f5 -f4 0</p><p>如果我们对差分数组这样修改，那么它的斐波那契前缀和即为修改量；</p><p>这样就简单啦，显然任意一组修改量和它的差分数组是一一对应的，我们直接把初始情况转化为差分数组，然后每次在差分数组上进行3次单点修改，就可以很方便的判断是否一样了。</p><div class="code-wrapper"><pre><code class="hljs c++">ll n, q, mod, a[maxn], tot = <span class="hljs-number">0</span>;ll f[maxn]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(ll x, ll ad)</span></span>&#123;    <span class="hljs-keyword">if</span>(x &gt; n) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(a[x] == <span class="hljs-number">0</span>) tot--;    a[x] = (a[x] + ad + mod) % mod;    <span class="hljs-keyword">if</span>(a[x] == <span class="hljs-number">0</span>) tot++;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; q &gt;&gt; mod;    f[<span class="hljs-number">1</span>] = f[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">3</span>;i&lt;=n;i++) f[i] = (f[i<span class="hljs-number">-1</span>] + f[i<span class="hljs-number">-2</span>]) % mod;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        ll x; cin &gt;&gt; x;        a[i] -= x;        a[i] = (a[i] % mod + mod) % mod;    &#125;    <span class="hljs-keyword">for</span>(ll i=n;i&gt;=<span class="hljs-number">2</span>;i--) a[i] -= a[i<span class="hljs-number">-1</span>] + a[i<span class="hljs-number">-2</span>], a[i] = (a[i] % mod + mod) % mod;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++) tot += !a[i];     <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;        <span class="hljs-type">char</span> c; ll x, y;        cin &gt;&gt; c &gt;&gt; x &gt;&gt; y;        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;A&#x27;</span>)&#123;            <span class="hljs-built_in">modify</span>(x, <span class="hljs-number">1</span>);            <span class="hljs-built_in">modify</span>(y+<span class="hljs-number">2</span>, -f[y-x+<span class="hljs-number">1</span>]);            <span class="hljs-built_in">modify</span>(y+<span class="hljs-number">1</span>, -f[y-x+<span class="hljs-number">2</span>]);        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">modify</span>(x, <span class="hljs-number">-1</span>);            <span class="hljs-built_in">modify</span>(y+<span class="hljs-number">2</span>, f[y-x+<span class="hljs-number">1</span>]);            <span class="hljs-built_in">modify</span>(y+<span class="hljs-number">1</span>, f[y-x+<span class="hljs-number">2</span>]);        &#125;        cout &lt;&lt; vector&lt;string&gt;&#123;<span class="hljs-string">&quot;NO&quot;</span>, <span class="hljs-string">&quot;YES&quot;</span>&#125;[tot == n] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新生赛题解之chiking的俄罗斯方块</title>
    <link href="/2021/12/10/%E9%A2%98%E8%A7%A3/%E6%96%B0%E7%94%9F%E8%B5%9B%E9%A2%98%E8%A7%A3-%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/"/>
    <url>/2021/12/10/%E9%A2%98%E8%A7%A3/%E6%96%B0%E7%94%9F%E8%B5%9B%E9%A2%98%E8%A7%A3-%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="xx的俄罗斯方块">XX的俄罗斯方块</h2><h6 id="时间限制1000ms-空间限制256m">时间限制：1000ms空间限制：256M</h6><h5 id="题目背景">题目背景:</h5><p>XX沉迷一款叫俄罗斯方块的游戏，但这个游戏对他来说实在太难了，于是它决定玩无敌版</p><p>无敌版俄罗斯方块中，有一个宽4格，高度无限的网格图，游戏流程如下：</p><ol type="1"><li><p>初始时网格图为空</p></li><li><p>一个由方块组成的砖块（只有1x4和2x2两种）出现在网格图内很高的地方，XX可以对它进行任意次操作：</p><ol type="1"><li>将这个方块整体左移一格（不能被已有的方块阻挡或超出边界）</li><li>将这个方块整体右移一格（不能被已有的方块阻挡或超出边界）</li></ol></li><li><p>砖块块每隔一段时间就会整体下落一格（当然由于XX的手速非常快，它可以在下落的间隙中进行无数次平移），当因被阻挡或即将超出下边界而无法下落时，它就会<strong>固定</strong>，紧接着出现下一个砖块</p></li><li><p>方块固定后，如果有一整行的四格方块都填满，这一行将被消除，XX得到1分；如果一次同时消除了多行，第二行将能得到2分，第三行就是3分，以此类推。</p><p>所以一次性消除4行就能获得一共10分！</p></li></ol><p><strong>注意</strong>：砖块不可分割，不可旋转，所有1x4的砖块均竖直，<strong>且保证1x4的方块仅出现偶数次</strong></p><p>下面这种插入方式也是允许的：</p><figure><img src="http://lxtyin.ac.cn/img/problem/Tetris/9.png" alt="9" /><figcaption aria-hidden="true">9</figcaption></figure><h5 id="题目描述">题目描述：</h5><p>XX现在正在打一局无敌版的俄罗斯方块，他知道接下来出现的 n个砖块的种类，你能帮他算一算他最高能获得多少分吗？</p><h5 id="输入格式">输入格式：</h5><p>输入有两行</p><p>第一行一个正整数 n，表示接下来有 n 个砖块 (1&lt;= n &lt;= 10^6)</p><p>第二行 n 个正整数，依次表示接下来出现的砖块种类，0表示 2x2的砖块，1表示 1x4 的砖块</p><h5 id="输出格式">输出格式：</h5><p>输出一个正整数，为XX能获得的最大分数</p><h5 id="样例输入">样例输入：</h5><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">4</span><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span></code></pre></div><h5 id="样例输出">样例输出：</h5><div class="code-wrapper"><pre><code class="hljs">6</code></pre></div><p><strong>样例解释：</strong></p><p>按下面这种方式堆放：</p><figure><img src="http://lxtyin.ac.cn/img/problem/Tetris/10.png" alt="10" /><figcaption aria-hidden="true">10</figcaption></figure><p>第三个插入时连消了两行，获得1+2分</p><p>第五个插入时连消了两行，获得1+2分</p><p>一共6分，不存在比这得分更多的方案</p><hr /><h2 id="题解">题解：</h2><p>先说结论：</p><p>用任何方式算出最大四连消的次数即可，其余尽可能多地三连消，最后可能剩余一个<span class="math inline">\(2\times2\)</span> 或者 <spanclass="math inline">\(2\times4\)</span>，可以发现一点：只要存在正方形的砖块，最后就不可能剩下<span class="math inline">\(2\times4\)</span> 的情况。</p><hr /><p>首先可以看出，只有2连消和4连消两种消法，分别对应3分和10分；</p><p>从贪心的角度来讲，我们需要尽可能多4连消；随便定一个数字 <spanclass="math inline">\(k\)</span>，考虑怎么去判断<strong>能否进行 <spanclass="math inline">\(k\)</span> 次4连消</strong>：</p><ul><li><span class="math inline">\(k\)</span> 至多为1的数量的一半；</li><li>先在第四列堆 <span class="math inline">\(k\)</span>根1x4，在前两列尽可能堆高，最后 <span class="math inline">\(k\)</span>根长条都插入第三列，这样能尽可能保证4连消；</li><li>在这种策略下，如果在第三列每根1*4插入时，前两列高度都 <spanclass="math inline">\(\ge4\)</span>，则能够进行 <spanclass="math inline">\(k\)</span> 次4连消，否则一定不能；</li></ul><p>所以进行 <span class="math inline">\(k\)</span>次4连消的条件就是：对于任意倒数第 <span class="math inline">\(b\)</span>个1 (<span class="math inline">\(b\lek\)</span>)，都满足到这里为止，前面可用的1和0在前两列能够堆的高度 <spanclass="math inline">\(\ge\)</span> <span class="math inline">\((k-b+1)\times4\)</span>，所谓“可用的0和1”就是指所有的0和去掉放在第四列的 <spanclass="math inline">\(k\)</span> 个和第三列的 <spanclass="math inline">\(k-b+1\)</span> 个1；</p><p>即对于任意倒数第 <span class="math inline">\(b\)</span> 个1（<spanclass="math inline">\(b\le k\)</span>），假设它在第 <spanclass="math inline">\(i\)</span> 位，满足 <spanclass="math inline">\((cnt1[i]-k-(k-b+1))/2\times4 +cnt0[i]\times2\ge(k-b+1)\times4\)</span></p><p>其中 <span class="math inline">\(cnt0[i]\)</span>，<spanclass="math inline">\(cnt1[i]\)</span> 分别为前 <spanclass="math inline">\(i\)</span>个块中0，1的数量；（式中除号为整除）</p><p>有了这个式子，最大的 <span class="math inline">\(k\)</span>就不难算了：初始将 <span class="math inline">\(k\)</span> 设为 <spanclass="math inline">\(cnt1[n]/2\)</span>，我们从后往前枚举，每枚举到一个1时就依据上式判断，不断减小<span class="math inline">\(k\)</span> 直到上式成立，这样就得到了最大的<span class="math inline">\(k\)</span>。</p><hr /><p>有必要解释一下：<span class="math inline">\(x\)</span> 个1可以在前两列堆出 <span class="math inline">\(x/2\times4\)</span>的高度：（式中除号为整除）</p><figure><img src="http://lxtyin.ac.cn/img/problem/Tetris/6.png" alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><p>当插入一根1x4时，直接放在第一列，接下来如果是方块则正常放置不影响，下一根1x4用这种插入的方式补在第二列即可，因为直到最后<span class="math inline">\(k\)</span>个1之前第三列都是空的，这种方式一定行的通。</p><hr /><p>一二列堆的多余部分要尽可能2连消，这个比较简单，堆的高度超出 <spanclass="math inline">\(k\times4\)</span> 后左右来回放就行了，总得分就是<spanclass="math inline">\(k\times4+(n-k)/2\times3\)</span>，最后可能会剩余1个2x2，这个没有办法消除；（式中除号为整除）</p><p>最后也有可能不得不剩下两根1x4，这种情况当且仅当全场都是1的时候才成立，否则一定能通过改变一个0的位置消掉（感性理解即可，想要严格证明可以私聊我，不太好讲）</p><p>因为 <span class="math inline">\(k\)</span>是最大的4连消次数，在此情况下也最多只会浪费两个方块，减少4连消次数损失的10收益远大于可能获得的3收益，所以这就是得分最大的方案。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, a[maxn];<span class="hljs-type">int</span> cnt0[maxn], cnt1[maxn];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cnt0[i] = cnt0[i<span class="hljs-number">-1</span>];        cnt1[i] = cnt1[i<span class="hljs-number">-1</span>];        <span class="hljs-keyword">if</span>(a[i] == <span class="hljs-number">0</span>) cnt0[i]++;        <span class="hljs-keyword">else</span> cnt1[i]++;    &#125;    <span class="hljs-type">int</span> k = cnt1[n] / <span class="hljs-number">2</span>;    <span class="hljs-type">int</span> brk = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;        <span class="hljs-keyword">if</span>(a[i] == <span class="hljs-number">1</span>)&#123;            brk++;            <span class="hljs-keyword">while</span>(k &gt;= brk &amp;&amp; (cnt1[i]-(k+k-brk+<span class="hljs-number">1</span>))/<span class="hljs-number">2</span>*<span class="hljs-number">4</span> + cnt0[i]*<span class="hljs-number">2</span> &lt; (k-brk+<span class="hljs-number">1</span>)*<span class="hljs-number">4</span>) k--;        &#125;    &#125;    <span class="hljs-keyword">if</span>(cnt0[n]) cout &lt;&lt; k*<span class="hljs-number">10</span>+(n-k*<span class="hljs-number">4</span>)/<span class="hljs-number">2</span>*<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    <span class="hljs-keyword">else</span> cout &lt;&lt; n/<span class="hljs-number">4</span>*<span class="hljs-number">10</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3id="ps由于这题最终答案偏差不大其他贪心方式也有机会通过">PS：由于这题最终答案偏差不大，其他贪心方式也有机会通过（</h3><p>来自老老会长的ac代码：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span>, lPos</span>;    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">flag</span><span class="hljs-params">(n, <span class="hljs-literal">true</span>)</span></span>;    queue&lt;<span class="hljs-type">int</span>&gt; oPos;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i];    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, tot2 = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 2*2 + 2*2 + 1*4 + 1*4</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;        <span class="hljs-keyword">if</span> (data[i] == <span class="hljs-number">0</span>) &#123;            oPos.<span class="hljs-built_in">push</span>(i);            tot2++;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span>) oPos.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span> &amp;&amp; (<span class="hljs-type">int</span>) lPos.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">1</span>) &#123;                flag[oPos.<span class="hljs-built_in">front</span>()] = <span class="hljs-literal">false</span>;                oPos.<span class="hljs-built_in">pop</span>();                flag[oPos.<span class="hljs-built_in">front</span>()] = <span class="hljs-literal">false</span>;                oPos.<span class="hljs-built_in">pop</span>();                flag[lPos.<span class="hljs-built_in">back</span>()] = <span class="hljs-literal">false</span>;                flag[i] = <span class="hljs-literal">false</span>;                lPos.<span class="hljs-built_in">pop_back</span>();                res += <span class="hljs-number">10</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                lPos.<span class="hljs-built_in">push_back</span>(i);            &#125;        &#125;    &#125;    <span class="hljs-type">int</span> cnt1 = (<span class="hljs-type">int</span>) lPos.<span class="hljs-built_in">size</span>();    <span class="hljs-type">int</span> cnt2 = (<span class="hljs-type">int</span>) oPos.<span class="hljs-built_in">size</span>();    <span class="hljs-comment">// 1*4 + 1*4 + 1*4 + 1*4</span>    <span class="hljs-type">int</span> tmp = cnt1 / <span class="hljs-number">4</span>;    res += tmp * <span class="hljs-number">10</span>;    cnt1 -= tmp * <span class="hljs-number">4</span>;    <span class="hljs-comment">// 1*4 + 1*4 + 2*2 + 2*2</span>    <span class="hljs-keyword">if</span> (cnt1 == <span class="hljs-number">2</span> &amp;&amp; cnt2 &gt;= <span class="hljs-number">2</span>) &#123;        res += <span class="hljs-number">6</span>;        cnt2 -= <span class="hljs-number">2</span>;        cnt1 -= <span class="hljs-number">2</span>;    &#125;    <span class="hljs-comment">// 2*2 + 2*2</span>    res += <span class="hljs-number">3</span> * (cnt2 / <span class="hljs-number">2</span>);    <span class="hljs-keyword">if</span> (cnt1 == <span class="hljs-number">2</span> &amp;&amp; (cnt2 == <span class="hljs-number">1</span> || tot2 &gt;= <span class="hljs-number">2</span>)) &#123;        res += <span class="hljs-number">3</span>;    &#125;    cout &lt;&lt; res &lt;&lt; endl;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新生赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 117 A-E</title>
    <link href="/2021/11/22/%E9%A2%98%E8%A7%A3/Educational%20Codeforces%20Round%20117/"/>
    <url>/2021/11/22/%E9%A2%98%E8%A7%A3/Educational%20Codeforces%20Round%20117/</url>
    
    <content type="html"><![CDATA[<h4 id="a.-distance">A. Distance</h4><p>题意：给出 <span class="math inline">\(B\)</span> 点坐标 <spanclass="math inline">\(bx,by\)</span>，要输出 <spanclass="math inline">\(C\)</span> 的坐标使得 <spanclass="math inline">\(C\)</span> 到原点，<spanclass="math inline">\(C\)</span> 到 <spanclass="math inline">\(B\)</span> 点的曼哈顿距离都为 <spanclass="math inline">\(B\)</span> 到原点的曼哈顿距离的一半。</p><p>分奇偶讨论即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> x, y;    cin &gt;&gt; x &gt;&gt; y;    <span class="hljs-type">int</span> dis =(<span class="hljs-built_in">abs</span>(x) + <span class="hljs-built_in">abs</span>(y));    <span class="hljs-keyword">if</span>(dis % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(x) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;            cout &lt;&lt; x/<span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; y/<span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            cout &lt;&lt; <span class="hljs-built_in">floor</span>(x/<span class="hljs-number">2.0</span>) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-built_in">ceil</span>(y/<span class="hljs-number">2.0</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;        &#125;    &#125;<span class="hljs-keyword">else</span>&#123;        cout &lt;&lt; <span class="hljs-string">&quot;-1 -1\n&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="b.-special-permutation">B. Special Permutation</h4><p>题意：要构造一个 <span class="math inline">\(n\)</span> 的排列（<spanclass="math inline">\(n\)</span> 为偶数），使得左半边最小值为 <spanclass="math inline">\(a\)</span>，右半边最小值为 <spanclass="math inline">\(b\)</span></p><p>左边取 <span class="math inline">\(a\)</span> 和尽可能大的值，右边取<span class="math inline">\(b\)</span> 和尽可能小的值，因为 <spanclass="math inline">\(n\)</span> 只给了100，可以 <spanclass="math inline">\(n^2\)</span> 暴力，省去了分类讨论的麻烦</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m, s[maxn];<span class="hljs-type">bool</span> vis[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a, b;    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) vis[i] = <span class="hljs-number">0</span>;    s[<span class="hljs-number">1</span>] = a; vis[a] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n/<span class="hljs-number">2</span>;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n;j&gt;=a;j--)&#123;            <span class="hljs-keyword">if</span>(!vis[j] &amp;&amp; j != b)&#123;                s[i] = j;                vis[j] = <span class="hljs-number">1</span>;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span>(j == a)&#123;                cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=b;j&gt;=<span class="hljs-number">1</span>;j--)&#123;            <span class="hljs-keyword">if</span>(!vis[j])&#123;                s[i] = j;                vis[j] = <span class="hljs-number">1</span>;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">1</span>)&#123;                cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) cout &lt;&lt; s[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    cout &lt;&lt; s[n] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="c.-chat-ban">C. Chat Ban</h4><p>题意：你要依次发送 <span class="math inline">\(2k-1\)</span>条消息，每条消息的字符个数分别为 1,2,3...k,k-1...2,1，输入达到 <spanclass="math inline">\(x\)</span>个字符时就会终止，问能发出几条消息（发一半也算）</p><p>分类讨论写比较麻烦，写一个计算发送前 <spanclass="math inline">\(x\)</span> 条消息需要的字符的函数 <spanclass="math inline">\(f(x)\)</span>，然后二分答案即可。</p><div class="code-wrapper"><pre><code class="hljs c++">ll k, x;<span class="hljs-function">ll <span class="hljs-title">cntk</span><span class="hljs-params">(ll s)</span></span>&#123;    <span class="hljs-keyword">if</span>(s &lt;= k) <span class="hljs-keyword">return</span> s*(s+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;    <span class="hljs-keyword">else</span>&#123;        ll r = (<span class="hljs-number">2</span>*k<span class="hljs-number">-1</span>-s+k) * (s-k) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">return</span> k*(k+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span> + r;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; k &gt;&gt; x;    ll l = <span class="hljs-number">1</span>, r = <span class="hljs-number">2</span>*k<span class="hljs-number">-1</span>;    <span class="hljs-keyword">while</span>(l &lt; r)&#123;        ll mid = (l+r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cntk</span>(mid) &gt;= x)&#123;            r = mid;        &#125;<span class="hljs-keyword">else</span>&#123;            l = mid+<span class="hljs-number">1</span>;        &#125;    &#125;    cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="d.-x-magic-pair">D. X-Magic Pair</h4><p>题意：有两个数字 <spanclass="math inline">\(a,b\)</span>，可以一次操作将 <spanclass="math inline">\(a=|a-b|\)</span> 或 <spanclass="math inline">\(b=|a-b|\)</span>，问能否凑出 <spanclass="math inline">\(x\)</span>（<span class="math inline">\(a\)</span>或 <span class="math inline">\(b\)</span> 等于 <spanclass="math inline">\(x\)</span> 都可，可以进行任意次操作）</p><p>用手模拟一下可以发现，当前为 <spanclass="math inline">\(a,b\)</span>（假设 <spanclass="math inline">\(a\lt b\)</span>），不论怎么操作一定会经过 <spanclass="math inline">\(a,b-a\)</span> 这个状态</p><p>那么可以用类似辗转相除法的办法处理，如果 <spanclass="math inline">\(x\)</span> 在 <spanclass="math inline">\(a,b\)</span> 之间且 <spanclass="math inline">\(x\equiv b\pmod a\)</span>，则可行，否则变化为<span class="math inline">\(b\%a,a\)</span> 继续；</p><p>记得判余数为 <span class="math inline">\(0\)</span> 的情况</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(ll a, ll b, ll x)</span></span>&#123;    <span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span> || b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(x == a || x == b) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(x &gt; b) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span>(b%a == x%a) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">judge</span>(b%a, a, x);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    ll a, b, x;    string sout[<span class="hljs-number">2</span>] = &#123;<span class="hljs-string">&quot;NO&quot;</span>, <span class="hljs-string">&quot;YES&quot;</span>&#125;;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; x;    <span class="hljs-keyword">if</span>(a &gt; b) <span class="hljs-built_in">swap</span>(a, b);    cout &lt;&lt; sout[<span class="hljs-built_in">judge</span>(a, b, x)] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="e.-messages">E. Messages</h4><p>题意：有 <span class="math inline">\(n\)</span>个人，每个人有一个期望读到的信 <spanclass="math inline">\(m_i\)</span>，和他将读的信数 <spanclass="math inline">\(k_i\)</span>，每个人都会在信堆里等概率地随机抽取<span class="math inline">\(k_i\)</span>封信阅读（不会取走）。现在你可以选择将哪些信放进信堆，使得读到想读信的人数期望最大。</p><p>第一反应想到了二分答案，因为确定了要放信的数量后比较容易judge</p><hr /><p>考虑怎么计算：选择一共放 <span class="math inline">\(m\)</span>封信时的最大期望</p><p>对于每个人来说，它读到想要的信的概率是 <spanclass="math inline">\(\frac{min(k_i,m)}{m}\)</span>，我们可以对于每一封信，统计想读它的人的 <spanclass="math inline">\(\min(k_i, m)\)</span> 之和（记为 <spanclass="math inline">\(tot\)</span>），那么选这封信的收益就是 <spanclass="math inline">\(\frac{tot}{m}\)</span> ；</p><p>将信按照 <span class="math inline">\(tot\)</span> 排序后选取前 <spanclass="math inline">\(m\)</span> 封就可以计算出最大期望了</p><hr /><p>然后很显然地发现，答案不具有单调性，二份答案X</p><p>输入数据保证了 <spanclass="math inline">\(k\le20\)</span>，用手模拟了一下极端情况，大胆猜测选<span class="math inline">\(20\)</span>封左右信时收益达到阈值，再多选收益一定更低</p><p>然后暴力跑了 <span class="math inline">\(m\le50\)</span>的情况，就过了！</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<span class="hljs-type">int</span> a[maxn], b[maxn];<span class="hljs-type">bool</span> apr[maxn];vector&lt;<span class="hljs-type">int</span>&gt; all;ll tot[maxn];<span class="hljs-type">double</span> ans[maxn]; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmpf</span><span class="hljs-params">(ll x, ll y)</span></span>&#123; <span class="hljs-keyword">return</span> x &gt; y;&#125; <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        tot[a[i]] += <span class="hljs-built_in">min</span>(b[i], m);    &#125;    <span class="hljs-built_in">sort</span>(tot+<span class="hljs-number">1</span>, tot+<span class="hljs-number">200000</span>+<span class="hljs-number">1</span>, cmpf);    ll fz = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        fz += tot[i];    &#125;    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(tot[i] &gt; <span class="hljs-number">0</span>) tot[i++] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> fz * <span class="hljs-number">1.0</span> / m;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; a[i] &gt;&gt; b[i];        <span class="hljs-keyword">if</span>(!apr[a[i]])&#123;            all.<span class="hljs-built_in">push_back</span>(a[i]);            apr[a[i]] = <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(<span class="hljs-number">50</span>, n);i++)&#123;        ans[i] = <span class="hljs-built_in">judge</span>(i);        <span class="hljs-keyword">if</span>(ans[i] &gt; ans[p]) p = i;    &#125;    cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) tot[a[i]] += <span class="hljs-built_in">min</span>(b[i], p);    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; vp;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:all) vp.<span class="hljs-built_in">push_back</span>(&#123;tot[v], v&#125;);    <span class="hljs-built_in">sort</span>(vp.<span class="hljs-built_in">begin</span>(), vp.<span class="hljs-built_in">end</span>());    <span class="hljs-type">bool</span> fg = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">while</span>(p--)&#123;        <span class="hljs-keyword">if</span>(fg) cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;        <span class="hljs-keyword">else</span> fg = <span class="hljs-number">1</span>;        cout &lt;&lt; vp.<span class="hljs-built_in">back</span>().second;        vp.<span class="hljs-built_in">pop_back</span>();    &#125;    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 746 div.2 CDE</title>
    <link href="/2021/11/17/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20746%20div.2/"/>
    <url>/2021/11/17/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20746%20div.2/</url>
    
    <content type="html"><![CDATA[<p>这场没打，赛后看了一下题值得补</p><h4 id="c.-bakry-and-partitioning">C. Bakry and Partitioning</h4><p>题意：给出一棵 <span class="math inline">\(n\)</span>节点的树，每个点有权值 <spanclass="math inline">\(a_i\)</span>，问能否割去至少一条，至多 <spanclass="math inline">\(k-1\)</span>条边，使得割完后各个连通块的权值异或和相等。</p><p>显然，如果整棵树的异或和为0，那么任选一条边割得到的两个连通块异或和都相等。（异或的性质）</p><p>如果整棵树异或和为 <span class="math inline">\(x\)</span>，那么问题就等价于能不能把树拆出三个异或和为 <spanclass="math inline">\(x\)</span>的连通块（三个可以合并成一个，所以能拆成更多块的也一定能拆成三块）</p><p>dfs地去找，当某个子树的异或和为 <spanclass="math inline">\(x\)</span>时，记录并将这个子树清零，跑完之后看找到了几个即可</p><p>记得对 <span class="math inline">\(k=2\)</span> 特判</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, k;<span class="hljs-type">int</span> a[maxn], xs[maxn];<span class="hljs-type">int</span> xsum, ans;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;    <span class="hljs-type">int</span> t, nt;&#125;e[maxn &lt;&lt; <span class="hljs-number">1</span>];<span class="hljs-type">int</span> head[maxn], cnt = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;    e[++cnt].t = y;    e[cnt].nt = head[x];    head[x] = cnt;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span></span>&#123;    xs[p] = a[p];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[p];i;i=e[i].nt)&#123;        <span class="hljs-type">int</span> v = e[i].t;        <span class="hljs-keyword">if</span>(v != fa)&#123;            <span class="hljs-built_in">dfs</span>(v, p);            xs[p] ^= xs[v];        &#125;    &#125;    <span class="hljs-keyword">if</span>(xs[p] == xsum)&#123;        ans++;        xs[p] = <span class="hljs-number">0</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; k;    xsum = cnt = ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) head[i] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; a[i];        xsum ^= a[i];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        <span class="hljs-built_in">add</span>(x, y);        <span class="hljs-built_in">add</span>(y, x);    &#125;    <span class="hljs-keyword">if</span>(xsum == <span class="hljs-number">0</span>)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">if</span>(k &lt;= <span class="hljs-number">2</span>)&#123;            cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span>(ans &gt; <span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="d.-hemose-in-icpc">D. Hemose in ICPC ?</h4><p>题意：交互题，现有一棵 <span class="math inline">\(n\)</span>节点的树，每个边有边权（边权未知），可以进行至多12次询问：每次询问一个点集，回复是这个点集中<span class="math inline">\(Dist(a,b)\)</span> 的最大值，<spanclass="math inline">\(Dist(a,b)\)</span> 定义为 <spanclass="math inline">\(a\)</span> 到 <spanclass="math inline">\(b\)</span> 路径上所有边权的gcd，求使 <spanclass="math inline">\(Dist(a,b)\)</span> 最大的 <spanclass="math inline">\(a,b\)</span></p><p>首先可以看出要找的就是权值最大的边，gcd是纯唬人的。</p><p>第一次查询先查询所有的点，这样就可以知道最大的边权是多少。</p><p>查询次数为12，数据规模 <spanclass="math inline">\(n&lt;1000\)</span>，如果我们能以某种方式把树映射到序列上，且序列上连续的点在树上也连续，就可以二分地询问，找最大边的位置（因为连续，所以序列上两点之间就是边）。</p><p>欧拉序即可保证连续性。</p><p>ps：一开始用dfs序糊里糊涂过了，不能保证连续性但也能通过某种玄学的巧合AC，正确性不是很显然，我也讲不清楚，就不介绍了</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;    <span class="hljs-type">int</span> fr, t, nt;&#125;e[maxn &lt;&lt; <span class="hljs-number">1</span>];<span class="hljs-type">int</span> head[maxn], cnt = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> vis[maxn], vp = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> a[maxn &lt;&lt; <span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;    e[++cnt].t = y;    e[cnt].fr = x;    e[cnt].nt = head[x];    head[x] = cnt;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span></span>&#123;    a[++cnt] = p;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[p];i;i=e[i].nt)&#123;        <span class="hljs-type">int</span> v = e[i].t;        <span class="hljs-keyword">if</span>(v != fa)&#123;            <span class="hljs-built_in">dfs</span>(v, p);            a[++cnt] = p;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getans</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;    vp++;    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, res;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;i++)&#123;        <span class="hljs-keyword">if</span>(vis[a[i]] != vp) vis[a[i]] = vp, k++;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; k;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(vis[i] == vp) cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; i;    &#125;    cout &lt;&lt; endl;    <span class="hljs-built_in">fflush</span>(stdout);    cin &gt;&gt; res;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    cnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        <span class="hljs-built_in">add</span>(x, y);        <span class="hljs-built_in">add</span>(y, x);    &#125;    cnt = <span class="hljs-number">0</span>;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);    <span class="hljs-type">int</span> mx;    cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    cout &lt;&lt; n &lt;&lt; endl;    <span class="hljs-built_in">fflush</span>(stdout);    cin &gt;&gt; mx;    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = cnt, mid;    <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> &lt; r)&#123;        mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">getans</span>(l, mid) == mx)&#123;            r = mid;        &#125;<span class="hljs-keyword">else</span>&#123;            l = mid;<span class="hljs-comment">//二分部分小改一下 因为要找的是两点间的连边</span>        &#125;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; a[l] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; a[r] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="e.-bored-bakry">E. Bored Bakry</h4><p>题意：给一个长度为 <span class="math inline">\(n\)</span> 的序列<span class="math inline">\(a\)</span>，找到最长的子区间 <spanclass="math inline">\(a_l..a_r\)</span>使得子区间所有元素的与运算和大于异或和</p><p>对每一位考虑，在第 <span class="math inline">\(k\)</span>位上，与和为1的条件是区间所有数第 <span class="math inline">\(k\)</span>位全是1；异或和为1的条件是区间中第 <spanclass="math inline">\(k\)</span> 位为1的数量是奇数个</p><p>那么可以注意到如果区间长度为奇数，任一位上与和为1的时候异或和也一定为1，与和不可能大于异或和</p><p>现在考虑，对于特定一个区间，如何判断它是否满足条件：</p><ul><li>首先它的长度必须为偶数</li><li>从高位到低位枚举，如果它在第 <span class="math inline">\(k\)</span>位时第一次满足了<strong>区间第 <span class="math inline">\(k\)</span>位全为1</strong>，那么比 <span class="math inline">\(k\)</span>更高的位上1数量必须都为偶数</li></ul><p>可以维护一个前缀异或和（记为 <spanclass="math inline">\(xsum\)</span>），从高位到低位枚举到第 <spanclass="math inline">\(k\)</span> 位时，<spanclass="math inline">\(xsum(i)\)</span>表示仅考虑前 <spanclass="math inline">\(k-1\)</span> 位值时，前 <spanclass="math inline">\(i\)</span> 位的异或和</p><p>第二个条件其实就相当于 <span class="math inline">\(xsum(r) =xsum(l-1)\)</span>，因为前面这些位上的1都是偶数个</p><p>那么做法就很显然了：从高位到低位枚举，每一层中对于每一个1的位置 <spanclass="math inline">\(r\)</span>，去找最小的满足条件的 <spanclass="math inline">\(l\)</span>，同时维护 <spanclass="math inline">\(xsum\)</span> 即可</p><p>关于找最小的 <span class="math inline">\(l\)</span>，记录同一段连续1内每一个 <span class="math inline">\(xsum\)</span>值最早出现的位置即可（详见代码）</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gtw</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> w)</span></span>&#123; <span class="hljs-keyword">return</span> (x &gt;&gt; (w<span class="hljs-number">-1</span>)) &amp; <span class="hljs-number">1</span>;&#125;<span class="hljs-type">int</span> n, a[maxn], p[maxn];<span class="hljs-type">int</span> xsum[maxn], pos[maxn * <span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; a[i];    &#125;    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">21</span>;k&gt;=<span class="hljs-number">1</span>;k--)&#123;        <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r;        <span class="hljs-keyword">while</span>(l &lt; n)&#123;            <span class="hljs-keyword">while</span>(l &lt;= n &amp;&amp; <span class="hljs-built_in">gtw</span>(a[l], k) == <span class="hljs-number">0</span>) l++;            <span class="hljs-keyword">if</span>(l &gt; n) <span class="hljs-keyword">break</span>;            r = l + <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span>(r &lt;= n &amp;&amp; <span class="hljs-built_in">gtw</span>(a[r], k) == <span class="hljs-number">1</span>) r++;            r--;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=l<span class="hljs-number">-1</span>;j&lt;=r;j+=<span class="hljs-number">2</span>) pos[xsum[j]] = <span class="hljs-number">-1</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=l<span class="hljs-number">-1</span>;j&lt;=r;j+=<span class="hljs-number">2</span>)&#123;                <span class="hljs-keyword">if</span>(pos[xsum[j]] == <span class="hljs-number">-1</span>) pos[xsum[j]] = j;                <span class="hljs-keyword">else</span> ans = <span class="hljs-built_in">max</span>(ans, j - pos[xsum[j]]);            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=l;j&lt;=r;j+=<span class="hljs-number">2</span>) pos[xsum[j]] = <span class="hljs-number">-1</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=l;j&lt;=r;j+=<span class="hljs-number">2</span>)&#123;                <span class="hljs-keyword">if</span>(pos[xsum[j]] == <span class="hljs-number">-1</span>) pos[xsum[j]] = j;                <span class="hljs-keyword">else</span> ans = <span class="hljs-built_in">max</span>(ans, j - pos[xsum[j]]);            &#125;            l = r + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;            p[i] += a[i] &amp; (<span class="hljs-number">1</span> &lt;&lt; (k<span class="hljs-number">-1</span>));            xsum[i] = xsum[i<span class="hljs-number">-1</span>] ^ p[i];        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 755 div.1 ABC</title>
    <link href="/2021/11/14/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20755%20div.1/"/>
    <url>/2021/11/14/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20755%20div.1/</url>
    
    <content type="html"><![CDATA[<p>第一次打div1，头被锤烂了（</p><h4 id="a.-two-arrays">A. Two Arrays</h4><p>题意：有两个 <span class="math inline">\(1-n\)</span> 的排列 <spanclass="math inline">\(a,b\)</span>，可以对 <spanclass="math inline">\(a\)</span> 序列进行如下操作：</p><ol type="1"><li>将一些位置上的数+1</li><li>任意改变 <span class="math inline">\(a\)</span> 的顺序</li></ol><p>问能否一次操作将 <span class="math inline">\(a\)</span> 变成 <spanclass="math inline">\(b\)</span></p><p>排序后依次判断每一位上的 <span class="math inline">\(a\)</span>能否变成 <span class="math inline">\(b\)</span> 即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn], b[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; b[i];    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+n+<span class="hljs-number">1</span>);    <span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>, b+n+<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(a[i] &gt; b[i])&#123;            cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(a[i] &lt; b[i] - <span class="hljs-number">1</span>)&#123;            cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;&#125;</code></pre></div><p>7分钟签完这题，剩下时间都在坐牢了（（</p><h4 id="b.-guess-the-permutation">B. Guess the Permutation</h4><p>题意：交互题，有一个 <span class="math inline">\(1-n\)</span> 的排列<span class="math inline">\(a\)</span>，初始时 <spanclass="math inline">\(a_i = i\)</span>，电脑对这个序列进行了一次更改：将<span class="math inline">\([i,j-1]\)</span>，<spanclass="math inline">\([j,k]\)</span> 两个区间翻转了，你可以询问：<spanclass="math inline">\([l,r]\)</span>上有多少个逆序对？询问至多40次，要猜出 <spanclass="math inline">\(i,j,k\)</span></p><p>先二分找到 <spanclass="math inline">\(i\)</span>，用至多30次，然后可以根据 <spanclass="math inline">\([i,n]\)</span> 的结果减去 <spanclass="math inline">\([i+1,n]\)</span>直接得出第一个逆序串的长度。。同理第二个也很好弄了。</p><p>考场上剩下时间全在搞这个题的玄学二分优化、三分</p><p>赛后一看代码，发现核心思维压根就没想到，很服气</p><div class="code-wrapper"><pre><code class="hljs c++">ll n;<span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll l, ll r)</span></span>&#123;    cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; l &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; r &lt;&lt; endl;    cout.<span class="hljs-built_in">flush</span>();    ll x;    cin &gt;&gt; x;    <span class="hljs-keyword">return</span> x;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;     cin &gt;&gt; n;    ll l = <span class="hljs-number">1</span>, r = n;    <span class="hljs-keyword">while</span>(l &lt; r)&#123;        ll mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        ll x = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, mid);        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>)&#123;            l = mid;        &#125;<span class="hljs-keyword">else</span>&#123;            r = mid - <span class="hljs-number">1</span>;        &#125;    &#125;    ll s1 = <span class="hljs-number">1</span> + <span class="hljs-built_in">query</span>(l, n) - <span class="hljs-built_in">query</span>(l + <span class="hljs-number">1</span>, n);    ll j = l + s1;    ll s2 = <span class="hljs-number">1</span> + <span class="hljs-built_in">query</span>(j, n) - <span class="hljs-built_in">query</span>(j + <span class="hljs-number">1</span>, n);    cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; l &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; l + s1 &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; l + s1 + s2 - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;     cout.<span class="hljs-built_in">flush</span>();&#125;</code></pre></div><h4 id="c.-game-with-stones">C. Game with Stones</h4><p>题意：有一列石头堆 <span class="math inline">\(a\)</span>，<spanclass="math inline">\(a_i\)</span> 表示第 <spanclass="math inline">\(i\)</span>堆石头的数量，Bob每次可以选择两个相邻的石头堆，同时从中拿走一个石头（不能选择空石头堆），如果Bob可以把这列石头堆全部清空，则Bob获胜。现在问有多少组<span class="math inline">\([l,r]\)</span> 使得单独拿出 <spanclass="math inline">\(l\)</span> 到 <spanclass="math inline">\(r\)</span> 位置上的石头，可以使Bob获胜。</p><p>首先可以注意到，任意一列石头，Bob必须从两端开始取，比如从左到右取，那么就依次让每个位置上的值减去上一位的值，设<spanclass="math inline">\(c_i=a_i-c_{i-1}\)</span>，如果取的中途出现了一位<span class="math inline">\(c_i\)</span>为负数，则一定不能获胜；取到结尾处如果 <spanclass="math inline">\(c_n=0\)</span> 则恰能获胜，否则还是不能获胜。</p><p>考虑左端点为1的情况：直接一遍计算出所有的 <spanclass="math inline">\(c\)</span>，然后统计 <spanclass="math inline">\(c\)</span><strong>在第一个负数之前0的个数</strong>，即为左端点为1的答案。</p><p>接下来考虑如何快速转移：忽略第一堆石头，将左端点为1情况下的 <spanclass="math inline">\(c\)</span> 转移到左端点为2的情况。</p><p>很显然，将最左边的 <span class="math inline">\(a_1\)</span>去掉会使得 <span class="math inline">\(c_2\)</span> 加上 <spanclass="math inline">\(a_1\)</span>，<spanclass="math inline">\(c_3\)</span> 减去 <spanclass="math inline">\(a_1\)</span>，<spanclass="math inline">\(c_4\)</span> 又加上 <spanclass="math inline">\(a_1\)</span> ...</p><p>即使得后面的所有奇数位加上或减去 <spanclass="math inline">\(a_1\)</span>，偶数位反之；在任何一次转移中，所有的奇数位都同时变化，偶数位也同时变化。</p><p>那么可以考虑将奇偶数位分开维护，这样我们只需要一种数据结构，需要支持<strong>区间加减法</strong>和区间查找<span class="math inline">\(c\)</span><strong>在第一个负数之前0的个数</strong></p><p>这里给出一种线段树维护的思路：</p><p>对于奇数位和偶数位各开一个线段树，维护区间<strong>最小值</strong>和<strong>最小值的数量</strong>，这个在区间加减法下很容易维护。</p><p>写两种操作：查询<strong>区间第一个负数的位置</strong>和查询<strong>不含负数区间中0的数量</strong>，显然这两个操作能够满足需求。</p><p>第一种操作，查找时若左段的最小值为负，则查找左边，否则查找右边；</p><p>第二种操作，因为保证区间没有负数了，找到对应区间后直接返回最小值数量即可，注意要筛掉最小值不为0的区间。</p><div class="code-wrapper"><pre><code class="hljs c++">ll n, a[maxn], c[maxn];<span class="hljs-function">ll <span class="hljs-title">f1</span><span class="hljs-params">(ll x)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x - <span class="hljs-number">1</span>;&#125;<span class="hljs-function">ll <span class="hljs-title">f2</span><span class="hljs-params">(ll x)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegTree</span>&#123;    ll num[maxn &lt;&lt; <span class="hljs-number">2</span>], mi[maxn &lt;&lt; <span class="hljs-number">2</span>], tad[maxn &lt;&lt; <span class="hljs-number">2</span>];    ll ls[maxn &lt;&lt; <span class="hljs-number">2</span>], rs[maxn &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-built_in">ll</span> (*fp)(ll);    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(ll p)</span></span>&#123;        num[p] = num[ls[p]] + num[rs[p]];        mi[p] = <span class="hljs-built_in">min</span>(mi[ls[p]], mi[rs[p]]);        num[p] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(mi[p] == mi[ls[p]]) num[p] += num[ls[p]];        <span class="hljs-keyword">if</span>(mi[p] == mi[rs[p]]) num[p] += num[rs[p]];    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_add</span><span class="hljs-params">(ll p, ll ad)</span></span>&#123;        mi[p] += ad;        tad[p] += ad;    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(ll p)</span></span>&#123;        <span class="hljs-built_in">push_add</span>(ls[p], tad[p]);        <span class="hljs-built_in">push_add</span>(rs[p], tad[p]);        tad[p] = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll p, ll l, ll r)</span></span>&#123;        <span class="hljs-keyword">if</span>(l &gt; r) <span class="hljs-keyword">return</span>;        tad[p] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(l == r)&#123;            num[p] = <span class="hljs-number">1</span>;            mi[p] = c[<span class="hljs-built_in">fp</span>(l)];            <span class="hljs-keyword">return</span>;        &#125;        ll mid = (l + r) / <span class="hljs-number">2</span>;        ls[p] = p*<span class="hljs-number">2</span>, rs[p] = p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;        <span class="hljs-built_in">build</span>(p*<span class="hljs-number">2</span>, l, mid);        <span class="hljs-built_in">build</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r);        <span class="hljs-built_in">push_up</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(ll p, ll l, ll r, ll L, ll R, ll ad)</span></span>&#123;        <span class="hljs-comment">//lr为线段树中节点管辖下标范围，LR为实际查询范围</span>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fp</span>(l) &gt; R || <span class="hljs-built_in">fp</span>(r) &lt; L) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(L &lt;= <span class="hljs-built_in">fp</span>(l) &amp;&amp; <span class="hljs-built_in">fp</span>(r) &lt;= R)&#123;            <span class="hljs-built_in">push_add</span>(p, ad);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-built_in">push_down</span>(p);        ll mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-built_in">modify</span>(ls[p], l, mid, L, R, ad);        <span class="hljs-built_in">modify</span>(rs[p], mid+<span class="hljs-number">1</span>, r, L, R, ad);        <span class="hljs-built_in">push_up</span>(p);    &#125;    <span class="hljs-function">ll <span class="hljs-title">query_lz</span><span class="hljs-params">(ll p, ll l, ll r, ll L, ll R)</span></span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fp</span>(l) &gt; R || <span class="hljs-built_in">fp</span>(r) &lt; L) <span class="hljs-keyword">return</span> <span class="hljs-number">1e9</span>;        <span class="hljs-keyword">if</span>(mi[p] &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1e9</span>;        <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> <span class="hljs-built_in">fp</span>(l);        <span class="hljs-built_in">push_down</span>(p);        ll mid = (l + r) / <span class="hljs-number">2</span>, re = <span class="hljs-number">1e9</span>;        re = <span class="hljs-built_in">min</span>(re, <span class="hljs-built_in">query_lz</span>(ls[p], l, mid, L, R));        <span class="hljs-keyword">if</span>(re &gt; <span class="hljs-number">1e8</span>) re = <span class="hljs-built_in">min</span>(re, <span class="hljs-built_in">query_lz</span>(rs[p], mid+<span class="hljs-number">1</span>, r, L, R));        <span class="hljs-keyword">return</span> re;    &#125;    <span class="hljs-function">ll <span class="hljs-title">query_num</span><span class="hljs-params">(ll p, ll l, ll r, ll L, ll R)</span></span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fp</span>(l) &gt; R || <span class="hljs-built_in">fp</span>(r) &lt; L) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(mi[p] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(L &lt;= <span class="hljs-built_in">fp</span>(l) &amp;&amp; <span class="hljs-built_in">fp</span>(r) &lt;= R) <span class="hljs-keyword">return</span> num[p];<span class="hljs-comment">//已经确认mi[p] == 0</span>        <span class="hljs-built_in">push_down</span>(p);        ll mid = (l + r) / <span class="hljs-number">2</span>, re = <span class="hljs-number">0</span>;        re += <span class="hljs-built_in">query_num</span>(ls[p], l, mid, L, R);        re += <span class="hljs-built_in">query_num</span>(rs[p], mid+<span class="hljs-number">1</span>, r, L, R);        <span class="hljs-keyword">return</span> re;    &#125;&#125;st1, st2;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++) c[i] = a[i] - c[i<span class="hljs-number">-1</span>];    st1.fp = f1;    st2.fp = f2;    st1.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>);    st2.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n/<span class="hljs-number">2</span>);    ll ans = <span class="hljs-number">0</span>;    ll zp = <span class="hljs-built_in">min</span>(st1.<span class="hljs-built_in">query_lz</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, n),                 st2.<span class="hljs-built_in">query_lz</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, n));    <span class="hljs-keyword">if</span>(zp &gt; <span class="hljs-number">1e8</span>) zp = n + <span class="hljs-number">1</span>;    ans += st1.<span class="hljs-built_in">query_num</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, zp<span class="hljs-number">-1</span>);    ans += st2.<span class="hljs-built_in">query_num</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, zp<span class="hljs-number">-1</span>);    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;            st1.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>, i+<span class="hljs-number">1</span>, n, a[i]);            st2.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n/<span class="hljs-number">2</span>, i+<span class="hljs-number">1</span>, n, -a[i]);        &#125;<span class="hljs-keyword">else</span>&#123;            st1.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>, i+<span class="hljs-number">1</span>, n, -a[i]);            st2.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n/<span class="hljs-number">2</span>, i+<span class="hljs-number">1</span>, n, a[i]);        &#125;        ll zp = <span class="hljs-built_in">min</span>(st1.<span class="hljs-built_in">query_lz</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>, i+<span class="hljs-number">1</span>, n),                     st2.<span class="hljs-built_in">query_lz</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n/<span class="hljs-number">2</span>, i+<span class="hljs-number">1</span>, n));        <span class="hljs-keyword">if</span>(zp &gt; <span class="hljs-number">1e8</span>) zp = n + <span class="hljs-number">1</span>;        ans += st1.<span class="hljs-built_in">query_num</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>, i+<span class="hljs-number">1</span>, zp<span class="hljs-number">-1</span>);        ans += st2.<span class="hljs-built_in">query_num</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n/<span class="hljs-number">2</span>, i+<span class="hljs-number">1</span>, zp<span class="hljs-number">-1</span>);    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 749 div.1 2 A-E</title>
    <link href="/2021/10/17/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20749%20div.1%202/"/>
    <url>/2021/10/17/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20749%20div.1%202/</url>
    
    <content type="html"><![CDATA[<h4 id="a.-windblume-ode">A. Windblume Ode</h4><p>题意：给一个数字集合（<spanclass="math inline">\(n\ge3\)</span>），要从中取出尽可能多的数字，使之和为合数</p><p>判断总和是否为质数，是质数就随便去掉一个奇数就好了</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; a[i];        sum += a[i];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;sum;i++)&#123;        <span class="hljs-keyword">if</span>(sum % i == <span class="hljs-number">0</span>)&#123;            cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;            cout &lt;&lt; n &lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(a[i] %<span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;            cout &lt;&lt; n - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;            <span class="hljs-type">bool</span> f = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;                <span class="hljs-keyword">if</span>(j == i) <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">if</span>(f) cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;                <span class="hljs-keyword">else</span> f = <span class="hljs-literal">true</span>;                cout &lt;&lt; j;            &#125;            cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;&#125;</code></pre></div><h4 id="b.-omkar-and-heavenly-tree">B. Omkar and Heavenly Tree</h4><p>题意：要构造一个 <span class="math inline">\(n\)</span>个节点的数，满足 <span class="math inline">\(m\)</span>个约束。一个约束描述为 <spanclass="math inline">\(a,b,c\)</span>，表示节点 <spanclass="math inline">\(b\)</span> 不能在 <spanclass="math inline">\(a,c\)</span> 之间的简单路径上，（<spanclass="math inline">\(m\lt n\)</span>）</p><p>这题乍一看没什么思路，突破口在于 <span class="math inline">\(m \ltn\)</span> 这个条件，我们发现，至少有一个节点没有被约束，设它为 <spanclass="math inline">\(mid\)</span></p><p>只需要把其他所有点都直接连在 <span class="math inline">\(mid\)</span>上即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> vis[maxn]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        vis[i] = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-type">int</span> x, y, z;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;        vis[y] = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-type">int</span> mid;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(!vis[i])&#123;            mid = i;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(i != mid)&#123;            cout &lt;&lt; mid &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;        &#125;    &#125; &#125;</code></pre></div><h4 id="c.-omkar-and-determination">C. Omkar and Determination</h4><p>题意：给出一个 <span class="math inline">\(n\times m\)</span>的地图，每一格可以是空地或墙，每个空地上存在一个机器人，它可以向左或向上走；</p><p>​对于一个地图，我们可以把所有<strong>能走出地图</strong>的空格染成白色，其他格子染成黑色；</p><p>​如果一个地图可以<strong>仅根据染色后的结果</strong>推断出原先的图（哪些是空地哪些是墙），那么称这个地图是<strong>有决心的</strong>；</p><p>​ 接下来有 <span class="math inline">\(q\)</span> 个询问，每次询问从<span class="math inline">\(x_1\)</span> 列到 <spanclass="math inline">\(x_2\)</span> 列的这个子图是不是有决心的。</p><p>解：考虑什么样的图的有决心的，可以想到如果存在这样的两个墙，一定不是有决心的（右下角无法确定）<span class="math display">\[0 1\\1 ?\]</span> ​再想一想可以发现，所有<strong>有决心的</strong>图都一定不包含这种东西</p><p>​ 对于每一列 <span class="math inline">\(j\)</span>，如果 <spanclass="math inline">\(j\)</span> 和 <spanclass="math inline">\(j+1\)</span>列中存在这样的形状就记这列为1，前缀和搞一下查询就好了</p><div class="code-wrapper"><pre><code class="hljs c++">string s[<span class="hljs-number">1000004</span>];<span class="hljs-type">int</span> n, m, sum[<span class="hljs-number">1000004</span>]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; s[i];        s[i] = <span class="hljs-string">&#x27;0&#x27;</span> + s[i];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) sum[i] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;m;j++)&#123;            <span class="hljs-keyword">if</span>(s[i][j] == <span class="hljs-string">&#x27;X&#x27;</span> &amp;&amp; s[i<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;X&#x27;</span>)&#123;                sum[j] = <span class="hljs-number">1</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;=m;j++) sum[j] += sum[j<span class="hljs-number">-1</span>];    <span class="hljs-type">int</span> Q;    cin &gt;&gt; Q;    <span class="hljs-keyword">while</span>(Q--)&#123;        <span class="hljs-type">int</span> l, r;        cin &gt;&gt; l &gt;&gt; r;        <span class="hljs-keyword">if</span>(sum[r<span class="hljs-number">-1</span>]-sum[l<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="d.-omkar-and-the-meaning-of-life">D. Omkar and the Meaning ofLife</h4><p>题意：交互题，要猜一个 <span class="math inline">\(n\)</span> 的排列<span class="math inline">\(p_1,p_2...p_n\)</span>，每次猜测可以输入一个长度为 <span class="math inline">\(n\)</span>的数列 <spanclass="math inline">\(a_1,a_2...a_n\)</span>，随后形成一个新的序列 <spanclass="math inline">\(s\)</span>，根据 <span class="math inline">\(s_i =a_i+p_i\)</span> ，然后会返回 <span class="math inline">\(s\)</span>中<strong>第一次重复出现元素的下标</strong>，都不重复则返回0，询问至多<span class="math inline">\(2n\)</span> 次</p><p>解：交互题往往有个构造题的思路，先考虑给所有数都加上1，唯独最后一个数加<span class="math inline">\(x\)</span>，如果 <spanclass="math inline">\(p_n + x \gtn+1\)</span>，那么输出为0，否则有其他输出，那么可以从小到大枚举 <spanclass="math inline">\(x\)</span>，最多 <spanclass="math inline">\(n\)</span> 次即可猜出 <spanclass="math inline">\(p_n\)</span> 的数值</p><p>现在知道最后一位数的值了，接下来给所有数都加上 <spanclass="math inline">\(p_n\)</span>，唯独最后一位数加上1，就可以知道1所在的位置</p><p>依次类推，再 <span class="math inline">\(n\)</span>次查询即可知道所有数的位置。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, a[maxn]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    a[n] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=n;k&gt;=<span class="hljs-number">2</span>;k--)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;        cout &lt;&lt; n-k+<span class="hljs-number">2</span> &lt;&lt; endl;        cout.<span class="hljs-built_in">flush</span>();        <span class="hljs-type">int</span> re;        cin &gt;&gt; re;        <span class="hljs-keyword">if</span>(re == <span class="hljs-number">0</span>)&#123;            a[n] = k;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(i == a[n]) <span class="hljs-keyword">continue</span>;        cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++) cout &lt;&lt; a[n] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;        cout &lt;&lt; i &lt;&lt; endl;        cout.<span class="hljs-built_in">flush</span>();         <span class="hljs-type">int</span> re;        cin &gt;&gt; re;        a[re] = i;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;!&quot;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; a[i];    cout &lt;&lt; endl;&#125;</code></pre></div><h4 id="d2.-half-of-same">D2. Half of Same</h4><p>题意：和D1一样，区别在于只需要有一半数减去若干个 <spanclass="math inline">\(k\)</span> 后变成相同的数字</p><p><span class="math inline">\(n\le40, -10^6\le a_i \le10^6\)</span></p><p>先考虑，如果有一个 <spanclass="math inline">\(k\)</span>，我们怎么判断它是否合法：</p><p>可以让每个数都减 <span class="math inline">\(k\)</span>减到<strong>第一次小于 <span class="math inline">\(mi\)</span>为止</strong>，然后数一下有多少数是相同的</p><p>这个Judge过程是 <span class="math inline">\(O(n)\)</span> 的</p><p>那么有多少个 <span class="math inline">\(k\)</span> 需要judge呢？</p><p>可以从1到2e6全部枚举一遍，<span class="math inline">\(O(2e6\timesn)\)</span> 看似可行，然而被卡常了</p><p>想到这个 <span class="math inline">\(k\)</span>一定是某两个数的差的约数，又因为 <span class="math inline">\(n\)</span>很小，可以非常暴力地枚举任意两个数，再枚举它们差的约数，总复杂度 <spanclass="math inline">\(O(n^2\sqrt{2\times10^6}\times n)\)</span></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">50</span>];<span class="hljs-type">int</span> mia, mxa;<span class="hljs-type">int</span> num[<span class="hljs-number">5000009</span>];<span class="hljs-type">int</span> n; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;    <span class="hljs-type">bool</span> re = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> t = a[i] - (a[i]-mia+k<span class="hljs-number">-1</span>)/k*k;        num[t]++;        <span class="hljs-keyword">if</span>(num[t] &gt;= n/<span class="hljs-number">2</span>) re = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> t = a[i] - (a[i]-mia+k<span class="hljs-number">-1</span>)/k*k;        num[t]--;    &#125;    <span class="hljs-keyword">return</span> re;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    mia = <span class="hljs-number">2e8</span>, mxa = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; a[i];        a[i] += <span class="hljs-number">4000000</span>;        mia = <span class="hljs-built_in">min</span>(mia, a[i]);        mxa = <span class="hljs-built_in">max</span>(mxa, a[i]);    &#125;     <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+n+<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n;j++)&#123;            <span class="hljs-keyword">if</span>(a[j] != a[i])&#123;                i = j - <span class="hljs-number">1</span>;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span>(j - i + <span class="hljs-number">1</span> &gt;= n/<span class="hljs-number">2</span>)&#123;                cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;        &#125;    &#125;     <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;            <span class="hljs-type">int</span> d = <span class="hljs-built_in">abs</span>(a[j] - a[i]);            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-built_in">sqrt</span>(d);k++)&#123;                <span class="hljs-keyword">if</span>(d % k != <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(k)) ans = <span class="hljs-built_in">max</span>(ans, k);                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(d/k)) ans = <span class="hljs-built_in">max</span>(ans, d/k);            &#125;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="e.-moment-of-bloom">E. Moment of Bloom</h4><p>个人感觉最妙的一道题，做的时候一点思路没有，一看题解恍然大悟</p><p>题意：有一个 <span class="math inline">\(n\)</span> 节点，<spanclass="math inline">\(m\)</span> 条边的连通图（无重边自环），有 <spanclass="math inline">\(q\)</span> 个操作，每次操作仅给出 <spanclass="math inline">\(a,b\)</span>两个点，可以在两点间任选一条简单路径，使路径上的边权都+1（初始为0），问这<span class="math inline">\(q\)</span>个操作后能否使所有边权均为偶数？如果不能输出需要额外操作的数量</p><p>解：一个点<strong>相邻边的边权之和</strong> =以这个点为端点的路径条数 + 其他经过这个点的路径条数 * 2</p><p>​那么如果一个点在操作中出现了奇数次，那么它连的边权之和也为奇数，也就是说必然存在一条边不满足条件</p><p>​所以可以统计所有操作中各个点出现的次数，如果存在奇数次的点，答案即为NO，额外需要奇数点个数/2次操作</p><p>​所有点均出现偶数次，答案即为YES，这题还要求输出每一个操作所选择的路径，怎么构造呢——</p><p>​其实很简单，把图改造成任一个生成树，然后走唯一路径就好了（（具体可以颅内理解一下，不难证明正确性</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> cnt[maxn];vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];vector&lt;<span class="hljs-type">int</span>&gt; vt[maxn]; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Query</span>&#123;    <span class="hljs-type">int</span> x, y;&#125;q[maxn]; <span class="hljs-type">int</span> vis[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;    vis[p] = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;v : vp[p])&#123;        <span class="hljs-keyword">if</span>(!vis[v])&#123;            vt[p].<span class="hljs-built_in">push_back</span>(v);            vt[v].<span class="hljs-built_in">push_back</span>(p);            <span class="hljs-built_in">dfs</span>(v);        &#125;    &#125;&#125; <span class="hljs-type">int</span> ans[maxn], hd;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfsf</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> t)</span></span>&#123;    ans[++hd] = p;    <span class="hljs-keyword">if</span>(p == t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;v : vt[p])&#123;        <span class="hljs-keyword">if</span>(v != fa)&#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfsf</span>(v, p, t)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;    &#125;    hd--;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        vp[x].<span class="hljs-built_in">push_back</span>(y);        vp[y].<span class="hljs-built_in">push_back</span>(x);    &#125;    <span class="hljs-type">int</span> qm;    cin &gt;&gt; qm;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=qm;i++)&#123;        cin &gt;&gt; q[i].x &gt;&gt; q[i].y;        cnt[q[i].x]++;        cnt[q[i].y]++;    &#125;    <span class="hljs-type">int</span> odd = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) odd += cnt[i]%<span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span>(odd &gt; <span class="hljs-number">0</span>)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;        cout &lt;&lt; odd/<span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=qm;i++)&#123;            hd = <span class="hljs-number">0</span>;            <span class="hljs-built_in">dfsf</span>(q[i].x, <span class="hljs-number">-1</span>, q[i].y);            cout &lt;&lt; hd &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;hd;j++) cout &lt;&lt; ans[j] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;            cout &lt;&lt; ans[hd] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 748 div.3 A-G</title>
    <link href="/2021/10/13/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20748%20div.3/"/>
    <url>/2021/10/13/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20748%20div.3/</url>
    
    <content type="html"><![CDATA[<h4 id="a.-elections">A. Elections</h4><p>题意：有三个数ABC，问他们分别需要加多少才能成为三个数中最大的</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> a, b, c;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;    <span class="hljs-type">int</span> mx = <span class="hljs-built_in">max</span>(a, <span class="hljs-built_in">max</span>(b, c));    <span class="hljs-type">int</span> mx2 = a+b+c - mx - <span class="hljs-built_in">min</span>(a, <span class="hljs-built_in">min</span>(b, c));     <span class="hljs-keyword">if</span>(a == mx &amp;&amp; mx2 != mx) cout &lt;&lt; <span class="hljs-string">&quot;0 &quot;</span>;    <span class="hljs-keyword">else</span> cout &lt;&lt; mx+<span class="hljs-number">1</span>-a &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    <span class="hljs-keyword">if</span>(b == mx &amp;&amp; mx2 != mx) cout &lt;&lt; <span class="hljs-string">&quot;0 &quot;</span>;    <span class="hljs-keyword">else</span> cout &lt;&lt; mx+<span class="hljs-number">1</span>-b &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;     <span class="hljs-keyword">if</span>(c == mx &amp;&amp; mx2 != mx) cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;    <span class="hljs-keyword">else</span> cout &lt;&lt; mx+<span class="hljs-number">1</span>-c &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; &#125;</code></pre></div><h4 id="b.-make-it-divisible-by-25">B. Make it Divisible by 25</h4><p>题意：给定一个数字，问至少从中删除几位数，可以使他能被25整除</p><p>只要最后两位是00,25,50,75即可，那么从低位到高位找，分别找这几种第一次出现的位置，取最小即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[maxn], ans;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getnum</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">int</span> a2)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">20</span>;i++)&#123;        <span class="hljs-keyword">if</span>(a[i] == a2)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;<span class="hljs-number">20</span>;j++)&#123;                <span class="hljs-keyword">if</span>(a[j] == a1)&#123;                    ans = <span class="hljs-built_in">min</span>(ans, j - <span class="hljs-number">2</span>);                    <span class="hljs-keyword">return</span>;                &#125;            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    ll n;    cin &gt;&gt; n;    ans = <span class="hljs-number">1e9</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">20</span>;i++)&#123;        a[i] = n%<span class="hljs-number">10</span>;        n /= <span class="hljs-number">10</span>;    &#125;    <span class="hljs-built_in">getnum</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    <span class="hljs-built_in">getnum</span>(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>);    <span class="hljs-built_in">getnum</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);    <span class="hljs-built_in">getnum</span>(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>);    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="c.-save-more-mice">C. Save More Mice</h4><p>题意：X轴上有若干个老鼠，每个老鼠的位置都是整数，<spanclass="math inline">\((n,0)\)</span> 处有一个洞，<spanclass="math inline">\((0,0)\)</span>中有一只猫，每回合可以选择一只老鼠向右移动一格，抵达洞即安全，每回合猫也向右移动一格，吃掉该格上的老鼠。问最多可以让多少老鼠存活</p><p>因为老鼠和猫的移动速度相同，任何一只老鼠都不可能和猫拉开距离，所以每次都选择离洞最近的老鼠让它进洞，答案一定最大。模拟即可。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    ll n, k;    cin &gt;&gt; n &gt;&gt; k;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;        cin &gt;&gt; a[i];    &#125;    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+k+<span class="hljs-number">1</span>);    ll ans = <span class="hljs-number">0</span>, p = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k;i&gt;=<span class="hljs-number">1</span>;i--)&#123;        <span class="hljs-keyword">if</span>(p &gt;= a[i]) <span class="hljs-keyword">break</span>;        p += n - a[i];        ans++;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="d1.-all-are-same">D1. All are Same</h4><p>题意：给一个序列，要找一个最大的 <spanclass="math inline">\(k\)</span>，使得所有数都可以减去若干个 <spanclass="math inline">\(k\)</span> 后变成相同的数字</p><p>找到最小的数 <spanclass="math inline">\(mi\)</span>，然后计算每个数和 <spanclass="math inline">\(mi\)</span> 的差的 <spanclass="math inline">\(gcd\)</span> 和即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> st[maxn];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;    <span class="hljs-type">int</span> t, nt, tp;&#125;e[maxn &lt;&lt; <span class="hljs-number">1</span>];<span class="hljs-type">int</span> head[maxn], ecnt = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> tp)</span></span>&#123;    e[++ecnt].t = y;    e[ecnt].tp = tp;    e[ecnt].nt = head[x];    head[x] = ecnt;&#125;<span class="hljs-type">int</span> num[<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[p];i;i=e[i].nt)&#123;        <span class="hljs-type">int</span> v = e[i].t;        <span class="hljs-keyword">if</span>(st[v] == <span class="hljs-number">-1</span>)&#123;            st[v] = st[p] ^ e[i].tp;            num[st[v]]++;            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(v)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(st[v] != (st[p] ^ e[i].tp)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n, m;    cin &gt;&gt; n &gt;&gt; m;    ecnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        head[i] = <span class="hljs-number">0</span>;        st[i] = <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-type">int</span> x, y; string s;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; s;        <span class="hljs-type">int</span> tp = (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;i&#x27;</span>);        <span class="hljs-built_in">add</span>(x, y, tp);        <span class="hljs-built_in">add</span>(y, x, tp);    &#125;    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(st[i] == <span class="hljs-number">-1</span>)&#123;            st[i] = <span class="hljs-number">1</span>;            num[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;            num[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i))&#123;                cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;            ans += <span class="hljs-built_in">max</span>(num[<span class="hljs-number">0</span>], num[<span class="hljs-number">1</span>]);        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="d2.-half-of-same">D2. Half of Same</h4><p>题意：和D1一样，区别在于只需要有一半数减去若干个 <spanclass="math inline">\(k\)</span> 后变成相同的数字</p><p><span class="math inline">\(n\le40, -10^6\le a_i \le10^6\)</span></p><p>先考虑，如果有一个 <spanclass="math inline">\(k\)</span>，我们怎么判断它是否合法：</p><p>可以让每个数都减 <span class="math inline">\(k\)</span>减到<strong>第一次小于 <span class="math inline">\(mi\)</span>为止</strong>，然后数一下有多少数是相同的</p><p>这个Judge过程是 <span class="math inline">\(O(n)\)</span> 的</p><p>那么有多少个 <span class="math inline">\(k\)</span> 需要judge呢？</p><p>可以从1到2e6全部枚举一遍，<span class="math inline">\(O(2e6\timesn)\)</span> 看似可行，然而被卡常了</p><p>想到这个 <span class="math inline">\(k\)</span>一定是某两个数的差的约数，又因为 <span class="math inline">\(n\)</span>很小，可以非常暴力地枚举任意两个数，再枚举它们差的约数，总复杂度 <spanclass="math inline">\(O(n^2\sqrt{2\times10^6}\times n)\)</span></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">50</span>];<span class="hljs-type">int</span> mia, mxa;<span class="hljs-type">int</span> num[<span class="hljs-number">5000009</span>];<span class="hljs-type">int</span> n; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;    <span class="hljs-type">bool</span> re = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> t = a[i] - (a[i]-mia+k<span class="hljs-number">-1</span>)/k*k;        num[t]++;        <span class="hljs-keyword">if</span>(num[t] &gt;= n/<span class="hljs-number">2</span>) re = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> t = a[i] - (a[i]-mia+k<span class="hljs-number">-1</span>)/k*k;        num[t]--;    &#125;    <span class="hljs-keyword">return</span> re;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    mia = <span class="hljs-number">2e8</span>, mxa = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; a[i];        a[i] += <span class="hljs-number">4000000</span>;        mia = <span class="hljs-built_in">min</span>(mia, a[i]);        mxa = <span class="hljs-built_in">max</span>(mxa, a[i]);    &#125;     <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+n+<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n;j++)&#123;            <span class="hljs-keyword">if</span>(a[j] != a[i])&#123;                i = j - <span class="hljs-number">1</span>;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span>(j - i + <span class="hljs-number">1</span> &gt;= n/<span class="hljs-number">2</span>)&#123;                cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;        &#125;    &#125;     <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;            <span class="hljs-type">int</span> d = <span class="hljs-built_in">abs</span>(a[j] - a[i]);            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-built_in">sqrt</span>(d);k++)&#123;                <span class="hljs-keyword">if</span>(d % k != <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(k)) ans = <span class="hljs-built_in">max</span>(ans, k);                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(d/k)) ans = <span class="hljs-built_in">max</span>(ans, d/k);            &#125;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="e.-gardener-and-tree">E. Gardener and Tree</h4><p>题意：有一棵树，每次操作可以删除所有的叶子节点（度数为1的节点），问几次操作后树为空</p><p>很明显拓扑删一遍即可，队友说也可以换根dp，改天了解一下（</p><div class="code-wrapper"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];<span class="hljs-type">int</span> du[maxn]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n, k;    cin &gt;&gt; n &gt;&gt; k;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) vp[i].<span class="hljs-built_in">clear</span>(), du[i] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        vp[x].<span class="hljs-built_in">push_back</span>(y);        vp[y].<span class="hljs-built_in">push_back</span>(x);        du[x]++;        du[y]++;    &#125;    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(du[i] == <span class="hljs-number">1</span>)&#123;            q.<span class="hljs-built_in">push</span>(i);        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;        vector&lt;<span class="hljs-type">int</span>&gt; tmp;        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;            <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();            q.<span class="hljs-built_in">pop</span>();            du[u]--;            n--;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;j:vp[u])&#123;                <span class="hljs-keyword">if</span>(du[j] &gt; <span class="hljs-number">0</span>)&#123;                    du[j]--;                    <span class="hljs-keyword">if</span>(du[j] == <span class="hljs-number">1</span>) tmp.<span class="hljs-built_in">push_back</span>(j);                &#125;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;x:tmp) q.<span class="hljs-built_in">push</span>(x);    &#125;    cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="f.-red-black-number">F. Red-Black Number</h4><p>题意：<del>红黑数</del>给一个可能含前导0的数字，要求对将每一位染色成红或者黑，在满足红色数字拼起来后可以被<span class="math inline">\(A\)</span> 整除，黑色数字拼起来可以被 <spanclass="math inline">\(B\)</span>整除的条件下，涂红和涂黑的数量差最小，输出涂色方案。</p><p>乍一看有点不好下手，一看数据范围 <spanclass="math inline">\(n\le40,A,B\le40\)</span>，考虑暴力dp</p><p>设 <span class="math inline">\(dp[i][r][m_1][m_2]\)</span> 表示前<span class="math inline">\(i\)</span> 位中，涂了 <spanclass="math inline">\(r\)</span> 个红色，红色部分模 <spanclass="math inline">\(A\)</span> 结果为 <spanclass="math inline">\(m_1\)</span>，黑色部分模 <spanclass="math inline">\(B\)</span> 结果为 <spanclass="math inline">\(m_2\)</span>时，选择的红色位置（状态压缩，保存方案）</p><p>这样设置状态的原因在于，在后方添加一个新数位时（比如涂成红色），<spanclass="math inline">\(m_1\)</span> 可以转移到 <spanclass="math inline">\((m_1\times10+a[i+1])\modA\)</span>，转移很方便，模结果为0即为合法答案</p><p>想到了状态后，转移不难写</p><div class="code-wrapper"><pre><code class="hljs c++"> <span class="hljs-type">int</span> n, mda, mdb;string a;ll dp[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>][<span class="hljs-number">50</span>][<span class="hljs-number">50</span>];<span class="hljs-comment">//pos, rednum, redres, blkres = respos</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; mda &gt;&gt; mdb;    cin &gt;&gt; a; a = <span class="hljs-string">&quot;s&quot;</span> + a;     <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(dp));    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>; r &lt;= i; r++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> rs = <span class="hljs-number">0</span>; rs &lt; mda; rs++)&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> rb = <span class="hljs-number">0</span>; rb &lt; mdb; rb++)&#123;                    ll t = dp[i][r][rs][rb];                    <span class="hljs-keyword">if</span>(t &gt;= <span class="hljs-number">0</span>)&#123;                        dp[i+<span class="hljs-number">1</span>][r][rs][(rb * <span class="hljs-number">10</span> + a[i+<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>)%mdb] = t;                        dp[i+<span class="hljs-number">1</span>][r+<span class="hljs-number">1</span>][(rs * <span class="hljs-number">10</span> + a[i+<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>)%mda][rb] = t | (<span class="hljs-number">1ll</span> &lt;&lt; i);                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-type">int</span> ans = <span class="hljs-number">1e9</span>;    ll redp;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = n<span class="hljs-number">-1</span>; r &gt;= <span class="hljs-number">1</span>; r--)&#123;        <span class="hljs-keyword">if</span>(dp[n][r][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &gt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>(ans &gt; <span class="hljs-built_in">abs</span>(<span class="hljs-number">2</span> * r - n))&#123;                ans = <span class="hljs-built_in">abs</span>(<span class="hljs-number">2</span> * r - n);                redp = dp[n][r][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(ans &gt;= n) cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;    <span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;            <span class="hljs-keyword">if</span>(redp &amp; (<span class="hljs-number">1ll</span> &lt;&lt; (i<span class="hljs-number">-1</span>))) cout &lt;&lt; <span class="hljs-string">&quot;R&quot;</span>;            <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;B&quot;</span>;        &#125;        cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div><h4 id="g.-changing-brackets">G. Changing Brackets</h4><p>题意：有一个括号序列，包含 ( ) [ ]四种括号，可以免费将括号翻转，或花费1块把圆括号变方括号（或者反过来），有多个询问，每次询问<span class="math inline">\([l,r]\)</span>，需要最少花费多少使这个区间的括号合法，保证 <spanclass="math inline">\([l,r]\)</span> 长度为偶数</p><p>一道纯思维题，考虑怎么样的一个括号序列才合法：我们不断将序列中相邻的同类括号删掉，两边的拼在一起，不断这样删去，最后可能全删了（即这个括号序合法），或者剩下形如( [ ( [ 这样交替出现的括号，剩下的长度的一半就是最小的花费</p><p>一个很容易理解（但可能比较难想到）的性质：圆括号我们直接不管了，剩下的方括号要么全在奇数位，要么全在偶数位</p><p>而这个序列中被删掉的那些方括号，也一定是一奇一偶一起删的</p><p>所以区间 <span class="math inline">\([l,r]\)</span> 的答案就是区间中奇数位方括号数量 - 偶数位方括号数量 再取个绝对值。前缀和搞一下就好了</p><p>感觉很不错的一个题，思维略有难度，但正解很容易让人接受</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> sum[maxn]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    string s;    cin &gt;&gt; s;    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();    s = <span class="hljs-string">&quot;0&quot;</span> + s;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        sum[i] = sum[i<span class="hljs-number">-1</span>];        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;[&#x27;</span> || s[i] == <span class="hljs-string">&#x27;]&#x27;</span>)&#123;            <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) sum[i]++;            <span class="hljs-keyword">else</span> sum[i]--;        &#125;    &#125;    <span class="hljs-type">int</span> q;    cin &gt;&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;        <span class="hljs-type">int</span> l, r;        cin &gt;&gt; l &gt;&gt; r;        cout &lt;&lt; <span class="hljs-built_in">abs</span>(sum[r] - sum[l<span class="hljs-number">-1</span>]) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125; &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 747 div.2 A-E</title>
    <link href="/2021/10/09/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20747%20div.2/"/>
    <url>/2021/10/09/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20747%20div.2/</url>
    
    <content type="html"><![CDATA[<h4 id="a.-consecutive-sum-riddle">A. Consecutive Sum Riddle</h4><p>题意：给定一个 <span class="math inline">\(n\)</span>，要找出 <spanclass="math inline">\(l,r\)</span> 使得 <spanclass="math inline">\(\sum_{i=l}^{r}i=n\)</span></p><p>解：显然，从 <span class="math inline">\(-n+1\)</span> 加到 <spanclass="math inline">\(n\)</span> 即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    ll n;    cin &gt;&gt; n;    cout &lt;&lt; -n+<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="b.-special-numbers">B. Special Numbers</h4><p>题意：找第 <span class="math inline">\(k\)</span> 个 <spanclass="math inline">\(n\)</span> 好数，<spanclass="math inline">\(n\)</span> 好数就是可以被 <spanclass="math inline">\(n\)</span> 的不同次幂组成，比如 <spanclass="math inline">\(n^0+n^2...\)</span> 的方式表示</p><p>解：把 <span class="math inline">\(k\)</span>转化为二进制，然后每一位按照 <span class="math inline">\(n\)</span>的次幂加权计算即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    ll n, k;    cin &gt;&gt; n &gt;&gt; k;    ll ans = <span class="hljs-number">0</span>, t = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(k &gt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>)&#123;            ans = (ans + t) % mode;        &#125;        k &gt;&gt;= <span class="hljs-number">1</span>;        t = t * n % mode;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="c.-make-them-equal">C. Make Them Equal</h4><p>题意：给出一个字符串 <span class="math inline">\(s\)</span> 和字符<spanclass="math inline">\(c\)</span>，可以进行若干次操作，每次操作可以选择一个数<span class="math inline">\(x\)</span>，然后令字符串中所有下标不能被<span class="math inline">\(x\)</span> 的整除的位置上的字符变成 <spanclass="math inline">\(c\)</span>，问最少多少次操作可以使字符串全变成<span class="math inline">\(c\)</span></p><p>解：由于 <spanclass="math inline">\(n&gt;2\)</span>，两次操作分别选择 <spanclass="math inline">\(n\)</span> 和 <spanclass="math inline">\(n-1\)</span>一定可以完成，那么只需要考虑能不能一次完成</p><p>一次完成要求存在一个数 <spanclass="math inline">\(x\)</span>，串中所有可以被 <spanclass="math inline">\(x\)</span> 整除的位置上都已经是 <spanclass="math inline">\(c\)</span>了，暴力枚举即可，复杂度比较玄学但它就是 <spanclass="math inline">\(nlogn\)</span></p><p>后来又听了无敌的会长的优化方案：只需要枚举 <spanclass="math inline">\(n/2\)</span> 以上的 <spanclass="math inline">\(x\)</span> 即可，因为更小的 <spanclass="math inline">\(x\)</span> 总有一个倍数比它更优，复杂度 <spanclass="math inline">\(2n\)</span></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n;    <span class="hljs-type">char</span> c;    string s;    cin &gt;&gt; n &gt;&gt; c &gt;&gt; s;    s = <span class="hljs-string">&quot;0&quot;</span> + s;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">bool</span> flg = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n;j+=i)&#123;            <span class="hljs-keyword">if</span>(s[j] != c)&#123;                flg = <span class="hljs-literal">false</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(flg)&#123;            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>)&#123;                cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;            cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    cout &lt;&lt; <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    cout &lt;&lt; n<span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="d.-the-number-of-imposters">D. The Number of Imposters</h4><p>题意：有 <span class="math inline">\(n\)</span> 个人和 <spanclass="math inline">\(m\)</span> 个陈述，每个陈述形如：<spanclass="math inline">\(i,j,imposter/crewmate\)</span> 表示 <spanclass="math inline">\(i\)</span> 说 <spanclass="math inline">\(j\)</span>是说真话的人/说谎者，问说谎话的人最多有几个</p><p>解：注意到一个性质：如果 <span class="math inline">\(i\)</span> 说<span class="math inline">\(j\)</span> 说的是谎话，那么 <spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span> 必定相反；如果 <spanclass="math inline">\(i\)</span> 说 <spanclass="math inline">\(j\)</span> 说的是真话，那么 <spanclass="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span> 相同。</p><p>那么每个陈述都可以转化为一条边，对每个联通块进行染色后取较多的颜色加入贡献即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> st[maxn];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;    <span class="hljs-type">int</span> t, nt, tp;&#125;e[maxn &lt;&lt; <span class="hljs-number">1</span>];<span class="hljs-type">int</span> head[maxn], ecnt = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> tp)</span></span>&#123;    e[++ecnt].t = y;    e[ecnt].tp = tp;    e[ecnt].nt = head[x];    head[x] = ecnt;&#125;<span class="hljs-type">int</span> num[<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[p];i;i=e[i].nt)&#123;        <span class="hljs-type">int</span> v = e[i].t;        <span class="hljs-keyword">if</span>(st[v] == <span class="hljs-number">-1</span>)&#123;            st[v] = st[p] ^ e[i].tp;            num[st[v]]++;            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(v)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(st[v] != (st[p] ^ e[i].tp)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n, m;    cin &gt;&gt; n &gt;&gt; m;    ecnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        head[i] = <span class="hljs-number">0</span>;        st[i] = <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-type">int</span> x, y; string s;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; s;        <span class="hljs-type">int</span> tp = (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;i&#x27;</span>);        <span class="hljs-built_in">add</span>(x, y, tp);        <span class="hljs-built_in">add</span>(y, x, tp);    &#125;    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(st[i] == <span class="hljs-number">-1</span>)&#123;            st[i] = <span class="hljs-number">1</span>;            num[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;            num[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i))&#123;                cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;            ans += <span class="hljs-built_in">max</span>(num[<span class="hljs-number">0</span>], num[<span class="hljs-number">1</span>]);        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="e1.-rubiks-cube-coloring-easy-version">E1. Rubik's Cube Coloring(easy version)</h4><p>题意：给一颗 <span class="math inline">\(k\)</span>层的完全二叉树，每个节点有一个颜色（共六种），要求每个节点和其相邻节点颜色不能相同，并且规定了三对不能相邻的颜色，问有多少中染色方案</p><p>解：答案为 <span class="math inline">\(4^{2^n-2}\times 6\)</span></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll x, ll p)</span></span>&#123;    ll r = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(p &gt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">if</span>(p &amp; <span class="hljs-number">1</span>) r = r * x % mode;        x = x * x % mode;        p &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> r;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    cout &lt;&lt; <span class="hljs-built_in">qpow</span>(<span class="hljs-number">4</span>, (<span class="hljs-number">1ll</span> &lt;&lt; n) - <span class="hljs-number">2</span>) * <span class="hljs-number">6</span> % mode &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不稳定扫雷 - LudumDare49</title>
    <link href="/2021/10/03/%E7%8E%A9%E5%85%B7/%E4%B8%8D%E7%A8%B3%E5%AE%9A%E6%89%AB%E9%9B%B7/"/>
    <url>/2021/10/03/%E7%8E%A9%E5%85%B7/%E4%B8%8D%E7%A8%B3%E5%AE%9A%E6%89%AB%E9%9B%B7/</url>
    
    <content type="html"><![CDATA[<h4 id="unstable-sweeping">Unstable-Sweeping</h4><p>It's a crazy game different from the original minesweeping:</p><ul><li>Each mine has a countdown! When a grid around the mine is opened,the countdown will begin.</li><li>The numbers no longer show the number of mines, but the minimum timeleft to count down in the surrounding circle of mines.</li><li>The mine will explode at the end of the countdown, then destroy theland within 3x3.</li><li>The mine explosion will detonate other mines around at the sametime!</li><li>Left click to open a plot (point to the mine will explodedirectly!), right click to delete the mine in a plot (wrong deletionwill accelerate the countdown of the surrounding mines!)</li></ul><p>Remove as many mines as possible, protect more land plots and gethigher scores.</p><p>It may be difficult. Relax. It's better to enjoy the explosionquietly...</p><p>Well, have a good time!</p><p>这是一个疯狂的游戏，他在原版扫雷的基础上加上了——</p><ul><li>每个地雷都有一个倒计时，当地雷周围一圈有格子被打开时，就会开始倒计时——</li><li>数字显示的不再是地雷数量，而是周围一圈雷中倒计时剩下的最少时间——</li><li>地雷倒计时结束就会爆炸，不过它不会直接导致你Gameover，而是摧毁3x3范围内的地块——</li><li>地雷爆炸同时会引爆周围的其他地雷——</li><li>左键点开一个地块（点到地雷会直接爆炸！），右键删去一个地块的地雷（删错会导致周围的地雷倒计时加速！）</li></ul><p>尽可能地切除更多地雷，保护更多地块，获得更高的评分——</p><p>可能会很难，放轻松，不如静静地欣赏爆炸——</p><p>那么，游戏愉快！</p><figure><img src="http://lxtyin.ac.cn/img/Unstable-Sweeping/0.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><figure><img src="http://lxtyin.ac.cn/img/Unstable-Sweeping/3.png" alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><figure><img src="http://lxtyin.ac.cn/img/Unstable-Sweeping/1.png" alt="3" /><figcaption aria-hidden="true">3</figcaption></figure><p>这已经是我最好的成绩了（在Easy难度下</p><p>=》<ahref="https://lx-tyin.itch.io/unstable-sweeping">下载链接(windows)</a></p><p>=》<ahref="https://github.com/lxtyin/lxtyin.github.io">Github源码</a></p><p>=》<ahref="https://ldjam.com/events/ludum-dare/49/unstable-sweeping">参赛界面</a>（多多支持！感谢！</p>]]></content>
    
    
    <categories>
      
      <category>玩具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unity</tag>
      
      <tag>自制游戏</tag>
      
      <tag>LudumDare</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>切炸弹小游戏</title>
    <link href="/2021/08/27/%E7%8E%A9%E5%85%B7/%E5%88%87%E7%82%B8%E5%BC%B9%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    <url>/2021/08/27/%E7%8E%A9%E5%85%B7/%E5%88%87%E7%82%B8%E5%BC%B9%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<p>这是一个我自己做的小游戏：</p><p>鼠标点击操控三角形，切除或躲避从四周扔来的炸弹，不被炸到即可。</p><p>游戏共25关，每5关会出现一种新的敌人，默认模式下按住鼠标会有缓时效果，难度不大</p><p>鼠标右键打开设置，可以开启release模式，取消缓时（难度较高，欢迎挑战！</p><p>欢迎体验，游戏愉快 ^_^</p><figure><img src="http://lxtyin.ac.cn/img/littlegameofcut/1.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><figure><img src="http://lxtyin.ac.cn/img/littlegameofcut/2.png" alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><figure><img src="http://lxtyin.ac.cn/img/littlegameofcut/3.png" alt="3" /><figcaption aria-hidden="true">3</figcaption></figure><figure><img src="http://lxtyin.ac.cn/img/littlegameofcut/4.png" alt="4" /><figcaption aria-hidden="true">4</figcaption></figure><p><strong>下载链接：<ahref="https://pan.baidu.com/s/1sByr24vguePcj3u9CMZ1Hg">https://pan.baidu.com/s/1sByr24vguePcj3u9CMZ1Hg</a></strong></p><p><strong>提取码：</strong>5207</p>]]></content>
    
    
    <categories>
      
      <category>玩具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unity</tag>
      
      <tag>自制游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
