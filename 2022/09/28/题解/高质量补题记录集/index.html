

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="lx_tyin">
  <meta name="keywords" content="">
  
    <meta name="description" content="2022牛客第一场 J Serval and Essay 一道不错的图论题 比较有价值的部分是图的合并，类似并查集，合并两点时可以使用其中一个点编号作为合并后的点集编号。 用启发式合并思想，让小集合向大集合合并，合并时将小集合上的连边转移到大集合上。 int n; int fa[maxn], siz[maxn], cnt[maxn]; set&lt;int&gt; nt[maxn],">
<meta property="og:type" content="article">
<meta property="og:title" content="高质量补题记录集">
<meta property="og:url" content="http://www.lxtyin.ac.cn/2022/09/28/%E9%A2%98%E8%A7%A3/%E9%AB%98%E8%B4%A8%E9%87%8F%E8%A1%A5%E9%A2%98%E8%AE%B0%E5%BD%95%E9%9B%86/index.html">
<meta property="og:site_name" content="lx_tyin">
<meta property="og:description" content="2022牛客第一场 J Serval and Essay 一道不错的图论题 比较有价值的部分是图的合并，类似并查集，合并两点时可以使用其中一个点编号作为合并后的点集编号。 用启发式合并思想，让小集合向大集合合并，合并时将小集合上的连边转移到大集合上。 int n; int fa[maxn], siz[maxn], cnt[maxn]; set&lt;int&gt; nt[maxn],">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://lxtyin.ac.cn/img/other/2.png">
<meta property="article:published_time" content="2022-09-27T16:00:00.000Z">
<meta property="article:modified_time" content="2022-11-08T04:00:01.000Z">
<meta property="article:author" content="lx_tyin">
<meta property="article:tag" content="题解">
<meta property="article:tag" content="牛客多校">
<meta property="article:tag" content="杭电多校">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://lxtyin.ac.cn/img/other/2.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>高质量补题记录集 - lx_tyin</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.lxtyin.ac.cn","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":4},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>lx_tyin</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-friends"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/welcome-cover.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="高质量补题记录集"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-28 00:00" pubdate>
          2022年9月28日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">高质量补题记录集</h1>
            
            
              <div class="markdown-body">
                
                <h4 id="牛客第一场-j">2022牛客第一场 J</h4>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/33186/J">Serval and
Essay</a></p>
<p>一道不错的图论题</p>
<p>比较有价值的部分是图的合并，类似并查集，合并两点时可以使用其中一个点编号作为合并后的点集编号。</p>
<p>用启发式合并思想，让小集合向大集合合并，合并时将小集合上的连边转移到大集合上。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;
<span class="hljs-type">int</span> fa[maxn], siz[maxn], cnt[maxn];
set&lt;<span class="hljs-type">int</span>&gt; nt[maxn], fm[maxn];

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;
    <span class="hljs-keyword">if</span>(fa[x] == x) <span class="hljs-keyword">return</span> x;
    <span class="hljs-keyword">return</span> fa[x] = <span class="hljs-built_in">find</span>(fa[x]);
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
    cin &gt;&gt; n;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;
        cnt[i] = <span class="hljs-number">0</span>;
        nt[i].<span class="hljs-built_in">clear</span>(), fm[i].<span class="hljs-built_in">clear</span>();
        fa[i] = i, siz[i] = <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;
        <span class="hljs-type">int</span> k; cin &gt;&gt; k;
        cnt[i] = k;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)&#123;
            <span class="hljs-type">int</span> x; cin &gt;&gt; x;
            nt[x].<span class="hljs-built_in">insert</span>(i);
            fm[i].<span class="hljs-built_in">insert</span>(x);
        &#125;
    &#125;
    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q; <span class="hljs-comment">//存要合并的两个集合</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;
        <span class="hljs-keyword">if</span>(cnt[i] == <span class="hljs-number">1</span>)&#123;
            q.<span class="hljs-built_in">emplace</span>(i, *fm[i].<span class="hljs-built_in">begin</span>());
        &#125;
    &#125;
    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;
        <span class="hljs-keyword">auto</span> [x, y] = q.<span class="hljs-built_in">front</span>();
        q.<span class="hljs-built_in">pop</span>();

        <span class="hljs-comment">//merge</span>
        x = <span class="hljs-built_in">find</span>(x), y = <span class="hljs-built_in">find</span>(y);
        <span class="hljs-keyword">if</span>(x == y) <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">if</span>(siz[x] &gt; siz[y]) <span class="hljs-built_in">swap</span>(x, y);
        fa[x] = y;
        siz[y] += siz[x];
        ans = <span class="hljs-built_in">max</span>(ans, siz[y]);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: nt[x])&#123;
            <span class="hljs-keyword">if</span>(nt[y].<span class="hljs-built_in">count</span>(v))&#123;
                cnt[v]--;
                <span class="hljs-keyword">if</span>(cnt[v] == <span class="hljs-number">1</span>) q.<span class="hljs-built_in">emplace</span>(v, y);
            nt[y].<span class="hljs-built_in">insert</span>(v);
        &#125;
    &#125;
    <span class="hljs-type">static</span> <span class="hljs-type">int</span> cas = <span class="hljs-number">0</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;Case #&quot;</span> &lt;&lt; ++cas &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
&#125;</code></pre></div>
<h4 id="牛客第三场b">2022牛客第三场B</h4>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/33188/B">Boss</a></p>
<p>学到一个可删除堆的奇技淫巧，但这还不是关键</p>
<p>这里的最短路类似二分图和网络流中的“增广路”，路径代表的是一种<strong>转移方案</strong>，<span
class="math inline">\(a-b-c-d\)</span>
这样的一条路径，实际上指将当前的人放到 <span
class="math inline">\(a\)</span> 处，<span
class="math inline">\(a\)</span> 中选取一个代价最小的人移到 <span
class="math inline">\(b\)</span> 处...最后 <span
class="math inline">\(d\)</span> 处多出一个人，最短路径即为将 <span
class="math inline">\(i\)</span> 塞入的最小代价。</p>
<p>可以用一个set记录每个节点上已经有哪些人，记 <span
class="math inline">\(u,v\)</span> 间的转移方案 <span
class="math inline">\(\{dis,id\}\)</span>，表示将 <span
class="math inline">\(id\)</span> 这个人从 <span
class="math inline">\(u\)</span> 转移到 <span
class="math inline">\(v\)</span> 的代价为 <span
class="math inline">\(dis\)</span>，开 <span
class="math inline">\(K^2\)</span>
个堆记录任意两点间的所有转移方案，在人员变动时维护。</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">heap</span>&#123; <span class="hljs-comment">//奇技淫巧：可删除堆 常数优秀</span>
    priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt; &gt; q1, q2;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x)</span> </span>&#123;q1.<span class="hljs-built_in">push</span>(x);&#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x)</span> </span>&#123;q2.<span class="hljs-built_in">push</span>(x);&#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">while</span>(!q1.<span class="hljs-built_in">empty</span>() &amp;&amp; !q2.<span class="hljs-built_in">empty</span>() &amp;&amp; q1.<span class="hljs-built_in">top</span>() == q2.<span class="hljs-built_in">top</span>())&#123;
            q1.<span class="hljs-built_in">pop</span>();
            q2.<span class="hljs-built_in">pop</span>();
        &#125;
    &#125;
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-built_in">release</span>();
        <span class="hljs-keyword">return</span> q1.<span class="hljs-built_in">empty</span>();
    &#125;
    <span class="hljs-function">T <span class="hljs-title">top</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-built_in">release</span>();
        <span class="hljs-keyword">return</span> q1.<span class="hljs-built_in">top</span>();
    &#125;
&#125;;

<span class="hljs-type">int</span> n, m;
heap&lt;pair&lt;ll, <span class="hljs-type">int</span>&gt;&gt; tr[<span class="hljs-number">12</span>][<span class="hljs-number">12</span>]; <span class="hljs-comment">//tr[x][y] 从x到y的所有可行路径，&#123;dis, id&#125;</span>
set&lt;<span class="hljs-type">int</span>&gt; nodes[<span class="hljs-number">12</span>]; <span class="hljs-comment">//存每个节点上所有的人</span>

ll vol[maxn];
ll cost[maxn][<span class="hljs-number">12</span>]; <span class="hljs-comment">//基础花费：cost[x][k] x这个人匹配第k个城市的代价</span>
<span class="hljs-function">ll <span class="hljs-title">move_dis</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123; <span class="hljs-comment">//转移代价：u这个人从x城切换到y城的代价</span>
    <span class="hljs-keyword">return</span> cost[u][y] - cost[u][x];
&#125;
<span class="hljs-function">pair&lt;ll, <span class="hljs-type">int</span>&gt; <span class="hljs-title">min_dis</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123; <span class="hljs-comment">//获取当前从x转移到y代价最小的路径</span>
    <span class="hljs-keyword">if</span>(tr[x][y].<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;INF, <span class="hljs-number">0</span>&#125;;
    <span class="hljs-keyword">return</span> tr[x][y].<span class="hljs-built_in">top</span>();
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span>&#123; <span class="hljs-comment">//在k城添加一个人p，维护</span>
    nodes[k].<span class="hljs-built_in">insert</span>(p);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;
        <span class="hljs-keyword">if</span>(i == k) <span class="hljs-keyword">continue</span>;
        tr[k][i].<span class="hljs-built_in">push</span>(&#123;<span class="hljs-built_in">move_dis</span>(p, k, i), p&#125;);
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span>&#123; <span class="hljs-comment">//从k城移除一个人p，维护</span>
    nodes[k].<span class="hljs-built_in">erase</span>(p);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;
        <span class="hljs-keyword">if</span>(i == k) <span class="hljs-keyword">continue</span>;
        tr[k][i].<span class="hljs-built_in">erase</span>(&#123;<span class="hljs-built_in">move_dis</span>(p, k, i), p&#125;);
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) cin &gt;&gt; vol[i];
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;
            cin &gt;&gt; cost[i][j];
        &#125;
    &#125;
    ll ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;
        queue&lt;<span class="hljs-type">int</span>&gt; q;		<span class="hljs-comment">//先跑最短路，即最小的将当前i塞进去的代价</span>
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(m+<span class="hljs-number">1</span>)</span></span>;
        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">frm</span>(m+<span class="hljs-number">1</span>, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);
        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">inq</span><span class="hljs-params">(m+<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++) q.<span class="hljs-built_in">push</span>(j), d[j] = cost[i][j];
        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;
            <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();
            q.<span class="hljs-built_in">pop</span>();
            inq[u] = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">1</span>;v&lt;=m;v++)&#123;
                <span class="hljs-keyword">if</span>(v == u) <span class="hljs-keyword">continue</span>;
                <span class="hljs-keyword">auto</span> [dis, id] = <span class="hljs-built_in">min_dis</span>(u, v);
                <span class="hljs-keyword">if</span>(d[v] &gt; d[u] + dis)&#123;
                    d[v] = d[u] + dis;
                    frm[v] = &#123;u, id&#125;;
                    <span class="hljs-keyword">if</span>(!inq[v]) q.<span class="hljs-built_in">push</span>(v), inq[v] = <span class="hljs-literal">true</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-type">int</span> ed = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;
            <span class="hljs-keyword">if</span>(nodes[j].<span class="hljs-built_in">size</span>() &gt;= vol[j]) <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">if</span>(!ed || d[j] &lt; d[ed]) ed = j;
        &#125;
        <span class="hljs-built_in">assert</span>(ed);
        ans += d[ed];	   <span class="hljs-comment">//记录将i这个人塞进去的转移路径，沿着路径每个节点的状态，同时维护堆</span>
        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;
            <span class="hljs-keyword">auto</span> [fa, id] = frm[ed];
            <span class="hljs-keyword">if</span>(!fa)&#123;
                <span class="hljs-built_in">add</span>(ed, i);
                <span class="hljs-keyword">break</span>;
            &#125;
            <span class="hljs-built_in">remove</span>(fa, id);
            <span class="hljs-built_in">add</span>(ed, id);
            ed = fa;
        &#125;
    &#125;
    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
&#125;</code></pre></div>
<h4 id="杭电第四场1002">2022杭电第四场1002</h4>
<p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=7175">Link with
Running</a></p>
<p>边权有两种：距离和价值，要求一条距离最短前提下的价值最大的路。（距离可以为0）</p>
<p>因为距离为0，一条无距离有价值的路实际上相当于一条负权边，无法用传统dijkstra解决。</p>
<p>解法：先仅按照距离dij跑出到每个点的最短距离，<strong>得到最短路径图</strong>，在最短路径图上，tarjian缩点去除可能存在的环，变成一个DAG，再在DAG上跑最长路即可。</p>
<ul>
<li><p>最短路径图即图上所有最短路径构成的图，可以从终点开始往前逆向跑，对于所有
<span class="math inline">\(dis_v=dis_u+w\)</span>
的路径加入最短路径图，也可以直接顺着跑，得到的点数会更多（包含了到所有点的最短路）。</p></li>
<li><p>DAG上的最长路可以按拓扑序更新（即一个点需要在前驱都遍历后更新），也可以直接spfa。</p></li>
</ul>
<p>思路很简单，但是几层图换来换去代码属实调了很久，最后整出来这么一份非常结构化的代码，但还是很难直接拿去当图论模板..</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;
    <span class="hljs-type">int</span> t, w, val;
&#125;;
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> E&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span>&#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-type">int</span> n;
    vector&lt;vector&lt;E&gt;&gt; vp;
    <span class="hljs-built_in">Graph</span>(<span class="hljs-type">int</span> n): <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">vp</span>(n+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;E&gt;())&#123;&#125;;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">const</span> E &amp;e)</span></span>&#123; vp[x].<span class="hljs-built_in">push_back</span>(e);&#125;
&#125;;

<span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">dijkstra</span><span class="hljs-params">(Graph&lt;Edge&gt; &amp;g, <span class="hljs-type">int</span> st)</span></span>&#123;
    <span class="hljs-keyword">using</span> pii = pair&lt;ll, <span class="hljs-type">int</span>&gt;;
    <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">dis</span><span class="hljs-params">(g.n+<span class="hljs-number">1</span>, INF)</span></span>;
    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; q;
    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, st&#125;); dis[st] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;
        pii uq = q.<span class="hljs-built_in">top</span>();
        ll ud = uq.first, u = uq.second;
        q.<span class="hljs-built_in">pop</span>();
        <span class="hljs-keyword">if</span>(ud &gt; dis[u]) <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">for</span>(Edge &amp;e: g.vp[u])&#123;
            <span class="hljs-type">int</span> v = e.t;
            <span class="hljs-keyword">if</span>(dis[v] &gt; dis[u] + e.w)&#123;
                dis[v] = dis[u] + e.w;
                q.<span class="hljs-built_in">push</span>(&#123;dis[v], v&#125;);
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> dis;
&#125;

<span class="hljs-comment">//获取最短路径图</span>
Graph&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; <span class="hljs-built_in">pathGraph</span>(Graph&lt;Edge&gt; &amp;g, <span class="hljs-type">int</span> st)&#123;
    <span class="hljs-keyword">auto</span> dis = <span class="hljs-built_in">dijkstra</span>(g, <span class="hljs-number">1</span>); <span class="hljs-comment">//计算最短路</span>
    Graph&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; <span class="hljs-built_in">res</span>(g.n);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=g.n;i++)&#123;
        <span class="hljs-keyword">for</span>(Edge &amp;e: g.vp[i])&#123;
            <span class="hljs-type">int</span> v = e.t;
            <span class="hljs-keyword">if</span>(dis[v] == dis[i] + e.w)&#123;
                res.<span class="hljs-built_in">addEdge</span>(i, &#123;v, e.val&#125;);
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; dis[g.n] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;
    <span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-keyword">namespace</span> Connect&#123;
    <span class="hljs-type">int</span> scc[maxn], stk[maxn], h, scn;
    <span class="hljs-type">int</span> dfn[maxn], low[maxn], dfc;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjian</span><span class="hljs-params">(Graph&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; &amp;g,<span class="hljs-type">int</span> p)</span></span>&#123;
        dfn[p] = low[p] = ++dfc;
        stk[++h] = p;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e: g.vp[p])&#123;
            <span class="hljs-type">int</span> v = e.first;
            <span class="hljs-keyword">if</span>(!dfn[v]) &#123;
                <span class="hljs-built_in">tarjian</span>(g, v);
                low[p] = <span class="hljs-built_in">min</span>(low[p], low[v]);
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!scc[v]) &#123;
                low[p] = <span class="hljs-built_in">min</span>(low[p], dfn[v]);
            &#125;
        &#125;
        <span class="hljs-keyword">if</span>(low[p] == dfn[p])&#123;
            ++scn;
            <span class="hljs-keyword">while</span>(stk[h] != p) scc[stk[h--]] = scn;
            scc[stk[h--]] = scn;
        &#125;
    &#125;
    Graph&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; <span class="hljs-built_in">getDag</span>(Graph&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; &amp;g)&#123;
        h = scn = dfc = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=g.n;i++) dfn[i] = scc[i] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=g.n;i++) <span class="hljs-keyword">if</span>(!scc[i]) <span class="hljs-built_in">tarjian</span>(g, i);
        Graph&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; <span class="hljs-built_in">res</span>(scn);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=g.n;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e: g.vp[i])&#123;
                <span class="hljs-type">int</span> v = e.first;
                <span class="hljs-keyword">if</span>(scc[i] != scc[v])&#123;
                    res.<span class="hljs-built_in">addEdge</span>(scc[i], &#123;scc[v], e.second&#125;);
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-type">int</span> n, m;
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-function">Graph&lt;Edge&gt; <span class="hljs-title">g</span><span class="hljs-params">(n)</span></span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;
        <span class="hljs-type">int</span> x, y, e, p;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; e &gt;&gt; p;
        g.<span class="hljs-built_in">addEdge</span>(x, &#123;y, e, p&#125;);
    &#125;
    <span class="hljs-keyword">auto</span> spg = <span class="hljs-built_in">pathGraph</span>(g, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">auto</span> dag = Connect::<span class="hljs-built_in">getDag</span>(spg);

    <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">f</span><span class="hljs-params">(dag.n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">du</span><span class="hljs-params">(dag.n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=dag.n;i++)&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e: dag.vp[i])&#123;
            du[e.first]++;
        &#125;
    &#125;
    queue&lt;<span class="hljs-type">int</span>&gt; q;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=dag.n;i++) <span class="hljs-keyword">if</span>(du[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);
    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;
        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();
        q.<span class="hljs-built_in">pop</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e: dag.vp[u])&#123;
            <span class="hljs-type">int</span> v = e.first;
            f[v] = <span class="hljs-built_in">max</span>(f[v], f[u] + e.second);
            <span class="hljs-keyword">if</span>(--du[v] &lt;= <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(v);
        &#125;
    &#125;
    cout &lt;&lt; f[Connect::scc[n]] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
&#125;</code></pre></div>
<h4 id="杭电第四场1005">2022杭电第四场1005</h4>
<p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=7178">Link with
Level Editor II</a></p>
<p>矩阵+神奇双指针（对顶栈）</p>
<p>首先这题可以用矩阵维护一段区间的方案数，但矩阵并非一定可逆，故没法用前缀和搞。</p>
<p>比较容易想到的是线段树暴力维护矩阵区间乘，常数很大但是卡卡能过。</p>
<p>另有神奇的<strong>无需删除</strong>的双指针尺取（题解叫对顶栈）：</p>
<p><img src="http://lxtyin.ac.cn/img/other/2.png" srcset="/img/loading.gif" lazyload /></p>
<p>如图所示，双指针 <span class="math inline">\(l,r\)</span>
即为两个栈顶，右指针移动时将新元素加入右栈中；左指针移动时将栈顶元素弹出，接触到中间点时，将右栈的所有元素一一弹出并加入左栈，将右端点作为新的中点。</p>
<p>左栈中加入元素时记录该元素到中点的后缀和，这样在左栈弹出后，仍可以得知左栈的总和，和右栈和相加得到区间和（此题中为积）。</p>
<p>如此便可以 <span class="math inline">\(O(n)\)</span>
地做不带删除的尺取了！</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> lim;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">matrix</span>&#123;
    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">21</span>, M = <span class="hljs-number">21</span>;
    ll a[N][M];
    <span class="hljs-built_in">matrix</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//单位矩阵</span>
        <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a));
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++) a[i][i] = x;
    &#125;
    <span class="hljs-keyword">inline</span> matrix <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> matrix&amp; y) <span class="hljs-type">const</span>&#123;
        matrix r = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; M; ++k) &#123;
                ll t = a[i][k];
                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; M; ++j)&#123;
                    r.a[i][j] += t * y.a[k][j];
                    <span class="hljs-keyword">if</span>(r.a[i][j] &gt; lim) r.a[i][j] = lim + <span class="hljs-number">1</span>;
                &#125;
            &#125;
        <span class="hljs-keyword">return</span> r;
    &#125;
&#125;;

matrix a[maxn], s[maxn];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-type">int</span> n, m;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; lim;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;
        <span class="hljs-type">int</span> l; cin &gt;&gt; l;
        a[i] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=l;j++)&#123;
            <span class="hljs-type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;
            a[i].a[x][y] = <span class="hljs-number">1</span>;
        &#125;
    &#125;
    <span class="hljs-function">matrix <span class="hljs-title">cur</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;
    <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)&#123;
        ll ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;
            ans += s[l].a[<span class="hljs-number">1</span>][i] * cur.a[i][m];
            <span class="hljs-keyword">if</span>(ans &gt; lim) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;;
    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, mid = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">1</span>; r&lt;=n; r++)&#123;
        cur = cur * a[r];
        <span class="hljs-keyword">while</span>(l == <span class="hljs-number">0</span> || !<span class="hljs-built_in">check</span>(l, r))&#123;
            l++;
            <span class="hljs-keyword">if</span>(l &gt; mid)&#123;
                s[r] = a[r];
                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=r<span class="hljs-number">-1</span>;i&gt;mid;i--) s[i] = a[i] * s[i+<span class="hljs-number">1</span>];
                mid = r;
                cur = <span class="hljs-number">1</span>;
            &#125;
        &#125;
        ans = <span class="hljs-built_in">max</span>(ans, r - l + <span class="hljs-number">1</span>);
    &#125;
    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
&#125;</code></pre></div>
<h4 id="杭电第八场1002">2022杭电第八场1002</h4>
<p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=7221">Darkmoon
Faire</a></p>
<p>大力数据结构维护题。</p>
<p>从左往右推，设 <span class="math inline">\(f_i\)</span> 为前 <span
class="math inline">\(i\)</span> 个位置划分好的方案数，接下来要转移到
<span class="math inline">\(i+1\)</span>。</p>
<p>维护两个单调栈，一个递增一个递减，对于递增单调栈中相邻两个位置 <span
class="math inline">\(x,y\)</span>，可以知道 <span
class="math inline">\((x,y]\)</span> 这段作为起始位置时，最小值都为
<span
class="math inline">\(a_y\)</span>。那么就可以知道：这段区间中的所有奇数/偶数位置都能满足最小值条件。</p>
<p>对于最大值条件也是同理，可以用两个线段树分别维护奇偶位置上的tag（满足条件数），同时满足两个条件的位置即可进行转移。</p>
<p>线段树中，维护每个区间的最大满足条件的数量（tag），和具有最大条件数量的位置的
<span class="math inline">\(f_i\)</span>
之和。对线段树的操作包括单点添加新的dp值，区间tag加1和减1（在单调栈中元素被pop时减）。</p>
<p>因为我们的操作能保证合理（只对具有tag1区间的减tag1，tag2一样），所以不需要记录区间具有两种条件的哪一种，只需要记录数量即可。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, a[maxn];
ll f[maxn];
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">segTree</span> &#123;
    function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; fp; <span class="hljs-comment">//自带离散映射的线段树</span>
    ll sum[maxn &lt;&lt; <span class="hljs-number">2</span>], mx[maxn &lt;&lt; <span class="hljs-number">2</span>];
    <span class="hljs-type">int</span> add[maxn &lt;&lt; <span class="hljs-number">2</span>];
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;
        add[p] = sum[p] = mx[p] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span>;
        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;
        <span class="hljs-built_in">build</span>(p * <span class="hljs-number">2</span>, l, mid);
        <span class="hljs-built_in">build</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
        sum[p] = <span class="hljs-number">0</span>, mx[p] = <span class="hljs-built_in">max</span>(mx[p * <span class="hljs-number">2</span>], mx[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]);
        <span class="hljs-keyword">if</span>(mx[p] == mx[p * <span class="hljs-number">2</span>]) (sum[p] += sum[p * <span class="hljs-number">2</span>]) %= mode;
        <span class="hljs-keyword">if</span>(mx[p] == mx[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]) (sum[p] += sum[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]) %= mode;
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_add</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> d)</span> </span>&#123;
        mx[p] += d;
        add[p] += d;
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(add[p]) &#123;
            <span class="hljs-built_in">push_add</span>(p * <span class="hljs-number">2</span>, add[p]);
            <span class="hljs-built_in">push_add</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, add[p]);
            add[p] = <span class="hljs-number">0</span>;
        &#125;
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addvalue</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, ll val)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(l == r) &#123;
            (sum[p] += val) %= mode;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-built_in">push_down</span>(p);
        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span>(pos &lt;= <span class="hljs-built_in">fp</span>(mid)) <span class="hljs-built_in">addvalue</span>(p * <span class="hljs-number">2</span>, l, mid, pos, val);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">addvalue</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, pos, val);
        <span class="hljs-built_in">push_up</span>(p);
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> d)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fp</span>(l) &gt; R || L &gt; <span class="hljs-built_in">fp</span>(r)) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span>(L &lt;= <span class="hljs-built_in">fp</span>(l) &amp;&amp; <span class="hljs-built_in">fp</span>(r) &lt;= R) &#123;
            <span class="hljs-built_in">push_add</span>(p, d);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-built_in">push_down</span>(p);
        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;
        <span class="hljs-built_in">modify</span>(p * <span class="hljs-number">2</span>, l, mid, L, R, d);
        <span class="hljs-built_in">modify</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R, d);
        <span class="hljs-built_in">push_up</span>(p);
    &#125;
    <span class="hljs-function">ll <span class="hljs-title">queryTot</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(mx[<span class="hljs-number">1</span>] == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> sum[<span class="hljs-number">1</span>];
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
&#125;st[<span class="hljs-number">2</span>];

<span class="hljs-type">int</span> stk[<span class="hljs-number">2</span>][maxn], h[<span class="hljs-number">2</span>];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
    cin &gt;&gt; n;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) cin &gt;&gt; a[i];

    st[<span class="hljs-number">0</span>].fp = [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x;&#125;;
    st[<span class="hljs-number">1</span>].fp = [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x - <span class="hljs-number">1</span>;&#125;;
    <span class="hljs-type">int</span> hn = (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
    st[<span class="hljs-number">0</span>].<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn);
    st[<span class="hljs-number">1</span>].<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn);
    h[<span class="hljs-number">0</span>] = h[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
    stk[<span class="hljs-number">1</span>][++h[<span class="hljs-number">1</span>]] = stk[<span class="hljs-number">0</span>][++h[<span class="hljs-number">0</span>]] = <span class="hljs-number">0</span>;
    f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;
        st[i &amp; <span class="hljs-number">1</span>].<span class="hljs-built_in">addvalue</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn, i, f[i - <span class="hljs-number">1</span>]);

        <span class="hljs-keyword">while</span>(h[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span> &amp;&amp; a[stk[<span class="hljs-number">0</span>][h[<span class="hljs-number">0</span>]]] &gt; a[i]) &#123;
            <span class="hljs-type">int</span> f = stk[<span class="hljs-number">0</span>][h[<span class="hljs-number">0</span>]] &amp; <span class="hljs-number">1</span>;
            st[f ^ <span class="hljs-number">1</span>].<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn, stk[<span class="hljs-number">0</span>][h[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, stk[<span class="hljs-number">0</span>][h[<span class="hljs-number">0</span>]], <span class="hljs-number">-1</span>);
            h[<span class="hljs-number">0</span>]--;
        &#125;
        st[(i &amp; <span class="hljs-number">1</span>) ^ <span class="hljs-number">1</span>].<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn, stk[<span class="hljs-number">0</span>][h[<span class="hljs-number">0</span>]] + <span class="hljs-number">1</span>, i, <span class="hljs-number">1</span>);
        stk[<span class="hljs-number">0</span>][++h[<span class="hljs-number">0</span>]] = i;

        <span class="hljs-keyword">while</span>(h[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span> &amp;&amp; a[stk[<span class="hljs-number">1</span>][h[<span class="hljs-number">1</span>]]] &lt; a[i]) &#123;
            <span class="hljs-type">int</span> f = stk[<span class="hljs-number">1</span>][h[<span class="hljs-number">1</span>]] &amp; <span class="hljs-number">1</span>;
            st[f].<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn, stk[<span class="hljs-number">1</span>][h[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, stk[<span class="hljs-number">1</span>][h[<span class="hljs-number">1</span>]], <span class="hljs-number">-1</span>);
            h[<span class="hljs-number">1</span>]--;
        &#125;
        st[i &amp; <span class="hljs-number">1</span>].<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn, stk[<span class="hljs-number">1</span>][h[<span class="hljs-number">1</span>]] + <span class="hljs-number">1</span>, i, <span class="hljs-number">1</span>);
        stk[<span class="hljs-number">1</span>][++h[<span class="hljs-number">1</span>]] = i;

        f[i] = (st[<span class="hljs-number">0</span>].<span class="hljs-built_in">queryTot</span>() + st[<span class="hljs-number">1</span>].<span class="hljs-built_in">queryTot</span>()) % mode;
    &#125;
    cout &lt;&lt; f[n] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
&#125;</code></pre></div>
<h4 id="杭电第八场1009">2022杭电第八场1009</h4>
<p><a
target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=7228">Gilneas</a></p>
<p>感觉挺妙的一个线段树上概率处理+线段树合并</p>
<p>对于每个点 <span
class="math inline">\(u\)</span>，它连向子树的边中一定只存在一条有颜色。</p>
<p>考虑 <span class="math inline">\(u\)</span>
的这个子树中的每个操作，将它们按照时间排序，一个操作能为 <span
class="math inline">\(u\)</span>
的连边作出贡献，当且仅当这个操作成功，且之后的操作都失败。</p>
<p>把操作按时间放到线段树上，区间维护 <span
class="math inline">\(sxp\)</span> 表示区间内所有操作的 <span
class="math inline">\(1-p\)</span> 乘积（全失败的概率），和 <span
class="math inline">\(sum\)</span> 表示 <span
class="math inline">\(c_i\times
p_i\times\prod_{j&gt;i}(1-p_{j})\)</span> 的总和。即期望贡献。</p>
<p>这两个信息很好push_up。</p>
<p>那么对于每个点 <span
class="math inline">\(u\)</span>，将其子树的线段树合并起来之后取 <span
class="math inline">\(sum\)</span>
即可得到它连儿子边的总贡献，注意还要考虑 <span
class="math inline">\(u\)</span>
这个点本身的操作会将边权清空，计算sum时可以先将 <span
class="math inline">\(u\)</span> 本身的操作的 <span
class="math inline">\(c_i\)</span> 视为0加入线段树，处理贡献后再将 <span
class="math inline">\(c_i\)</span> 改回来。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">segTree</span> &#123;
    ll sum[maxn &lt;&lt; <span class="hljs-number">5</span>], sxp[maxn &lt;&lt; <span class="hljs-number">5</span>];
    <span class="hljs-type">int</span> ls[maxn &lt;&lt; <span class="hljs-number">5</span>], rs[maxn &lt;&lt; <span class="hljs-number">5</span>];
    <span class="hljs-type">int</span> tcnt = <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newnode</span><span class="hljs-params">()</span> </span>&#123;
        ++tcnt;
        sum[tcnt] = <span class="hljs-number">0</span>;
        sxp[tcnt] = <span class="hljs-number">1</span>;
        ls[tcnt] = rs[tcnt] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> tcnt;
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
        sum[p] = (sum[ls[p]] * sxp[rs[p]] % mode + sum[rs[p]]) % mode;
        sxp[p] = sxp[ls[p]] * sxp[rs[p]] % mode;
    &#125;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(!x) <span class="hljs-keyword">return</span> y;
        <span class="hljs-keyword">if</span>(!y) <span class="hljs-keyword">return</span> x;
        <span class="hljs-built_in">assert</span>(l != r);
        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;
        ls[x] = <span class="hljs-built_in">merge</span>(ls[x], ls[y], l, mid);
        rs[x] = <span class="hljs-built_in">merge</span>(rs[x], rs[y], mid + <span class="hljs-number">1</span>, r);
        <span class="hljs-built_in">push_up</span>(x);
        <span class="hljs-keyword">return</span> x;
    &#125;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, ll pi, ll ci)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(!p) p = <span class="hljs-built_in">newnode</span>();
        <span class="hljs-keyword">if</span>(l == r) &#123;
            sxp[p] = (<span class="hljs-number">1ll</span> - pi + mode) % mode;
            sum[p] = pi * ci % mode;
            <span class="hljs-keyword">return</span> p;
        &#125;
        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span>(pos &lt;= mid) ls[p] = <span class="hljs-built_in">modify</span>(ls[p], l, mid, pos, pi, ci);
        <span class="hljs-keyword">else</span> rs[p] = <span class="hljs-built_in">modify</span>(rs[p], mid + <span class="hljs-number">1</span>, r, pos, pi, ci);
        <span class="hljs-built_in">push_up</span>(p);
        <span class="hljs-keyword">return</span> p;
    &#125;
&#125;st;

<span class="hljs-type">int</span> n, m;
vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];
vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; opt[maxn];

ll ans = <span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123; <span class="hljs-comment">//返回子树的线段树根节点</span>
    <span class="hljs-type">int</span> rt = st.<span class="hljs-built_in">newnode</span>();
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> tup: opt[p]) &#123;
        <span class="hljs-type">int</span> id = tup[<span class="hljs-number">0</span>], pi = tup[<span class="hljs-number">1</span>];
        st.<span class="hljs-built_in">modify</span>(rt, <span class="hljs-number">1</span>, m, id, pi, <span class="hljs-number">0</span>);
    &#125; 
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : vp[p]) rt = st.<span class="hljs-built_in">merge</span>(rt, <span class="hljs-built_in">dfs</span>(v), <span class="hljs-number">1</span>, m);
    (ans += st.sum[rt]) %= mode;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> tup : opt[p]) &#123;
        <span class="hljs-type">int</span> id = tup[<span class="hljs-number">0</span>], pi = tup[<span class="hljs-number">1</span>], ci = tup[<span class="hljs-number">2</span>];
        st.<span class="hljs-built_in">modify</span>(rt, <span class="hljs-number">1</span>, m, id, pi, ci);
    &#125;
    <span class="hljs-keyword">return</span> rt;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
    st.tcnt = <span class="hljs-number">-1</span>;
    st.<span class="hljs-built_in">newnode</span>(); <span class="hljs-comment">//初始化0点</span>
    ans = <span class="hljs-number">0</span>;
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;
        vp[i].<span class="hljs-built_in">clear</span>();
        opt[i].<span class="hljs-built_in">clear</span>();
    &#125;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++) &#123;
        <span class="hljs-type">int</span> fa; cin &gt;&gt; fa;
        vp[fa].<span class="hljs-built_in">push_back</span>(i);
    &#125;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++) &#123;
        <span class="hljs-type">int</span> x, c, p;
        cin &gt;&gt; x &gt;&gt; c &gt;&gt; p;
        opt[x].<span class="hljs-built_in">push_back</span>(&#123;i, p, c&#125;);
    &#125;
    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);
    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
&#125;</code></pre></div>
<h4 id="杭电第九场1001">2022杭电第九场1001</h4>
<p><a
target="_blank" rel="noopener" href="https://acm.dingbacode.com/showproblem.php?pid=7233">Arithmetic
Subsequence</a></p>
<p>比较难想到是构造题</p>
<p>需要不包含任何等差数列，一个可以切入的思考点是：等差数列要么全是奇数/偶数，要么在奇偶之间来回切换</p>
<p>如果把奇数放到一边，偶数放到另一边，那么必然不存在跨两边的等差数列，就可以分治求解了。</p>
<p>奇数部分可以集体-1，偶数部分可以集体除2，都不影响等差数列的存在性。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, a[maxn];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cdq</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(l + <span class="hljs-number">1</span> &gt;= r) <span class="hljs-keyword">return</span>;
    <span class="hljs-type">int</span> m = l;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l;i &lt;= r;i++) <span class="hljs-keyword">if</span>(a[i] &amp; <span class="hljs-number">1</span>) <span class="hljs-built_in">swap</span>(a[m++], a[i]);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l;i &lt; m;i++) a[i]--;
    <span class="hljs-built_in">cdq</span>(l, m - <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = m;i &lt;= r;i++) a[i] /= <span class="hljs-number">2</span>;
    <span class="hljs-built_in">cdq</span>(m, r);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l;i &lt; m;i++) a[i]++;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = m;i &lt;= r;i++) a[i] *= <span class="hljs-number">2</span>;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
    cin &gt;&gt; n;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) cin &gt;&gt; a[i];
    <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>;i &lt;= n;i++) <span class="hljs-keyword">if</span>(a[i] == a[i - <span class="hljs-number">1</span>] &amp;&amp; a[i] == a[i - <span class="hljs-number">2</span>]) &#123;
        cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;
        <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-built_in">cdq</span>(<span class="hljs-number">1</span>, n);
    cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];
&#125;</code></pre></div>
<h4 id="杭电第十场1008">2022杭电第十场1008</h4>
<p><a target="_blank" rel="noopener" href="https://acm.dingbacode.com/showproblem.php?pid=7251">Minimum
Diameter</a></p>
<p>对于静态森林，可以求出各个树的直径，将其他小直径的中点和最大直径的中点相连，答案易得。</p>
<p>所以问题转化为动态维护树上直径，操作只有连边</p>
<p>我们可以单开一个并查集记录每个树的直径以及直径两端点，合并两树时，只需考虑四个端点的两两组合，合并后的直径一定在它们当中。</p>
<p>使用LCT可以快速求出任意两点间距离，且支持森林连边操作。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LCT</span> &#123;
    <span class="hljs-type">int</span> ch[maxn][<span class="hljs-number">2</span>], fa[maxn], siz[maxn], swp[maxn];
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">dir</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123; <span class="hljs-keyword">return</span> ch[fa[p]][<span class="hljs-number">1</span>] == p; &#125;
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123; siz[p] = <span class="hljs-number">1</span> + siz[ch[p][<span class="hljs-number">0</span>]] + siz[ch[p][<span class="hljs-number">1</span>]]; &#125;<span class="hljs-comment">//sum[p] = sum[ch[p][0]] ^ sum[ch[p][1]] ^ val[p]; &#125;</span>
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">isroot</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123; <span class="hljs-keyword">return</span> fa[p] == <span class="hljs-number">0</span> || (ch[fa[p]][<span class="hljs-number">0</span>] != p &amp;&amp; ch[fa[p]][<span class="hljs-number">1</span>] != p); &#125; <span class="hljs-comment">//是否为splay的根（不是原树的根！）</span>
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span>;
        <span class="hljs-built_in">swap</span>(ch[p][<span class="hljs-number">0</span>], ch[p][<span class="hljs-number">1</span>]), swp[p] ^= <span class="hljs-number">1</span>;
        <span class="hljs-comment">//        push_down(p);//调试用 立即下放所有懒标记</span>
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(swp[p]) &#123;
            swp[p] = <span class="hljs-number">0</span>;
            <span class="hljs-built_in">push_swap</span>(ch[p][<span class="hljs-number">0</span>]);
            <span class="hljs-built_in">push_swap</span>(ch[p][<span class="hljs-number">1</span>]);
        &#125;
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-comment">//出bug了必须首先来查rotate 注意变化前后顺序的问题 太麻了</span>
        <span class="hljs-keyword">if</span>(fa[p] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-type">int</span> f = fa[p], ff = fa[f];
        <span class="hljs-type">int</span> d = <span class="hljs-built_in">dir</span>(p), s = ch[p][d ^ <span class="hljs-number">1</span>];
        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isroot</span>(f)) ch[ff][<span class="hljs-built_in">dir</span>(f)] = p;<span class="hljs-comment">//与普通splay不同之处：如果父亲节点已经是根节点，一定不能让ff认儿子</span>
        fa[s] = f;
        fa[p] = ff; ch[p][d ^ <span class="hljs-number">1</span>] = f;
        fa[f] = p; ch[f][d] = s;
        <span class="hljs-built_in">push_up</span>(f);<span class="hljs-comment">//最后一个节点的push_up在splay那</span>
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_all</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isroot</span>(p)) <span class="hljs-built_in">push_all</span>(fa[p]);
        <span class="hljs-built_in">push_down</span>(p);
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-comment">//将p转到其所在splay（实链节点集合）的根节点</span>
        <span class="hljs-built_in">push_all</span>(p);<span class="hljs-comment">//从顶向下push_down</span>
        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isroot</span>(p)) &#123;
            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isroot</span>(fa[p])) <span class="hljs-built_in">rotate</span>(<span class="hljs-built_in">dir</span>(p) == <span class="hljs-built_in">dir</span>(fa[p]) ? fa[p] : p);
            <span class="hljs-built_in">rotate</span>(p);<span class="hljs-comment">//双旋，不管旋了父还是子，第二次旋转都要跟上，不然会假</span>
        &#125;
        <span class="hljs-built_in">push_up</span>(p);
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-comment">//打通p所在真实树的根节点到p的路径</span>
        <span class="hljs-type">int</span> lst = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(p) &#123;
            <span class="hljs-built_in">splay</span>(p);
            ch[p][<span class="hljs-number">1</span>] = lst;
            <span class="hljs-built_in">push_up</span>(p);
            lst = p;
            p = fa[p];
        &#125;
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeroot</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-comment">//p变为其所在真实树中的根节点（同时也是splay根）</span>
        <span class="hljs-built_in">access</span>(p);
        <span class="hljs-built_in">splay</span>(p);
        <span class="hljs-built_in">push_swap</span>(p);
    &#125;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findroot</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-comment">//查找所在真实树的根节点，注意这个也会改变p所在splay结构</span>
        <span class="hljs-built_in">access</span>(p);
        <span class="hljs-built_in">splay</span>(p);
        <span class="hljs-keyword">while</span>(ch[p][<span class="hljs-number">0</span>]) <span class="hljs-built_in">push_down</span>(p), p = ch[p][<span class="hljs-number">0</span>];
        <span class="hljs-keyword">return</span> p;
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-comment">//将x,y之间的路径剖出来作为splay，然后x作为原树根，y作为splay根</span>
        <span class="hljs-built_in">makeroot</span>(x);
        <span class="hljs-built_in">access</span>(y);
        <span class="hljs-built_in">splay</span>(y);
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-comment">//连边（虚边）</span>
        <span class="hljs-built_in">makeroot</span>(x);
        <span class="hljs-keyword">if</span>(x != <span class="hljs-built_in">findroot</span>(y)) fa[x] = y;<span class="hljs-comment">//注意，连虚边一定要让所在splay的根节点的fa连出去，这里x已经是splay根节点了而y不一定</span>
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-comment">//删边</span>
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">findroot</span>(x) != <span class="hljs-built_in">findroot</span>(y)) <span class="hljs-keyword">return</span>;
        <span class="hljs-built_in">split</span>(x, y);<span class="hljs-comment">//记牢此时x为原树根，y为splay根，原树根仅仅是深度最小的节点，完全可以有fa</span>
        <span class="hljs-keyword">if</span>(fa[x] != y || ch[x][<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//要x,y之间有连边，就要它们在splay的中序遍历上相邻</span>
        ch[y][<span class="hljs-number">0</span>] = fa[x] = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">push_up</span>(y);
    &#125;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dist</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;
        <span class="hljs-built_in">split</span>(x, y);
        <span class="hljs-keyword">return</span> siz[y];
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++) ch[i][<span class="hljs-number">0</span>] = ch[i][<span class="hljs-number">1</span>] = fa[i] = swp[i] = <span class="hljs-number">0</span>;
    &#125;
&#125;lct;

<span class="hljs-type">int</span> a[maxn], f[maxn];
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">diameter</span> &#123;
    <span class="hljs-type">int</span> x, y, d;
    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> diameter&amp; t)<span class="hljs-type">const</span> &#123;
        <span class="hljs-keyword">return</span> d &lt; t.d;
    &#125;
&#125;d[maxn];

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(x == f[x]) <span class="hljs-keyword">return</span> x;
    <span class="hljs-keyword">return</span> f[x] = <span class="hljs-built_in">find</span>(f[x]);
&#125;
<span class="hljs-type">int</span> cnt[maxn];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-type">int</span> n, m;
    cin &gt;&gt; n &gt;&gt; m;
    lct.<span class="hljs-built_in">init</span>(n);
    cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;
        f[i] = i;
        lct.siz[i] = <span class="hljs-number">1</span>;
        d[i] = &#123;i, i, <span class="hljs-number">0</span>&#125;;
        cnt[i] = <span class="hljs-number">0</span>;
        cnt[<span class="hljs-number">0</span>]++;
    &#125;
    <span class="hljs-type">int</span> mxd = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++) &#123;
        <span class="hljs-type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;
        <span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(x), fy = <span class="hljs-built_in">find</span>(y);
        cnt[d[fx].d]--;
        cnt[d[fy].d]--;
        lct.<span class="hljs-built_in">link</span>(x, y);
        diameter tmp = <span class="hljs-built_in">max</span>(d[fx], d[fy]);
        tmp = <span class="hljs-built_in">max</span>(tmp, &#123;d[fx].x, d[fy].x, lct.<span class="hljs-built_in">dist</span>(d[fx].x, d[fy].x) - <span class="hljs-number">1</span>&#125;);
        tmp = <span class="hljs-built_in">max</span>(tmp, &#123;d[fx].x, d[fy].y, lct.<span class="hljs-built_in">dist</span>(d[fx].x, d[fy].y) - <span class="hljs-number">1</span>&#125;);
        tmp = <span class="hljs-built_in">max</span>(tmp, &#123;d[fx].y, d[fy].x, lct.<span class="hljs-built_in">dist</span>(d[fx].y, d[fy].x) - <span class="hljs-number">1</span>&#125;);
        tmp = <span class="hljs-built_in">max</span>(tmp, &#123;d[fx].y, d[fy].y, lct.<span class="hljs-built_in">dist</span>(d[fx].y, d[fy].y) - <span class="hljs-number">1</span>&#125;);
        f[fx] = fy;
        d[fy] = tmp;
        cnt[tmp.d]++;
        mxd = <span class="hljs-built_in">max</span>(mxd, tmp.d);

        <span class="hljs-comment">// for(auto x : alld) cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;</span>
        <span class="hljs-comment">// cout &lt;&lt; &#x27;\n&#x27;;</span>

        <span class="hljs-type">int</span> mx[<span class="hljs-number">4</span>], h = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;h &lt; <span class="hljs-number">3</span> &amp;&amp; i &lt;= cnt[mxd];i++) mx[++h] = mxd;
        <span class="hljs-keyword">if</span>(mxd &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;h &lt; <span class="hljs-number">3</span> &amp;&amp; i &lt;= cnt[mxd - <span class="hljs-number">1</span>];i++) mx[++h] = mxd - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span>(mxd &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;h &lt; <span class="hljs-number">3</span> &amp;&amp; i &lt;= cnt[mxd - <span class="hljs-number">2</span>];i++) mx[++h] = mxd - <span class="hljs-number">2</span>;
        <span class="hljs-type">int</span> ans = mx[<span class="hljs-number">1</span>];
        <span class="hljs-keyword">if</span>(h &gt; <span class="hljs-number">1</span>) ans = <span class="hljs-built_in">max</span>(ans, (mx[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span> + (mx[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);
        <span class="hljs-keyword">if</span>(h &gt; <span class="hljs-number">2</span>) ans = <span class="hljs-built_in">max</span>(ans, (mx[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">2</span> + (mx[<span class="hljs-number">3</span>] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);
        cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    &#125;
&#125;</code></pre></div>
<h4 id="compfest-14-j.-journey"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1725/problem/J">COMPFEST 14 J.
Journey</a></h4>
<p>如果只有一个起点，答案即所有边权x2再减去树上的最长路径（直径）</p>
<p>现在可以取第二个起点，那么答案（要减去的部分）有两种情况：</p>
<ul>
<li>树上两条有单个点相交的路径</li>
<li>树上两条不相交的路径，再加上两路径之间的最大边x2</li>
</ul>
<p>对于第一种情况，考虑枚举交点，然后走四条链出去，这个比较好维护</p>
<p>第二种情况，枚举中间边，然后需要知道以这条边作为分割，上下两棵树的直径。</p>
<p>要维护这两个东西比较麻烦，具体如下：</p>
<div class="code-wrapper"><pre><code class="hljs C++">ll dia[maxn];   <span class="hljs-comment">// p这个子树的直径</span>
ll dup[maxn];   <span class="hljs-comment">// 除去p子树的直径</span>
ll dp[maxn][<span class="hljs-number">4</span>]; <span class="hljs-comment">// p向下最大的四条链</span>
ll dp2[maxn][<span class="hljs-number">2</span>];<span class="hljs-comment">// p儿子中最大的两个直径</span>
ll up[maxn];    <span class="hljs-comment">// p向上走的最长链</span></code></pre></div>
<p>首先一遍 dfs 求出 <code>dp, dp2, dia</code></p>
<p>然后再 dfs 第二遍，这一遍<strong>从上向下转移</strong></p>
<p>设当前跑到边 <span class="math inline">\(u\rightarrow
v\)</span>，边权 <span class="math inline">\(w\)</span></p>
<p><code>up[v]</code> 可以由 <code>up[u] + w</code>，以及
<code>u子树中除了v之外的最长链 + w</code> 转移来</p>
<p><code>dup[v]</code> 可以由 <code>dup[u]</code> 以及
<code>u子树中除了v之外的最大直径</code> 和
<code>u连出的链中除了v之外的最大两条链之和</code> 转移来</p>
<p>想到了这些就会发现题目可做了，然后就是分类讨论的事了（</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e6</span> + <span class="hljs-number">100</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> mode = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;
 
vector&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; vp[maxn];
ll dia[maxn];   <span class="hljs-comment">// p子树的直径</span>
ll dup[maxn];   <span class="hljs-comment">// 除去p子树的直径</span>
ll dp[maxn][<span class="hljs-number">4</span>]; <span class="hljs-comment">// p向下最大的四条链</span>
ll dp2[maxn][<span class="hljs-number">2</span>];<span class="hljs-comment">// p儿子中最大的两个直径</span>
ll up[maxn];    <span class="hljs-comment">// 向上最长链</span>
 
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add1to</span><span class="hljs-params">(<span class="hljs-type">int</span> p, ll val)</span></span>&#123;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">4</span>;i++) &#123;
        <span class="hljs-keyword">if</span>(dp[p][i] &lt; val) <span class="hljs-built_in">swap</span>(val, dp[p][i]);
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add2to</span><span class="hljs-params">(<span class="hljs-type">int</span> p, ll val)</span> </span>&#123;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">2</span>;i++) &#123;
        <span class="hljs-keyword">if</span>(dp2[p][i] &lt; val) <span class="hljs-built_in">swap</span>(val, dp2[p][i]);
    &#125;
&#125;
 
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span> </span>&#123;
    dia[p] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [v, w] : vp[p]) &#123;
        <span class="hljs-keyword">if</span>(v != fa) &#123;
            <span class="hljs-built_in">dfs</span>(v, p);
            <span class="hljs-built_in">add1to</span>(p, dp[v][<span class="hljs-number">0</span>] + w);
            <span class="hljs-built_in">add2to</span>(p, dia[v]);
            dia[p] = <span class="hljs-built_in">max</span>(dia[p], dia[v]);
        &#125;
    &#125;
    dia[p] = <span class="hljs-built_in">max</span>(dia[p], dp[p][<span class="hljs-number">0</span>] + dp[p][<span class="hljs-number">1</span>]);
&#125;
 
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa, ll&amp; res)</span> </span>&#123;
    ll tmp;
    <span class="hljs-built_in">add1to</span>(p, up[p]);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [v, w] : vp[p]) &#123;
        <span class="hljs-keyword">if</span>(v != fa) &#123;
            up[v] = w + dp[p][dp[p][<span class="hljs-number">0</span>] == dp[v][<span class="hljs-number">0</span>] + w ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>];
            ll mx1 = dp2[p][dp2[p][<span class="hljs-number">0</span>] == dia[v] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>];
            ll mx2;
            <span class="hljs-keyword">if</span>(dp[p][<span class="hljs-number">0</span>] == dp[v][<span class="hljs-number">0</span>] + w) mx2 = dp[p][<span class="hljs-number">1</span>] + dp[p][<span class="hljs-number">2</span>];
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[p][<span class="hljs-number">1</span>] == dp[v][<span class="hljs-number">0</span>] + w) mx2 = dp[p][<span class="hljs-number">0</span>] + dp[p][<span class="hljs-number">2</span>];
            <span class="hljs-keyword">else</span> mx2 = dp[p][<span class="hljs-number">0</span>] + dp[p][<span class="hljs-number">1</span>];
            dup[v] = <span class="hljs-built_in">max</span>(&#123;dup[p], mx1, mx2&#125;);
 
            res = <span class="hljs-built_in">max</span>(res, dia[v] + dup[v] + <span class="hljs-number">2</span> * w);
            <span class="hljs-built_in">dfs2</span>(v, p, res);
        &#125;
    &#125;
&#125;
 
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-type">int</span> n;
    cin &gt;&gt; n;
    ll ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++) &#123;
        <span class="hljs-type">int</span> u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        vp[u].<span class="hljs-built_in">emplace_back</span>(v, w);
        vp[v].<span class="hljs-built_in">emplace_back</span>(u, w);
        ans += w * <span class="hljs-number">2</span>;
    &#125;
    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
    ll res = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, res);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;
        <span class="hljs-keyword">if</span>(vp[i].<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">continue</span>;
        res = <span class="hljs-built_in">max</span>(res, dp[i][<span class="hljs-number">0</span>] + dp[i][<span class="hljs-number">1</span>] + dp[i][<span class="hljs-number">2</span>] + dp[i][<span class="hljs-number">3</span>]);
    &#125;
    cout &lt;&lt; ans - res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
 
&#125;</code></pre></div>
<h4 id="icpc-网赛2-h"><a
target="_blank" rel="noopener" href="https://pintia.cn/problem-sets/1574060137151397888/problems/1574060247893606407">2022
ICPC 网赛2 H</a></h4>
<p>首先分别考虑贡献，因为这题中一个方案的贡献由所有 <span
class="math inline">\(u,v\)</span> 间的路径长度（ <span
class="math inline">\(u,v\)</span>
之间没有其他选中点）组成，故去考虑<strong>每一条路径</strong>
的贡献。</p>
<p>一条路径计入答案，当且仅当其两端点 <span
class="math inline">\(u,v\)</span>
都选中，且路径中其他点都不被选中（仅计算被直接选择时的贡献，作为子路径时不考虑，这样能做到不重复不遗漏），然后我们再去考虑这个路径会被计算多少次。</p>
<p>此时其他点可选可不选，对于任意一点 <span
class="math inline">\(i\)</span>，它对这个路径产生贡献的次数都为 <span
class="math inline">\(2^{n-d-2}\)</span>，那么这条路径的总贡献为：<span
class="math inline">\(d(n-d+3)2^{n-d-2}\)</span></p>
<p>有了这个式子，只需要枚举图中所有的路径计算和即可，但这显然不现实。</p>
<p>考虑换根dp，对于每个点记录其向上走和向下走的所有路径贡献和，如何转移？</p>
<p>注意到每条路径的式子形式类似 <span
class="math inline">\(xy2^y\)</span>，对于许多这样的式子和，要进行全体
<code>x+1</code> 等类似操作并维护是很容易的，只需要维护 <span
class="math inline">\(x2^y,y2^y,2^y\)</span> 和作为辅助即可。</p>
<p>同理进行 <code>y-1</code>
等操作也不难，剩下的就是一个标准的换根dp了。</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll x, ll p)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(p &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qpow</span>(<span class="hljs-built_in">qpow</span>(x, -p), mode - <span class="hljs-number">2</span>);
    ll r = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>(p &gt; <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">if</span>(p &amp; <span class="hljs-number">1</span>) r = r * x % mode;
        x = x * x % mode;
        p /= <span class="hljs-number">2</span>;
    &#125;
    <span class="hljs-keyword">return</span> r;
&#125;

ll iv2 = <span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>, mode - <span class="hljs-number">2</span>);

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;
    ll xxy, xy, yy, y;
    <span class="hljs-built_in">node</span>() : <span class="hljs-built_in">xxy</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">xy</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">yy</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>) &#123;&#125;;
    <span class="hljs-built_in">node</span>(ll a, ll b) &#123;
        y = <span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>, b);
        yy = b * y % mode;
        xy = a * y % mode;
        xxy = b * xy % mode;
    &#125;
    node <span class="hljs-keyword">operator</span> +(<span class="hljs-type">const</span> node&amp; t) &#123;
        node r = *<span class="hljs-keyword">this</span>;
        (r.xxy += t.xxy) %= mode;
        (r.xy += t.xy) %= mode;
        (r.yy += t.yy) %= mode;
        (r.y += t.y) %= mode;
        <span class="hljs-keyword">return</span> r;
    &#125;
    node <span class="hljs-keyword">operator</span> -(<span class="hljs-type">const</span> node&amp; t) &#123;
        node r = *<span class="hljs-keyword">this</span>;
        (r.xxy -= t.xxy) %= mode;
        (r.xy -= t.xy) %= mode;
        (r.yy -= t.yy) %= mode;
        (r.y -= t.y) %= mode;
        <span class="hljs-keyword">return</span> r;
    &#125;
    <span class="hljs-function">node <span class="hljs-title">add1</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-function">node <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;
        r.xxy = (xxy + yy - xy - y + <span class="hljs-number">2</span> * mode) % mode * iv2 % mode;
        r.yy = (yy - y + mode) * iv2 % mode;
        r.xy = (xy + y) * iv2 % mode;
        r.y = y * iv2 % mode;
        <span class="hljs-keyword">return</span> r;
    &#125;
&#125;;

<span class="hljs-type">int</span> n;
vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];
node dw[maxn], up[maxn];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span> </span>&#123;
    dw[p] = <span class="hljs-built_in">node</span>(<span class="hljs-number">0</span>, n + <span class="hljs-number">3</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : vp[p]) &#123;
        <span class="hljs-keyword">if</span>(v != fa) &#123;
            <span class="hljs-built_in">dfs1</span>(v, p);
            dw[p] = dw[p] + dw[v].<span class="hljs-built_in">add1</span>();
        &#125;
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span> </span>&#123;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : vp[p]) &#123;
        <span class="hljs-keyword">if</span>(v != fa) &#123;
            up[v] = (up[p] + dw[p] - dw[v].<span class="hljs-built_in">add1</span>()).<span class="hljs-built_in">add1</span>();
            <span class="hljs-built_in">dfs2</span>(v, p);
        &#125;
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
    cin &gt;&gt; n;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++) &#123;
        <span class="hljs-type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;
        vp[x].<span class="hljs-built_in">push_back</span>(y);
        vp[y].<span class="hljs-built_in">push_back</span>(x);
    &#125;
    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
    ll ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) ans = (ans + (up[i] + dw[i] - <span class="hljs-built_in">node</span>(<span class="hljs-number">0</span>, n + <span class="hljs-number">3</span>)).xxy) % mode;
    cout &lt;&lt; <span class="hljs-function">ans * <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-number">64</span>, mode - <span class="hljs-number">2</span>)</span> % mode &lt;&lt; &#x27;\n&#x27;</span>;
&#125;</code></pre></div>
<h4 id="ccpc-威海-k"><a
target="_blank" rel="noopener" href="https://codeforces.com/gym/104023/problem/K">2022 CCPC 威海
K</a></h4>
<blockquote>
<p>题意：要求寻找区间 <span class="math inline">\([l, r](0&lt;l\le
r)\)</span> 的个数，满足给出的 <span class="math inline">\(n\)</span>
个条件，条件形式如下：</p>
<ul>
<li>1 <span class="math inline">\(k\)</span> <span
class="math inline">\(x\)</span>：可以在 <span
class="math inline">\([l,r]\)</span> 中找出 <span
class="math inline">\(k\)</span> 个不同数，使得他们的和为 <span
class="math inline">\(x\)</span></li>
<li>2 <span class="math inline">\(k\)</span> <span
class="math inline">\(x\)</span>：无法在 <span
class="math inline">\([l,r]\)</span> 中找出 <span
class="math inline">\(k\)</span> 个不同数，使得他们的和为 <span
class="math inline">\(x\)</span></li>
</ul>
</blockquote>
<p>首先注意到一点：对于任意区间 <span
class="math inline">\([l,r]\)</span>，从中取 <span
class="math inline">\(k\)</span> 个数的值域是连续的，最小值为 <span
class="math inline">\(\frac{(l+l+k-1)\times
l}{2}\)</span>，最大值同理（式子不写了）</p>
<p>考虑第一种条件，我们可以找到这样一个区间： <span
class="math inline">\([L,L+k-1]\)</span> 总和为 <span
class="math inline">\(x\)</span>，或者 <span
class="math inline">\([L,L+k]\)</span>，前 <span
class="math inline">\(k\)</span> 个数和小于 <span
class="math inline">\(x\)</span> 且后 <span
class="math inline">\(k\)</span> 个数和大于 <span
class="math inline">\(x\)</span>。</p>
<p>条件一转化为：<span class="math inline">\([l,r]\)</span>
必须包括这个区间，可以合并所有条件一得到 <span
class="math inline">\(l\)</span> 的最大值和 <span
class="math inline">\(r\)</span> 的最小值。</p>
<p>同理，条件二转化为 <span class="math inline">\([l,r]\)</span>
必须不包括这个区间，然而这个东西在线段上比较难处理，可以在 <span
class="math inline">\(lOr\)</span> 平面上考虑。</p>
<p>画个图发现就是求个矩形面积并，可以扫描线或者单调栈处理。</p>
<div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-type">int</span> n; cin &gt;&gt; n;
    ll L = <span class="hljs-number">2e9</span>, R = <span class="hljs-number">0</span>;
    vector&lt;pii&gt; ban;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;
        <span class="hljs-type">int</span> opt, k, x;
        cin &gt;&gt; opt &gt;&gt; k &gt;&gt; x;

        ll l = <span class="hljs-number">1</span>, r = <span class="hljs-number">2e9</span>;
        <span class="hljs-keyword">while</span>(l &lt; r) &#123;
            ll mid = (l + r) / <span class="hljs-number">2</span>;
            ll val = (mid + mid + k - <span class="hljs-number">1</span>) * k / <span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span>(val &gt;= x) r = mid;
            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;
        &#125;
        r = l + k - <span class="hljs-number">1</span>;
        ll val = (l + l + k - <span class="hljs-number">1</span>) * k / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span>(val != x) l--;

        <span class="hljs-keyword">if</span>(opt == <span class="hljs-number">1</span>) &#123;
            L = <span class="hljs-built_in">min</span>(L, l);
            R = <span class="hljs-built_in">max</span>(R, r);
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">if</span>(l == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
            ban.<span class="hljs-built_in">emplace_back</span>(l, r);
        &#125;
    &#125;
    <span class="hljs-keyword">if</span>(L == <span class="hljs-number">0</span>) &#123;
        cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;
        <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-keyword">if</span>(ban.<span class="hljs-built_in">empty</span>()) &#123;
        cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;
        <span class="hljs-keyword">return</span>;
    &#125;

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; [x, y] : ban) &#123;
        <span class="hljs-keyword">if</span>(x &gt; L) x = L;
        <span class="hljs-keyword">if</span>(y &lt; R) y = R;
    &#125;
    <span class="hljs-built_in">sort</span>(ban.<span class="hljs-built_in">begin</span>(), ban.<span class="hljs-built_in">end</span>(), [&amp;](pii&amp; a, pii&amp; b) &#123; <span class="hljs-keyword">return</span> a.second &lt; b.second;&#125;);

    stack&lt;pii&gt; stk;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; [x, y] : ban) &#123;
        <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">empty</span>() || x &gt; stk.<span class="hljs-built_in">top</span>().first) &#123;
            stk.<span class="hljs-built_in">emplace</span>(x, y);
        &#125;
    &#125;

    <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">top</span>().first &lt; L) &#123;
        cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;
        <span class="hljs-keyword">return</span>;
    &#125;
    ll ans = <span class="hljs-number">0</span>;
    ll lst = stk.<span class="hljs-built_in">top</span>().second;
    stk.<span class="hljs-built_in">pop</span>();
    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>()) &#123;
        <span class="hljs-keyword">auto</span> [x, y] = stk.<span class="hljs-built_in">top</span>();
        stk.<span class="hljs-built_in">pop</span>();
        ans += (lst - y) * (L - x);
        lst = y;
    &#125;
    ans += (lst - R) * L;
    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
&#125;</code></pre></div>
<h4 id="ccpc-威海-f"><a
target="_blank" rel="noopener" href="https://codeforces.com/gym/104023/problem/F">2022 CCPC 威海
F</a></h4>
<blockquote>
<p>题意：给出一个有向图，每个点有颜色 <span
class="math inline">\(c_i\)</span> 和费用 <span
class="math inline">\(w_i\)</span>，走到一个未打标记的点时，需花费 <span
class="math inline">\(w_i\)</span>
并打标记，随后你可以选择任意个颜色不同的节点 <span
class="math inline">\(j\)</span>，回收上面的标记并返还 <span
class="math inline">\(w_j\)</span> 的费用。</p>
<p>问：对于每一对起点终点，初始需要多少钱才能抵达。 <span
class="math inline">\(n \le 300\)</span></p>
</blockquote>
<p>显然当我们走到一个点时，会选择回收所有不同颜色的节点的费用，</p>
<p>那么对于一条路径，把它拆分为若干颜色段，走到每一段时都会回收前一段的费用，那么这段路径的代价就是<strong>MAX(每一段的费用和+下一段第一个点的费用，最后一段的费用)</strong></p>
<p>就变成了一个瓶颈路的问题。</p>
<p>具体做法：把原图划分为若干个同颜色的连通块，在每个连通块内部floyd求出两两间最短路，然后枚举块内的起点（<span
class="math inline">\(s\)</span>）和终点（<span
class="math inline">\(t\)</span>），再枚举终点向块外连的边（<span
class="math inline">\(t\rightarrow j\)</span>），在新图上建一条 <span
class="math inline">\(s\rightarrow j\)</span> 的边。</p>
<p>在新图上枚举起点，朴素prim跑最小瓶颈路（<span
class="math inline">\(n^2\)</span>）</p>
<p>这样就将 "每一段的费用和+下一段第一个点的费用"
考虑完了，还需要考虑最后一段的费用，这个不能直接在块内连边，因为我们要求最小瓶颈路，边权不能“合成”。（这个词用的比较抽象，自行理解一下）</p>
<p>只需要在最后输出前，用块内其他点+块内距离松弛一次即可，同样因为边不能“合成”，松弛后的结果不能更新到最短路中，而应当直接输出。</p>
<div class="code-wrapper"><pre><code class="hljs C++">ll dis[<span class="hljs-number">303</span>][<span class="hljs-number">303</span>];
<span class="hljs-type">int</span> col[<span class="hljs-number">303</span>], w[<span class="hljs-number">303</span>];
<span class="hljs-type">bool</span> vis[<span class="hljs-number">303</span>];
 
vector&lt;<span class="hljs-type">int</span>&gt; vp1[<span class="hljs-number">303</span>];
ll dis2[<span class="hljs-number">303</span>][<span class="hljs-number">303</span>];
 
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, vector&lt;<span class="hljs-type">int</span>&gt;&amp; ls)</span> </span>&#123; <span class="hljs-comment">//染色</span>
    vis[p] = <span class="hljs-literal">true</span>;
    ls.<span class="hljs-built_in">push_back</span>(p);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : vp1[p]) &#123;
        <span class="hljs-keyword">if</span>(!vis[v] &amp;&amp; col[v] == col[p]) &#123;
            <span class="hljs-built_in">dfs</span>(v, ls);
        &#125;
    &#125;
&#125;
 
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-type">int</span> n, m;
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-built_in">fill</span>(dis[<span class="hljs-number">0</span>], dis[<span class="hljs-number">0</span>] + <span class="hljs-number">303</span> * <span class="hljs-number">303</span>, <span class="hljs-number">1e18</span>);
    <span class="hljs-built_in">fill</span>(dis2[<span class="hljs-number">0</span>], dis2[<span class="hljs-number">0</span>] + <span class="hljs-number">303</span> * <span class="hljs-number">303</span>, <span class="hljs-number">1e18</span>);
    <span class="hljs-built_in">fill</span>(vis, vis + n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;
        vp1[i].<span class="hljs-built_in">clear</span>();
    &#125;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) cin &gt;&gt; col[i];
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) cin &gt;&gt; w[i], dis[i][i] = w[i];
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++) &#123;
        <span class="hljs-type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;
        vp1[x].<span class="hljs-built_in">push_back</span>(y);
        vp1[y].<span class="hljs-built_in">push_back</span>(x);
        dis[x][y] = dis[y][x] = w[x] + w[y];
    &#125;
    
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;
        <span class="hljs-keyword">if</span>(!vis[i]) &#123;
            vector&lt;<span class="hljs-type">int</span>&gt; ls;
            <span class="hljs-built_in">dfs</span>(i, ls);
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k : ls) &#123;
                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : ls) &#123;
                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j : ls) &#123;
                        <span class="hljs-keyword">if</span>(dis[i][k] + dis[k][j] - w[k] &lt; dis[i][j]) &#123;
                            dis[i][j] = dis[j][i] = dis[i][k] + dis[k][j] - w[k];
                        &#125;
                    &#125;
                &#125;
            &#125;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : ls) &#123;
                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j : ls) &#123;
                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : vp1[j]) &#123;
                        <span class="hljs-keyword">if</span>(col[j] != col[v]) &#123;
                            dis2[i][v] = <span class="hljs-built_in">min</span>(dis2[i][v], dis[i][j] + w[v]);
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
 
    <span class="hljs-function">vector <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;ll&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">1e18</span>))</span></span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;
        ans[i][i] = w[i];
        <span class="hljs-built_in">fill</span>(vis, vis + n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cc = <span class="hljs-number">1</span>;cc &lt;= n;cc++) &#123; <span class="hljs-comment">//prim</span>
            <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>; ans[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1e18</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++) &#123;
                <span class="hljs-keyword">if</span>(!vis[j] &amp;&amp; ans[i][j] &lt; ans[i][p]) p = j;
            &#125;
            vis[p] = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>;v &lt;= n;v++) &#123;
                ans[i][v] = <span class="hljs-built_in">min</span>(ans[i][v], <span class="hljs-built_in">max</span>(ans[i][p], dis2[p][v]));
            &#125;
        &#125;
    &#125;
 
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++) &#123;
            ll opt = ans[i][j];
            <span class="hljs-comment">// 最后一步可以使用dis</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k &lt;= n;k++) &#123;
                opt = <span class="hljs-built_in">min</span>(opt, <span class="hljs-built_in">max</span>(ans[i][k], dis[k][j]));
            &#125;
            <span class="hljs-keyword">if</span>(i == j) opt = <span class="hljs-number">0</span>;
            cout &lt;&lt; opt &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[j == n];
        &#125;
    &#125;
&#125;</code></pre></div>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%A2%98%E8%A7%A3/" class="category-chain-item">题解</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%A2%98%E8%A7%A3/">#题解</a>
      
        <a href="/tags/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/">#牛客多校</a>
      
        <a href="/tags/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/">#杭电多校</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>高质量补题记录集</div>
      <div>http://www.lxtyin.ac.cn/2022/09/28/题解/高质量补题记录集/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>lx_tyin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年9月28日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://lib.baomitu.com/gitalk/1.8.0/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"Ov23liFxPzhSbzZd0QNI","clientSecret":"7e5fb85cacc26889dd0841b70a8344f6adbe0f75","repo":"lxtyin.github.io.comments","owner":"lxtyin","admin":["lxtyin"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '3a04c0e81ecbf0aa9b7e63b512c32877'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-left: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="题解"
        id="heading-4161afd7a4e47ddb8376cb63ba58880f" role="tab" data-toggle="collapse" href="#collapse-4161afd7a4e47ddb8376cb63ba58880f"
        aria-expanded="true"
      >
        题解
        <span class="list-group-count">(25)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-4161afd7a4e47ddb8376cb63ba58880f"
           role="tabpanel" aria-labelledby="heading-4161afd7a4e47ddb8376cb63ba58880f">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2022/03/31/%E9%A2%98%E8%A7%A3/Atcoder%20ABC%20245%20G/" title="Atcoder Beginner 245 G"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Atcoder Beginner 245 G</span>
        </a>
      
    
      
      
        <a href="/2022/04/11/%E9%A2%98%E8%A7%A3/Atcoder%20ABC%20247%20EFG/" title="Atcoder Beginner 246 EFG"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Atcoder Beginner 246 EFG</span>
        </a>
      
    
      
      
        <a href="/2022/04/07/%E9%A2%98%E8%A7%A3/Atcoder%20ABC%20246%20FG%20EX%20-%20%E5%89%AF%E6%9C%AC/" title="Atcoder Beginner 246 FG EX"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Atcoder Beginner 246 FG EX</span>
        </a>
      
    
      
      
        <a href="/2022/04/23/%E9%A2%98%E8%A7%A3/Codeforces%20Global%20Round%2020%20A-F1,H/" title="Codeforces Global Round 20 A-F,H"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Codeforces Global Round 20 A-F,H</span>
        </a>
      
    
      
      
        <a href="/2021/11/17/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20746%20div.2/" title="Codeforces Round 746 div.2 CDE"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Codeforces Round 746 div.2 CDE</span>
        </a>
      
    
      
      
        <a href="/2021/10/09/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20747%20div.2/" title="Codeforces Round 747 div.2 A-E"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Codeforces Round 747 div.2 A-E</span>
        </a>
      
    
      
      
        <a href="/2021/10/13/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20748%20div.3/" title="Codeforces Round 748 div.3 A-G"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Codeforces Round 748 div.3 A-G</span>
        </a>
      
    
      
      
        <a href="/2021/10/17/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20749%20div.1%202/" title="Codeforces Round 749 div.1 2 A-E"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Codeforces Round 749 div.1 2 A-E</span>
        </a>
      
    
      
      
        <a href="/2021/11/14/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20755%20div.1/" title="Codeforces Round 755 div.1 ABC"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Codeforces Round 755 div.1 ABC</span>
        </a>
      
    
      
      
        <a href="/2022/02/06/%E9%A2%98%E8%A7%A3/Codeforces%20Round%20770%20div.2%20EF/" title="Codeforces Round 770 div.2 EF"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Codeforces Round 770 div.2 EF</span>
        </a>
      
    
      
      
        <a href="/categories/%E9%A2%98%E8%A7%A3/" class="list-group-item list-group-item-action">
          <span class="category-post">More...</span>
        </a>
        
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
