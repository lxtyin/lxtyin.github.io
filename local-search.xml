<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>24届计算机推免 四非0科研图形学菜狗的经验贴（北航vr、南开cs）</title>
    <link href="/2023/09/29/24%E5%B1%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A8%E5%85%8D%20%E5%9B%9B%E9%9D%9E0%E7%A7%91%E7%A0%94%E5%9B%BE%E5%BD%A2%E5%AD%A6%E8%8F%9C%E7%8B%97%E7%9A%84%E7%BB%8F%E9%AA%8C%E8%B4%B4%EF%BC%88%E5%8C%97%E8%88%AAvr%E3%80%81%E5%8D%97%E5%BC%80cs%EF%BC%89/"/>
    <url>/2023/09/29/24%E5%B1%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A8%E5%85%8D%20%E5%9B%9B%E9%9D%9E0%E7%A7%91%E7%A0%94%E5%9B%BE%E5%BD%A2%E5%AD%A6%E8%8F%9C%E7%8B%97%E7%9A%84%E7%BB%8F%E9%AA%8C%E8%B4%B4%EF%BC%88%E5%8C%97%E8%88%AAvr%E3%80%81%E5%8D%97%E5%BC%80cs%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><img src="http://lxtyin.ac.cn/img/baoyan/nku.png"></p><h2 id="个人情况"><a href="#个人情况" class="headerlink" title="个人情况"></a>个人情况</h2><p>本科：四非rk1或2</p><p>科研：null</p><p>竞赛：acm区域金（非银川）</p><p>项目：一个图形学lab，一个实时光追渲染器，还有一些乱七八糟的小东西</p><p>意向：cg方向，不考虑直博，学硕专硕无所谓</p><p>不考虑直博主要还是因为没做过科研，风险太大，打算读硕期间根据情况再考虑要不要读博。</p><p>本人一开始是头铁的非图形不走，中途经历了各种人间疾苦后也考虑了别的方向，最后认识到：<strong>在自己主攻的方向都没老师要的话，别的方向就更别想了</strong>，于是又回归到了头铁图形的路子上。</p><p>图形学方向窄，我又想做渲染相关的，可选项其实已经非常少了。</p><h2 id="前期"><a href="#前期" class="headerlink" title="前期"></a>前期</h2><p>3月份开始准备保研，这时acm已经退役，一边做项目一边联系导师。</p><p>此时我最希望的是能找个组进去打工，即使最后没去成，也能丰富一下科研经历。然而结果非常惨淡，联系导师大多官回，最后也没能进行一段科研实习。这段时间对自己的定位一直摇摆不定，不断自我怀疑，把期待值拉到了一个很低的程度。现在回顾一下，<strong>陶瓷阶段发挥主要作用的还是科研经历</strong>，而这块算是我最大的短板，其实没有必要因此妄自菲薄的。</p><p>不过这段时间积累的一些东西在后面发挥了很大作用：</p><p>一个浙大老师（当时唯一加上的老师）给了两个作业做（包括一个图形学Lab，后面写进简历），花了挺多时间，但因为后面觉得浙计CAD进不去，浙软不太想去，老师又不再浙工招生，就没联系了。</p><p>撸了一个实时光追，当时觉得很nb，每封陶瓷信都附一份渲染图，现在感觉这个行为有点憨，，，，不过通过这个项目算是把图形学基础打牢了，应该也是南开进面的关键。</p><p>因为提前了解到北航比较倾向ACMer，就早早准备，在3月份去考了个CSP，它也的确救回了我稀烂的北航面试（虽然最后没去）。</p><p>期间还心不在焉地去EC和CCFinal打了两块铁，，，，（?</p><h2 id="夏令营"><a href="#夏令营" class="headerlink" title="夏令营"></a>夏令营</h2><table><thead><tr><th>学校&#x2F;院</th><th>结果</th></tr></thead><tbody><tr><td>中山计算机</td><td>寄</td></tr><tr><td>华师计算机</td><td>寄</td></tr><tr><td>北航计算机</td><td>优营（未签约）</td></tr><tr><td>山大软件</td><td>寄</td></tr><tr><td>深圳大学计算机</td><td>入营放弃</td></tr><tr><td>南开计算机</td><td>offer</td></tr><tr><td>浙大工程师</td><td>寄</td></tr></tbody></table><p>报夏令营突出一个普信，要填科研经历的地方全是空着的，还到处报学硕</p><p>我怎么敢的</p><p>中山寄了情理之中（报学硕、无科研）</p><p>华师寄了情理之中（报学硕、似乎要陶瓷，我没套）</p><p>山大寄了有点没想到</p><p>浙工程师今年貌似bar特别离谱（某fducs优营、预推免冲进贵系的hdu佬都没进）</p><p>北航报名的时候没区分学专且看重ACM，南开cs自己联系导师考核就行了。最后夏令营就是这两个。</p><p>深大VCC图形学非常强，且钱多补助高，地域也好，但我还是做不到彻底丢下title不管，夏令营又和南开的考核重叠，就放弃了。</p><h5 id="北航cs"><a href="#北航cs" class="headerlink" title="北航cs"></a>北航cs</h5><p>预期，北航看中ACM且机试分差大，可以说是鼠鼠唯一有优势的地方了。</p><p>入营不歧视双非，看ACM奖项（但不绝对，rk1还是有用），拼住宿的时候一间三个双非，形成鼠窝（三人最后两优营一个wl第7），群里也看到了好几个别的双非。面试也是考基础知识，客观分，不看背景，对双非还是比较友好的。</p><blockquote><p>这里稍微多提一下：据我观察，真正歧视双非的学校（点名不要的那种）并没有那么多，北航这种放你进来，但是基础知识你就是没打过92学生的话，就不要说自己被歧视了…</p><p>鼠鼠群里经常看到群友说自己又被歧视了，我觉得大家还是多从自己身上找原因吧，这样才有的提升。</p></blockquote><p>机试可以CSP抵分，且按CSP的累计排名抵分（具体规则b站可搜），众所周知CSP百分比排名虚高很严重，抵分大概率是赚的。我CSP440分，估计了一下大概率能抵满，就直接抵了（现场机试oi赛制，有风险）</p><p>虽然最后，很多机考爆0的也进了面试（群友说是人工阅卷了），但机试拉分非常多，机考爆0就很难优营了。</p><p>面试的具体细节就不说了，拷打线代高数概率论+408以及你成绩单上任何一个科目，基本都是基础问题，但我很多记不清了，直接被问穿。事后拿这些题去给考研的同学看，他们都没绷住</p><p>面试寄+机试大概满分，最后是优营rk70+（基本是专硕）</p><p>签约环节，每个老师只能签一个人，竞争非常激烈，vr国重里面几个做渲染的老师都没签成。另一位年轻导师给了我很高评价（感动），但考虑到方向不是很match，后续也还有很多机会，也不太想海这位老师，就和老师开诚布公了。最后没有签约。</p><h5 id="南开cs"><a href="#南开cs" class="headerlink" title="南开cs"></a>南开cs</h5><p>南开cs纯弱com，直接联系导师，完全由课题组安排考核，导师要就等于offer。</p><p>很早在绿裙加的一个学长就跟我强推wbb老师，wbb老师在yj组里，34岁的教授，非常好交流且尊重学生，产出很多Siggraph，在渲染这块做的不错。</p><p>我早期联系了一次，6月份再去联系的时候，仅2分钟就得到了回信，当天中午做了个简单的ppt，下午马上电话交流，是我整个保研过程中最通畅丝滑的一天。电话交流的时候问了几个和我的项目相关的问题，当时的直观感受就是：老师是了解技术细节的，能够给我实质性的帮助（可能我见的主打一个管理的老师太多了）。</p><p>鼠鼠本科学校还出息了一次，承办了一个学术会议，wbb老师来报告，我直接线下陶瓷</p><p>后面认真做了老师的考核（大半个月），8月初答辩当天就得到了准确、无歧义的回复：给我保留一个学硕名额。</p><p>南开的title+学硕+强组好导+match方向，对此我已经不需要犹豫了，南开cs没有鸽人历史，因此我也决定相信老师，给出了一定会去的承诺，预推免开摆了。</p><p>后续到南开线下面试，大老板请了组里所有人一顿饭，感觉大伙水平都很高！我不出意外地是组里本科最差的，好在有块牌还不至于自卑哈哈哈（X</p><h2 id="预推免"><a href="#预推免" class="headerlink" title="预推免"></a>预推免</h2><p>驾校，启动！</p><h2 id="关于去向"><a href="#关于去向" class="headerlink" title="关于去向"></a>关于去向</h2><p>平心而论，对于这个去向自己是否足够满意：我想是满意的，好于我最初的预期。但的确因为更好的都没有去尝试，略有遗憾。在投递的时候还是因为种种因素给自己设限了。</p><p>不知道北航预推免有没有机会拿到vr强导offer，也不知道自己是否有一丝可能冲进浙计硕、南计学硕、清深imdt之类的地方。如果试过，即使收个拒信，现在应该也会少纠结一点。</p><p>最大的遗憾就是——我不敢说自己尽力了。之前和群友聊的时候我曾表达过类似的观点：选择最适合自己的就好，不一定非得搏“上限”。</p><p>然而，三年苦读下来了，真的不想看看自己能到什么地步吗？</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>给下一届的一点小建议：</p><p>不要给自己设限，211把你拒了不代表华五一定不要你，一切皆有可能。</p><p>除了纸面上的title、排名、科研、竞赛、英语等指标，大伙也要注重软实力（面试、心态、表达能力等等），影响很大，群里一位与我bg相似的佬，一路从fdu学硕杀到rw强组直博，了解后发现他的软实力要远远强于我，不得不服。</p><p>关于鸽与被鸽，我衷心希望大家都能真诚一点，让保研别那么累。当然这点我没办法要求大家都做到，环境如此。</p><p>广告时间：</p><img src="http://lxtyin.ac.cn/img/baoyan/green.jpg" style="zoom: 50%;" /><p>全国最大非商业用爱交流计算机保研群，在绿群一年，不管怎么说，它是一个打破信息壁垒的地方，在里面也认识了很多很nb的学长<del>（可惜没有学姐）</del>和同僚，包括向我力荐wbb老师的Xu学长；四非出生的选手往往有很重的title情结，然而经过绿群的洗礼，我越发觉得觉得：导师、方向、地域等等因素，要比你是所谓的中九还是次九重要的多。</p><img src="http://lxtyin.ac.cn/img/baoyan/green_mouse.jpg" style="zoom: 50%;" /><p>绿群双非鼠鼠联盟，群里常出现的院校档次会低一些，对于目标是211到普通985的同学，这个群里的有效信息密度会高一点，当然里面也藏着各种巨佬。</p>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>推免</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图形学杂记（光栅化）</title>
    <link href="/2023/09/22/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%9D%82%E8%AE%B0/"/>
    <url>/2023/09/22/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%9D%82%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这是一个图形学杂记，从光栅化到RT的诸多东西都乱记在里面，大多数只在这里记录了基本思想（有些暂时理解不深的也简记在这里），具体的一些东西可能会另开一贴来记录。</p><h3 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h3><p>“投影”直观上容易被理解为将三维空间物体变换到二维屏幕的过程（可以有这样一种降维的线性变换），但如果直接用矩阵来做这样一件事，不方便处理深度信息（遮挡效果）。</p><p>故实际上我们说的投影矩阵，是将三维空间中的一个长方体或平头截体（观察区域）映射到标准立方体（Canonical Cube，$[-1, 1]^3$）的过程，这个空间也叫<strong>裁剪空间</strong>。映射到这里的好处是方便进行后续操作。</p><h4 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h4><p>将一个长方体映射到 $[-1,1]^3$，比较简单</p><p>很多时候我们会在正交投影时把 $z$ 倒过来，这样摄像机朝 $-z$ 方向，而深度缓冲中的 $z$ 越小表示离摄像机越近。</p><h4 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h4><p>透视投影的观察区域是一个平头截体，我们希望也使用一种（四维矩阵可表示的）线性变换将它映射到 $[-1,1]^3$。</p><p>思路：首先进行的是一个“压扁”的缩放过程，令远处的平面缩放幅度更大，近平面不变，使得平头截体变成一个长方体，随后进行正交投影。</p><p>最简单的想法：让一条观察射线（朝-z方向）上所有 $x,y$ 坐标缩放后都相同，先假定 $z$ 轴不变。</p><p>通过相似三角形容易计算出新坐标应该为 $(n&#x2F;z\times x,n&#x2F;z\times y,z)$</p><p>编出一个变换矩阵，其中参数 $n$ 为近平面的 $z$ 坐标（负值！）<br>$$<br>\begin{bmatrix}<br>n&amp;0&amp;0&amp;0\<br>0&amp;n&amp;0&amp;0\<br>?&amp;?&amp;?&amp;?\<br>0&amp;0&amp;1&amp;0\<br>\end{bmatrix}<br>\times<br>\begin{bmatrix}<br>x\<br>y\<br>z\<br>1\<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>n&#x2F;z\times x\<br>n&#x2F;z\times y\<br>z\<br>1\<br>\end{bmatrix}<br>\rightarrow<br>\begin{bmatrix}<br>nx\<br>ny\<br>z^2\<br>z\<br>\end{bmatrix}<br>$$</p><p>我们发现1，2，4行的参数都很容易确定，但是第三行似乎没法搞？</p><p>问题出现了，这样的变换似乎不是一个线性变换（即使在四维下）</p><p>那么只能放弃追求 $z$ 轴不变了。</p><p>实际的投影矩阵要求只有：近平面坐标不变，以及远平面的z轴（$f$）不变</p><p>$$<br>\begin{bmatrix}<br>n&amp;0&amp;0&amp;0\<br>0&amp;n&amp;0&amp;0\<br>0&amp;0&amp;A&amp;B\<br>0&amp;0&amp;1&amp;0\<br>\end{bmatrix}<br>\times<br>\begin{bmatrix}<br>x\<br>y\<br>n\<br>1\<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>nx\<br>ny\<br>n^2\<br>n\<br>\end{bmatrix}<br>$$</p><p>$$<br>\begin{bmatrix}<br>n&amp;0&amp;0&amp;0\<br>0&amp;n&amp;0&amp;0\<br>0&amp;0&amp;A&amp;B\<br>0&amp;0&amp;1&amp;0\<br>\end{bmatrix}<br>\times<br>\begin{bmatrix}<br>x\<br>y\<br>f\<br>1\<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>nx\<br>ny\<br>f^2\<br>f\<br>\end{bmatrix}<br>$$<br>$$<br>An+B&#x3D;n^2\<br>Af+B&#x3D;f^2\<br>A &#x3D; n + f\<br>B &#x3D; -nf<br>$$</p><p>由此得到了这个压缩矩阵：<br>$$<br>\begin{bmatrix}<br>n&amp;0&amp;0&amp;0\<br>0&amp;n&amp;0&amp;0\<br>0&amp;0&amp;n+f&amp;-nf\<br>0&amp;0&amp;1&amp;0\<br>\end{bmatrix}<br>$$</p><p>现在得到需要的矩阵了，它满足变换后<strong>近平面不变，远平面 $z$ 不变，且中间的 $z$ 坐标依旧保持顺序</strong>的性质，变换到 $[-1,1]^3$ 之后大概长这样：</p><p><img src="http://lxtyin.ac.cn/img/Gemo/projection.png" alt="projection"></p><p>（图源网络且魔改）</p><p>可以看到，虽然它让中间部分保持了顺序，深度测试不会出错，但是不均匀地拉伸会让三角形内部的<strong>插值</strong>有很大问题，需要进行下一节所说的透视插值矫正。</p><p>但这样的不均匀也不是没有好处：它将深度测试中我们所说的“非均匀精度分配”直接实现了！</p><blockquote><p>LearnOpenGL：</p><p>可以看到，深度值很大一部分是由很小的z值所决定的，这给了近处的物体很大的深度精度。这个（从观察者的视角）变换z值的方程是嵌入在投影矩阵中的，所以当我们想将一个顶点坐标从观察空间至裁剪空间的时候这个非线性方程就被应用了。</p></blockquote><p>再次体会到投影矩阵的强大</p><p>手动推导一下这个深度变换式子：</p><p>“压扁”后：$z_1 &#x3D; n+f-nf&#x2F;z$</p><p>标准坐标系内：$z_2&#x3D;-1+2\times (n-z_1)&#x2F;(n-f)$</p><p>如果深度值范围是0-1：$z_3 &#x3D; (z_2+1)&#x2F;2 &#x3D; (n-z_1) &#x2F; (n - f) &#x3D; \frac{(1&#x2F;z-1&#x2F;n)}{(1&#x2F;f-1&#x2F;n)}$</p><p>和LearnOpenGL上给出的式子完全一致！简洁优雅</p><h5 id="透视插值矫正"><a href="#透视插值矫正" class="headerlink" title="透视插值矫正"></a>透视插值矫正</h5><p>图不想画了，二维情况下的计算不难，推广到三维也很合理，直接给出结论：</p><p>设屏幕空间下，某点的重心坐标为 $a,b,c$，则该点的实际深度值 $w_0$<br>$$<br>\frac{1}{w_0}&#x3D;\frac{a}{w_1}+\frac{b}{w_2}+\frac{c}{w_3}<br>$$<br>插值结果（假设对 $p$ 这个属性插值）：<br>$$<br>p_0 &#x3D; w_0\times(\frac{ap_1}{w_1}+\frac{bp_2}{w_2}+\frac{cp_3}{w_3})<br>$$<br><a href="https://zhuanlan.zhihu.com/p/403259571">推导链接</a></p><p><strong>注意</strong>：这里用 $w$ 表示顶点在<strong>透视投影变换前</strong>的 $z$ 坐标，为顶点的实际深度，要和变换到标准设备坐标下之后的 $z$ 坐标作区分。</p><p>这个 $w_{123}$ 是怎么留下来的呢？还记得投影矩阵变换后的 $w$ 分量吗，它恰恰等于原先的 $z$。我们通常会在齐次除法中保留它不变（因为后面也不会用到线性变换了，留着也没关系（视口变换可以直接操作）。</p><p>最后，深度测试使用的深度值并不是 $w$（如果用 $w$ 就做不到非均匀分配精度了），而是NDC下的 $z$ 坐标。我们可以用三个顶点的 $z$ 坐标按照上述方式插值到单点的 $z$ 坐标，它早在投影时便完成了精度的分配。</p><h3 id="反走样"><a href="#反走样" class="headerlink" title="反走样"></a>反走样</h3><p>可以采用先模糊，再采样的方法。</p><p>理解走样的来源是：采样频率跟不上信号变化的速率，两个采样点之间信号可能发生了很多未被采集到的变化。</p><p>模糊操作本身是对信号做了一个均值处理，此时一个像素上包含了其附近像素的信息，故模糊后采样能非常有效地缓解锯齿。</p><p>另一个角度：模糊操作相当于一个低通滤波，除去了高频部分。而锯齿现象本质是源于对高频信号采样时的信息缺失。</p><p>从这两个角度都可以理解：为什么先采样，后模糊不行。</p><p>模糊的一种办法是对连续图像取平均得到离散结果。具体到三角形上，可以在每个像素处根据覆盖三角形的面积来改变颜色，再具体的，可以在每个像素中设多个采样点（4个，9个..），看几个在三角形内来粗略计算面积（MSAA方法）。</p><h3 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h3><ul><li><p>Flat Shading，逐三角形着色，每个三角形的法线都完全一样，适用于有锐利转折的平面。</p></li><li><p>Gouraud Shading，逐顶点着色，在顶点处计算出颜色，将颜色&#x2F;光强插值到各个片元。</p><ul><li>双线性光强插值指的也是这个</li></ul></li><li><p>Phong Shading，逐像素着色，将顶点法线插值到像素上后逐像素计算颜色。效果最平滑，也比较常用。</p><ul><li>双线性法向插值指的也是这个</li></ul></li></ul><p>顶点法向量：近似地由各个相邻面的法向量平均得出。</p><h4 id="具体插值方法"><a href="#具体插值方法" class="headerlink" title="具体插值方法"></a>具体插值方法</h4><h5 id="重心坐标"><a href="#重心坐标" class="headerlink" title="重心坐标"></a>重心坐标</h5><p>重心坐标（Barycentric Coordinates）定理：即三角形中任意一点 $X$，都可以表示成 $X&#x3D;aA+bB+cC$，其中 $ABC$ 为三个顶点的坐标向量，$abc$ 为系数且满足 $a+b+c&#x3D;1$。</p><p>一个顶点的重心坐标可以用这样的 $(a,b,c)$ 来表示，实际上，可以根据顶点对面的三角形面积占比来快速计算 $abc$（具体图去百度找一下）</p><p>重心坐标本身就代表了三个顶点在此点所占的权重，故可以轻松得到插值比例。</p><h5 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h5><p>具体思路：先插值一次得到每条线上的值，再插值得到每个位置上的值。</p><p>可以利用扫描线算法，进行增量插值。</p><h4 id="图像放大方法"><a href="#图像放大方法" class="headerlink" title="图像放大方法"></a>图像放大方法</h4><p>高分辨率对象上应用低分辨率图像时常用算法：</p><ul><li>Nearest：取最近像素</li><li>Linear：线性插值，按距离分配权重，取周边像素均值<ul><li>BiLinear：对于图像而言的双线性插值，按水平和垂直线性插值两趟</li></ul></li><li>Bicubic：双三次插值，效果更好，原理涉及信号系统（暂略）</li></ul><h4 id="图像缩小方法"><a href="#图像缩小方法" class="headerlink" title="图像缩小方法"></a>图像缩小方法</h4><p>低分辨率对象上应用高分辨率图像（渲染远处物体上常见这种情况），一个屏幕像素对应了多个纹理像素，采样时理应取均值。</p><p>但按原本的采样方式，会仅取到中心处的纹理像素，它显然无法代表这一片区域的像素值。也就是说我们需要进行区间查询操作，实际进行的是单点查询。</p><p>于是有了<strong>mipmap</strong>（多级渐远纹理），其本质是预处理的思路，有点类似线段树。</p><h4 id="Mipmap"><a href="#Mipmap" class="headerlink" title="Mipmap"></a>Mipmap</h4><p>即对于一张纹理，事先将其缩放为一半、1&#x2F;4、1&#x2F;8…（缩放时计算了区间均值），将这些缩小的纹理全都存放起来。这些全部存放的空间仅为原先的 $4&#x2F;3$ 倍。</p><p>具体渲染时，对于一个即将渲染的像素（已经知道了其uv），可根据它与相邻像素uv的差值，估算出它覆盖了多大的纹理（<code>pixel footprint</code>）。</p><p>注意这是一种粗略的近似，<strong>像素实际覆盖的纹理区域不一定是矩形</strong>，而mipmap方法根本上是对一个矩形区域求了均值，故这里并不完全准确。</p><p>假设现在这个像素需要覆盖一个宽为 $L$ （个纹理像素）的正方形，那么实际如何利用多级渐远纹理取样？</p><ul><li>Trilinear：三线性插值，计算 $D&#x3D;log_2 L$，即要在第 $D$ 层纹理上取样比较合理，$D$ 为浮点数时就，在 $\lfloor D\rfloor$ 和 $\lfloor D\rfloor +1$ 层分别进行双线性插值，然后再依据 $D$ 插值一次得到实际颜色。</li></ul><h4 id="Ray-differential"><a href="#Ray-differential" class="headerlink" title="Ray differential"></a>Ray differential</h4><p>上述计算footprint的方式只在光栅化框架中可行，在路径追踪中，我们需要追踪纹理uv对屏幕像素xy的偏导，如 $\frac{\partial u}{\partial x}$，即屏幕像素偏移1单位时，uv偏移了多少，它可以用于估计pixel footprint。</p><p>具体而言，我们可以记录当前光线对屏幕像素的偏导 $\frac{\partial \bold R}{ \partial xy}$，其中 $\bold R &#x3D; \vec O + t\vec D$，在光线传播过程中分别维护 $\frac{\partial \vec O}{\partial x}$，$\frac{\partial \vec D}{\partial x}$….等等信息。</p><p>具体更新方式可查原论文，在大多渲染器框架中此功能都已经实现。</p><h4 id="各向异性过滤"><a href="#各向异性过滤" class="headerlink" title="各向异性过滤"></a>各向异性过滤</h4><p>Mipmap只能求正方形区域的均值，故在覆盖斜着的、长的纹理时会出现overblur（过度模糊）的现象。</p><p>各向异性过滤额外预处理了一些不等比缩放的纹理（具体图百度），空间翻到了3倍，能很好地处理覆盖区域为长方形的情况，但对于斜长的情况还是会overblur。</p><p>EWA filtering是一种更复杂的方法，具体略过。</p><h3 id="纹理应用"><a href="#纹理应用" class="headerlink" title="纹理应用"></a>纹理应用</h3><h4 id="环境贴图"><a href="#环境贴图" class="headerlink" title="环境贴图"></a>环境贴图</h4><p>可以用来做天空盒、环境光等<strong>全景贴图</strong>。</p><p>一种方式是使用六个张纹理做立方体贴图，另一种方式是使用球面的展开图。</p><p>两种方式都能用三维向量来采样纹理，球面展开方式是将球面坐标作为展开图的xy坐标。</p><p>通常，将矩形贴图转换到球面坐标的环绕方式是这样的：</p><p><img src="http://lxtyin.ac.cn/img/Gemo/envmap.png" alt="1"></p><h4 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h4><p>字面意思很好理解，用纹理来直接指定每一个像素上的法线，能在平面上做到丰富的光照细节。</p><p>但直接在模型空间下指定法线，不是太好。例如当一个立方体的六个面都使用相同的纹理时，我们却不得不为它分配六张不同的法线贴图。</p><p>一个更好的坐标系是切线空间，在切线空间下表示法线，可以只关注平面，而不关心其方向。</p><h5 id="切线空间"><a href="#切线空间" class="headerlink" title="切线空间"></a>切线空间</h5><p><img src="http://lxtyin.ac.cn/img/Gemo/tangent.png" alt="1"></p><p>对于一个表面而言，法线是唯一的，而切线可能有很多种，通常会将uv展开的方向定义为切线。</p><p>具体如图所示，绿色为空间中任一个三角形，灰色部分为将这个三角形的纹理（uv）直接贴上去的样子，我们定义沿纹理 $x$ 轴方向的单位向量为切线 $T$（Tangent），同时沿纹理 $y$ 轴方向的单位向量为 $B$（bitangent），三角形的法线朝向 $+z$ 方向，这样的空间叫做切线空间。</p><p>切线 $T$ 通常作为顶点数据的一部分，会在模型中给定，如果希望自己算，也可以通过上图中三角形的另外两点的顶点坐标和uv列式计算得到。</p><p>具体式子可以来这边找到 <a href="https://learnopengl.com/Advanced-Lighting/Normal-Mapping">https://learnopengl.com/Advanced-Lighting/Normal-Mapping</a></p><p>使用切线空间来应用法线贴图的流程大概是这样的：</p><ul><li>将 Normal、Tangent 以及MVP这类的矩阵传入顶点着色器，也可以预先将法线矩阵（3x3的逆的转置的那个）计算好传入。</li><li>叉乘得到 Bitangent，将三个轴都变换到世界坐标系下（同法线变换方法），得到 TBN 矩阵</li><li>把 TBN 矩阵传入片段着色器</li><li>在片段着色器中，从 Normal map 中采样法线，然后让这个法线左乘 TBN 矩阵即可得到世界坐标系下的法线。<ul><li>TBN是一个仅有旋转的3x3矩阵，故不需要再进行法线变换。</li></ul></li></ul><p>如果在观察坐标系下计算光照，也是同理。</p><p>我们通常看到的法线贴图偏蓝色，正是因为切线空间下法线大多朝向 $+z$ 方向（0, 0, 1），仅对一部分细节有所扰动。</p><p>在多个三角面共享顶点时，我们用类似法线的处理思路：如果希望有平滑的效果，就平均一下，如果要锐利就把公共顶点拆开。</p><h5 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h5><p>normal map会导致某些角度的入射&#x2F;出射光，在宏观表面的上方，但却在normal所示的表面下方（反之一样），这种情况下进行光照计算会有歧义。</p><p>参照mitsuba中的法线贴图实现，若光源方向遇到了这种情况，直接舍弃；而若观察方向遇到这种情况，不舍弃，按照normal所示的新表面计算（可能由反射变成透射）</p><p><img src="http://lxtyin.ac.cn/img/Gemo/normal_problem.png"></p><p>这个地方究竟应该如何舍弃，目前我还没找到什么逻辑严谨的定论，暂且按照mitsuba来。</p><p>upd: 最新发现，这个特性通常在几何项中被处理（包括mitsuba中），也即两个方向都会产生这样的遮挡。</p><h4 id="凹凸贴图"><a href="#凹凸贴图" class="headerlink" title="凹凸贴图"></a>凹凸贴图</h4><p>更直观的做法：不是直接指定每个像素的法线，而是指定每个像素的高度偏移，然后自行计算法线。</p><p>计算法线同样在切线空间下进行，假设原法线朝向 $(0, 0, 1)$，可以在凹凸贴图上做个差分来计算新法线。<br>$$<br>dp&#x2F;du&#x3D;c_1\times (h(u+1)-h(u))\<br>dp&#x2F;dv &#x3D; c_2\times (h(v+1)-h(v))\<br>n&#x3D;(-dp&#x2F;du,-dp&#x2F;dv,1)<br>$$</p><h4 id="阴影贴图"><a href="#阴影贴图" class="headerlink" title="阴影贴图"></a>阴影贴图</h4><p>实现阴影的经典办法，但是有非常多弊端。</p><p>思路：首先在光源位置观察场景，走一遍光栅化流程（但不着色），渲染出一张阴影贴图，每个像素上记录深度。</p><p>然后再正常渲染场景，对于每个片段，我们再将这个片段变换到光源的观察坐标系下，做一次投影，找出这个片段在阴影贴图上对应的位置。然后对比深度值，以判断这个像素是否能被光源看到。</p><p>上述是最简单的阴影贴图逻辑，它只能处理平行光，只考虑了单光源，只能产生硬阴影，且依赖阴影贴图的分别率，容易产生锯齿。</p><h5 id="多光源"><a href="#多光源" class="headerlink" title="多光源"></a>多光源</h5><p>本身我们在着色时，多光源就是分别着色后叠加的。因此阴影只对每个光源分开考虑就好。</p><h5 id="软阴影"><a href="#软阴影" class="headerlink" title="软阴影"></a>软阴影</h5><p>麻烦 跳过</p><h3 id="HDR与色调映射"><a href="#HDR与色调映射" class="headerlink" title="HDR与色调映射"></a>HDR与色调映射</h3><p>HDR <code>High Dynamic Range</code> 高动态范围，指使用不限制的范围（超过 $[0,1.0]$）来表达场景亮度，在需要显示时（显示器只能显示 $[0,1.0]$ 之间的亮度）再转换到低动态范围 <code>LDR</code>。转换的方式叫色调映射（Tonemapping），一般不是简单的线性转换，而是通过特殊手段尽可能保留场景细节。</p><h5 id="Reinhard色调映射"><a href="#Reinhard色调映射" class="headerlink" title="Reinhard色调映射"></a>Reinhard色调映射</h5><p>$f(x) &#x3D; \frac{1}{x+1}$</p><p>简单好用，偏向亮色</p><h3 id="Gamma矫正"><a href="#Gamma矫正" class="headerlink" title="Gamma矫正"></a>Gamma矫正</h3><p><strong>物理亮度</strong>是正比于能量（光子数量）的，人眼看到的<strong>感知亮度</strong>实际为 $物理亮度^{1&#x2F;gamma}$</p><p>如果我们不进行任何处理，图片直接按物理亮度存储，显示器按物理亮度发射光线，我们人眼看到的颜色也是对的（和拍摄时的颜色相同）；但这样，图片的存储密度<strong>对于物理亮度而言是均匀的，但对于感知亮度就不均匀了</strong>。</p><p>对于人眼而言，信息利用率没有做到最好，直观的感受就是，调颜色会发现颜色的变化不均匀。</p><p>因此，现在绝大多数电脑图片都存储在sRGB空间下，也即按感知亮度存储。</p><p><img src="https://pic1.zhimg.com/80/v2-0d2434c806b4a76436db481f822e9d28_1440w.webp"></p><p>对于大多数使用者，不需要关注到gamma矫正的存在，因为他们始终在感知亮度空间下工作。而我们在进行光照运算时，必须转换到物理空间下进行。</p><p>通常说的线性工作流，指的就是在物理空间下进行计算，<strong>线性空间通常指物理亮度空间</strong>。</p><p>常用到的一些知识：</p><ul><li>大多数图片（ <code>jpg, png</code> 等）都存储在sRGB空间，线性工作流中应将他们变换到物理空间进行运算；<code>exr</code> 文件存储在物理空间，不需要转换。</li><li>在线性空间下计算的渲染结果若要保存为 <code>jpg, png</code> 等，应将输出颜色变换到感知空间。我们只需负责按sRGB格式保存正确的图像，显示器会自动完成sRGB的显示工作（变换到物理空间去决定发射多少光子）。</li><li>美术工具通常都是工作在sRGB上的，各种调色板调的通常都是sRGB。专业的显示器和软件（tev等）一定会考虑到线性空间和sRGB的不同，进行显示、格式转换时都会进行Gamma处理。</li><li><code>OpenCV</code> 在读取图像时并不会进行处理，很多CV工作都是在LDR、感知空间下计算Loss的，这也合理，这样计算的Loss更符合人眼感受。需要注意的是如果我们要使用别人预训练的网络，最好也先将HDR值<strong>截断</strong>，再将图像转换为sRGB输入。<ul><li>这里我们说到截断。事实上在科研中Tone mapping大多数时候是不用的，它更多是一个游戏或者显示器中的功能，用于提升画面细节。我们也不希望读取图像时还要进行反向Tone mapping。</li><li>最近发现做CVCG科研的人好像都认为Gamma矫正也是一种Tone mapping，这个在CG的线性工作流中就是必须的了。</li></ul></li></ul><h3 id="Sobol序列"><a href="#Sobol序列" class="headerlink" title="Sobol序列"></a>Sobol序列</h3><p>Sobol序列是一种低差异序列，支持生成大量的 $n$ 维点集。我们用 $x_{i,j}$ 表示第 $i$ 个样本的第 $j$ 维。 </p><p>其每一个维度 $j$ 需要一个二进制生成矩阵 $C_j$（有了生成矩阵后，Sobol可以通过index $i$ 计算出第 $i$ 个数，计算过程很多地方都有，此处不赘述）</p><p>为了方便，通常会使用32x32或64x64的生成矩阵，这样可以将一行&#x2F;列视为一个二进制表示，用一个整数存储。因此生成矩阵通常显示为一串整数。以32x32的生成矩阵为例，它可以支持 $2^{32}$ 个样本。当然，这并不是Sobol的理论上限，理论上只要我们愿意去实现更高维的生成矩阵，它支持的样本数量是无限的。</p><p><a href="https://web.maths.unsw.edu.au/~fkuo/sobol/">Sobol官网</a> 给出了一些文件，这里重点讲一下这个文件的用法：</p><div class="code-wrapper"><pre><code class="hljs tap">d       s       a       m_i     2      <span class="hljs-number"> 1 </span>     <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 1 </span>3      <span class="hljs-number"> 2 </span>     <span class="hljs-number"> 1 </span>     <span class="hljs-number"> 1 </span>3 4      <span class="hljs-number"> 3 </span>     <span class="hljs-number"> 1 </span>     <span class="hljs-number"> 1 </span>3<span class="hljs-number"> 1 </span>5      <span class="hljs-number"> 3 </span>     <span class="hljs-number"> 2 </span>     <span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>6      <span class="hljs-number"> 4 </span>     <span class="hljs-number"> 1 </span>     <span class="hljs-number"> 1 </span>1<span class="hljs-number"> 3 </span>3 7      <span class="hljs-number"> 4 </span>     <span class="hljs-number"> 4 </span>     <span class="hljs-number"> 1 </span>3<span class="hljs-number"> 5 </span>13 ....21201  <span class="hljs-number"> 18 </span>    <span class="hljs-number"> 131059 </span><span class="hljs-number"> 1 </span>1<span class="hljs-number"> 7 </span>11<span class="hljs-number"> 15 </span>7<span class="hljs-number"> 37 </span>239<span class="hljs-number"> 337 </span>245<span class="hljs-number"> 1557 </span>3681<span class="hljs-number"> 7357 </span>9639<span class="hljs-number"> 27367 </span>26869<span class="hljs-number"> 114603 </span>86317</code></pre></div><p>这里的 $d$ 指维度，可以看到这个文件支持生成最高21201维的点集，每行描述了一个维度的生成矩阵。但并没有直接给出，而是只给出了矩阵的前 $s$ 个数，后续需要我们根据公式自己推出来（具体就不细谈了，可以直接套官网的代码）。</p><p>最后再说一下Sobol在渲染中的应用。</p><p>例如，一次路径追踪中，要产生8个随机数，那么我们会使用一个8维样本来表达这<strong>一整个随机过程</strong>，而非使用8个一维样本。</p><h3 id="光场"><a href="#光场" class="headerlink" title="光场"></a>光场</h3><p><code>Plenoptic Function</code>（全光函数）：$P(\theta, \phi, \lambda,t,x,y,z)$，指任一个位置，任一时刻向任一方向看到的某波长的光强。一个抽象概念，可以描述整个世界。</p><p><code>Light Field</code>（光场）：全光函数的一个子集，对于一个物体，考虑其包围盒，光场表达从任一位置，向任一方向发出的光（4D，位置和方向都可以用球面坐标表示）</p><p>nerf即使用神经网络来拟合这样一个光场（辐射场），来实现重建。</p><h3 id="球面谐波函数"><a href="#球面谐波函数" class="headerlink" title="球面谐波函数"></a>球面谐波函数</h3><p>基函数：使用一组函数 $b_i(x)$，他们的线性组合可以近似任一其他函数：$f(x)\approx \sum_i^n A_ib_i(x)$</p><p>我倾向于将基函数理解成“无限维度的向量”，即每个 $x$ 都是一个维度。</p><p>类似于基向量，因为维度是无限的，故希望不是近似而是完全匹配任一函数的话，需要无限个基函数：$f(x)&#x3D;\sum_i^{\infty} A_ib_i(x)$</p><p>函数的乘积积分(Product integral) 类似于向量点乘，故基函数的正交性类似于：$\int f(x)g(x)d_x&#x3D;0$ 对其中任两个基函数都成立。</p><p>回到球面谐波函数上来，它是一组定义在球面上的基函数 $r&#x3D;b_i(\theta, \phi)$，它是正交的。</p><p><img src="http://lxtyin.ac.cn/img/Gemo/spherical_harmonics.png"></p><p>如图所示，球谐函数可以使用若干阶，越高阶频率越高，越能表现函数细节，通常使用前3阶即可比较好的近似。</p><p>近似 $f(w)$ 时，对于每个基函数前的系数，可以这样计算：$c_i&#x3D;\int_\Omega f(w)b_i(w)d_w$</p><p>这称为“投影”，从上述基向量的角度来看非常显然。</p><p><strong>应用</strong></p><p>取低阶的SH可以拟合一个球面光照（如环境光），类似一种低通filter</p><p>对于漫反射材质，其反射的主要是低频光照信息，仅需使用3阶SH拟合环境光，就能取得极其近似的效果。</p><h3 id="球面高斯函数"><a href="#球面高斯函数" class="headerlink" title="球面高斯函数"></a>球面高斯函数</h3><p>定义：<br>$$<br>G(\vec n,\vec v, a, \lambda)&#x3D;ae^{\lambda(\vec n \cdot \vec v - 1)}<br>$$<br>高斯分布，即正态分布，距离轴线越远函数值越小。球面高斯函数（SG）将这种分布迁移到了三维球面上，用以表示一个波瓣。以 $\vec  n$ 定义波瓣的中心方向，$\lambda$ 系数定义波瓣的”胖瘦“，$a$ 对波瓣进行整体缩放。这些从上式中不难看出。</p><p>SG的特点：</p><ul><li>它的积分是封闭形式的</li><li>两个SG的乘积仍然是SG，因此两个SG的点积也是封闭形式</li><li>…</li></ul><p>我们也可以定义一组SG基函数，通过调整他们的参数和系数来混合成新的球面函数。但SG有两个问题：它是各项同性的，且随意的一组SGs很难正交。</p><p>一组SH基函数能够快速拟合一个任意函数（求出系数组），利用的是对正交基的“投影”。SGs没了正交性，这个过程的复杂度将不可接受。故SGs基函数的数量不能很多。</p><p><strong>ASG</strong></p><p><a href="https://dl.acm.org/doi/10.1145/2508363.2508386">Xu 2009</a></p><p>各向异性的SG，定义为：<br>$$<br>G(\vec v,[\vec x, \vec y, \vec z], [\lambda, u], c)&#x3D;c\cdot max(v\cdot z, 0) \cdot e^{-\lambda(v\cdot x)-u(v\cdot y)}<br>$$<br>定义也比较直观，波峰在 $\vec v&#x3D;\vec z$ 处，其中 $\vec x,\vec y, \vec z$ 是一个三维空间下的正交基。</p><p>原SGs也可以拼出各向异性的球面函数，但需要非常多的SG，而使用ASGs则可以使用一组数量较少的基函数。</p><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p><code>Spectral Power Distributions (SPD)</code>：各个波长上分布的光强，多个光叠加时，SPD也可以叠加（线性性质）。</p><p>同色异谱：不同分布的光谱，人看起来可能是一样的（三种视锥细胞各自感应的结果）</p><h3 id="Irradiance-map"><a href="#Irradiance-map" class="headerlink" title="Irradiance map"></a>Irradiance map</h3><p>可以认为：环境贴图、面积光的数值单位都是irradiance，因为其描述的是一个微面发出的总的辐射（无方向性），取任意方向就是radiance</p><p>但irradiance map说的irradiance并不是这个，它通常用来做间接光预积分。</p><p>由于漫反射部分BRDF通常与wo无关（Lambertain项），可以从积分中分离，那么剩下的部分仅与法线n有关。预积分出对于每个法线n而言的irradiance，存在一张贴图里，就是常说的irradiance map。</p><h3 id="烘焙"><a href="#烘焙" class="headerlink" title="烘焙"></a>烘焙</h3><p>烘焙操作，通常就是在贴图上保存irradiance信息。</p><p>烘焙需要先进行一波展UV，得到UV2，这个UV2它保证不重复，而原来的UV就不一定了。</p><p>烘焙，逐物体操作，每个mesh丢入管线，顶点着色器输出的裁剪坐标直接为UV2，而计算仍然在世界空间下进行，方便地得到纹理空间的烘焙结果。</p><h3 id="画饼"><a href="#画饼" class="headerlink" title="画饼"></a>画饼</h3><p>视差贴图（法线贴图进阶）</p><p>B样条曲线</p><p>微分方程、RungeKutta方法</p><p>Spatial hash?</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数的本质</title>
    <link href="/2023/09/20/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <url>/2023/09/20/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<p>学习自 <a href="https://www.bilibili.com/video/BV1ys411472E?p=7&spm_id_from=pageDriver&vd_source=f3bceb9b12c557f0a9cdb5ac0d26fee6">3b1b 线性代数的本质</a></p><h5 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h5><p>可看做点，这里统一竖着写（列向量）。</p><h5 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h5><p>对空间中的每个点作变换后，轴保持平行等距，原点不变。</p><h5 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h5><p>表达一种一种线性变换，这里我们统一将向量竖着写，向量左乘一个矩阵即应用一个变换。</p><p>矩阵中一列的意义是：一个基向量变换后的新位置，因为是线性变换，我们只需要指定变换后的基向量，写入矩阵即可构建一个这样的变换矩阵。</p><p>对空间中一点变换时，可以直接将基向量代换掉，即可计算向量变换后的位置。</p><h5 id="非方阵"><a href="#非方阵" class="headerlink" title="非方阵"></a>非方阵</h5><p>非方阵同样代表着线性变换，但它还涉及维数的改变。</p><p>非方阵中的列同样代表着变换后的新基向量位置，但这些新的基向量可能少维或者多维。</p><p>回忆矩阵乘法中，$n\times m$ 的矩阵只能和 $m$ 维的向量相乘，它将 $m$ 维向量的每个基代换为一个新的 $n$ 维向量（系数不变），这样得到的新向量便从 $m$ 维变到了 $n$ 维。</p><p>$n\times m$ 的矩阵将 $m$ 维标准基向量变换为了 $m$ 个 $n$ 维向量，这 $m$ 个 $n$ 维向量也许会平行或重合，变换后空间的实际维度（矩阵的秩）等于这 $m$ 个向量的极大线性无关组中向量的个数。</p><h5 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h5><p>等于相应矩阵对应的变换下，<strong>空间内任意物体缩放的比例。</strong>若行列式为负，则空间发生翻转，行列式为0，则变换将压缩至少一个维度。</p><p>我们已经知道，将矩阵看做线性变换后，其每一列都可以看做一个基向量变换后的位置。故矩阵对应行列式的值，即该矩阵各列向量拼出来的空间大小(二维的平行四边形面积，三维的平行六面体体积等）。</p><h5 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h5><p>按此矩阵变换后，空间的维度，不降维的变换矩阵（必须是方阵）满秩。</p><h5 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h5><p>显然，只有不降维（满秩）的变换才可逆。</p><h5 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h5><p>线性方程组可以看做对一个由未知量组成的向量 $x$，施加以变换矩阵 $A$ 后得到一个已知向量 $y$，即 $Ax&#x3D;y$。如果这个矩阵可逆，则可以反推出所有未知量，否则要么无解（变换降维了，$y$ 在变化后的维度之外），要么有无穷多解（$y$ 恰好在变换后的维度之内）。</p><h5 id="列空间"><a href="#列空间" class="headerlink" title="列空间"></a>列空间</h5><p>即变换后的空间，叫列空间即矩阵每一列（变换后每个基）的张成空间。<strong>秩精确定义为列空间的维数</strong>。$y$ 在列空间内，方程才有解。</p><h5 id="零空间"><a href="#零空间" class="headerlink" title="零空间"></a>零空间</h5><p>使 $Ax&#x3D;0$ 成立的 $x$ 的集合，即变换后会变为零向量的向量集，对于满秩矩阵，零空间中只有零向量。</p><h5 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h5><p>点积在数值上等于两个向量对应位相乘之和，几何上等于一个向量投影到另一个向量上之后模相乘。</p><p>这两者可以得以联系，是因为可以将点积的两个向量，一个看做向量 $[a,b]^T$，另一个转置后看做线性变换 $[x, y]$。这个显然这是一个将二维降至一维的线性变换，它的含义恰恰就是将向量投影到一维空间。</p><p>更进一步，我们会发现<strong>每一种二维到一维的线性变换都与一个某个向量一一对应</strong>（转置即可）。应用此变换等价于与该向量点乘。</p><h5 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h5><p>通常在三维空间下讨论叉积，我们都知道的是：两个向量叉积得到一个与它们都垂直的向量，模长等于两向量张成的平行四边形面积，方向取决于右手定则，叉积公式即将 $i,j,k$ 与两向量放入一个行列式。</p><p>叉积的几何意义很明朗，但问题在于为什么计算会和行列式相关。</p><p>考虑三个向量 $u,v,m$，把它们放入一个三阶行列式，结果显然为张成的平行六面体体积。</p><p>如果我们固定其中两个，任选第三个，这就相当于是一个变换函数，输入向量 $[x,y,z]^T$，得到一个标量输出：<br>$$<br>f\begin{pmatrix}<br>x\<br>y\<br>z\<br>\end{pmatrix}&#x3D;<br>\begin{vmatrix}<br>x,v_1,m_1\<br>y,v_2,m_2\<br>z,v_3,m_3<br>\end{vmatrix}<br>$$<br>可以证明，这同样是一个三维到一维的<strong>线性变换</strong>。既然是线性变换，可以表示为矩阵 $P\times [x,y,z]^T$，其中 $P$ 为1x3的降维变换矩阵。</p><p>根据点积中提到的对偶性，这个变换等价于 $P^T\cdot [x,y,z]^T$</p><p>什么样的 $P^T$ 点乘任意一个向量，都能得到它与 $v,m$ 组成的平行六面体体积？</p><p>画图，根据点积的投影计算方式，容易发现，$P^T$ 模长为 $v,m$ 平行四边形面积，方向与它们都垂直，正是我们需要叉积结果。</p><p>那么要计算这个 $P^T$，可以用一点运算小技巧，取 $(x,y,z)$ 为单位向量，并且把它们的方向 $(i,j,k)$ 写出来，就能化标量为矢量了。<br>$$<br>P^T\cdot [i,j,k]^T&#x3D;<br>\begin{vmatrix}<br>i,v_1,m_1\<br>j,v_2,m_2\<br>k,v_3,m_3<br>\end{vmatrix}<br>$$</p><h5 id="基变换"><a href="#基变换" class="headerlink" title="基变换"></a>基变换</h5><p>基变换的逻辑容易理解，但方向很容易搞反，关键在于弄清<strong>向量的实际位置</strong>是否改变。</p><p>如：坐标系 $A$ 的基向量为 $[0,1],[1,0]$，坐标系 $B$ 的基向量为 $b1,b2$，根据之前的知识，我们可以将其看做变换矩阵 $[b1,b2]$，让向量乘上这个矩阵，即进行等同于 $B$ 的变换，向量的实际位置无疑改变了，变换后相对于 $B$ 的位移，即变换前相对于 $A$ 的位移。这个矩阵可以进行局部坐标-全局坐标的转换。</p><p>其他情况下，我们知道了向量在 $A$ 坐标系下的表示，希望知道这个向量在 $B$ 下的表示如何（而非变换向量本身），其实就是上述过程的逆，让向量乘上 上述矩阵逆矩阵即可</p><h5 id="相似矩阵"><a href="#相似矩阵" class="headerlink" title="相似矩阵"></a>相似矩阵</h5><p>相似矩阵实际上表达的是相同的变换，只不过在不同的坐标系下表示。</p><p>理解相似矩阵实际上对空间的变换是一样的，我们就能轻易得出：</p><ul><li>相似矩阵具有相同的秩和行列式</li><li>相似矩阵具有相同的特征值，特征向量其实也是同样的向量，只不过在不同的坐标系下表示。</li></ul><h5 id="特征值-x2F-特征向量"><a href="#特征值-x2F-特征向量" class="headerlink" title="特征值&#x2F;特征向量"></a>特征值&#x2F;特征向量</h5><p>按某矩阵进行变换后，会发现有些向量只是缩放，并没有离开原来的直线</p><p>这些向量便是矩阵的特征向量，其缩放比例即为对应的特征值。</p><h5 id="相似对角化（特征分解）"><a href="#相似对角化（特征分解）" class="headerlink" title="相似对角化（特征分解）"></a>相似对角化（特征分解）</h5><p>指矩阵 $A$ 能够相似与一个对角矩阵 $B$，在求幂时有意义：$A^m &#x3D; PB^mP^{-1}$，转化为对角矩阵的求幂。</p><p>矩阵可相似对角化的充要条件是，矩阵有 $n$ 个线性无关的特征向量。</p><p>我们知道相似矩阵实际上表达的是相同的变换，那么如果直接把 <strong>$A$ 的特征向量构成的基作为新坐标系</strong>的话——</p><p>相似矩阵的特征向量一定都在坐标轴上！也就是说相似矩阵一定是对角矩阵了。</p><h5 id="二次型"><a href="#二次型" class="headerlink" title="二次型"></a>二次型</h5><p>一个每项均为二次项的多元多项式（称为二次型）可以写为 $f(x_1,x_2..x_n)&#x3D;x^TAx$，对于原式中的项 $kx_ix_j$，有 $A_{i,j} &#x3D; A_{j,i} &#x3D; \frac{k}{2}$​（对角线除外），也即 $A$ 是二次型唯一对应的实对称矩阵。</p><p>由于实对称矩阵的特征向量彼此正交，$A$ 一定可相似对角化，那么<br>$$<br>x^TAx &amp;&#x3D;&amp; x^TQBQ^{-1}x\<br>      &amp;&#x3D;&amp; x^TQBQ^Tx \<br>      &amp;&#x3D;&amp; (Q^Tx)^TB(Q^Tx)<br>$$<br>其中 $Q$ 是 $A$ 的特征基，为正交矩阵，$B$ 为对角矩阵</p><p>也就是可以利用 $y &#x3D; Q^Tx$ 这个变化，将其变成一个标准型（只含有平方项的二次型）。</p><p>几何意义上：以三维空间为例，若 $A$ 是一个对角矩阵，则这个标准型可写作 $d_1x^2+d_2y^2+d_3z^3 &#x3D; 1$，它可以轻松地定义三维空间中的一个圆锥曲面；同样的，二次型也可以定义曲面，是相应标准型施加了变换 $Q^{-1}$ 的效果。</p><p>当标准型的所有系数均大于0时，这是一个椭圆；当有系数小于0时，这是一个双曲面或者别的什么奇特曲面；正交变换 $Q$ 不会改变他们的形状，<strong>描述椭圆的二次型对应的实对称矩阵A称为正定矩阵。</strong></p><p>正定矩阵的定义通常是：对于任意非零向量 $x$，有 $x^TAx &gt;0$。正定矩阵的特征值都大于0</p><p>一个正定矩阵判定的充分条件是：每一行（或列）的对角元素都大于这一行（或列）的其他元素之和（对角占优）。</p><h5 id="Cholesky-factorization"><a href="#Cholesky-factorization" class="headerlink" title="Cholesky-factorization"></a>Cholesky-factorization</h5><p>正定矩阵必然可以分解为 $A &#x3D; LL^T$，$L$ 是一个下三角矩阵，对角线上元素均大于0。</p><p>不难发现 $A_{uv} &#x3D; \sum_{k&#x3D;1}^{n} L_{uk}L_{vk}$</p><p>我们可以从左到右、从上到下地计算 $L$<br>$$<br>L_{vv}^2 &#x3D;A_{vv} - \sum_{k&#x3D;1}^{v-1} L_{vk} \<br>L_{vv}L_{uv} &#x3D; A_{vv} - \sum_{k&#x3D;1}^{v-1} L_{uk} L_{vk},(u\ge v)<br>$$</p><h5 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h5><p>特征值和特征向量是方阵的概念，非方阵则可以求出奇异值。</p><p>有非方阵 $A(m\times n)$，它可以分解为 $A &#x3D; U\sum V^T$</p><p><img src="http://lxtyin.ac.cn/img/math/svd.png"></p><p>$A^TA$ 是一个 $n\times n$ 的对称矩阵，它可以特征分解，得到的特征向量张成的基为 $V$；同理 $AA^T$ 为 $m\times m$ 的对称矩阵，特征向量张成为 $U$。$U,V$ 都为正交矩阵</p><p>$\sum$ 中主对角线元素为奇异值，其他都为0</p><p>类似特征分解，可以将 $A$ 看做旋转 - 按轴缩放 - 旋转的一个变化，区别在于这里的缩放可能改变维度。奇异值的意义类似特征值，是特定轴上的缩放比例。</p><p>用特征向量张成为正交矩阵时，可以控制顺序，使得特征值（奇异值）有序。实际应用中，排序后往往前面少数几个奇异值就占据了99%以上的比例，那么我们可以仅取前 $k$ 个奇异值（以及相应部分左右矩阵，具体见下图）来近似原矩阵 $A$，实现压缩。</p><p><img src="http://lxtyin.ac.cn/img/math/svd2.png"></p><h5 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h5><p>这个东西在很多地方都有应用，因此也在这里提及</p><p>协方差表达了两个随机变量的线性相关性，$cov(x,y)&#x3D;E((x-\overline x)(y-\overline y))$</p><p>协方差可以为正或者负，两变量线性不相关时，协方差为0（注意不相关不等于独立，它们还可以有非线性的相关性）</p><p>协方差矩阵，即对于 $m$ 个随机变量 $x_1,..x_m$，$C_{i,j} &#x3D; cov(x_i, x_j)$，包含了所有随机变量的两两协方差，显然，协方差矩阵是一个实对称矩阵，它的特征向量彼此正交。</p><p>我们令 $A &#x3D; X - \overline X$，于是 $C &#x3D; \frac{1}{m} A^TA$。有以下推导：<br>$$<br>A^TAx &#x3D; \lambda x \<br>(Ax)^T(Ax) &#x3D; \lambda x^Tx &#x3D; \lambda<br>$$<br>$Ax$ 实际上是所有点与 $x$ 作点乘，$(Ax)^T(Ax)$ 表示所有点在 $x$ 方向的投影的平方和，而它恰好就是特征向量。</p><p>结论是：协方差矩阵的最大特征值对应的特征向量即为点集分布方差最大的方向（点云朝向）；最小的方向即为法向。</p><h5 id="Jacobin矩阵"><a href="#Jacobin矩阵" class="headerlink" title="Jacobin矩阵"></a>Jacobin矩阵</h5><p>Jacobin矩阵是偏导数的矩阵，考虑一个 $n$ 元输入（$\bold x &#x3D; x_1,…x_n$），$m$ 元输出（$\bold y &#x3D; y_1,…y_m$）的函数，Jacobin矩阵包含了其中两两变量之间的偏导。</p><p>函数 $f(\bold x) \rarr \bold y$，则 Jacobin 矩阵 $J_{i,j} &#x3D; \frac{\part y_j}{\part x_i}$，有 $\bold y &#x3D; J \bold x$</p><p>它是两个参数空间的变换矩阵，相应的，$J$ 的行列式即为这一变化对应的<strong>参数空间缩放</strong>的比例。</p><p>因此，在各种积分问题中，如果涉及了积分域的变换，一定要乘上对应的雅可比行列式，以确保积分正确。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数理基础</tag>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Volume rendering</title>
    <link href="/2023/09/20/Volume%20Rendering/"/>
    <url>/2023/09/20/Volume%20Rendering/</url>
    
    <content type="html"><![CDATA[<p>Volume Rendering考虑参与介质（如雾、烟等）中的光线传播情况。</p><h4 id="辐射传输方程"><a href="#辐射传输方程" class="headerlink" title="辐射传输方程"></a>辐射传输方程</h4><p>Radiative Transfer Equation, RTE</p><p>考虑光线穿过参与介质中 $p$ 点时，radiance的变化量：</p><p>大致形式：<br>$$<br>L_o - L_i &#x3D; -\sigma_t \cdot L_i + L_e + \sigma_s\int_{S^2}f_pL_jdw_j<br>$$<br>其中：</p><p>$\sigma_a$ 为吸收系数，表示光线被介质吸收的比例。</p><p>$\sigma_s$ 为散射系数，表示光线被散射到其他方向的比例。</p><p>$ \sigma_t &#x3D; \sigma_a + \sigma_s$，即光线撞击到粒子的比例。</p><p>$f_p$ 为Phase function，$f_p(w_i \rightarrow w_o)$ 表示 $w_i$ 入射的光<strong>发生散射后</strong>，散射到 $w$ 方向的比例。注意，$f_p$ 仅衡量散射性质，而入射光并不都发生散射。因此，$L_o \leftarrow \sigma_t f_pL_i$。事实上，$f_p$ 也需要带上 $\sigma_t$ 才可逆。</p><p>$L_e$ 为介质的自发光。</p><p>通常在推导时会用到反照率 <code>albedo</code>，它等于 $\frac{\sigma_s}{\sigma_t}$</p><p>大部分情况下我们都考虑均匀介质，不均匀介质则还需在各个函数中加入参数 $p$</p><h4 id="Volume-Rendering"><a href="#Volume-Rendering" class="headerlink" title="Volume Rendering"></a>Volume Rendering</h4><p>对RTE的具体估计，使用蒙特卡洛方法。</p><p>考虑最简单的均匀各向同性介质情况，$\sigma_t $ 是一个常数</p><p>经过 $d_x$，能量损耗为：<br>$$<br>dL &#x3D; L_i(-\sigma_td_x)<br>$$<br>求解这个微分方程，我们抄来结果：<br>$$<br>L &#x3D; e^{-\sigma_tx}<br>$$<br>这是经过 $x$ 距离后的光线余量（不限制距离）。</p><p>可以用这个式子作为<strong>光线传播到 $x$ 还未被吸收或折射的概率</strong>，当然要将概率归一化到1：<br>$$<br>pdf(x) &#x3D; \frac{e^{-\sigma_tx}}{\sigma_t} \<br>\int_0^{\infty} pdf(x)d_x &#x3D; 1<br>$$<br>重要性采样，推得<br>$$<br>CDF^{-1}(x) &#x3D; \frac{ln(1-y)}{-\sigma_t}<br>$$<br>$y$ 替换成0-1之间的随机数，即可完成抽样。</p><p>若发生散射，则再对phase function作重要性采样决定散射方向。</p><p>这是在体积介质中做蒙特卡洛路径追踪的基本原理，可以扩展到各项异性、不均匀介质中。</p><h4 id="Phase-function"><a href="#Phase-function" class="headerlink" title="Phase function"></a>Phase function</h4><p>重复一下，Phase function $f_p(w_i\rightarrow w_o)$ 定义为<strong>散射到 $w_o$ 的能量与所有散射能量</strong>的比值，它是归一化的。<br>$$<br>\int_{S^2} f_p(w_i\rightarrow w_o) dw_i &#x3D; 1<br>$$</p><p>另外，<strong>散射到 $w_o$ 的能量与所有入射能量</strong>的比值定义为 $f_a(w_i\leftrightarrow w_o)$，它不是归一化的，但具有可逆性。<br>$$<br>f_a(w_i\leftrightarrow w_o) &#x3D; f_p(w_i\rightarrow w_o) \cdot \sigma_s(w_i)<br>$$<br>在均匀的各项同性介质中，$f_p$ 与位置和方向无关，只与 $w_i,w_o$ 之间的夹角有关，可以视为一维函数 $f_p(\theta)$，更简单地，相函数也是各项同性的情况：$f_p(\theta) &#x3D;  \frac{1}{4\pi}$</p><h4 id="Microflake-model"><a href="#Microflake-model" class="headerlink" title="Microflake model"></a>Microflake model</h4><p>这是一种各项异性的体积模型，将参与介质看做由无数微小的，随机朝向的薄片组成，类似微表面模型，使用 $D(m)$ 表示朝向 $m$ 的微薄片分布。</p><p>我们可以具体将 $D(m)$ 定义为<strong>朝向 $m$ 的微薄片面积与宏截面的比例</strong>，这种定义与微表面类似，但它不是归一化的（和微表面不同，薄片间存在间隙），不能直接用作pdf。</p><p>注意，一个微薄片可以有很多个方向的法线，取决于具体的形状。</p><p>单个微薄片在 $w_i$ 方向的投影面积定义为<br>$$<br>\sigma(w_i) &#x3D; \int_{S^2} D(m) &lt;w_i\cdot m&gt; d_m<br>$$<br>这里的 $\sigma$ 没有下标，为单个薄片的投影面积，和前文中表示光线比例的 $\sigma_t$ 等区分（许多经典文献中的符号都是这样，因此尽管容易混淆还是不作更改。）</p><p>归一化到投影面上：<br>$$<br>D_{w_i}(m) &#x3D; \frac{D(m)&lt;w_i\cdot m&gt;}{\sigma(w_i)} \<br>\int_{S^2} D_{wi}(m)dm &#x3D; 1<br>$$<br>这里的 $D_{w_i}(m)$ 被称为Visible normal。</p><p>广义上，微薄片不一定要是镜面，它可以有一个小的BRDF，我们定义micro-phase function：$p(m,w_i\rightarrow w_o)$，指特定方向微薄片的phase function，那么有：<br>$$<br>f_p(w_i\rightarrow w_o) &#x3D; \int_{S^2} p(m,w_i\rightarrow w_o) \cdot D_{w_i}(m)d_m<br>$$<br>如果认为所有微薄片都是镜面，推导Specular phase function：</p><p>仅当 $h&#x3D;m$ 时有：<br>$$<br>p(m,w_i\rightarrow w_o) &#x3D; \frac{1}{4|w_i\cdot w_h|}<br>$$<br>代入得到：<br>$$<br>f^{spec}_p(w_i\rightarrow w_o) &#x3D; \frac{D(h)}{4\sigma(w_i)}<br>$$</p><p>另外，$w_i$ 方向的光线撞击到粒子的比例有：<br>$$<br>\sigma_t(w_i) &#x3D; \rho \sigma(w_i)<br>$$</p><h4 id="SpongeCake"><a href="#SpongeCake" class="headerlink" title="SpongeCake"></a>SpongeCake</h4><p>SpongeCake其实是表面材质，但他是基于Volume推导得到的。</p><p>使用Microflake模型表达Volume，简化地认为所有flake都是镜面，不考虑吸收和漫反射，可以直接使用上述 $f_p&#x3D;f_p^{spec}$ 的形式</p><p>上面提到过，定义为<strong>散射光与入射光比值</strong>的phase function具有可逆性，我们再额外考虑菲涅尔效应，得：<br>$$<br>f_a(w_i\rightarrow w_o) &#x3D; f_p(w_i\rightarrow w_o)F(h) \sigma_t(w_i) &#x3D; \frac{D(h)F(h)\sigma_t(w_i)}{4\sigma(w_i)}<br>$$<br>由于 $\sigma_t(w_i) &#x3D; \rho\sigma(w_i)$<br>$$<br>f_a(w_i \rightarrow w_o) &#x3D; \frac{\rho D(h)F(h)}{4}<br>$$</p><blockquote><p>注意：菲涅尔项的含义是：反射光的比例，另一部分是折射（被吸收）了，而不是穿过去了！</p><p>SpongeCake是一个表面模型，下文要考虑的Transmission也只是穿过这个表面的光线，而不是被折射的光线。故可以发现下面用的还是 F(h) 而非1 - F(h)</p></blockquote><p><img src="http://lxtyin.ac.cn/img/Gemo/spongcake1.png"></p><p>考虑整个部分的贡献，可以写出下面的积分式：<br>$$<br>f_r(w_i \rightarrow w_o) &#x3D; \int_o^T \frac{f_a(w_i \rightarrow w_o)}{cos(w_i)cos(w_o)} \cdot att(w_i,t)\cdot  att(w_o,t) \cdot d_t \<br>att(w,t) &#x3D; exp<br>\left(<br>-\frac{t}{cos(w)} \sigma_t(w)<br>\right)<br>$$<br>其中 $att$ 指的是一个方向上的衰减，使用上文体渲染中推导出的式子，分母项的 $cos(w_i)$ 来自于brdf的定义，$cos(w_o)$ 是因为体渲染积分本身是在出射光线上积的，要将积分域转换到深度上。</p><p>由此代入，我们得到了下面形式：<br>$$<br>f_r(w_i \rightarrow w_o) &amp;&#x3D;&amp; \frac{\rho D(h)F(h)}{4cos(w_i)cos(w_o)}  \int_o^T att(w_i,t)\cdot  att(w_o,t) \cdot d_t \<br>&amp;&#x3D;&amp;…\<br>&amp;&#x3D;&amp; \frac{D(h)F(h)G(w_i, w_o)}{4cos(w_i)cos(w_o)}<br>$$<br>其中：<br>$$<br>G(w_i, w_o) &amp;&#x3D;&amp; \frac{1 - exp(T\rho(\Lambda(w_i) + \Lambda(w_o)))}{\Lambda(w_i) + \Lambda(w_o)}\<br>\Lambda(w) &amp;&#x3D;&amp; \frac{\sigma(w)}{cos(w)}<br>$$<br>推导过程中套入了 $\sigma_t &#x3D; \sigma \rho$，中间不难就不想码了）</p><p>这样就有了一个类似传统BRDF的形式，只需要更改法线分布和 $G$ 项。</p><p><img src="http://lxtyin.ac.cn/img/Gemo/spongcake2.png"></p><p>考虑透射，也非常简单：只需更改上述积分的一段长度，推导容易得到：<br>$$<br>G(w_i, w_o) &#x3D; \frac{1 - exp(T\rho(\Lambda(w_i) + \Lambda(w_o)))}{\Lambda(w_i) + \Lambda(w_o)} \cdot exp(T\rho\Lambda(w_o))<br>$$<br>其中 $cos(w_o \lt 0)$，已经考虑到。</p><h4 id="SGGX"><a href="#SGGX" class="headerlink" title="SGGX"></a>SGGX</h4><p><a href="https://dl.acm.org/doi/abs/10.1145/2766988">https://dl.acm.org/doi/abs/10.1145/2766988</a></p><p>这篇文章提出了一种可以自由控制的Microflake分布，使用一个3x3的正定对称矩阵 $S$ 控制一个椭球微片的形态。</p><p>$$<br>S &#x3D; (w_1, w_2, w_3)<br>\left(<br>\begin{matrix}<br>S_{11} &amp; 0 &amp; 0\<br>0 &amp; S_{22} &amp; 0\<br>0 &amp; 0 &amp; S_{33}<br>\end{matrix}<br>\right)<br>(w_1, w_2, w_3) ^T<br>$$<br>$w_1, w_2, w_3$ 是椭圆的三个轴，这里看似是用一个transform矩阵定义椭球。但文章用了另一种定义。</p><p>用二次型来定义椭球，椭球上的点 $P$ 有<br>$$<br>P^TSP &#x3D; \frac{\sqrt{|S|}}{\pi}<br>$$<br>因此说矩阵 $S$ 是正定对称的。不过需要注意式子右边并不是常见的1，它相当于为椭圆的三个轴添加了同一个缩放，可能是为了让椭球在某方向的投影面积更易于表示？</p><p>椭球长这样：</p><p><img src="http://lxtyin.ac.cn/img/Gemo/sggx1.png"></p><p>如果仅考虑 $P^TSP$ 对应的标准型（即忽略旋转），我们得到椭球的表达式：<br>$$<br>S_{11}x^2 + S_{22}y^2 + S_{33}z^2 &#x3D; \frac{\sqrt{|S|}}{\pi}<br>$$<br>先推导这个椭球在x轴（即旋转后的 $w_1$ 轴）的投影 $A_x$，在 $x &#x3D; 0$ 时：<br>$$<br>\frac{S_{22}\pi}{\sqrt{|S|}}y^2 + \frac{S_{33}\pi}{\sqrt{|S|}}z^2 &#x3D; 1 \<br>A_x &#x3D; \sqrt{S_{11}}<br>$$<br>任意方向 $w_i$ 的投影：（推导跳了先（<br>$$<br>\sigma(w_i) &#x3D; \sqrt{w_i^TSw_i}<br>$$<br>表面法线（unnormalized）：<br>$$<br>\frac{\partial P^TSP}{\partial P} &#x3D; 2SP<br>$$<br>法线分布：（推导跳了（<br>$$<br>D(w_m) &#x3D; \frac{1}{\pi \sqrt{|S|}(w_m^TS^{-1}w_m)^2}<br>$$<br>应用举例：在SpongeCake模型中，用SGGX来做fiber的分布，fiber是条状的，我们可以更简单地使用一个 $\alpha$ 参数控制fiber形状。<br>$$<br>S &#x3D; (w_1, w_2, w_3)<br>\left(<br>\begin{matrix}<br>1 &amp; 0 &amp; 0\<br>0 &amp; 1 &amp; 0\<br>0 &amp; 0 &amp; \alpha^2<br>\end{matrix}<br>\right)<br>(w_1, w_2, w_3) ^T<br>$$</p><h4 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h4><p>Volume Rendering是基于RTE进行渲染，可以代入任意介质，仅需介质的Phase Function以及 $\sigma_t$ 等等；</p><p>Microflake是一种介质模型，可以代入任意形式的微薄片，SGGX是Microflake的一种具体实现，通过正定矩阵定义了微薄片的 $D(h), \sigma$ ，再加上介质中微薄片的 $\rho$，通过他们推导Phase Function和 $\sigma_t$</p><p>Microflake也有一些不同的实现模型，它仅仅只是一种描述微薄片的思想。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReSTIR</title>
    <link href="/2023/03/15/ReSTIR/"/>
    <url>/2023/03/15/ReSTIR/</url>
    
    <content type="html"><![CDATA[<p>2024.2.18 学到了一些新的关于IS和MIS的理解，故在学习ReSTIR前重新整理一遍。</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/670309912">https://zhuanlan.zhihu.com/p/670309912</a></p><h5 id="重要性采样"><a href="#重要性采样" class="headerlink" title="重要性采样"></a>重要性采样</h5><p>考虑随机变量 $\frac{f(x)}{p(x)}$，$p(x)$ 为我们选取的任意一个pdf。随机变量的期望为：<br>$$<br>E(\frac{f(x)}{p(x)}) &#x3D; \int \frac{f(x)}{p(x)}p(x) dx &#x3D; \int f(x) dx<br>$$<br>可以将<strong>求积分问题转为求随机变量的期望</strong>，估计此期望很简单：<br>$$<br>I_{IS} &#x3D; \frac{1}{N} \sum_{i&#x3D;1}^N \frac{f(x_i)}{p(x_i)}<br>$$<br>这就是蒙特卡洛估计的原理，要使这个估计的方差尽可能小，即要求 $\frac{f(x)}{p(x)}$ 的期望尽可能小，故 $p(x)$ 要尽可能接近 $f(x)$。</p><h5 id="多重重要性采样"><a href="#多重重要性采样" class="headerlink" title="多重重要性采样"></a>多重重要性采样</h5><p>被积函数很多时候很复杂，我们没办法用一个简单的 $p(x)$ 近似它，但存在多个pdf： $p_1(x),p_2(x)…p_m(x)$，每个pdf和 $f(x)$ 的一部分近似。MIS提供了一种多种采样策略结合的方案。</p><p>考虑随机变量 $w_i(x)\frac{f(x)}{p_i(x)}$，这个随机变量的期望为：<br>$$<br>E(w_i(x)\frac{f(x)}{p_i(x)}) &#x3D; \int w_i(x)f(x) dx \<br>$$<br>将M种随机变量对应的期望加起来，又变成了所求积分：<br>$$<br>\sum_{i&#x3D;1}^M E(w_i(x)\frac{f(x)}{p_i(x)}) &#x3D; \int \left ( \sum_{i&#x3D;0}^M w_i(x) \right ) f(x) dx &#x3D; \int f(x) dx\<br>$$<br>于是我们得到了MIS的估计式：<br>$$<br>I_{MIS} &#x3D; \sum_{i&#x3D;1}^M \frac{1}{N_i}\sum_{j&#x3D;1}^{N_i} w_i(x) \frac{f(x)}{p_i(x)} \<br>$$<br>通常的MIS要求 $\sum_{i&#x3D;0}^M w_i(x) &#x3D; 1$，这保证了结果是无偏的，同时隐含了这M种采样策略估计的结果，应当等权地相加；相应地在只有1样本情况下，应该等概率地选取这M种采样方式。我们如果启发式地控制采样方式出现的概率，例如，以0.25的概率取光源采样，0.75的概率取BSDF采样，那么就等价于BSDF采样出现了3次，光源采样出现了1次，必须有 $w_{光源采样}(x) +3 w_{BSDF采样}(x) &#x3D; 1$</p><p>MIS是有条件的：1. 所有 $f(x)$ 有值的区域，都必须有某个采样方式能采样到；2. 若 $p_i(x) &#x3D; 0$ 则必须 $w_i(x) &#x3D; 0$。第二个条件使用启发式权重时通常都是成立的，第一个条件其实相比重要性采样更宽松，它告诉我们：某些采样方式（例如光源采样）可以只关注一部分区域。</p><p>要令MIS的方差尽可能小，其实也就是令 $p_i(x)$ 与 $w_i(x)f(x)$ 尽可能接近。按最开始的设定，每个 $p_i(x)$ 都只有一部分和 $f(x)$ 匹配较好，通常是用 $p_i(x)$ 的波峰来匹配 $f(x)$ 的一个波峰。我们希望在 $p_i(x)$ 较匹配处，$w_i(x)$ 取尽可能大值。在不匹配处，$w_i(x)$ 取尽可能小值，来减小此处造成的方差。因此一个启发式地分配策略就是：<br>$$<br>w_i(x) &#x3D; \frac{p_i(x)}{\sum_{j&#x3D;1}^M p_j(x)}<br>$$<br>也有平方归一的和其他方式，但都比较感性，没有明显的优劣之分，随便取一种即可。</p><h6 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h6><p>我们可以用MIS重新理解前面的提到的直接间接光划分：将他们也看做两种不同的采样策略的结合。</p><p><img src="http://lxtyin.ac.cn/img/Gemo/tracing1_2.png"></p><p>如图所示，红色部分表示直接光采样策略和间接光采样策略，他们在不同区域上被赋予不同的权重（0或1），符合上述MIS要求。</p><p>在实际的采样中，我们只能使用一条光线，不可能对 $M$ 种采样策略都采样一遍，那么就需要从概率上等分它们（注意必须是等分，不能想当然地用其他启发式的划分）。</p><p>此时，若我们按照 $w_i(x) &#x3D; \frac{p_i(x)}{\sum p(x)}$，并假设每个采样策略的 $N_i$ 相同，就会得到一个优美的性质：<br>$$<br>I_{MIS} &#x3D; \sum_{i&#x3D;1}^M \frac{1}{N_i}\sum_{j&#x3D;1}^{N_i} \frac{p_i(x)}{\sum p(x)} \frac{f(x)} {p_i(x)} \<br>&#x3D; \sum_{i&#x3D;1}^M \frac{1}{N_i}\sum_{j&#x3D;1}^{N_i} \frac{f(x)}{\sum p(x)} \<br>&#x3D; \frac{1}{N}\sum_{j&#x3D;1}^{N} \frac{f(x)}{\frac{1}{M}\sum p(x)}  \<br>$$<br>即，我们可以将多个采样策略合成为一个采样策略，合成的pdf为 $p_{sum}(x) &#x3D; \frac{1}{M} \sum p(x)$，也就是单纯的PDF平均。</p><p>注意PDF平均，和各自估计后的结果平均是不一样的，前者等价于MIS，后者是naive的，并无优化。为了区分，这里再写出后者的估计式：$\frac{1}{M}\sum_{i&#x3D;1}^M \frac{1}{N}\sum_{j&#x3D;1}^{N} \frac{f(x)}{p_i(x)}$，它等价于MIS使用均匀权重。</p><p>更一般地，可以有 $p_{sum}(x) &#x3D; \sum p_i(x) m_i(x)$，只要满足 $\sum m_i(x) &#x3D; 1$ 即可。这里的 $m_i(x)$ 是我们选取采样方式 $i$ 的概率，与 $w_i(x)$ 不同。</p><h5 id="IR-Importance-Resampling"><a href="#IR-Importance-Resampling" class="headerlink" title="IR (Importance Resampling)"></a><strong>IR</strong> (Importance Resampling)</h5><p>设已有目标PDF为 $\hat p(x)$，可以用另一个简单可快速采样的提议PDF $p(x)$ 来生成接近 $\hat p$ 分布的样本。</p><ol><li>从 $p(x)$ 中抽取 $M$ 个候选样本 $x_1,x_2…x_M$</li><li>样本的初始权重设为：$w(x_i) &#x3D; \frac{\hat p(x_i)}{p(x_i)}$</li><li>用归一化后的权重作为概率 $p_{SIR}&#x3D;\frac{w(x_i)}{\sum w}$，从样本集中重新抽取。为了叙述方便，这里将重新抽取的概率分布称为 <code>SIRPDF</code> 。在 $M\rarr \infty$ 时，SIRPDF符合目标分布 $\hat p(x)$</li></ol><p>$M&#x3D;1$ 时，SIRPDF等于提议分布 $p(x)$，$M$ 越大，SIRPDF越贴近 $\hat p(x)$，但不完全相等。不难想到，这种性质很方便我们用来做蒙特卡洛估计，但还有一个问题：我们只知道如何采样SIRPDF，而不知道它的pdf到底是多少。所以需要新的估计式，后文提及。</p><p>重采样的优势在于，我们不需要知道 $\hat p(x)$ 的解析式，甚至不需要 $\hat p(x)$ 归一化，因为归一化操作隐含在归一化权重中了。或者说，我们可以将任何未归一的分布作为目标，自动得到接近它归一后版本的样本集。</p><p>我们可以直接以完整的渲染方程被积项作为 $\hat p$，不过后面会说明，实际并不会这样。</p><p>（SIR即Sample Importance Resampling，指代IR采集的样本）</p><h5 id="RIS-Resampled-Importance-Sampling"><a href="#RIS-Resampled-Importance-Sampling" class="headerlink" title="RIS (Resampled Importance Sampling)"></a><strong>RIS</strong> (Resampled Importance Sampling)</h5><p>为什么SIRPDF不能直接用于蒙特卡洛呢？因为pdf没法算，我们根本不知道重采样出来的是啥分布。</p><p>RIS提供了一个新的无偏估计公式：<br>$$<br>I_{RIS} &#x3D; \frac{1}{N} \sum_{i&#x3D;1}^N \frac{f(y_i)}{\hat p(y_i)}\frac{\sum_{j&#x3D;1}^M w(x_j) }{M}\<br>$$<br>其中 $f(x)$ 是渲染方程的被积项， $M$ 是提议样本个数，$N$ 是估计时用的样本个数。无偏性的证明放在后面，可以和RIS+MIS一起理解。</p><p>如果令 $\hat p(x) &#x3D; f(x)$，我们会发现这个式子又变回蒙特卡洛了，方差取决于提议分布 $p(x)$ 的选取。</p><p>那么RIS真正的优势在哪里呢？</p><p>看一下RIS在Direct light中的应用就明白了：<a href="https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=1662&context=etd">论文原文</a>选取的 $\hat p$ 为：<br>$$<br>\hat p &#x3D; f_s\cdot G\cdot Le<br>$$<br>是去掉了可见项后的被积项，这个 $\hat p$ 函数的特点是：接近被积项，计算开销小（因为去掉了最昂贵的遮挡项），同时又不可直接采样（没法直接蒙特卡洛）。</p><p>用RIS来处理的话，在 $M$ 够大，重采样分布能够接近 $\hat p$ 的情况下，所需的样本数 $N$ 相比传统IS是有优势的。我们选取计算开销小的 $\hat p$ 也是为了初始的 $M$ 个样本权重计算更快。</p><p>总结一下的话，最初的RIS其实是一个trade off的方法，通过<strong>提高提议数 $M$ 来减小所需的样本数 $N$<strong>。效果上也只能说和IS互有优劣。后续提出的</strong>复用提议样本</strong>的方法，才真正让RIS得以发光发热。</p><p>这里偷一个方差公式：<br>$$<br>V &#x3D; \frac{1}{M} V(\frac{f(X)}{p(X)}) + (1-\frac{1}{M})\frac{1}{N}V(\frac{f(Y)}{\hat p(Y)})<br>$$<br>为了简化，这里假设 $\hat p$ 是归一化的，如果不是，式子中应为归一化的 $\hat p$。</p><p>可见，$M$ 越大，提议分布 $p$ 越不重要，方差越接近直接用 $\hat p$ 做蒙特卡洛的结果。，</p><p>$p$ 会影响SIRPDF收敛到 $\hat p$ 的速度，因此也不能乱取，通常可能会取BSDF之类的好采样的分布。</p><p>回忆一下，$p$ 是一个简单易采样的提议分布，$\hat p$ 是一个不易采样，但非常接近目标积分的分布。显然我们需要<br>$$<br>V(\frac{f(X)}{p(X)}) &gt; V(\frac{f(Y)}{\hat p(Y)})<br>$$<br>否则进行重采样没有任何意义；其次，$\hat p(x)$ 的计算开销也需要显著小于 $f(x)$，否则不如直接进行蒙特卡洛采样。</p><p>从另一个角度理解，RIS相较于IS其实是提供了一个额外的控制自由度，$M$。</p><h5 id="RIS的无偏性证明"><a href="#RIS的无偏性证明" class="headerlink" title="RIS的无偏性证明"></a>RIS的无偏性证明</h5><p>我们直接考虑最广义的情况：每个提议样本 $x_i$ 各自使用单独的提议分布 $p_i$ 采样，$w_i(x_i) &#x3D; \frac{\hat p(x_i)}{p_i(x_i)}$。先说结论：这样取提议样本也是正确的，并且有一个更加广义的形式。下面一起证明：</p><p>这一小节我们用 $p_i$ 表示提议PDF，$p$ 为通用的概率符号</p><p>这里需要先弄清楚几个概率：<br>$$<br>p(\bold x) &#x3D; \prod_{i&#x3D;1}^M p_i(x_i),样本集恰为\bold x的概率 \<br>p(z|\bold x) &#x3D; \frac{w(x_z)}{\sum w}, 已知样本集为\bold x的情况下,重抽样到第z个元素的的概率 \<br>p(\bold x, z) &#x3D; p(\bold x) \cdot p(z|\bold x), 样本集为\bold x 且重抽样到第z个元素的概率<br>$$<br>注意，SIRPDF $p_{SIR}(x_z)$ 并不等于 $p(\bold x,z)$，因为可以有多种 $\bold x, z$ 的组合可以产生 $x_z$，如果我们写出 $p_{SIR}$ 的形式：<br>$$<br>p_{SIR}(y) &#x3D; \sum_{i\in Z(y)} \int_{\bold x|x_i&#x3D;y} p(\bold x, i) d\bold x<br>$$<br>其中 $Z(y) &#x3D; {i|1\le i\le M \and p_i(y)\gt 0 }$，积分域是所有满足 $x_i&#x3D;y$ 样本集（相当于限制第 $i$ 的样本的值，其余样本均自由）。这个式子枚举了所有能够重抽样产生 $y$ 的情况，并将其概率相加。这才是SIRPDF的完整表达，它没有一个闭合解。</p><p>我们需要证明的是估计式无偏，<br>$$<br>\left&lt; I_{RIS}^{1,M} \right&gt; &#x3D; \frac{f(y)}{\hat p(y)}\frac{\sum_{j&#x3D;1}^M w_j(x_j) }{M} &#x3D; f(y)W(\bold x,z),其中\<br>y&#x3D;x_z\<br>W(\bold x,z) &#x3D; \frac{1}{\hat p(x_z)}\frac{\sum_{j&#x3D;1}^M w_j(x_j) }{M} \<br>$$<br>这里，$W(\bold x,z)$ 是一个随机变量，虽然此时已知 $x_z&#x3D;y$，但仍有有多种组合能够满足这一约束，并且每一种组合下 $W(\bold x, z)$ 的值都不一样。如果我们能够证明：<br>$$<br>\mathbb E_{x_z&#x3D;y}(W(\bold x, z)) &#x3D; \frac{1}{p_{SIR}(y)}<br>$$<br>就相当于将估计式变成了蒙特卡洛估计，结果自然是无偏的。</p><p>至于为何期望能拿来替换pdf，我觉得可以感性理解，也许不是太严谨，<a href="https://agraphicsguynotes.com/posts/understanding_the_math_behind_restir_di/#restir-di-introduction">Understanding The Math Behind ReStir DI</a> 给出了证明。</p><p>继续证明，用类似描述SIRPDF的思路写出上面这个 $\mathbb E$：<br>$$<br>\mathbb E_{x_z&#x3D;y}(W(\bold x, z)) &#x3D; \sum_{i\in Z(y)} \int_{\bold x| x_i&#x3D;y} W(\bold x, i)<br>\frac{p(\bold x,i)}{p_{SIR}(y)} d\bold x<br>$$<br>这是一个条件期望，上式中，$p(\bold x,i)$ 是采样到这样一个样本集，并重采样到index $i$ 的概率，还需 要除以 $p_{SIR}(y)$ 才是已知结果为 $y$ 时的条件概率。继续展开：<br>$$<br>\mathbb E_{x_z&#x3D;y}(W(\bold x, z)) &amp;&#x3D;&amp; \frac{1}{p_{SIR}(y)}<br>\sum_{i\in Z(y)} \int_{\bold x| x_i&#x3D;y}<br>\left[\frac{1}{\hat p(x_i)} \frac{\sum_{j&#x3D;1}^M w_j(x_j) }{M} \right]<br>\left[ \frac{w_i(x_i)}{\sum_{j&#x3D;1}^M w_j(x_j)} \prod_{j&#x3D;1}^M p_j(x_j) \right]<br>d\bold x \</p><p>&amp;&#x3D;&amp; \frac{1}{p_{SIR}(y)}<br>\sum_{i\in Z(y)} \int_{\bold x| x_i&#x3D;y}<br>\frac{w_i(x_i)}{\hat p(x_i)M}<br>\prod_{j&#x3D;1}^M p_j(x_j)<br>d\bold x \</p><p>&amp;&#x3D;&amp; \frac{1}{p_{SIR}(y)}\frac{1}{M}<br>\sum_{i\in Z(y)} \int_{\bold x| x_i&#x3D;y}<br>\frac{1}{p(x_i)}<br>\prod_{j&#x3D;1}^M p_j(x_j)<br>d\bold x \</p><p>&amp;&#x3D;&amp; \frac{1}{p_{SIR}(y)} \frac{1}{M}<br>\sum_{i\in Z(y)} \int_{\bold x| x_i&#x3D;y}<br>\prod_{x_j \in \bold x-x_i } p_j(x_j)<br>d\bold x \</p><p>&amp;&#x3D;&amp; \frac{1}{p_{SIR}(y)} \frac{Z(y)}{M}<br>$$<br>最后一步，被积项即为 ${\bold x |x_i&#x3D;y}$ 中所有样本集的出现概率的积分，即为1。</p><p>于是，当 $Z(y)&#x3D;M$ 时，$W(\bold x, z)$ 的期望为 $1&#x2F;p_{SIR}(x_z)$，估计是无偏的。</p><p>实际情况中，若提议分布并不能保证处处 $&gt;0$，则估计是有偏的。我们可以修改：<br>$$<br>W(\bold x,z) &#x3D; \frac{1}{\hat p(x_z)}\frac{\sum_{j&#x3D;1}^M w_j(x_j) }{Z(x_z)} \<br>$$<br>达成无偏。不过这样并不是最好的，可以使用类似MIS的方式加权：<br>$$<br>W(\bold x,z) &#x3D; \frac{1}{\hat p(x_z)} m_z(x_z)\sum_{j&#x3D;1}^M w_j(x_j) \<br>$$<br>满足 $\sum_i^M m_i(x) &#x3D; 1$ 对于任意 $x$ 均成立即可，一种启发式平衡策略为 $m_i(x) &#x3D; \frac{p_i(x)}{\sum_{j&#x3D;1}^M p_j(x)}$</p><p>可以将该式代入上面的证明过程，很容易证明。</p><p>总结一下，这一节我们证明了 $\mathbb E_{x_z&#x3D;y}(W(\bold x, z)) &#x3D; \frac{1}{p_{SIR}(x_z)}$，可以在估计中使用 $W$ 替代 $p_{SIR}$ 的作用。另外还还说明了RIS支持使用不同的提议分布。</p><h5 id="加权蓄水池采样（WRS）"><a href="#加权蓄水池采样（WRS）" class="headerlink" title="加权蓄水池采样（WRS）"></a>加权蓄水池采样（WRS）</h5><p>考虑流式地处理提议样本，即已有 $M$ 个提议样本 $x_1,..x_M$ 和SIR样本 $y$（可以为 $N$ 个重采样样本，此处仅考虑一个的情况），现需要加入第 $M+1$ 个提议样本 $x_{M+1}$，要维护SIR样本的概率正确。</p><p>用 $w_{sum}$ 来表示此前 $M$ 个样本的权重和 $\sum w_i$，$w_{M+1}$ 可以直接算，那么样本 $x_{M+1}$ 被采样的概率理应为 $\frac{w_{M+1}}{w_{sum}+w_{M+1}}$</p><p>此前所有样本 $x_j,j\le M$ 被采样到的概率应当变为原来的 $\frac{w_{sum}}{w_{sum}+w_{M+1}}$ 倍。</p><p>那么，策略就是以 $\frac{w_{M+1}}{w_{sum}+w_{M+1}}$ 的概率替换原样本 $y$ 。</p><p>WRS还支持两个蓄水池的合并：</p><p>$w_{sum1}, y_1$ 合并 $w_{sum2}, y_2$，则 $y_2$ 以 $\frac{w_{sum2}}{w_{sum1} +w_{sum2}}$ 的概率替换 $y_1$，证明比较简单。</p><p>注意合并的时候维护 $w_{sum}$</p><h5 id="不同目标分布的蓄水池合并"><a href="#不同目标分布的蓄水池合并" class="headerlink" title="不同目标分布的蓄水池合并"></a>不同目标分布的蓄水池合并</h5><p>在上面，我们已经证明了RIS可以使用各不相同的提议分布，现在利用这一点，实现两个连目标分布都不同的蓄水池合并。这也是所有时空复用的基础。</p><p>首先，这种策略仅适合两个蓄水池的目标分布接近的情况（相邻像素或相邻帧），若相差较远，此方法同样是无偏的，但合并不会让采样质量更高。</p><p>以合并相邻像素的蓄水池为例，设当前像素为 $q$，蓄水池为 $s$，待合并像素为 $q’$，蓄水池为 $r$，蓄水池各自存储了 $\left&lt; w_{sum},y,M,W\right&gt;$，两个蓄水池中的目标分布 $\hat p_q$ 和 $\hat p_q’$ 不同，无法直接合并。</p><p>事实上，我们可以将相邻蓄水池的SIRPDF视为一个高质量的提议分布，$r.y$ 即为该SIRPDF的一个样本，要将其加入 $s$，这就比较容易了。</p><p>下面是 <a href="https://agraphicsguynotes.com/posts/understanding_the_math_behind_restir_di/#restir-di-introduction">Understanding The Math Behind ReStir DI</a> 中给出的图。</p><p><img src="https://agraphicsguynotes.com/img/posts/understanding_the_math_behind_restir_di/ReStir_3.png"></p><p>我们在先前已经证明了提议分布可以各不相同，且有了一个 $W$ 用于代替 $p_{SIR}$ 的作用。</p><p>要加入的样本权重为：<br>$$<br>w &#x3D; \frac{\hat p_q(r.y)}{p_{SIR}(r.y)} \Rarr \hat p_q(r.y) r.W &#x3D; \frac{\hat p_q(r.y)}{\hat p_q’(r.y)} \frac{r.w_{sum}}{r.M}<br>$$<br>中间再次利用了 $W$ 的期望和 $p_{SIR}$ 的关系，故没有写等号。</p><h6 id="扩大SIR样本的影响"><a href="#扩大SIR样本的影响" class="headerlink" title="扩大SIR样本的影响"></a>扩大SIR样本的影响</h6><p>容易想到，$r.y$ 应当是一个质量非常高的样本，代表了相邻像素的 $r.M$ 个样本，仅仅将其视为一个提议样本有些浪费。考虑到它的重要程度和 $r.M$ 相关，我们可以<strong>视为这个样本插入了 $r.M$ 次</strong>，等价于插入一次，但权重乘了 $r.M$ 倍（如果不理解为什么等价，可以算一下全部插入之后，$r.y$ 替代上位的概率）。</p><p>于是最终的权重为：<br>$$<br>\frac{\hat p_q(r.y)}{\hat p_q’(r.y)} r.w_{sum}<br>$$<br>同样，$s.M$ 也需要加上 $r.M$，而不是简单地+1。</p><p>这种权重也可以理解为一种MIS，不过由于后面计算 $Z(y)$ 时还用到了这种思想，我更倾向于将其理解为插入 $M$ 次，私以为更加容易理解。</p><p>注意：这种重用<strong>和真的把 $s.M+r.M$ 个样本拿来重采样一次是不等价的</strong>，但同样能反映采样质量随着提议样本数 $M$ 的提高而提高。</p><h5 id="ReSTIR-DI"><a href="#ReSTIR-DI" class="headerlink" title="ReSTIR DI"></a>ReSTIR DI</h5><p>最关键的蓄水池合并问题已经解决了，空间样本重用方法见上，时域样本重用也只是合并来自上一帧的蓄水池，寻找上一帧的对应也是利用Motion Vector。</p><p>TAA是有偏的，我们需要头疼上一帧和这一帧在各种情况下的不同，并且通常很难做到尽善尽美。而ReSTIR的时域重用是无偏的，因为我们的重用策略本身就支持合并目标分布不同的蓄水池，将另一个蓄水池并过来后，仍然是对当前目标分布的无偏估计，可以放心大胆的合并。</p><h6 id="可见性重用"><a href="#可见性重用" class="headerlink" title="可见性重用"></a>可见性重用</h6><p>ReSTIR DI的目标分布是去掉可见性项后的直接光照 $\rho L_eG$，这样的好处是在计算 $\hat p$ 时无需进行场景求交，但这也带来了一定的噪声。</p><p><a href="https://agraphicsguynotes.com/posts/understanding_the_math_behind_restir_di/#restir-di-introduction">Understanding The Math Behind ReStir DI</a> 指出的方案是在目标分布中带上可见性项，这里似乎和原文的思路不同。原文将其策略称为Visibility Reuse，并没有提及要改变目标分布，下面按照原文的思路来：</p><p>原文方法非常简单：在蓄水池合并时，检测SIR样本 $y$ 是否可见，若不可见，则直接将该蓄水池的 $W$ 设为0，相当于丢弃了这一蓄水池。这阻止了被遮挡的样本向外传播，使得最终使用的样本大概率是不被遮挡的。</p><h5 id="无偏版本实现"><a href="#无偏版本实现" class="headerlink" title="无偏版本实现"></a>无偏版本实现</h5><p>回忆一下，无偏版本需要修改 $W$：<br>$$<br>W(\bold x,z) &#x3D; \frac{1}{\hat p(y)}\frac{\sum_{j&#x3D;1}^M w_j(x_j) }{Z(y)}, y&#x3D;x_z<br>$$</p><p>考虑如何计算这个 $Z(y)$，它表示 $M$ 个样本（来自于 $M$ 个提议分布）中，有多少提议分布满足 $p_i(y) &gt; 0$。</p><p>有两个问题：1. 提议分布可能来自相邻的SIRPDF，它没有闭合解；2. 我们不可能追踪所有Proposal PDF。</p><p>对于第一个问题，由于 $\hat p(x)$ 与SIRPDF在同样的区域成为0（参照SIRPDF的定义式），可以用 $\hat p(x)$ 来代替SIRPDF来计算 $Z$。</p><p>对于第二个问题，我们需要再次强调插入 $M$ 次的思想：在合并一个蓄水池 $r$ 的时候，我们并不是合并这个蓄水池的所有历史样本，而是视为当前的SIRPDF样本 $r.y$ 插入了 $r.M$ 次，这 $r.M$ 个样本全部来自于该SIRPDF。于是只要 $p_{SIR}(y) &gt; 0$，就可以直接令 $Z +&#x3D; r.M$ 。</p><p>计算过程可以看论文中的伪代码。</p><p>至于MIS版本的 $W$：<br>$$<br>W(\bold x,z) &#x3D; \frac{1}{\hat p(x_z)} \frac{p_z(x_z)}{\sum_{j&#x3D;1}^M p_j(x_z)} \sum_{j&#x3D;1}^M w_j(x_j) \<br>$$<br>这个版本的无偏公式在论文中没有实现，我也不知道具体要怎么实现。</p><h5 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h5><ul><li>为什么去掉可见性项，计算 $\hat p $ 就不需要光线求交了？如何从给定位置+方向找到光源？</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BXDF以及MR工作流</title>
    <link href="/2023/02/26/BXDF%E4%BB%A5%E5%8F%8AMR%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <url>/2023/02/26/BXDF%E4%BB%A5%E5%8F%8AMR%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h4 id="基本物理观念"><a href="#基本物理观念" class="headerlink" title="基本物理观念"></a>基本物理观念</h4><ol><li>金属的折射光会被自由电子立刻吸收，几乎只有反射。非金属才有明显散射行为。</li><li>非金属的镜面反射是无彩色的（白色），金属才具有彩色的镜面反射。</li><li>光打中平面后，只发生反射（镜面反射）和折射，折射入物体内部后一部分被吸收，另一部分散射出来成为漫反射。其中漫反射部分又可以拆分出次表面散射，即散射距离显著大于像素大小时，散射影响到了附件的其他像素上，称为次表面散射。</li></ol><p><img src="https://raw.githubusercontent.com/QianMo/PBR-White-Paper/master/content/part%202/media/db572e0923acd8d22e67a4e1875fb206.png"></p><h4 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>BRDF的定义式：<br>$$<br>f_r &#x3D; \frac{dL_o}{d E_i}<br>$$<br>此前我疑惑过为什么不简单定义为 $\frac{dL_o}{d L_i}$，在搞明白Radiance之后理解了。$L_o$ 为反射方向的Radiance，贡献来自于整个上半球，$dL_o$ 指 $dw_i$ 方向的入射光对 $L_o$ 的贡献；$E$ 为表面接受到Irradiance，贡献来自于整个上半球， $dE_i$ 指 $dw_i$ 方向的入射光对 $E$ 的贡献。</p><p>简单而言，他们都是微分量，都是对入射角的微分；而 $dL_i$ 则说不清具体含义；也不可能定义成 $\frac{dL_o}{L_i}$ 的形式，它是一个趋于0的值，需要除上一个微分立体角才能有意义。</p><p>$$<br>L_o &#x3D; L_i \cdot f_r(i,o)\cdot cos(i) \<br>L_i &#x3D; L_o \cdot f_r(o,i)\cdot cos(o)<br>$$</p><p>那为什么不定义为 $\frac{dL_o}{L_i dw_i}$ 的形式呢？（相比正式定义少了个 $cos$）</p><p>还可以从实际测量的角度理解，实际测量中 $dL_o$ </p><p>….</p><p>除此之外，在最常见的微表面模型中，这种定义的BRDF是可逆的，带上cos之后就不可逆了。</p><h5 id="Microfacet-BRDF推导"><a href="#Microfacet-BRDF推导" class="headerlink" title="Microfacet BRDF推导"></a>Microfacet BRDF推导</h5><p>下面推导微表面模型中的 $f_r$ 具体形式，暂时忽略菲涅尔项和几何遮蔽。</p><p>我们用 $cos(i,n)$ 这样的形式来表示两向量夹角的 $cos$。</p><p>设 $D(h)$ 指代微法线在 $dw_h$ 微立体角内的微表面面积与宏表面面积的比例，有<br>$$<br>\int D(h) \cdot cos(n,h) \cdot dw_h &#x3D; 1<br>$$<br>先推导 $dL_o$，它指 $dw_i$ 方向的入射光对 $L_o$ 的贡献。</p><p>首先，$dw_h$ 方向的微表面面积为<br>$$<br>d^2A_h &#x3D; dA \cdot D(h) \cdot dw_h<br>$$<br>可以得出进入表面（且对 $L_o$ 有贡献）的辐射通量（微平面视角下理解）：<br>$$<br>d^3\phi &#x3D; L_i \cdot d^2A_h \cdot dw_i \cdot cos(h,i)<br>$$<br>$\phi$ 是由输入到输出的不变量 $\phi_i&#x3D;\phi_o$，那么可以得到（回到宏观视角）：<br>$$<br>dL_o &#x3D; \frac{d^3\phi}{dA\cdot dw_o \cdot cos(n,o)}<br>$$<br>左侧是 $dL_o$，因为右侧还是对 $dw_i$ 微分的一个量，得到的正是 $dw_i$ 方向对 $L_o$ 的贡献。也可以从 $d$ 的次数守恒来理解。</p><p>$dE_i$ 比较简单：<br>$$<br>E_i &#x3D; \int L_i \cdot cos(n,i) \cdot dw_i \<br>dE_i &#x3D; L_i \cdot cos(n,i) \cdot dw_i<br>$$<br>那么展开上述式子，得到：<br>$$<br>f_r &#x3D; \frac{D(h) \cdot cos(h,i) \cdot dw_h}{cos(n,o) \cdot cos(n, i) \cdot dw_o}<br>$$<br>$dw_h$ 与 $dw_o$ 之间存在一个几何上的关系</p><p><img src="http://lxtyin.ac.cn/img/Gemo/reflection_jaco.png"></p><p>这是Walter 07年论文中的图，很多博客也喜欢从这张图出发解释它们的几何关系，但由于我个人无法理解这个图的作图逻辑，所以从另一个角度来解释。</p><p>首先，显然有 $d_{\theta o} &#x3D; 2d_{\theta h}$，$d_{\phi o} &#x3D; 2d_{\phi h}$</p><p>从立体角定义的角度，$dw_h &#x3D; d_{\theta h} d_{\phi h}cos(\theta_h)$，我们将 $h$ 摆到竖直的位置上，就有了<br>$$<br>dw_h &#x3D; d_{\theta h} d_{\phi h} \<br>dw_o &#x3D; d_{\theta o} d_{\phi o} |w_o\cdot w_h| &#x3D; 4|w_o\cdot w_h|dw_h<br>$$<br>于是有：<br>$$<br>f_r &#x3D; \frac{D(h)}{4cos(n,i) \cdot cos(n,o)}<br>$$</p><p>再加上几何项G与菲涅尔项F，就得到了经典的<code>Cook-Torrance BRDF</code> 形式：<br>$$<br>f_r&#x3D;\frac{DFG}{4cos(n,i) \cdot cos(n,o)}<br>$$<br>当然，这里只考虑了reflect，通常的反射模型还要再加一个diffuse部分。</p><p><strong>可逆性：</strong>$f_r(w_r\rightarrow w_i)&#x3D;f_r(w_i\rightarrow w_r)$</p><p><strong>能量守恒：</strong>总量可以衰减（吸收），但不能多，这决定了光线追踪是否能够收敛（物理上的正确性）。</p><h5 id="Diffuse"><a href="#Diffuse" class="headerlink" title="Diffuse"></a>Diffuse</h5><ul><li>最简单的Lambert均匀漫反射：$f_{lambert}&#x3D;\frac{q}{\pi}$</li></ul><p>因为需要能量守恒：<br>$$<br>\int_{\Omega^+} f_p cos\theta d_w &#x3D; 1<br>$$<br>得 $f_p &#x3D; \frac{1}{\pi}$，再加上albedo系数即可。</p><ul><li>Disney经验模型，在漫反射部分也加上了菲涅尔因子，公式如下：</li></ul><p>$$<br>f_d &#x3D; \frac{baseColor}{\pi}(1+(F_{D90} - 1)(1 - cos_{NL})^5)(1+(F_{D90} - 1)(1 - cos_{NV})^5)\<br>F_{D90} &#x3D; 0.5 + 2roughness \times cos_{VH}^2<br>$$</p><ul><li>次表面散射也属于Diffuse，暂略。</li></ul><h5 id="D项"><a href="#D项" class="headerlink" title="D项"></a>D项</h5><p>$D(h)$ 指微表面中法线为 $h$ 的微表面面积比例，是微表面模型中最重要的一个统计量。</p><p>它指的是微表面面积 &#x2F; 宏观面积，故乘上余弦项后积分才为1。<br>$$<br>\int_{\Omega^+} D(h)(h\cdot n)dw_h &#x3D; 1\<br>\int_{\Omega^+} D(h)(h\cdot v)dw_h &#x3D; v\cdot n<br>$$<br>关于2式的理解：</p><p><img src="https://raw.githubusercontent.com/QianMo/PBR-White-Paper/master/content/part%204/media/b6a70732fd616c56ad51468b2d5630cc.png"></p><p>比较常用各项同性GGX分布：<br>$$<br>D_{GGX}(h)&#x3D;\frac{\alpha^2}{\pi(cos_{NH}^2(\alpha^2-1)+1)^2}<br>$$</p><p>式子中 $\alpha$ 表示粗糙度 <code>roughness</code> ，其值越大，反射越不集中。</p><p>除此之外还有许多中分布模型，大多公式不是推导出来的，而是凭借经验和直觉拟合测量结果得出的。</p><p>形状不变性：缩放 $\alpha$ 时，等价于拉伸微观几何。GGX具备形状不变性，而另一个常见的GTR模型不具备。</p><p>各向异性：暂略</p><h5 id="G项"><a href="#G项" class="headerlink" title="G项"></a>G项</h5><p>几何项，微表面模型中，一部分微表面会被遮挡，导致即使其法线方向符合，也没有产生贡献。我们用 $G1(h,v)$ 表示沿视图 $v$ 方向，可见的法线为 $h$ 的微平面比例，作为对 $D$ 项的补充。</p><p>之前的 $D$ 项、漫反射项的常用分布，都是人们依据经验拟合的，而G项是依赖所选D项，可以推导的。</p><p>单D项还不能推导出G，因为D项仅定义了分布，未定义“轮廓”，还需要一个定义轮廓的模型。目前最好的轮廓模型是<strong>Smith遮蔽函数</strong>。</p><p>Smith遮蔽函数的具体内容暂略（（（（</p><p>Smith模型将微表面看做若干不连续的表面（无自相关性，即轮廓不连续），这当然与现实不符，不过在表面随机的情况下表现很好，对于具备一定规律的表面材质，一般使用专门的模型。</p><p>Smith遮蔽函数是常见遮蔽函数中，唯一既满足能量守恒又具有法线遮蔽独立性（即法线&#x2F;高度都和相邻点无关）便利特性的函数。</p><p>下面是GGX导出的G项：Smith-GGX函数<br>$$<br>G_{GGX}(v)&#x3D;\frac{2(n\cdot v)}{(n\cdot v)+\sqrt{a^2+(1-a^2)(n\cdot v)^2}}<br>$$</p><p>其中 $v$ 为光线方向，显然角度越大，这个项越小（衰减越重）</p><p>其中 $\alpha&#x3D;(\frac{1+roughness}{2})^2$，也有其他形式的 $\alpha$。</p><p>我们要用的几何项同时考虑入射和出射方向的几何遮蔽，$G&#x3D;G_{GGX}(w_i) G_{GGX}(w_o)$</p><p>G项虽然基本都用Smith，但是有很多不同的近似方案，内容较多，具体见<a href="https://github.com/QianMo/PBR-White-Paper/blob/master/content/part%205/README.md">https://github.com/QianMo/PBR-White-Paper/blob/master/content/part%205/README.md</a></p><p><strong>Kulla-Conty近似：</strong></p><p>简单地乘以G项显然会导致能量丢失，事实上，被遮挡的部分会经过反弹再出去。</p><p>这里需要做一个fix【暂略】</p><p>不能单纯加上一个diffuse！</p><h5 id="F项"><a href="#F项" class="headerlink" title="F项"></a>F项</h5><p>菲涅尔项，指物体镜面反射的能量比例，入射角与法线夹角越大，反射率越大。通常用 $F_0$ 表示0度角（垂直）入射时的反射率。金属的 $F_0$ 值通常为 $0.5-1$，非金属通常为 $0.02-0.05$。</p><p>在掠射（90度）时，菲涅尔项达到1（全反射），不过由于微表面的存在，宏观观察的菲涅尔项达不到1也很正常。</p><p>菲涅尔项的实际计算比较复杂，它与材质的折射率、波动光学相关，不同材质的菲涅尔项差别也很大。但是经过一些观察，人们发现了一些共性：</p><ul><li>对于0-45度的入射角（与法线夹角），菲涅尔项几乎不变。</li><li>45-75度，菲涅尔项明显增大，75-90度，菲涅尔项总是快速达到1。</li></ul><p>因此可以用 $F_0$ 来近似地确定整个菲涅尔函数。</p><p>一种近似求法 SchlickFresnel：<br>$$<br>F&#x3D;F_0+(1-F_0)(1-cos\theta)^5<br>$$<br>$cos\theta$ 为入射方向与法线的夹角（$w_i\cdot h$），随角度增大逐渐拉到全部反射。</p><p>常见材质的 $F_0$ 可以查表得出，也可以用 $F_0&#x3D;(\frac{n_1-n_2}{n_1+n_2})^2$ 来计算，这里看到 $F_0$ 其实并不是一个属于材质的属性，而是与两边介质的折射率均有关，大多数情况下 $n_1 &#x3D; 1$。</p><p>在相对IOR接近1时，上述式子误差较大，此时可以直接使用精确菲涅尔方程计算。</p><p>据人们观察，非金属的菲涅尔效应在光的各个波长上表现比较一致，而金属的菲涅尔效应随波长变化明显。因此实现上，金属的F0可以定义为彩色，非金属F0定义为白色，混合介质的 $F_0$ 可以简单地线性估计：<code>F_0=mix(vec3(0.04), albedo, metallic)</code>，这个式子中，非金属F0取典型值0.04，金属部分F0 &#x3D; albedo，这也是M&#x2F;R工作流中的常见做法，albedo同时作为非金属的漫反射颜色和金属的F0。</p><p>菲涅尔项是可逆的（仅限目前的几何光学），就是说 $F(w_i, w_o)&#x3D;F(w_o, w_i)$，这一点无论是反射还是折射都成立。</p><h4 id="Disney模型"><a href="#Disney模型" class="headerlink" title="Disney模型"></a>Disney模型</h4><p>Disney BRDF将物体视为金属部分和非金属部分，依据金属度 <code>metallic</code> 混合。由于仅非金属具有漫反射，我们为diffuse部分乘一个系数 $(1-metallic)$，右部specular为金属和非金属共同作用的，金属度体现在 $F$ 项中的 $F_0 &#x3D; mix(0.04, albedo, metallic)$。</p><p>漫反射属于折射后的散射，理应也具有与菲涅尔相关的系数，Disney没有使用简单的lambert模型也没有乘（1-F），而是单独加了一些菲涅尔因子（具体见上Diffuse）</p><p>$$<br>f_r &#x3D; (1 - metallic)f_d + \frac{D_{GGX}F_{SchlickFresnel}G_{SchlickGGX}}{4cos_i cos_o}<br>$$</p><h4 id="BSDF"><a href="#BSDF" class="headerlink" title="BSDF"></a>BSDF</h4><p>BSDF &#x3D; BRDF + BTDF</p><p>BTDF（双向透射分布函数）的积分域是下半球面，与BRDF组合后就是一个完整的球面积分。</p><p>BTDF同样可以使用微表面模型，将微表面看做光滑的，只会朝固定方向折射。</p><p>那么BTDF前面的推导过程和BRDF完全一致，得到：<br>$$<br>f_t &#x3D; \frac{D(h) \cdot cos(h,i) \cdot dw_h}{cos(n,o) \cdot cos(n, i) \cdot dw_o}<br>$$<br>最后的 $\frac{dw_h}{dw_o}$ 和BRDF不同（仅仅是几何关系上不同），见Walter论文中的图，可以推出关系：<br>$$<br>dw_h &#x3D; \frac{dw_o \cdot \eta^2 \cdot cos(h,o)}{||h||^2}<br>$$<br>这里的 $\eta &#x3D; \frac{\eta_o}{\eta_i}$，合并起来，得到 $f_t$ 的表达式：<br>$$<br>f_t &#x3D;\frac{cos(h,i) \cdot cos(h,o)}{cos(n,o) \cdot cos(n, i)}\cdot \frac{D(h) \cdot \eta^2}{||h||^2}<br>$$<br>再添加菲涅尔项（1-F）和几何项，定义都与BRDF中一致。</p><p>由于折射两边的介质不同，我们发现这个式子并不是可逆的，但幸运的是还有另一种可逆性存在：<br>$$<br>f_t(i,o) \cdot \eta_i^2 &#x3D; f_t(o,i) \cdot \eta_o^2<br>$$</p><h4 id="Disney-BSDF"><a href="#Disney-BSDF" class="headerlink" title="Disney BSDF"></a>Disney BSDF</h4><p><img src="https://raw.githubusercontent.com/QianMo/PBR-White-Paper/master/content/part%203/media/e7f8349e326040400f36d6de724d1871.png"></p><p>原先的BRDF依据metallic划分为了散射和反射两部分，现在继续在散射中划分为折射（Specular BSDF）和漫反射两部分（Disney方法使用specTrans参数）。</p><p>折射部分和反射很接近，只不过菲涅尔项需要使用 $1-F$ 以及 $IOR$ 修正，此时的菲涅尔项可以直接用折射率算出来精确值。</p><p>折射下的半法向：$h&#x3D;normalize(wi+\frac{\eta_2}{\eta_1}wo)$</p><p>它的分布 $D(h)$ 可以按照和BRDF相同的方式得出。</p><p>实际应用中，我们通常以表面法线朝向作为外侧，定义介质内外两侧的折射率（外侧通常视为空气）</p><h4 id="重要性采样"><a href="#重要性采样" class="headerlink" title="重要性采样"></a>重要性采样</h4><h5 id="对D进行重要性采样"><a href="#对D进行重要性采样" class="headerlink" title="对D进行重要性采样"></a>对D进行重要性采样</h5><p>我们很难严格画出渲染方程的曲线，故通常只对法线分布函数进行重要性采样。</p><p><img src="https://img2020.cnblogs.com/blog/519775/202010/519775-20201010225605808-1680627455.png"></p><p>如上，$D(h)$ 实际应满足 $\int_{\Omega^+} D(h)cos\theta_hd_w&#x3D;1$，$\theta_h$ 为宏面法线和 $h$ 的夹角，那太方便了，直接拿 $D(h)cos\theta_h$ 当概率密度，采样 $h$。</p><p>将向量转化到球面坐标系 $\theta,\phi$：<br>$$<br>\int_0^{2\pi}\int_0^{\pi} D(\theta, \phi) cos_\theta sin_\theta d_{\theta}d_{\phi}<br>$$<br>显然这里的式子与 $\phi$ 无关，我们可以得到 $pdf(\theta)&#x3D;\frac{2\alpha^2cos\theta sin\theta}{(cos^2\theta(\alpha^2-1)+1)^2}$</p><p>接下来的问题是如何生成一个符合这个概率的随机数：</p><h6 id="逆分布函数方法"><a href="#逆分布函数方法" class="headerlink" title="逆分布函数方法"></a>逆分布函数方法</h6><p>首先计算 $pdf(x)$ 的累计分布函数 $P(x)$，它的值域是 $[0, 1]$，然后利用反函数 $P^{-1}(x)$ 。</p><p>这样就可以利用 $[0,1]$ 之间的均匀随机数生成符合 $pdf(x)$ 的随机数。</p><p>为了方便起见，设 $x&#x3D;cos\theta$<br>$$<br>\begin{aligned}<br>p(\theta)&#x3D;&amp;\frac{2\alpha^2cos\theta sin\theta}{(x^2(\alpha^2-1)+1)^2}, x\in[0,1]\<br>P(t)&#x3D;&amp;\int_0^t\frac{2\alpha^2cos\theta sin\theta}{(x^2(\alpha^2-1)+1)^2}d\theta\<br>&#x3D;&amp;\int_{..}\frac{\alpha^2}{(x^2(\alpha^2-1)+1)^2}dx^2\<br>&#x3D;&amp;\int_{..}\frac{a^2}{u^2(a^2-1)}du,u&#x3D;x^2(a^2-1)\<br>&#x3D;&amp;\frac{a^2}{(a^2-1)(cos^2t(a^2-1)+1)}-\frac{1}{a^2-1}\<br>P^{-1}(x)&#x3D;&amp;\arccos\sqrt \frac{1-x}{x(a^2-1)+1}<br>\end{aligned}<br>$$<br>故随机抽样 $x\in [0,1]$，然后得出 $\theta&#x3D;P^{-1}(x)$。$\phi$ 这一项是均匀的， 在 $[0,2\pi]$ 上随机即可。注意pdf还需除以这个 $2\pi$</p><p>注意如此采样的是 $h$，随后可以进行反射得到 $wo$ 方向，此时还需要再次应用 $wh,wo$ 之间的变换比例：$pdf &#x2F;&#x3D; 4cos_{ih}$。</p><h5 id="对环境贴图重要性采样"><a href="#对环境贴图重要性采样" class="headerlink" title="对环境贴图重要性采样"></a>对环境贴图重要性采样</h5><p>以HDR环境贴图作为主要光源时，对其进行重要性采样。</p><p>首先将HDR贴图的颜色值归一化为概率密度</p><p>此时我们相当于有了一个函数 $pdf(x, y)$​，只不过没有解析式，求不出cdf，那就只能二分了。</p><p>可以求出边缘密度函数 $F_x(x)&#x3D;F(x,\infty)$，它相当于前缀和，我们可以在[0,1]间均匀抽样，然后在 $F_x$ 上面二分得到采样的 $x$</p><p>然后在 $x$ 列上求出每个 $y$ 的条件概率密度 $f_{Y|X}(y)$，在这个东西的CDF上同理二分得到 $y$。</p><p>在GPU中二分实在太慢，我们可以先预处理一个二维缓冲，在这个缓冲中以 $(u,v)$ 采样的值对应上述过程中，随机数为 $u,v$ 时采得的 $x,y$ 坐标。同时还需要传递这个位置的pdf，一共三个浮点数，正好利用三个通道。</p><p>显然这个cache和原图的关系基本上是“连续”的，被插值了也没有关系。</p><p>关于pdf：谨记它表示的是这个值被采样到的概率，而非此次采样发生的概率，不可忽略。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenGL入门</title>
    <link href="/2023/02/26/openGL%E5%85%A5%E9%97%A8/"/>
    <url>/2023/02/26/openGL%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://learnopengl-cn.github.io/">https://learnopengl-cn.github.io/</a></p><p>基本是跟着这个网站来的，感谢大佬们提供了这么好的资源</p><h4 id="OpenGL-状态机"><a href="#OpenGL-状态机" class="headerlink" title="OpenGL 状态机"></a>OpenGL 状态机</h4><p>熟悉这种状态机的模式非常有帮助。</p><p>openGL中的各种对象通常通过 <code>glGenXXX</code> 来生成，对象用一个uint来标识，openGL内部会记录这个uint对应的对象内容，我们只需把这个数看做一个对象即可。</p><p>绑定，openGL中常需要进行 <code>glBindxxx</code> 操作，这是将对象绑定到一个<strong>上下文</strong>，如 <code>glBindBuffer(GL_ARRAY_BUFFER, VBO)</code>，可以认为 <code>GL_ARRAY_BUFFER</code> 是一个上下文，有时也称 <code>Target</code>，绑定后，接下来对 <code>GL_ARRAY_BUFFER</code> 的操作就是对 <code>VBO</code> 的操作。</p><h4 id="VBO，VAO"><a href="#VBO，VAO" class="headerlink" title="VBO，VAO"></a>VBO，VAO</h4><p>首先关注他们的名字：</p><ul><li>顶点缓冲对象：Vertex Buffer Object，<strong>VBO</strong></li><li>顶点数组对象：Vertex Array Object，<strong>VAO</strong></li></ul><p>每个顶点可能会包含一堆数据（常见的有坐标，颜色等），CPU需要把这些数据发送给显卡，为了一次性发送大量数据，会使用一个缓冲来暂存顶点数据，这就是VBO，它仅仅只是一堆本质上没区别的数据，具体如何访问这些数据，就是VAO决定的。</p><p>可以认为，VAO对VBO的数据定义了一种分类，组装的方式，将一堆数据拼成了有意义的一个数组，VAO就是把这种访问方式保存下来。</p><p>具体而言，我们可以创建一个VBO来保存东西：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO;<span class="hljs-comment">//glGenXXX就是创建一个对象，为其分配空间</span><span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;VBO);<span class="hljs-comment">//将VBO绑定上缓冲GL_ARRAY_BUFFER，可以理解为设置状态：当前存储顶点的位置是VBO</span><span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<span class="hljs-comment">//往一个缓冲中塞数据，这时的VBO已经绑定GL_ARRAY_BUFFER，这样就能保存在这个VBO当中</span><span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(dataSource), dataSource, GL_STATIC_DRAW);</code></pre></div><p>这样就有一块纯纯的数据了，可以用下面两行东西来指定这块东西的解读方式：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//设置对数据的解读方式</span><span class="hljs-comment">//首先，每个顶点属性有一个属性值（标号）（即vertexShader中的layout）</span><span class="hljs-comment">//这里的意思是：对于属性值为0的属性，它要读取3个float，不需要标准化，下一个顶点的对应属性在3个步长之后，从0开始读。</span><span class="hljs-comment">//然后设置：将属性值为0的顶点属性启用（默认是禁用的）</span><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);</code></pre></div><p>然后就能一行完成渲染啦！第一个参数为图元装配方式，指定为三角形，也就是说会把我们输入的顶点，每三个组成一个三角形传入片元着色器。从0位置开始，一共读3个顶点</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);</code></pre></div><p>因为openGL是一个大状态机，在渲染不同物体时，必须绑定对应的VBO，更改对应的解读方式才行。这样换起来太麻烦了，于是有了VAO：它能把这些都保存起来，然后直接绑定VAO就能自动绑定上VBO和切换glVertexAttribPointer。为什么它叫<strong>顶点数组对象</strong>呢？我理解为，它获取到一块数据和对应的解读方式，就直接将顶点分类包装成数组了。它具体存储的是什么，目前理解比较浅。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VAO;<span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>, &amp;VAO);<span class="hljs-built_in">glBindVertexArray</span>(VAO);...<span class="hljs-built_in">glBindVertexArray</span>(<span class="hljs-number">0</span>);</code></pre></div><p>VAO是工作在bind和unbind之间的，也就是说，在glVertexAttribPointer之前，先将VAO绑定，然后VAO将记录你执行的glVertexAttribPointer，保存这一解读方式（同时也保存了当前绑定的VBO），记录完成后解绑VAO即可。渲染时如果要调用这组数据，直接绑定这个VAO就可以了，将自动设置glVertexAttrib Pointer和VBO，非常方便。</p><p><img src="https://learnopengl-cn.github.io/img/01/04/vertex_array_objects.png"></p><h5 id="更多顶点属性"><a href="#更多顶点属性" class="headerlink" title="更多顶点属性"></a>更多顶点属性</h5><p>如果顶点包含两个属性：位置和颜色，在顶点着色器中分别将属性值设置为0和1</p><p>属性值只是一种标号，和内存地址无关</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#version 330 core</span><span class="hljs-built_in">layout</span> (location = <span class="hljs-number">0</span>) in vec3 aPos;   <span class="hljs-comment">// 位置变量的属性位置值为 0 </span><span class="hljs-built_in">layout</span> (location = <span class="hljs-number">1</span>) in vec3 aColor; <span class="hljs-comment">// 颜色变量的属性位置值为 1</span></code></pre></div><p>然后是VBO中的数据，里面有三个顶点：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">float</span> vertices[] = &#123;    <span class="hljs-comment">// 位置              // 颜色</span>     <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// 右下</span>    <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// 左下</span>     <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>    <span class="hljs-comment">// 顶部</span>&#125;;</code></pre></div><p>对于这样的情况，解读方式应该是：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//位置属性</span><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">6</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//颜色属性</span><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">6</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)(<span class="hljs-number">3</span>* <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">1</span>);</code></pre></div><p>注意：属性长度仍然是3，两个属性都只需要读3float的数据，步长是6，因为一个位置属性和下一个位置属性间隔6float，颜色属性的偏移为3，即起始点从3开始，6格6格跳</p><h5 id="EBO-索引缓冲"><a href="#EBO-索引缓冲" class="headerlink" title="EBO 索引缓冲"></a>EBO 索引缓冲</h5><p>实际绘制物体时，可以用一个个小三角拼成，比如要拼一个正方形，顶点数组可以这样：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">float</span> dataSource2[] = &#123;        <span class="hljs-number">0.9f</span>, <span class="hljs-number">0.9f</span>, <span class="hljs-number">0.0f</span>,        <span class="hljs-number">0.9f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,        <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,        <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,        <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.9f</span>, <span class="hljs-number">0.0f</span>,        <span class="hljs-number">0.9f</span>, <span class="hljs-number">0.9f</span>, <span class="hljs-number">0.0f</span>&#125;;</code></pre></div><p>图元装配时指定装配6个顶点，可以轻松得到一个正方形，它是两个三角形拼起来的</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);</code></pre></div><p>但是这样显然有大量冗余，所谓索引缓冲对象，就是指定了遍历顶点的方式，默认是从0..n这样遍历的，</p><p>我们可以指定遍历顺序。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> indices[] = &#123; <span class="hljs-comment">// 注意索引从0开始!</span>        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-comment">// 第一个三角形</span>        <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>  <span class="hljs-comment">// 第二个三角形</span>&#125;;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> EBO;<span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;EBO);<span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);<span class="hljs-built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</code></pre></div><p>这里用和VBO相似的方式，配置了一个EBO，同样地，这个信息可以被VAO存储，只需要写在VAO的bind和unbind之间即可。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES, <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);</code></pre></div><p>把绘图函数改成这个，即可按照当前绑定在GL_ELEMENT_ARRAY_BUFFER上的索引表来遍历。</p><h4 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h4><p>主要编写的是顶点着色器和片段着色器</p><p>顶点着色器必须给出一个<code>gl_Position</code>，它表示这个顶点所在的位置（在<strong>标准化设备坐标</strong>下的，实际参与渲染的位置，不是什么局部坐标世界坐标之类的）</p><p>顶点着色器的其他各种输出信息在光栅化阶段会被各种“插值”，变成大量片元输出到片元着色器。比如经典的：用三个顶点坐标显示一个宏观的三角形，实际上片元着色器接受到的片段有成百上千个，但我们仅输入了三个顶点，每一个片段的具体位置均是根据插值得到的。</p><p>同时，各种其他顶点输出的信息也都会被插值，比如颜色等等。</p><p>片段着色器负责计算一个像素的最终颜色，它可能需要从顶点着色器中接收一些</p><h5 id="uniform"><a href="#uniform" class="headerlink" title="uniform"></a>uniform</h5><p>着色器中可以使用uniform定义一个唯一的变量，在外部通过一些操作更改（实现外部直接把值传入shader任意一个阶段）</p><div class="code-wrapper"><pre><code class="hljs glsl"><span class="hljs-keyword">uniform</span> <span class="hljs-type">float</span> offX = <span class="hljs-number">0</span>, offY = <span class="hljs-number">0</span>;</code></pre></div><p>外部，传入名称和值即可，glUniform后+数字+类型，如3f表示更改的是一个3维float向量类型</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">glUniform1i</span>(<span class="hljs-built_in">glGetUniformLocation</span>(shaderProgram, name), value);</code></pre></div><p>外部获取这个值？没有找到资料，可能从外部获取它的值本就不合逻辑</p><p>uniform不能在shader内部赋值，但可以初始化（设置缺省值）</p><h5 id="特殊的uniform"><a href="#特殊的uniform" class="headerlink" title="特殊的uniform"></a>特殊的uniform</h5><div class="code-wrapper"><pre><code class="hljs c++">uniform sampler2D texture1;</code></pre></div><p>用于获取纹理，它的值可以用int方式更改，如果它为2，那么它就表示GL_TEXTURE2这个纹理单元上的纹理图片，在shader中使用 <code>texture(texture1, Texpos) </code>获得这张纹理具体位置上的颜色。</p><p><code>sampler2D</code> 是一种“不透明类型”，它不能被实例化，只能定义为uniform。</p><p>包含有不透明类型的结构体、类同样为不透明类型。</p><p><strong>注意：</strong>虽然 <code>glUseProgram</code> 指明了shaderprogram，但仍必须use着色器之后才能对其设置！</p><h4 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h4><p><code>Texture unit</code>（<code>GL_TEXTUREi</code>） 包含了多种 Target，但规范明确表示了，每个sampler必须使用不同的unit，即便它们的类型不同。</p><h4 id="完整管线"><a href="#完整管线" class="headerlink" title="完整管线"></a>完整管线</h4><p>顶点进入顶点着色器，经历局部坐标 - 世界坐标 - 观察坐标，变换到观察空间</p><p>随后通过一个投影矩阵，这个投影矩阵定义了空间中一块能看见的区域（长方体、平头截体），投影矩阵将这片区域映射到 $[-1,1]^3$ 这个小立方体中，我们最终只绘制这个小立方体内的物体。</p><p>这个小立方体就是裁剪空间，也叫<strong>标准设备坐标系，NDC</strong>。后续操作在这个坐标系中进行。</p><p>我们在上面的变换中一直认为 $(a,b,c,1)$ 和 $(aw,bw,cw,w)$ 是同一个坐标，转换到NDC之后该归一化一下了，这一步也叫透视除法，就是让每个顶点的 $x,y,z$ 都除以它的 $w$ 分量，$w$ 分量本身保持不变，是为了保留其深度信息以做矫正。</p><p>然后进行一个简单的视口变换，在 $xy$ 方向拉伸平移一下，不去动 $z$。</p><p>在此之前我们一直对顶点操作，接下来进行图元装配，经过几何着色器我们得到了三角形（或者其他形状）</p><p>对三角形进行光栅化，随后每个像素（片段）进入片段着色器，用插值后的数据来计算这个像素的最终颜色并输出。</p><p>随后进行深度测试，丢弃一些片段，通常也可以在着色一个像素前就测试并丢弃。</p><p>上述视口变换和图元装配，顺序应该无所谓。</p><h4 id="理清变换"><a href="#理清变换" class="headerlink" title="理清变换"></a>理清变换</h4><p>理清的关键点：</p><ul><li><p>使用四阶矩阵，不仅能表达一种变换，也能表达一种<strong>坐标系</strong>。左上三维为三个基向量，右列三个数为原点位置，右下角为 $w$ 分量</p><ul><li>可以视为先进行了左上3x3矩阵所示的线性变换，再进行了一个平移</li></ul></li><li><p>对于每个物体，用一个<strong>Transform</strong>矩阵表达其坐标系，它也相当于物体从和世界坐标系重合（单位矩阵）开始，到当前状态经历的变换。对物体的变换都是对整个坐标系的变换</p><ul><li>这个变换看起来不是线性变换（移动了原点），但在四维空间下，它是线性变换。</li><li>如果想让物体参照世界坐标系变换，就直接在其矩阵左侧乘即可。</li><li>如果想让物体参考自身坐标系变换，可以运用相似矩阵（相当于矩阵右侧乘）</li></ul></li><li><p>对于单个顶点，才用向量表示，它在物体坐标系下是一个固定的量。</p></li><li><p>相机可以认为是一个物体，它有一个坐标系，它的朝向是一个向量，相对于相机坐标系也固定的，在openGL中应为 $(0,0,-1)$（朝 $z$ 轴负方向）</p><ul><li>因此也可以用一个简单的矩阵来描述相机，不必关心其朝向，因为我们直接记录了相机坐标系，朝向固定为 $(0,0-1)$</li></ul></li></ul><h4 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h4><p>当我们把一个光照施加到一个物体上时，输出光照颜色和物体颜色的乘积（各个分量各自相乘）即可，注意这里的颜色量值域为(0, 1)，而非(0, 255)</p><p>冯氏光照模型主要分三部分：环境光照，漫反射，镜面反射</p><p><strong>环境光照</strong>：始终使物体接受到某个光照，例如(0.1, 0.1, 0.1)</p><p><strong>漫反射</strong>：对于每个片元，取其法向量和光照方向的点积（二者都标准化到模为1）作为光照强度，即正对光照的亮度高，背对的亮度低。（这个阶段我们一般不考虑阻挡、距离等因素）</p><p><strong>镜面反射</strong>：对每个片元，取其光照反射方向（通过法向量计算）和玩家视觉方向的点积，作为光照强度，意义是玩家在某个片元反射方向附近时，能看到它上面的高光。</p><p>点积的两个向量都为标准化向量，故结果不大于1，为了更加凸显高光可以对这个值取幂，一般取32次幂为宜，越大则说明高光越集中，反射能力越强。</p><p>注意镜面反射仅与观察者位置有关，与观察者视角无关</p><h4 id="法线"><a href="#法线" class="headerlink" title="法线"></a>法线</h4><p>直观上来讲，一个三角形的法线可以直接由三条边计算出来，但openGL并不会直接帮我们算这个，是有原因的。</p><p>法线信息一般放在顶点上，若模型没给定，可以由面法线均值计算得到。</p><p>片元法线如果由插值得到，可以获得平滑的光照效果，而如果三个顶点法线都一样，则可以有锐利边缘。</p><h5 id="法线变换"><a href="#法线变换" class="headerlink" title="法线变换"></a>法线变换</h5><p>物体变换时法线也应该跟着变，法线和一般的顶点位置向量不同，在不等比缩放时，它应当保持<strong>垂直</strong>关系而非进行相同变换；它也不应受位移影响。</p><p>简单数理推导可得出，法线变换矩阵应当是<code>变换矩阵左上3x3矩阵的逆矩阵的转置</code></p><p>逆矩阵运算对于GPU来说非常慢，故最好在CPU中计算好直接传入。</p><h4 id="材质和光照贴图"><a href="#材质和光照贴图" class="headerlink" title="材质和光照贴图"></a>材质和光照贴图</h4><p>材质即物体的贴图+上述光照模型中的参数，通过更改三种光的强度以及反光度可以模拟不同物体的反射效果。</p><p>并不是每一个参数都值得更改，一般的材质：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Material</span>&#123;    sampler2D diffuse;    vec3 specular;    <span class="hljs-type">float</span> spininess;&#125;;</code></pre></div><ul><li>环境光颜色与漫反射颜色 &#x3D; 物体自身颜色，通常没必要更改，强度差别取决于光照设定</li><li>镜面光颜色 &#x3D; 白 * 一定系数，这个系数决定了镜面光的亮度。<ul><li>也可以用物体自身颜色，这会使高光更接近物体自身颜色，使用白色则高光更接近光源颜色。</li></ul></li><li>反光度&#x2F;镜面反射率决定了表面反光能力，越大则反光越强，高光越集中，越适用于金属玻璃等材质。</li></ul><p>材质参考：<a href="http://devernay.free.fr/cours/opengl/materials.html">http://devernay.free.fr/cours/opengl/materials.html</a></p><p>光照材质：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Light</span>&#123;    vec3 position;    vec3 ambient;    vec3 diffuse;    vec3 specular;&#125;;</code></pre></div><p>环境光、漫反射、镜面反射的配比取决于我们对光照的设定。通常镜面颜色设置为光源本身颜色，漫反射和环境光设置为光源颜色的0.6, 0.2倍左右。</p><h5 id="光照贴图"><a href="#光照贴图" class="headerlink" title="光照贴图"></a>光照贴图</h5><p>可以给物体附上多张贴图，在漫反射部分使用漫反射贴图，镜面反射部分使用高光反射贴图，实现同一个物体表面不同部分的不同效果。</p><h4 id="网格与模型"><a href="#网格与模型" class="headerlink" title="网格与模型"></a>网格与模型</h4><p>网格这个名词一开始让我有点搞不明白，后来我意识到一件事情：3d模型是十分复杂的，除了基本的顶点数据之外，还可能包含多张贴图、动画、多种材质乃至场景信息，不同部分可能应用不同贴图。</p><p>“网格”就是一组三角面片，包含一个顶点数组和相应贴图，即先前我们理解中最简单的模型，一个实际的模型包含许多网格。</p><p>模型除了用网格表示外，还有点云、体素等多种方式。本项目只考虑网格。</p><p>模型文件格式众多，可以使用工具库assimp读取，需要了解的是大多数模型存储的逻辑：使用一个模型文件记录网格信息，在旁边放贴图等资源文件，模型文件中包含了<strong>贴图相对路径</strong>等信息。故通常不能将下载到的模型和资源文件拆开。</p><h4 id="缓冲与测试"><a href="#缓冲与测试" class="headerlink" title="缓冲与测试"></a>缓冲与测试</h4><p>openGL提供了若干种缓冲（临时数组），我们通常在每一帧绘制前使用 <code>glClear</code> 清空这些缓冲。</p><p>深度测试和模板测试可以根据缓冲内容选择性地抛弃一些片元，可以用 <code>glEnable</code> 启用测试，也有各自的函数来配置筛选方法、写入掩码等等。</p><p>深度缓冲和模板缓冲都以屏幕位置为索引，它们在每一次绘制前被清空，绘制内容时被更新，从而影响接下来的绘制。简而言之它们是面向整个场景而非单个物体的。</p><h5 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h5><p>记录屏幕坐标下每个位置上的片元深度（$z$ 坐标），一般情况下，仅当新片元深度更小时才会绘制并更新。可以用 <code>glglDepthFunc</code> 配置其他的筛选方式。</p><p>关于深度：强大的裁剪矩阵已经帮我们计算好了每个片元的 $x,y$ 位置以及深度，深度测试其实就是记录每个位置的最大深度以及颜色。它使用的缓冲我们需要手动清空 <code>glClear(GL_DEPTH_BUFFER_BIT);</code>，记得 <code>glClear</code> 是用bitmask的，可以把 <code>GL_DEPTH_BUFFER_BIT</code> 和其他东西或起来。</p><p>裁剪矩阵对 $z$ 轴的映射也不是线性的，越远的地方粒度越大，精度越低。</p><p>具体而言，映射后的深度值（也叫深度精度值？）是与 $1&#x2F;z$ 正相关的，如近平面距离为2，远平面距离为10，则深度值0.5实际对应了 $\frac{1}{1&#x2F;2+1&#x2F;10}$ 即距离2.5的地方。</p><p>片段着色器中，<code>gl_FragCoord</code>这个内建变量存储了该片段的深度信息，$x,y,z$ 分别表示片段的位置和深度。</p><h5 id="深度冲突"><a href="#深度冲突" class="headerlink" title="深度冲突"></a>深度冲突</h5><p>如果两个平面恰好重叠在一起，就很难说明谁上谁下了，常常会导致闪烁，实际渲染中应当尽量避免此类情况。</p><h5 id="模板测试"><a href="#模板测试" class="headerlink" title="模板测试"></a>模板测试</h5><h4 id="面剔除"><a href="#面剔除" class="headerlink" title="面剔除"></a>面剔除</h4><p>一种非常聪明的技巧。</p><p>试想：在我们观察一个<strong>封闭几何体</strong>的时候，总有几个面是永远看不到的（是指背面，而非里面），对于这几个面，虽然用深度缓冲能覆盖他们，但还不够优秀，我们有办法把它更早一步剔除掉。</p><p>如果我们在定义一个面的顶点顺序时，始终假设我们面向它（从封闭几何体的外部），然后逆时针写下这三个顶点。</p><p>那么在三角形变换到裁剪空间下后，如果它还是面向我们，三个顶点就一定是逆时针的，否则就一定是顺时针，可以直接将其剔除。</p><p>判断顺逆时针是个运算量很小的活，所以面剔除能非常有效地提升性能。</p><p>面剔除的结果：在封闭几何体的内部观察时，它透明了。如果我们对一个单独的三角形进行面剔除，会发现只能从一个方向上看到它，这些特性有时也会被利用到。</p><p>它可能很像是剔除了一个面的<em>里面</em>，但我们都知道图形学本身没有什么内外双面的概念，只是剔除了背面而已。</p><h4 id="透明与混合"><a href="#透明与混合" class="headerlink" title="透明与混合"></a>透明与混合</h4><p>将半透明的物体绘制到原有颜色缓冲上，需要进行混合。</p><p>通常将颜色缓冲中原有的内容叫目标，即将绘制的半透明颜色叫源，将源绘制到目标上。</p><p>问题：深度测试，处于前方的透明物体先绘制之后，后面的内容将不会绘制。</p><p>解决：透明物体最后绘制，且按到视点的距离排序，由远到近绘制。</p><p>问题：距离不好排序，通常采取近似方法，适用于大部分场合。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>openGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几何笔记</title>
    <link href="/2023/02/26/%E5%87%A0%E4%BD%95%E6%9D%82%E8%AE%B0/"/>
    <url>/2023/02/26/%E5%87%A0%E4%BD%95%E6%9D%82%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="隐式几何表示"><a href="#隐式几何表示" class="headerlink" title="隐式几何表示"></a>隐式几何表示</h3><p>往往通过一个方程来定义，不够直观，但存储量小，运算简单。</p><h3 id="显示几何表示"><a href="#显示几何表示" class="headerlink" title="显示几何表示"></a>显示几何表示</h3><p>要么直接定义，要么通过一些参数来定义。</p><h4 id="点云"><a href="#点云" class="headerlink" title="点云"></a>点云</h4><p>一堆点，要构成面需要极大的密度。</p><p>通常用于三维扫描，后续再通过其他方法将点云转化为其他表示方法。</p><h4 id="多边形网格"><a href="#多边形网格" class="headerlink" title="多边形网格"></a>多边形网格</h4><p>使用三角形或其他多边形表示（最常用）</p><h4 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h4><p>通过参数来显示表示几何的实例</p><p>几何意义：很好理解但不太好描述，百度找图（</p><p>代数表示（用参数 $t$ 来表示时间&#x2F;比例，$t\in [0, 1]$）推导：</p><ul><li>有 $n+1$ 个控制点 $b_{0..n}$，控制一条 $n$ 次贝塞尔曲线。</li><li>首先对于任意点 $A$（非两边的点），在一次取点过后，会将 $tA$ 分配到一边，$(1-t)A$ 分配到另一边。</li><li>那么一个点 $A$ 最终能分配到答案中多少，可以看做是一个金字塔状的路径选取的问题。</li><li>然后就不难从中发现二项式了。</li><li>最终结论为：$ans &#x3D; \sum_{i&#x3D;0}^{n}C_n^ib_it^i(1-t)^{n-i}$</li></ul><p>贝塞尔曲线性质：</p><ul><li>仿射变换不变性：对贝塞尔曲线仿射变换，等价于对几个控制点仿射变换后再生成贝塞尔曲线</li><li>贝塞尔曲线始终在控制点的凸包内</li><li>贝塞尔曲线的阶次等于控制点数-1，曲线的起点&#x2F;终点与第一个&#x2F;最后一个控制点重合。</li></ul><p>分段贝塞尔曲线</p><p>贝塞尔曲线的一大缺点是没有局部控制能力，任一控制点的变化都会影响到整个曲线（B样条曲线能解决这个问题），有时也会用分段贝塞尔曲线解决。</p><p>如PS的钢笔工具就是每段使用四个控制点，每段画三次贝塞尔曲线（Cubic Bezier Curve）</p><p>两端段贝塞尔曲线交接的部分，相交处的控制点连线若平行，即可平滑连接，若连线长度也相同，就能使二阶导数也连续。</p><p>显然，曲线应当可以表示成关于 $t$ 的 $n$ 阶多项式 $G(t)$</p><p>例如对于 $n &#x3D; 3$，$G(t)&#x3D;(1-t)^3b_0+3t(1-t)^2b_1+3t^2(1-t)b_2+t^3b_3$<br>$$<br>\begin{bmatrix}<br>-1&amp;3&amp;-3&amp;1\<br>3&amp;-6&amp;3&amp;0\<br>-3&amp;3&amp;0&amp;0\<br>1&amp;0&amp;0&amp;0<br>\end{bmatrix}<br>\times<br>\begin{bmatrix}<br>b_0\<br>b_1\<br>b_2\<br>b_3<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>p_3\<br>p_2\<br>p_1\<br>p_0<br>\end{bmatrix}<br>$$<br>我们可以用矩阵计算得出各次系数 $p$，$G(t)&#x3D;p_3t^3+p_2t^2+p_1t+p_0$，此处的系数为一个vec2。</p><p>后面我们可以把其他形式的曲线（如B样条）也写成这种矩阵形式，然后轻松在两者之间转化。</p><h4 id="B样条曲线"><a href="#B样条曲线" class="headerlink" title="B样条曲线"></a>B样条曲线</h4><p>三次B样条曲线的矩阵表达如下：<br>$$<br>\frac1{6}\begin{bmatrix}<br>-1&amp;3&amp;-3&amp;1\<br>3&amp;-6&amp;3&amp;0\<br>-3&amp;0&amp;3&amp;0\<br>1&amp;4&amp;1&amp;0<br>\end{bmatrix}<br>\times<br>\begin{bmatrix}<br>b_0\<br>b_1\<br>b_2\<br>b_3<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>p_3\<br>p_2\<br>p_1\<br>p_0<br>\end{bmatrix}<br>$$</p><h4 id="贝塞尔曲面"><a href="#贝塞尔曲面" class="headerlink" title="贝塞尔曲面"></a>贝塞尔曲面</h4><p>以4x4控制点为例：先将四列分别画出贝塞尔曲线，然后每一行取出四个点作为新贝塞尔曲线的控制点，得到一行贝塞尔曲线，扫出一个曲面。</p><p>贝塞尔曲面可以用参数 $u,v$ 来表示。</p><h4 id="网格细分"><a href="#网格细分" class="headerlink" title="网格细分"></a>网格细分</h4><p>用于将网格变得更平滑，本质上是一种模糊操作，并没有更多的信息量。在已有网格能大致表示物体轮廓时，用网格细分使得它更平滑。</p><h5 id="Loop-细分"><a href="#Loop-细分" class="headerlink" title="Loop 细分"></a>Loop 细分</h5><p>Loop是人名</p><p>细分：在每条三角形边上取一个新的顶点，形成 4 倍顶点。</p><p>调整：对顶点位置进行一个“模糊”，思路如下：</p><p>对于新顶点，它在两个三角形的重边上，设重边上的两个点为 $A,B$，重边对的两个点为 $C,D$，新顶点的位置为 $3&#x2F;8\times (A+B)+1&#x2F;8 \times (C+D)$</p><p>系数取决于调参经验，总之就是加权平均。</p><p>对于原顶点，它由相邻的原顶点和自身加权平均得来，具体设 $n$ 为度数，$u$ 为相邻顶点的比例系数，通常设 $u &#x3D; 3&#x2F;(8n)$，特别当 $n&#x3D;3$ 时设 $u&#x3D;3&#x2F;16$</p><p>最终位置为 $(1-nu)ori+u\sum adj$</p><h5 id="Catmull-Clark细分"><a href="#Catmull-Clark细分" class="headerlink" title="Catmull-Clark细分"></a>Catmull-Clark细分</h5><p>多边形网格的细分</p><p>每轮细分在每条线上产生一个点，每个面上也产生一个点。</p><p>以一定的权值来调整新点的位置。</p><p>其特点是：经过一轮变换后，所有面都会变成四边形。</p><h4 id="网格简化"><a href="#网格简化" class="headerlink" title="网格简化"></a>网格简化</h4><p>在尽可能保留信息的前提下简化网格，常用于LOD。</p><h5 id="边坍缩"><a href="#边坍缩" class="headerlink" title="边坍缩"></a>边坍缩</h5>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>光线追踪入门</title>
    <link href="/2023/02/26/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%85%A5%E9%97%A8/"/>
    <url>/2023/02/26/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="光线与平面求交"><a href="#光线与平面求交" class="headerlink" title="光线与平面求交"></a>光线与平面求交</h4><p>光线可以表示为 $r&#x3D;o+td$，其中 $o$ 为原点，$d$ 为方向。</p><h5 id="隐式表面"><a href="#隐式表面" class="headerlink" title="隐式表面"></a>隐式表面</h5><p>隐式表面定义为 $f(p)&#x3D;0$</p><p>则求解 $f(o+td)&#x3D;0$ 即可，取 $t$ 最小值（$t&gt;0$）对应处作为交点。</p><h5 id="显示表面"><a href="#显示表面" class="headerlink" title="显示表面"></a>显示表面</h5><p>光线与三角形求交：</p><p>首先计算光线与三角形所在平面的交点，然后计算点是否在三角形内。</p><p>平面的方程：$f(p)&#x3D;(p-p’)\cdot N&#x3D;0$，$p’$ 为平面上任意点，$N$ 为平面的任意垂线，而从三角形得出这样的平面参数很简单。</p><p> 另一种方式：列出三角形面的方程（重心坐标），得到 $O+tD&#x3D;(1-u-v)P_0+uP_1+vP_2$，它可以写作一个线性方程组，解得 $t,u,v$，然后判断重心坐标是否都在 $[0,1]$ 内。</p><p>此处碰撞得到的 $u,v$ 可以记录下来，之后用这个坐标获取表面材质信息。</p><h4 id="AABB"><a href="#AABB" class="headerlink" title="AABB"></a>AABB</h4><p>轴对齐包围盒（Axis-Aligened Bounding Box）</p><p>求光线与包围盒是否相交：包围盒有三个对面，计算光线与每对面相交的两个 $t$ 值（$t_{min}$ 和 $t_{max}$），得到三组 $t$ 的区间，这三组的区间的交集即为光线在盒子中的时间。</p><h4 id="Grid方法"><a href="#Grid方法" class="headerlink" title="Grid方法"></a>Grid方法</h4><p>旧方法</p><p>将区域划分为很多个格子，计算每个格子中是否有物体，光线进入时可以采用类似Bresenham的方法计算接触的格子（很快），若格子中有物体再检测。</p><h4 id="空间划分方法"><a href="#空间划分方法" class="headerlink" title="空间划分方法"></a>空间划分方法</h4><h5 id="八叉树"><a href="#八叉树" class="headerlink" title="八叉树"></a>八叉树</h5><p>每次划分都划分为8块，直到区域不包含内容或者足够小</p><h5 id="KD-Tree"><a href="#KD-Tree" class="headerlink" title="KD-Tree"></a>KD-Tree</h5><p>每次仅将区域划分为2块，采用某种策略选取最优的划分位置和方向。</p><p>划分的方向还是平行的</p><p>中间节点都是包围盒，物体都存在叶子节点中。</p><p>一个图元可能被划分到多个空间中，此时这个图元就需要在多个空间中都进行求交。</p><h5 id="BSP-Tree"><a href="#BSP-Tree" class="headerlink" title="BSP-Tree"></a>BSP-Tree</h5><p>在KD-tree的基础上，划分方向可以是斜的，划分效果可能更好，但抛弃了AABB，计算效率并不优秀。</p><h5 id="BVH"><a href="#BVH" class="headerlink" title="BVH"></a>BVH</h5><p>Bounding Volume Hierarchy</p><p>基于物体的划分，而非基于空间的划分。</p><p>和KD-Tree差不多，但是划分时不再是将空间一刀划开，而是将其中物体分为两个部分，两个部分各自形成一棵子树，两个子树的包围盒<strong>可以重叠</strong>，这使得每个图元可以仅属于一棵子树。</p><p>实现起来非常容易，可以直接根据父包围盒三维的长度，在最长的一维上，按三角形个数划分（一半划到左一半划到右，$O(n)$ 找出中位数即可）。</p><p>递归求交时，严格意义上来说两个子空间是没有先后顺序的，即使在一个空间内找到了交点，另一个必须求交计算，这使得朴素BVH求交效率会低于kd-tree。我们很容易想到一些剪枝：根据包围盒的交点决定顺序，若在第一个空间中已经得到交点，且在第二个空间的包围盒交点之前，则跳过。</p><h6 id="SAH优化"><a href="#SAH优化" class="headerlink" title="SAH优化"></a>SAH优化</h6><p>按三角形个数进行的划分有显而易见的问题，当出现特别大时三角形时，划分不那么均匀，重叠部分也可能非常大。</p><p>SAH (Surface Area Heuristic) 优化即按照包围表盒面积来确定一个最优的划分方案。粗略认为，一个包围盒被击中的概率与其面积成 $S$ 正比，而击中这个包围盒之后的开销，又可以粗略认为和其中的物体数 $N$ 成正比。于是SAH策略要求我们找到 $S_1N_1+S_2N_2$ 最小的划分策略。</p><p>需要排序，前后各扫一遍预处理出包围盒之后，尝试所有划分点即可（三个轴各自来一次）。</p><h4 id="Radiometry"><a href="#Radiometry" class="headerlink" title="Radiometry"></a>Radiometry</h4><h5 id="立体角"><a href="#立体角" class="headerlink" title="立体角"></a>立体角</h5><p><code>steradians</code></p><p>二维角度的标准定义（弧度）：$\theta&#x3D;\frac{l}{r}$，弧长&#x2F;半径</p><p>三维立体角的定义：$w &#x3D; \frac{A}{r^2}$，弧面面积&#x2F;半径方</p><p>单位立体角：</p><p>在球面上 $(\theta,\phi)$ （通常 $\theta$ 指与z轴的夹角，$\phi$ 指在xy平面上投影的经典一维角度）处，画图容易计算弧面的微分<br>$$<br>d_A&#x3D;(rd_\theta)(rsin_\theta d_\phi)<br>$$<br>则有单位立体角（微分立体角）<br>$$<br>d_w&#x3D;\frac{d_A}{r^2}&#x3D;sin_\theta d_\theta d_\phi<br>$$<br>立体角积分：<br>$$<br>\theta\leq \pi,\phi\leq 2\pi\<br>\int_{\Omega^+}d_w&#x3D;\int_0^{2\pi}\int_0^{\pi} sin_\theta d_\theta d_\phi&#x3D;4\pi<br>$$</p><p>这里具体要看球面坐标怎么定义，知道原理即可。</p><h5 id="辐射度量学"><a href="#辐射度量学" class="headerlink" title="辐射度量学"></a>辐射度量学</h5><p>$\phi$：辐射通量，单位时间发出的能量 $\phi&#x3D;\frac{dQ}{dt}$，类似功率。通量也可以理解为单位时间通过的光子数量。单位有流明 <code>lumen</code></p><ul><li>渲染中我们通常不会用到 $Q$，通常都是以 $\phi$ 来衡量能量。</li></ul><p>$I$：Intensity，点光源发出的，在单位立体角上的Power，$I&#x3D;\frac{d\phi}{dw}$，或 $I&#x3D;\frac{\phi}{4\pi}$</p><p>$E$：Irradiance，每单位面积接受到的Power，$E&#x3D;\frac{d\phi}{dA}$，这个量仅用来衡量单位面积上接收到的通量，并关心光是从什么方向入射的。</p><ul><li>点光源自由发散时，随距离增大，Intensity不变（单位立体角上的光强没变），接受方的Irradiance按 $r^2$ 衰减。</li></ul><p>$L$：Radiance，单位面积在单位立体角上的辐射Power $L&#x3D;\frac{d^2\phi}{d_wd_Acos_\theta}$</p><ul><li>$E &#x3D; \int_{\Omega^+} Lcos_\theta d_w$，这里看出，$E$ 是从表面角度来考虑的，而 $L$ 是从光线角度考虑的。</li></ul><p>关于Radiance，我在很长一段时间里没能理解它的本质，从而对无法自己推导出BRDF的公式。另一件事情也同样困惑了我很久：直接光照下，光源距离物体越远，照明效果越差；而在路径追踪中，我们计算来自下一次反射的 $L_i$ 时，却根本不考虑下一个Bounce距离我们有多远。更进一步，人眼无论距离物体多远，看到的颜色都一样，应该怎么解释？</p><p><img src="http://lxtyin.ac.cn/img/Gemo/radiance.png"></p><p>如果只看前两幅图，会觉得计算 $L_i$ 必然要考虑到双方之间的距离，并且处理起来很困难。同时还面临着“发射方的L和接收方的L是一个东西吗？”的疑问。</p><p>但当微分立体角无限小，$dA$ 无限小时，$L$ <strong>就是</strong>一根光线（不存在近似，这是一个 $\frac{x}{\infty}$ 的问题）。它无论传输到近处还是远处，只要距离是有限的，都一样。</p><p>有了这个想法，一切都迎刃而解了：$L$ 是衡量光线的一个物理量，它<strong>不会随着传输距离而损耗</strong>。那么，发射方的Radiance和接收方的Radiance得以统一，Radiance成为了我们路径追踪中，最适合用于衡量光线能量的物理量。</p><p>人眼看到物体的颜色与距离无关，也可以用上述理论阐述：视网膜上任意微面 $dA$ 接收到的Radiance没有变，变了的只是物体在视网膜上成像的面积。</p><p><strong>错误认识</strong>：物体发出很多根光线，随着距离增大，光线会变稀疏（Radiance变小）。</p><p>在 $d_w$ 无限细分的情况下，光线有无数根，在有限的距离下，Radiance不变。这是一个 $\frac{\infty}{x}$ 的问题。</p><h4 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h4><p>$$<br>L_o(p,w_o)&#x3D;L_e(p,w_o)+\int_{\Omega^+}L_i(p,w_i)f_r(p,w_i\rightarrow w_o)cos\theta_idw_i<br>$$<br>其中，$w$ 表示一个方向，$dw$ 为这个方向上的微分立体角。</p><p>$w_r$ 方向上的辐射，等于自身在这个方向的发光（辐射）加上所有其他方向 $w_i$ 入射的光反射对 $w_r$ 的贡献。$f_r(p,w_i\rightarrow w_r)$ 是一个BRDF方程，定义了一个方向的入射光对另一个方向出射光的贡献，通过定义不同的BRDF方程可以实现不同的材质。</p><p>渲染方程是递归定义的，是<strong>正确的</strong>，这里的正确指它完全符合现实世界，但我们实现时还是需要用到一点近似，或者说仅仅实现“<strong>期望上正确</strong>”。</p><h4 id="蒙特卡洛方法"><a href="#蒙特卡洛方法" class="headerlink" title="蒙特卡洛方法"></a>蒙特卡洛方法</h4><p>随机采样。</p><p>通用形式（使用任何分布的概率来采样），近似地求 $f(x)$ 的定积分，定积分域蕴含在随机变量 $X$ 中。<br>$$<br>\frac{1}{N}\sum_{i&#x3D;1}^N \frac{f(X_i)}{p(X_i)}<br>$$<br>渲染方程应用蒙特卡洛方法之后（这里暂时忽略了自发光）：<br>$$<br>L_o(p,w_o)&#x3D;\frac{1}{N}\sum_{i&#x3D;1}^N \frac{L_i(p,w_i)f_r(p,w_i\rightarrow w_o)(n\cdot w_i)}{p(w_i)}<br>$$</p><p>注意：上式考虑到了 $X$ 的概率密度，故一定要按照 $X$ 的分布来抽样，而不能人为干预，否则结果的期望就不正确了。</p><h5 id="多种策略下应用蒙特卡洛方法"><a href="#多种策略下应用蒙特卡洛方法" class="headerlink" title="多种策略下应用蒙特卡洛方法"></a>多种策略下应用蒙特卡洛方法</h5><p>采样蒙特卡洛方法可以使用任何分布的概率，都正确，而使用特殊的分布可以加速收敛（准确来说，能够降低采样结果的方差）。重要性采样即对贡献较大的方向以更高的概率采样。</p><p>还可以将直接光与间接光的贡献分开统计，但这里要注意期望的正确性，不能违背蒙特卡洛方法的概率性原则，否则会收敛于一个错误结果。</p><ul><li><p>对于面积光源的采样，具体见下</p></li><li><p>对于点光源的采样，很麻烦，一般使用一个小面片代表点光源。</p><ul><li>一种错误的思路是直接加上点光源方向的贡献（设pdf&#x3D;1），因为随机的间接光方向击中光源点的概率为0</li><li>这种思路下，点光源距离物体的距离不影响点光源的贡献，显然是错误的。根本在于点光源在半球上的占比没有随着距离的增大而缩小。</li></ul></li><li><p>对于环境光源，一种想法是将其单纯作为背景色，另一种策略是对其进行重要性采样，某种意义上相当于对直接光照单独考虑。</p></li></ul><h5 id="蒙特卡洛方法的要求"><a href="#蒙特卡洛方法的要求" class="headerlink" title="蒙特卡洛方法的要求"></a>蒙特卡洛方法的要求</h5><p>虽然概率分布可以随意，但也要注意一点：</p><ul><li>所有 $f(x)\gt 0$ 的地方，需要有 $p(x)\gt 0$。<ul><li>（我并没有找到这个定义，但自己想想是显然的）</li></ul></li></ul><p>可以随便举个极端例子，如只在前半段有概率，后半段无，那么结果的期望当然是不正确的。这本质是因为出现了未定义的 $\frac{0}{0}$，被当做了0处理。</p><p>不过，在 $f(x)&#x3D;0$ 的地方，是可以有 $p(x)&#x3D;0$ 的。</p><h4 id="路径追踪"><a href="#路径追踪" class="headerlink" title="路径追踪"></a>路径追踪</h4><p>问题：即使随机采样，还是会出现指数爆炸的问题</p><ul><li>N &#x3D; 1，仅反射一次，这样得到的图像会有大量噪声。<ul><li>每个像素发出多根光线以平均</li><li>后期去噪</li></ul></li></ul><p>问题：无限递归</p><ul><li>当然可以简单设置反弹次数，但不够好</li><li>轮盘赌法：设置一个概率 $p$，以概率 $p$ 往外反弹一次，得到的结果再除以 $p$，这样可以维护期望不变，场景亮度是真实的。</li></ul><p>优化：直接光照、间接光照划分</p><ul><li><p>思路：将直接光照和间接光照分开计算（分别划分到球面上的一块区域，各应用用蒙特卡洛方式积分）</p></li><li><p>因直接光照贡献较大，随机一条直线很可能碰不到直接光，故单独计算。</p><ul><li><p>面光源：在立体角上的采样改为<strong>在光源面上</strong>的采样。我们将光源面投影到立体角，得到映射关系 $dw &#x3D; \frac{cos\theta’}{|x’-p|^2}dA$，其中 $x’$ 是在光源面上的抽样，$\theta’$ 是 $xx’$ 连线与光源面法线的夹角，直接光照的贡献为：<br>$$<br>L_o’&#x3D;AL_i(p,w_i)f_r(p,w_i\rightarrow w_o)cos\theta\frac{cos\theta’}{|x’-x|^2}<br>$$</p></li><li><p>这是在光源面上均匀抽样了一个点，概率为 $1&#x2F;A$，然后将对 $w$ 的积分改为对 $A$ 的积分。可以发现，这里实际上还蕴含了 $r^2$ 的距离衰减。</p></li><li><p>$xx’$ 连线若中间撞到其他物体，则直接光贡献为0</p></li><li><p>点光源很难处理，一般可以使用微小的面光源代替</p></li></ul></li><li><p>计算间接光照，若随机到的方向撞上了光源，则贡献为0</p></li></ul><p><img src="http://lxtyin.ac.cn/img/Gemo/tracing1_1.png"></p><p>这里我将球面看做ABC三部分，直接光照求B+C段的蒙特卡洛积分，但将C段贡献视为0；间接光照求A+B+C段的蒙特卡洛积分，但将B段贡献视为0，故直接光照与间接光照相加，恰好为整个球面上的积分。至此，路径追踪仍然保持了<strong>期望上的正确性</strong>。</p><p>这种每个交点都求一次直接光照贡献的方法其实就是所谓的NEE (Next Event Estimation)。</p><h5 id="调试策略"><a href="#调试策略" class="headerlink" title="调试策略"></a>调试策略</h5><p>单纯的蒙特卡洛方法无疑是正确的，但在加上<strong>影响概率</strong>的各种操作后（如主动向光源、折射方向采样）时，就比较难保持正确性。</p><p>我曾在应用多光源时采用了错误的办法，然后调了很久都调不出想要的效果…最后发现是概率在不经意间被我改变了，，，错误的方法可能导致收敛于一个错误的结果。</p><p>个人经验：想要快速判断自己的策略在期望上是否正确，可以简单地用最朴素的蒙特卡洛方法渲染一次（均匀采样，不加任何trick），只要渲染久一点，就能看到正确的效果是什么样的。</p><h4 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h4><p>我们已经知道怎么在蒙特卡洛路径追踪中对面积光源进行采样，并且体现出“光源的照明效果与距离相关”这件事，对于点光源，如果我们之间加上特定方向的一根光线采样，点光源的距离不会影响照明，结果显然是不对的。</p><p>在mitsuba中，面积光源的强度单位是 Radiance，而点光源的单位是 Intensity，显然这不是随意命名的。这是辐射度量学的命名。点光源没有面积，无法用Radiance衡量表面亮度，因此用Intensity，相应的，在计算点光源贡献时，到达的 Radiance &#x3D; Intensity &#x2F; dis ^ 2</p><h4 id="降噪"><a href="#降噪" class="headerlink" title="降噪"></a>降噪</h4><h5 id="当前帧滤波"><a href="#当前帧滤波" class="headerlink" title="当前帧滤波"></a>当前帧滤波</h5><ul><li>模糊操作：高斯滤波</li><li>保留一些高频的，边缘信息：双边滤波<ul><li>将颜色距离因素加入到滤波中去，如果两像素颜色差距较大，则减小贡献。</li></ul></li><li>如何分辨边缘与噪声？额外信息：<strong>G-Buffer！</strong></li></ul><p>既然我们掌握了渲染的全过程，很容易得到一些如法线图、Albedo图，<strong>它们完全没有噪声</strong>。</p><p>类似双边滤波，我们可以将各种其他G-Buffer Feature添加到滤波中来加以指导，它们能非常有效地区分噪声和图像边缘，非常有效。</p><p>于是我们得到了<strong>联合双边滤波</strong> <code>Joint Bilateral Filtering</code></p><p>outlier&#x2F;fire fly：蒙特卡洛方法容易产生一些过亮的点，也许要非常多sample才能将其平均下来；通常为了提速（并不物理正确），可以将其clamp掉。在滤波时，常将过高的颜色值clamp到 $[u-k\sigma,u+k\sigma]$ 上，同理Tempora中，也可以这么做。</p><h5 id="TAA"><a href="#TAA" class="headerlink" title="TAA"></a>TAA</h5><p><a href="https://zhuanlan.zhihu.com/p/425233743">https://zhuanlan.zhihu.com/p/425233743</a> 这篇讲得很好</p><p>求一个 <code>Motion Vector</code>，即当前帧的像素，在上一帧的屏幕中的位置，以此混合历史像素。</p><p>混合时，可能有种种情况使得相同位置在当前帧与上一帧颜色不同（动态光源、动态物体、阴影变化等），可以利用GBuffer进行一些简单的判断来排除一些情况，但很难完全避免（例如阴影变化，就没什么很好办法能解决）。UE4的策略是利用当前帧像素的周围九个像素，计算出当前帧色彩的大致范围（可以计算颜色空间（通常转移到YCgCo下进行）的AABB来实现），混合历史帧时，clamp&#x2F;clip在该范围外的信息。</p><p>另一种策略也是使用周围九宫格像素，但不直接计算包围盒，而是计算均值与方差，使用以均值为中心、若干个方差为宽度的AABB。</p><p>方差在降噪中是一个很重要的信息，降噪很多时候就是在噪声与overblur之间权衡，而方差可以指导我们动态地进行这种权衡，在噪声更严重的区域进行激进的降噪。</p><h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h4><p><code>pixel reconstruction filter</code></p><p><code>Metropolis Light Transport</code></p><p><code>Photon Mapping</code></p><p><code>Radiosity Matrix</code> </p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>Raytracing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网实验复习</title>
    <link href="/2022/11/30/2022-11-30-%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/11/30/2022-11-30-%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="Cisco命令汇总"><a href="#Cisco命令汇总" class="headerlink" title="Cisco命令汇总"></a>Cisco命令汇总</h3><h5 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h5><p>前缀标识</p><div class="code-wrapper"><pre><code class="hljs 1c">&gt;<span class="hljs-comment">//指示当前为用户模式</span><span class="hljs-meta">#<span class="hljs-comment">//特权模式</span></span>(config)<span class="hljs-meta"># <span class="hljs-comment">//配置模式</span></span>(config-if)<span class="hljs-meta"># <span class="hljs-comment">//接口配置</span></span>(config-subif)<span class="hljs-meta"># <span class="hljs-comment">//子接口配置</span></span>(config-if-range)<span class="hljs-meta">#<span class="hljs-comment">//多接口配置</span></span>(config-vlan)<span class="hljs-meta">#<span class="hljs-comment">//vlan配置</span></span></code></pre></div><p>一般默认都在配置模式下进行，show相关命令一般在特权模式下进行。</p><div class="code-wrapper"><pre><code class="hljs fsharp">enable <span class="hljs-comment">//进入特权模式</span>configure terminal <span class="hljs-comment">//进入配置模式</span>exit <span class="hljs-comment">//退出一层</span>vlan [<span class="hljs-built_in">id</span>]<span class="hljs-comment">//创建并进入vlan配置 (config-vlan)#</span><span class="hljs-keyword">interface</span> [<span class="hljs-built_in">id</span>]<span class="hljs-comment">//进入接口配置  (config-if)#</span><span class="hljs-keyword">interface</span> range fa0<span class="hljs-operator">/</span><span class="hljs-number">1</span><span class="hljs-number">-5</span><span class="hljs-comment">//进入多个接口的配置模式，可以对一组同时进行</span>no xxx<span class="hljs-comment">//删除xxx（xxx是任一种创建/添加命令）</span></code></pre></div><h5 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h5><div class="code-wrapper"><pre><code class="hljs css">mac-<span class="hljs-selector-tag">address</span>-<span class="hljs-selector-tag">table</span> static <span class="hljs-selector-attr">[mac]</span> vlan <span class="hljs-selector-attr">[vlan_id]</span> interface <span class="hljs-selector-attr">[fa_id]</span>//添加静态mac<span class="hljs-attribute">clear</span> mac-<span class="hljs-selector-tag">address</span>-<span class="hljs-selector-tag">table</span> dynamic//清空动态Mac，后面可以跟一些筛选（vlan <span class="hljs-selector-attr">[id]</span>，interface <span class="hljs-selector-attr">[id]</span>, <span class="hljs-selector-tag">address</span> <span class="hljs-selector-attr">[mac]</span> 等）show mac-<span class="hljs-selector-tag">address</span>-<span class="hljs-selector-tag">table</span>//查看mac地址表</code></pre></div><div class="code-wrapper"><pre><code class="hljs awk">vlan [id]  <span class="hljs-regexp">//</span>创建vlanshow vlan brief   <span class="hljs-regexp">//</span>查看vlanshow interface trunk<span class="hljs-regexp">//</span>查看trunk端口</code></pre></div><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-comment">//在接口配置模式下(config-if)</span><span class="hljs-selector-tag">switchport</span> <span class="hljs-selector-tag">mode</span> <span class="hljs-selector-tag">access</span>/<span class="hljs-selector-tag">trunk</span> <span class="hljs-comment">//切换端口为access模式</span><span class="hljs-selector-tag">switchport</span> <span class="hljs-selector-tag">access</span> <span class="hljs-selector-tag">vlan</span> <span class="hljs-selector-attr">[vlan-id]</span><span class="hljs-comment">//给端口分配vlan</span><span class="hljs-selector-tag">switchport</span> <span class="hljs-selector-tag">trunk</span> <span class="hljs-selector-tag">native</span> <span class="hljs-selector-tag">vlan</span> <span class="hljs-selector-attr">[vlan-id]</span><span class="hljs-comment">//给trunk端口设置默认vlan</span><span class="hljs-comment">//设置trunk端口允许的vlan</span><span class="hljs-selector-tag">switchport</span> <span class="hljs-selector-tag">trunk</span> <span class="hljs-selector-tag">allowed</span> <span class="hljs-selector-tag">vlan</span> &#123; <span class="hljs-keyword">all</span> | <span class="hljs-selector-attr">[add| remove | except]</span> <span class="hljs-selector-tag">vlan-list</span> &#125;</code></pre></div><h5 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h5><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>在端口配置模式下ip address [ip][mask]<span class="hljs-regexp">//</span>为端口配置IPno shutdown<span class="hljs-regexp">//</span>打开端口，默认是关闭的，用到的端口都需要打开interface gig0<span class="hljs-regexp">/0/</span><span class="hljs-number">0.1</span><span class="hljs-regexp">//</span>进入子端口配置模式ip route [prefix] [mask] [ip] <span class="hljs-regexp">//</span>设置静态路由show ip route<span class="hljs-regexp">//</span>查看路由信息</code></pre></div><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-comment">//端口配置模式下</span><span class="hljs-selector-tag">ip</span> <span class="hljs-selector-tag">nat</span> <span class="hljs-selector-tag">inside</span>/<span class="hljs-selector-tag">outside</span><span class="hljs-comment">//设为内/外端口(nat)</span><span class="hljs-selector-tag">ip</span> <span class="hljs-selector-tag">nat</span> <span class="hljs-selector-tag">inside</span> <span class="hljs-selector-tag">source</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-attr">[local-ip]</span> <span class="hljs-selector-attr">[global-ip]</span><span class="hljs-comment">//配置静态nat地址转换</span><span class="hljs-selector-tag">ip</span> <span class="hljs-selector-tag">nat</span> <span class="hljs-selector-tag">inside</span> <span class="hljs-selector-tag">source</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">tcp</span> <span class="hljs-selector-attr">[local-ip]</span> <span class="hljs-selector-attr">[loacl-port]</span> <span class="hljs-selector-attr">[global-ip]</span> <span class="hljs-selector-attr">[global-port]</span><span class="hljs-comment">//配置静态nat地址带tcp端口转换</span><span class="hljs-selector-tag">access-list</span> <span class="hljs-selector-attr">[id]</span> <span class="hljs-selector-tag">permit</span>/<span class="hljs-selector-tag">deny</span> <span class="hljs-selector-tag">any</span><span class="hljs-comment">//设置访问控制列表</span><span class="hljs-selector-tag">ip</span> <span class="hljs-selector-tag">nat</span> <span class="hljs-selector-tag">pool</span> <span class="hljs-selector-attr">[name]</span> <span class="hljs-selector-attr">[start-ip]</span> <span class="hljs-selector-attr">[end-ip]</span> <span class="hljs-selector-tag">netmask</span> <span class="hljs-selector-attr">[mask]</span><span class="hljs-comment">//设置地址池</span><span class="hljs-selector-tag">ip</span> <span class="hljs-selector-tag">nat</span> <span class="hljs-selector-tag">inside</span> <span class="hljs-selector-tag">source</span> <span class="hljs-selector-tag">list</span> <span class="hljs-selector-attr">[access-list-id]</span> <span class="hljs-selector-tag">pool</span> <span class="hljs-selector-attr">[pool-name]</span><span class="hljs-comment">//配置动态地址转换条目</span><span class="hljs-selector-tag">ip</span> <span class="hljs-selector-tag">nat</span> <span class="hljs-selector-tag">inside</span> <span class="hljs-selector-tag">source</span> <span class="hljs-selector-tag">list</span> <span class="hljs-selector-attr">[access-list-id]</span> <span class="hljs-selector-tag">pool</span> <span class="hljs-selector-attr">[pool-name]</span> <span class="hljs-selector-tag">overload</span><span class="hljs-comment">//配置动态地址转换条目（超载）</span><span class="hljs-selector-tag">ip</span> <span class="hljs-selector-tag">nat</span> <span class="hljs-selector-tag">inside</span> <span class="hljs-selector-tag">source</span> <span class="hljs-selector-tag">list</span> <span class="hljs-selector-attr">[access-list-id]</span> <span class="hljs-selector-tag">interface</span> <span class="hljs-selector-attr">[inter-name]</span> <span class="hljs-selector-tag">overload</span><span class="hljs-comment">//不使用地址池，使用外部接口IP的各个端口来分配。（只能是Outside接口）</span><span class="hljs-selector-tag">show</span> <span class="hljs-selector-tag">ip</span> <span class="hljs-selector-tag">nat</span> <span class="hljs-selector-tag">statistics</span><span class="hljs-selector-tag">show</span> <span class="hljs-selector-tag">ip</span> <span class="hljs-selector-tag">nat</span> <span class="hljs-selector-tag">translations</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>单臂路由，在端口配置模式下no ip address<span class="hljs-regexp">//</span>去掉端口IP，转化为干道模式（用子接口）。注意不需要跟ip和maskno shutdown <span class="hljs-regexp">//</span>父端口打开即可，子端口不需要额外no shutdown<span class="hljs-regexp">//</span>在子端口配置模式下<span class="hljs-regexp">//</span>配置本端口对应的vlan，封装<span class="hljs-number">802.1</span>Q（单臂路由）<span class="hljs-regexp">//</span>子端口需要先执行这一句话，才能配置ip.encapsulation dot1q [vlan-id]</code></pre></div><h5 id="三层交换机"><a href="#三层交换机" class="headerlink" title="三层交换机"></a>三层交换机</h5><div class="code-wrapper"><pre><code class="hljs awk">vlan [vlan_id]<span class="hljs-regexp">//</span>创建vlaninterface vlan [vlan-id] <span class="hljs-regexp">//</span>进入虚接口，虚接口同样需要配置ip address，但无需no shutdownip routing<span class="hljs-regexp">//</span>开启路由功能</code></pre></div><h3 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h3><p>绞线</p><p>TCP&#x2F;UDP</p><p>ARP&#x2F;TCP报文格式</p><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>应用层协议，工作在UDP协议之上。</p><p>服务端使用UPD：67作为端口，客户机使用UDP：68作为端口，约定俗成。</p><p>工作前，本机还没有IP：</p><ul><li><p>客户端发送DHCP DISCOVER，源0.0.0.0（空），目的255.255.255.255（广播）</p><ul><li>DHCP包中加了自己的MAC</li><li>所有DHCP服务器接受到这个消息都会尝试提供一个IP，但还不确定客户是否接收。</li></ul></li><li><p>因为客户端还没有IP，服务器也只能通过广播方式回应，发送DHCP OFFER，源为服务器IP，目的255.255.255.255，数据包中包含了提供的IP地址（your ip address）。</p><ul><li>数据包中还会包含客户端的MAC地址等信息，这确实是一个广播，但只有特定目标才会接收。</li></ul></li><li><p>客户端选择收到的首个DHCP OFFER，为了严谨期间还不能直接用上这个IP，发送DHCP REQUEST，源为0.0.0.0，目的255.255.255.255，告知所有服务器自己所选择的IP。</p><ul><li>这里虽然已经知道了服务器的IP信息，但需要让其他没被选的服务器也知道，故还是广播。</li><li>包中也填写了选中的DHCP服务器，服务器若发现自己未被选择，则回收IP。</li></ul></li><li><p>服务器收到REQUEST，再次发送广播（因为客户还是没有定IP）DHCP ACK包来确认，客户接到ACK之后获得该IP。</p><ul><li>同样的，这个广播中包含了目的MAC信息。</li></ul></li></ul><p>总结：全是广播，在没有IP的时候通过广播 + MAC地址的方式确认对方，避免混淆。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>域名解析系统</p><p><code>www.baidu.com</code> 域名右侧等级最高，例如 <code>com</code> 是顶级域名服务器；<code>baidu.com</code> 是权威域名服务器，每个域名服务器都知道自己下面的所有服务器地址，如 <code>baidu.com</code> 直接知道 <code>www.baidu.com</code> 的地址。</p><p>根域名服务器知道所有顶级域名服务器的地址。用户查询时首先查询首选DNS服务器，它不知道则从根域名服务器开始递归或迭代查询（根域名服务器全球只有13个，地址大家都知道）</p><p>递归查询即询问时对方需要返回最终结果，迭代查询即对方返回下一个地址，用户机再去重新查。</p><p>Ping 域名</p><ul><li>unknown host… 无法解析</li><li>request time out 可以解析，但ping不通</li></ul><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>应用层协议，基于TCP协议之上。</p><p>工作步骤：</p><ul><li>客户端解析URL</li><li>客户端发送HTTP请求</li><li>服务端响应HTTP页面</li></ul><p>HTTP请求（Request）格式：</p><div class="code-wrapper"><pre><code class="hljs mathematica">请求行：方法<span class="hljs-operator">-</span><span class="hljs-built_in">URL</span><span class="hljs-operator">-</span><span class="hljs-variable">HTTP</span>版本请求报头：<span class="hljs-built_in">Key</span>：<span class="hljs-built_in">Value</span><span class="hljs-built_in">Key</span>：<span class="hljs-built_in">Value</span><span class="hljs-operator">...</span>（空行）正文</code></pre></div><p>HTTP基于TCP，而TCP基于字节流，这个空行标志请求报头的结束。</p><p>请求方法很多，常用GET&#x2F;POST用于获取和发送数据。</p><p>习惯上，GET请求通常没有正文，通过url提出请求，而POST通过正文将需要传的数据提交。</p><p>URL格式见下文</p><p>HTTP响应（Response）格式：</p><div class="code-wrapper"><pre><code class="hljs mathematica">请求行：版本号<span class="hljs-operator">-</span>状态码<span class="hljs-operator">-</span>状态解释请求报头：<span class="hljs-built_in">Key</span>：<span class="hljs-built_in">Value</span><span class="hljs-built_in">Key</span>：<span class="hljs-built_in">Value</span><span class="hljs-operator">...</span>（空行）正文</code></pre></div><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>（计网应该不考但我觉得非常有必要了解）</p><p><code>http://user:pass@www.baidu.com:80/dir/index.htm?uid=1&amp;count=2#ch1</code></p><p><code>http</code> 所用协议</p><p><code>user:pass@</code> 用户（登录信息），<code>用户名@地址</code> 是很常用的一种指示格式</p><p><code>www.baidu.com:80</code> 域名&#x2F;地址 + 端口号</p><p><code>/dir/index.htm</code> 文件路径</p><p><code>?uid=1&amp;count=2</code> 查询字符串，把一串键值对写进URL</p><p><code>#ch1</code> 文档片段，例如博客查看markdown常用这个定位</p><h3 id="交换机-1"><a href="#交换机-1" class="headerlink" title="交换机"></a>交换机</h3><p>交换机是数据链路层设备，可以在同一网络下基于MAC地址通信。</p><p>交换机存储一张MAC地址表，记录每个MAC对应的端口，它可以静态配置也可以动态分配学习。</p><p>静态分配：由用户直接设置，是稳固的，不会随时间或链接变化而被删除的。</p><p>动态学习：</p><ul><li><p>当 A $\rightarrow$ B 发送一条消息，交换机首先更新A的MAC地址和端口的对应信息。</p></li><li><p>若交换机MAC地址表中没有B的MAC信息，则向所有端口发送（泛洪）</p><ul><li>注意，交换机的泛洪和广播不一样，它并不期待B作出任何回应，只是简单地向所有端口发送。</li><li>设备对MAC地址自然有所过滤，接到的消息不匹配时会丢弃。</li><li>在B主动发送一条信息出来时，交换机才会更新B的信息。</li></ul></li><li><p>动态分配的信息具有时效，一段时间后会被删除。</p></li></ul><p>MAC地址中，除了表示单个设备的MAC地址外还有组播和广播mac地址，它们表示多个设备。以太网中MAC最高字节的最低位设为1表示这是一个组播地址，其中<code>ff.ff.ff.ff.ff.ff</code>是广播地址。</p><p>MAC地址表中可以有多MAC映射到一个端口，即多个设备连在一个端口（可能通过另一个交换机）</p><h5 id="以太网帧"><a href="#以太网帧" class="headerlink" title="以太网帧"></a>以太网帧</h5><p>最常用的Ethernet2帧，依次包含目的地址、源地址、类型、数据、FCS检测。</p><p>交换机帧转发方式：</p><ul><li>直通转发：收到帧头后找到MAC就转发。</li><li>无碎片直通转发：交换机读取前64个字节后开始转发。</li><li>存储转发：接收完整的帧，检验后丢弃错误的帧再转发。</li></ul><h3 id="vlan"><a href="#vlan" class="headerlink" title="vlan"></a>vlan</h3><p>普通的局域网即使用路由器链接多个子网，可能会很大，vlan就是将大型局域网划分成小型局域网的技术。</p><p>vlan：虚拟局域网，基于逻辑划分，地址无关，划分广播域以减少网络风暴。vlan是数据链路层的概念，一个vlan不能跨路由器。</p><p>vlan在交换机上配置，其中端口可以设为接入（Access）端口和干道（Trunk）端口</p><p>Access端口本身标记了vlan（基于端口划分），所以发送的帧不再带有vlan标签，故叫Untagged端口，一般用于连接计算机。</p><p>Trunk端口本身不限制vlan，允许多种vlan通过，故发送的帧需带有vlan标签。通常用于连接两个交换机。</p><p>Trunk端口也设有vlan缺省值，且连接两端的缺省值必须一致。</p><h4 id="IEEE-802-1Q协议"><a href="#IEEE-802-1Q协议" class="headerlink" title="IEEE 802.1Q协议"></a>IEEE 802.1Q协议</h4><p>概念，定义了基于端口的VLAN模型，规定如何标识带有VLAN成员信息的以太帧，以及格式。</p><p>IEEE 802.1Q帧是一条插入帧，插入到原有的以太网帧（源地址之后）中以表示vlan信息。</p><h4 id="vlan间通信"><a href="#vlan间通信" class="headerlink" title="vlan间通信"></a>vlan间通信</h4><p>vlan是二层概念，两个vlan已经是不同子网了，实现两个子网间的通信自然用到网络层。</p><h5 id="路由器多端口"><a href="#路由器多端口" class="headerlink" title="路由器多端口"></a>路由器多端口</h5><p>每个vlan使用一个路由器的端口，配置相应IP作为网关。相当于直接进行三层间的通行。</p><p>缺陷：vlan数量多而路由器端口数量少，另一个角度看，同一个路由器和交换机之间要连数条重边，显然是一种浪费。</p><h5 id="单臂路由"><a href="#单臂路由" class="headerlink" title="单臂路由"></a>单臂路由</h5><p>也是使用路由器，只是可以将路由器的一个接口分成更多的子接口（逻辑接口），来对应不同的vlan。</p><p>具体命令见文顶。</p><p>缺陷：路由器转发慢（对于上一个也是），容易单点故障。</p><h5 id="三层交换机-1"><a href="#三层交换机-1" class="headerlink" title="三层交换机"></a>三层交换机</h5><p>一种特殊的具备路由功能的交换机，对于大型局域网内的数据转发更快。</p><p>它可以在已有的vlan上建立<strong>虚接口</strong>，接口形式如下：</p><div class="code-wrapper"><pre><code class="hljs awk">vlan [vlan_id]<span class="hljs-regexp">//</span>创建vlaninterface vlan [vlan-id] <span class="hljs-regexp">//</span>进入虚接口</code></pre></div><p>在这些接口间路由，就实现了vlan间通信。</p><p>细节：</p><ul><li>多端口方式中，连接路由器的端口也需要设置为access，配置相应vlan；另两种方式都设置为Trunk端口。</li><li>三层交换机中实际连的端口随意，也不用配置。</li><li>Trunk端口设置后，若端口上没有连东西，<code>show interface trunk</code> 并不会显示端口，先连上后再查看就能正常显示。</li><li><code>no shutdown</code> 对正经接口打开即可，虚接口和子接口都不需要打开（当然子接口的父接口需要打开）</li></ul><h3 id="路由器-1"><a href="#路由器-1" class="headerlink" title="路由器"></a>路由器</h3><p>路由器根据<strong>目的网络</strong>的<strong>网络地址号</strong>来转发</p><p>存储有路由表，记录每个网络地址（子网号不需要，为0即可）对应的下一跳（next hop）</p><p>注意这个下一跳：是指下一个目的地的<strong>完整</strong>IP，而不是自身某个端口的IP。</p><p>默认：</p><p><code>0.0.0.0 255.255.255.0 x.x.x.x</code>：使用x.x.x.x访问所有掩码为24位的地址。</p><p><code>0.0.0.0 0.0.0.0 x.x.x.x</code>：使用x.x.x.x访问所有地址。</p><p>路由器的每个端口上配了IP，可以把路由器也看做一个主机，ping端口什么的都是可以通的。</p><p>主机上配的网关，实际意思是：如果目的在局域网外，我应该发给谁。</p><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>NAT的作用：</p><ol><li>保护IP地址</li><li>缓解IP告急情况</li></ol><p>NAT是如何工作的？（纯个人测试理解）</p><p>路由器的NAT表每条记录包含四个内容：Inside&#x2F;Outside Local&#x2F;Global</p><p>它的实际含义是：内部数据包的源&#x2F;目的为 Inside Local，Outside Local 应与外部数据包的 Inside Global 和 Outside Global 一一对应，NAT从中进行转换。</p><p>也就是说发送出去的IP作为Inside Local会被转换到Inside Global，发进来的反向转换。</p><p>通常我们不会转化Outside IP（交由对方的路由器上进行转换），故通常配置转换条目时只需要inside。</p><p>使用静态net直接向NAT表中插入一条数据，指示Inside Local和Inside Global，而使用动态net和超载net则会在使用时向net表中添加。</p><p>为内部主机配置NAT之后，在外部仍然通过内网IP去ping可以ping通（显示由Inside Global返回），而Web服务不能通。（推测是由于发出的返回的IP不匹配导致）</p><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>已知目的IP，求目的MAC地址。</p><p>ARP协议工作在网络层，与数据链路层相接，在向远端IP发送消息时，每层都会做一次ARP请求，获得网关的MAC后将数据包发送给路由器。</p><p>路由器再使用ARP进行下一步MAC地址的获取，如此向前推进。</p><p>远距离初次连接时常常Timeout几次大多是因为还没有任何ARP缓存，需要进行很多操作。</p><p>注意：抓ARP包时不能用 <code>ip.</code> 来筛选，因为它也是网络层的协议，不是IP协议。</p><p>合理的方式是使用 数据链路层协议中的mac来查找 <code>eth.addr</code></p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>需要注意的：</p><ul><li>首部长度要保留到4个字节的整数倍（看ppt图），故首部长度字段指示的是4字节数，如该值为8，说明首部长32个字节。</li><li>四次挥手中间两次都由服务端发出，开始关闭时发送第二次，关闭后发送第三次。</li><li>TCP三次握手和四次挥手的过程中，只有第一次不带有ACK标志，后续每次发送的ACK都指示上一次收到的SEQ+1，表示希望接到的下一个SEQ。</li><li>握手和挥手之间，数据传输部分，也是每次一发一回应，由于TCP是基于字节流的通信，可以通过维护ACK和SEQ来保持字节流的可靠。</li><li>为什么是三次握手？（个人理解）<ul><li>无论进行几次握手，都只有最后一次是冒险的（假设对方能收到我的消息并建立链接）</li><li>那么一定不能让服务端进行最后一次握手，这样失败的代价较高。也就是说握手次数最好是奇数次。</li><li>一次太少，五次太多，所以就三次。</li></ul></li></ul><p>另外用Wireshark查看Seq和Ack序号时，会有一个 <code>(raw)</code> 的和 <code>(relative sequence number)</code> 的，前一个表示原始的序号，后一个表示相对序号（从本次链接开始）</p><h3 id="WireShark-筛选规则"><a href="#WireShark-筛选规则" class="headerlink" title="WireShark 筛选规则"></a>WireShark 筛选规则</h3><p>基本格式 <code>协议.字段</code></p><p>如 <code>ip.addr</code> 指示IP协议地址，<code>eth.addr</code> 指示数据链路层协议的MAC地址，<code>tcp.port</code> 等</p><p>通常 <code>addr</code> 指示任意一方的地址，<code>src</code> 和 <code>dst</code> 指示源和目的。</p><p>逻辑符 <code>|| &amp;&amp; !</code></p><p>另外，启动时的筛选器和之后的筛选器似乎不一样？是一个前置的筛选，可以指示 <code>host x.x.x.x</code> 筛选主机</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉角、万向节锁、顺规</title>
    <link href="/2022/11/16/2022-11-16-%E6%AC%A7%E6%8B%89%E8%A7%92%E3%80%81%E4%B8%87%E5%90%91%E8%8A%82%E9%94%81%E3%80%81%E9%A1%BA%E8%A7%84%E9%97%AE%E9%A2%98%E7%9A%84%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3/"/>
    <url>/2022/11/16/2022-11-16-%E6%AC%A7%E6%8B%89%E8%A7%92%E3%80%81%E4%B8%87%E5%90%91%E8%8A%82%E9%94%81%E3%80%81%E9%A1%BA%E8%A7%84%E9%97%AE%E9%A2%98%E7%9A%84%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>最早接触四元数是unity3d里面的旋转，当时不太理解使用四元数的意义（在此时的我看来欧拉角已经可以完全表示一个朝向了），后来在旋转时出了很多莫名其妙的问题，发现有必要remake一下。</p><p>参考资料，感谢大佬们</p><p><a href="https://krasjet.github.io/quaternion/quaternion.pdf">https://krasjet.github.io/quaternion/quaternion.pdf</a></p><p><a href="https://www.bilibili.com/video/BV1SW411y7W1?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1SW411y7W1?spm_id_from=333.999.0.0</a></p><h4 id="为什么直接改欧拉角，效果经常与预期不符"><a href="#为什么直接改欧拉角，效果经常与预期不符" class="headerlink" title="为什么直接改欧拉角，效果经常与预期不符"></a>为什么直接改欧拉角，效果经常与预期不符</h4><p>现在考虑一个问题：在你修改欧拉角时，意味的到底是“<strong>绕自身坐标轴旋转</strong>”，还是“<strong>绕世界坐标轴旋转</strong>”？</p><p>在unity里面测试，多测测就会发现：既不是按自身也不是按世界，而是有时按自身有时按世界？？</p><p>如果你随便拿一支笔（不要用unity），用手先绕X轴旋转90度，再绕Y轴旋转90度；再反过来试一下，会发现得到的位置不一样了。</p><p>这是因为<strong>旋转不具有交换律</strong>，相应的矩阵乘法也不具有交换律。</p><h4 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h4><p>欧拉角需要区分为两种：动态欧拉角和静态欧拉角，他们都需要定义顺规。</p><p>静态欧拉角即绕世界静止坐标系旋转，动态欧拉角即绕自身坐标系旋转，前一个轴的旋转会影响下一个轴。</p><p>这里只分析动态欧拉角（我认为更好用）</p><h4 id="顺规"><a href="#顺规" class="headerlink" title="顺规"></a>顺规</h4><p>考虑这么一个问题：如何实现一个可以自由旋转的飞机（假设面向+Z轴，要求Yaw-Pitch-Roll）？</p><p>可以用三个嵌套（做父物体）的箱子，最里面的箱子可以直接用飞机本身，所有物体的坐标都是相对父物体的；</p><p>第一个箱子仅绕自身y轴旋转（实现Yaw），第二个仅绕自身x轴旋转（Pitch），第三个仅绕自身z轴旋转（Roll）</p><p>通过控制这三个箱子，我们可以用比较好理解的方式合理、正确地旋转飞机。</p><p>这样的箱子便是动态欧拉角中的<strong>万向节</strong>，上述例子其实就是一个顺规为<strong>YXZ</strong>的动态欧拉角。</p><p>注意：这个顺规如果改变的话，飞机的旋转就很奇怪了，这并不是因为其他顺规错了（在数学上都没错）</p><p>而是因为我们对飞机的自然直觉就是符合动态欧拉角下的Yaw-Pitch-Roll顺规的。</p><p>在遇到其他复杂旋转问题时也可以使用箱子嵌套的方式思考，然后得出一个理想的顺规。</p><p>至于万向节锁，个人认为并不是什么大问题（飞机头垂直向上时，Roll和Yaw结果相同），依旧符合我们的自然直觉，且可以通过Pitch化解。</p><h4 id="旋转矩阵表示"><a href="#旋转矩阵表示" class="headerlink" title="旋转矩阵表示"></a>旋转矩阵表示</h4><p>这里使用<strong>列向量</strong>。</p><p>我们通常用一个transform矩阵来表达一个物体的位置，大小，朝向信息。</p><ul><li>它表示的是物体从世界坐标的原点（没有缩放、平移、旋转）到当前状态经历的变换。</li><li>它能表示物体的<strong>坐标系</strong>。</li><li>更一般地，它是物体顶点从局部坐标变换到世界坐标时需要乘上的矩阵。</li></ul><h5 id="直接维护Transform"><a href="#直接维护Transform" class="headerlink" title="直接维护Transform"></a>直接维护Transform</h5><p>单独的旋转、平移、缩放矩阵形式在此不再多提及，它们直接应用在一个向量（点）上的意义非常明确。</p><p>假设有了一个物体，它的Transform为 $T$（已经经过了一些复杂变换），现要让这个物体继续进行某种位移，位移矩阵为 $V$</p><p>假如我们直接令 $T &#x3D;V\times T$，即在左侧乘，效果是怎么样的？</p><p>可以想象 $T$ 的右边还有个向量 $v$，考虑这单个 $v$ 的变换，它先变换 $T$，然后再位移 $V$，即最终效果为在世界坐标系下位移了 $V$，很好理解。</p><p>如果 $T&#x3D;T\times V$ 呢？</p><p>这个 $v$ 在所有原先的变换前，先进行了位移，然后再变换 $T$，相应的，这个<strong>位移本身</strong>也会被变换 $T$。</p><p>如果把变换前的 $T$ 看做一个坐标系，就可以说，这是在物体自身坐标系下位移了 $V$。</p><p>另一个角度，如果要在自身坐标系下位移，可以利用相似矩阵 $TVT^{-1}$，乘上原有的矩阵就变成 $TV$ 了。</p><p>总结：</p><ul><li>左边乘变换矩阵，相当于在世界（父）坐标系下变换</li><li>右边乘变换矩阵，相当于在自身坐标系下变换</li></ul><p>用旋转矩阵表示旋转不会遇到歧义、死锁的问题，缺点是占用空间大，运算量大（欧拉角使用3个数，四元数使用4个数，而旋转矩阵使用了16个数），另外不太直观。</p><h5 id="从Transform中看"><a href="#从Transform中看" class="headerlink" title="从Transform中看"></a>从Transform中看</h5><p>如果把Transform矩阵看成一个仿射变换和一个位移的组合（世界坐标下位移），通常我们说它是<strong>先仿射再位移</strong>得到的。</p><p>为什么？不是因为先位移不对，而是先位移的话，位移的量就不再是矩阵第四列的三个值了。我们说先仿射再位移，是基于位移量直接等于第四列的值来说的。</p><p>而从仿射矩阵中分解出缩放和旋转，需要另做一些计算。</p><p>我更喜欢用基向量、坐标系的方式来考虑矩阵，它的前三列分别表示了这个坐标系的三个基向量，最后一列表示这个坐标系原点的位置。</p><h4 id="四元数表示"><a href="#四元数表示" class="headerlink" title="四元数表示"></a>四元数表示</h4><p>$$<br>\newcommand{\vec}{\bold}<br>$$</p><p><a href="https://krasjet.github.io/quaternion/quaternion.pdf">https://krasjet.github.io/quaternion/quaternion.pdf</a> 推导的非常好</p><p>四元数表示为 $q&#x3D;[s, \vec v], \vec v&#x3D;[x,y,z]$，$q &#x3D; a+bi+cj+dk$</p><p>有三个虚部，满足关系：<br>$$<br>i^2 &#x3D; j^2 &#x3D; k^2 &#x3D; ijk &#x3D; -1<br>$$<br>可以推得 $jk&#x3D;i, ij&#x3D;k$ 等等关系</p><p>四元数乘法也按照多项式相乘规则，展开化简后可得：<br>$$<br>q_1 &#x3D; [s, \vec v], q_2 &#x3D; [t, \vec u]\<br>q_1 q_2 &#x3D; [st-\vec v\cdot \vec u, s\vec u+t\vec v + \vec v \times \vec u]<br>$$<br>如果两个四元数的实部都为0（纯四元数），则会得到：<br>$$<br>q_1q_2 &#x3D; [-\vec v\cdot \vec u, \vec v \times \vec u]<br>$$<br>下面直接给出结论：</p><p>对任意向量 $\vec v$，沿着轴 $\vec u$ 旋转 $\theta$ 度得到 $\vec v’$</p><p>可以构造四元数：$v &#x3D; [0, \vec v], q &#x3D; [cos(\frac{1}{2}\theta), sin(\frac{1}{2}\theta) \vec u]$</p><p>旋转可以用四元数乘法表示：<br>$$<br>[0, \vec v’] &#x3D; qvq^{<em>}<br>$$<br>其中 $q^</em>$ 即将虚部取反，实部不变。注意 $q$ 是一个单位四元数。</p><p>同样的，给定一个四元数，也可以轻松得到对应的旋转轴和角度。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数理基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XCPC退役记</title>
    <link href="/2022/11/14/2022-11-14-XCPC%E9%80%80%E5%BD%B9%E8%AE%B0/"/>
    <url>/2022/11/14/2022-11-14-XCPC%E9%80%80%E5%BD%B9%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>有关我大学算法竞赛生涯的一点回顾（流水账）</p><p>and 一点关于XCPC的感想&amp;入坑建议</p><hr><h4 id="大一（2020-2021）"><a href="#大一（2020-2021）" class="headerlink" title="大一（2020-2021）"></a>大一（2020-2021）</h4><h5 id="入坑"><a href="#入坑" class="headerlink" title="入坑"></a>入坑</h5><p>进商专之后唯一确定的要做是转专业，没什么其他规划</p><p>去面了一堆组织部门啥的，面科协的时候我提到高中有打过noip，马上就被一个学长拐来了集训队（</p><p>不久后的新生赛，靠啃老本拿了rk1，还记得当时写站神的防ak题的时候提交了这么一份代码：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    cout &lt;&lt; <span class="hljs-string">&quot;不会真的是ec最后一题吧，不会吧不会吧&quot;</span> &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>果然学长们在后台看见了，被群里爆破，节目效果拉满</p><p>然后经理（当时的大四学长）就拉我跟何大老（另一大一巨佬）组了个临时队去打ICPC济南（当时是名额多出来了用不完？怎么会事呢）果不其然被锤烂了</p><ul><li>ICPC 济南 铁</li></ul><p>经理随之退役，我也从那个时候开始认识到了差距</p><p>原来我那点破noip基础不值一提</p><p>​</p><h5 id="拜师"><a href="#拜师" class="headerlink" title="拜师"></a>拜师</h5><p>之后是集训队的一些活动，拜师啥的</p><p>我选了老会长（the胡）</p><blockquote><p>特别感谢the胡</p><p>大一我问他：XXX和XXX+比赛要参加不</p><p>他：没卵用</p><p>简单粗暴地帮我把弯路堵死，大学也因此少了很多迷茫</p><p>现在我成了大三，但新生问类似问题的时候，我也只会在那高情商，做不到像他那样直接</p><p>（另外胡是真的强orz</p></blockquote><p><a href="https://hukeqing.github.io/2020/12/21/acm/myACM/">胡kq两年前的退役记</a></p><p>​</p><h5 id="组队"><a href="#组队" class="headerlink" title="组队"></a>组队</h5><p>寒假跟何大佬用一个号打牛客寒假训练营</p><p>学长都建议我们早点抓来第三个人组队，并推荐了几个综合能力很强，GPA很猛的同学</p><p>我觉得这不行，然后抓来了洋神</p><p>事实已经证明了此次决策的正确性.jpg</p><p>​</p><h5 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h5><p>三个人想了半天确定了个比较无聊的队名：键盘滚脸 &#x2F; asdfghjkl</p><p>继续比赛</p><ul><li>校赛二等奖（被学长乱杀）</li><li>浙江省赛 铜</li><li>ICPC 银川 铜（偷鸡）</li></ul><p>银川第一次公费旅游，全程吃瓜看戏看宁理表演（具体瓜不在这边赘述了，搜一搜都有）</p><p>拿了铜，还蹭到了缪少他们金牌（校史首金）的庆功宴</p><p><img src="http://lxtyin.ac.cn/img/xcpc_retire/4.png"></p><p>当时自我感觉还挺良好，后来才意识到银川是究极偷鸡场，只偷到铜实在是有点浪费了</p><p>​</p><p>然后学长又说沈阳站多了一个名额没人去，问我们要不要去（？当时怎么名额这么富足）</p><p>于是又公费出游了，因为不太抱拿牌的希望，不好意思报销太多，就体验了一下22h的绿皮（</p><p><img src="http://lxtyin.ac.cn/img/xcpc_retire/3.png"></p><p>到了沈阳发现原来ICPC每年只能打两场，我们已经打了济南+银川了，于是临时变成打星</p><p>结果符合预期：</p><ul><li>ICPC 沈阳（打星）  铁</li></ul><p>纯铁牌变成了打星铁，赢！</p><p>滚榜滚到宁理TS1队 银牌的时候，全场爆发鼓掌，太乐了</p><p><a href="https://www.bilibili.com/video/BV13q4y1p7M1/?spm_id_from=333.337.search-card.all.click&vd_source=f3bceb9b12c557f0a9cdb5ac0d26fee6">当时的录像</a></p><p>​</p><p>回来后被隔离，在隔离点连麦打牛客多校</p><p>当时没意识到一点是：未来两年可能都没有那么多公费出游的机会了</p><p>​</p><hr><h4 id="大二（2021-2022）"><a href="#大二（2021-2022）" class="headerlink" title="大二（2021-2022）"></a>大二（2021-2022）</h4><h5 id="令人嫉妒的学弟2-0"><a href="#令人嫉妒的学弟2-0" class="headerlink" title="令人嫉妒的学弟2.0"></a>令人嫉妒的学弟2.0</h5><p>招新的时候拉我去讲旅游经历，给新生画大饼</p><p>然后招着招着发现21届新生有点强的离谱，各路oi爷层出不穷，2 * zj1&#x3D; + 1 * ah1&#x3D;，还有2&#x3D;和初中oi爷若干</p><p>更是有个进来就cf1800的（威神），那时候我还在1700上下横跳</p><p>然后加紧开卷，开学一个月后赶在大一佬之前上了紫，随后发了一个 <code>晚节保住.jpg</code></p><ul><li>2021&#x2F;09&#x2F;30 —— codeforces紫</li></ul><p>然后他就一路上橙了，还上了两个号</p><p>晚节不保</p><p>​</p><h5 id="2021新生赛"><a href="#2021新生赛" class="headerlink" title="2021新生赛"></a>2021新生赛</h5><p>鉴于这届太强，我们出题的时候决定往死里出。</p><p>我准备了几个预估在 <code>mid-hard</code> 到 <code>hard</code> 的题，其中一道俄罗斯方块出完之后发现自己不会做（</p><p>跟老会长（胡）一起研究了几天才把它搞出来，那时候就觉得新生赛上不可能有人做出来了。</p><p>“不错的毒瘤题，要了。”</p><p>结果组题的时候貌似选了不止一道 <code>very-hard</code>，新生赛最终结果是威神做出来n - 3题rk1，最后三个题都0AC</p><p>另外，那个俄罗斯方块至今为止，除了我跟老会长无人ac（555你们快去做很好做的</p><p>赛后：我们出了很多简单题的，组题人只选了最毒瘤的，别找我们.jpg</p><p>​</p><h5 id="比赛-1"><a href="#比赛-1" class="headerlink" title="比赛"></a>比赛</h5><p>大二的比赛是要准备冲好一点的奖牌了，然而赛前出了一点意外 我直接进医院躺了两周。</p><p>回来后一周就开始连着打比赛了：</p><ul><li>CCPC 桂林 铁</li><li>ICPC 上海 铁（寄）</li><li>ICPC 南京 铜</li></ul><p>连着打出两把铁是真的感觉要废了，那会就是生涯低谷吧。</p><p>甚至去重新做了一遍NOIP2018，想看看相比高中到底有无进步。</p><p>再输下去要输大一，然后没得输了。</p><p>之后的南京站卷成诸神黄昏（群友称之为小EC），卷到一块铜牌也算回了点信心。</p><p>​</p><p>另外，这些比赛全都变成了线上进行，再无公费出游（nmdyqsmsh414</p><p>​</p><h5 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h5><p>之后的寒假训练营，全实验室的大二大三被威神乱杀，校赛被威神压两题乱杀。</p><p>被打麻了之后开始改变训练策略了，开始刷cf当前分数+1000的题，经常一下午写一道；</p><p>开始追求补完div2，AKdiv3，因为要写能力范围外的题，经常会硬啃题解、曲线救国、看jly代码。</p><p>现在看来这种策略也不是非常的科学，但那会可以说是提升速度最快的一段时间了。</p><p>大二下省赛前状态极佳：</p><ul><li>浙江省赛 金</li></ul><p>是我校第一块省赛金牌，<del>省金也算金</del></p><p>ECF的名额从老会长给到涛哥，然后又让给了我们。非常感谢学长们，然而我们还是太菜了</p><p>​</p><h5 id="EC-Final"><a href="#EC-Final" class="headerlink" title="EC Final"></a>EC Final</h5><p>EC硬是拖到了2022.7才办，但是线下，又能公费出游了。</p><p>见到了jly，dls本人还有一堆群友。</p><p>然而大秦办的真的不是一般的烂，具体大伙可以自信知乎，同样不赘述</p><p><a href="https://www.zhihu.com/question/543699999/answer/2584755503">如何评价2021 ICPC EC-Final？</a></p><p>我队三次出游分别见证了西部枢纽、东北枢纽和大秦枢纽的诞生，乐</p><p>说回比赛本身：</p><ul><li>ICPC EC Final 铁（菜）</li></ul><p>纯菜，心态和实力都不太足吧。</p><p>座位对面是南大-虚幻黄昏，赛时对面疯狂拿气球，一度冲到rk2，而我队三线卡题；</p><p>心态没能调整过来，三边一起乱wa的时候就感觉没戏了，但赛后发现其实只要过其中一个就有铜了。</p><p>反思：比赛策略出错，心态不稳，受旁边队伍影响比较大。如果找清定位all in一题的话，拿个铜还是有机会的。</p><p>​</p><p>不得不感叹ec里面巨佬是真的多，各种企业的宣讲、抽奖啥的也真的多，这就是含金量吗。</p><p>华为晚会抽到一个手环，蹭到巨佬们的光了</p><p>​</p><h5 id="CF实况"><a href="#CF实况" class="headerlink" title="CF实况"></a>CF实况</h5><p>之前就看到很多人在b站发cf的实况或者讲题，各种水平段的选手都有，强如dls也会发比赛实况。</p><p>于是我也趁着暑假寝室没人，开始打cf的时候录屏，比赛完了之后简短讲一下写出来的题然后发b站。</p><p>感觉录播的时候上分非常顺畅，不清楚什么原理，暑假很顺利地把两个号都打上橙了。</p><ul><li>2022&#x2F;08&#x2F;06 —— codeforces橙</li></ul><p><img src="http://lxtyin.ac.cn/img/xcpc_retire/5.png"></p><p><img src="http://lxtyin.ac.cn/img/xcpc_retire/6.png"></p><hr><h4 id="大三（2022-2023）"><a href="#大三（2022-2023）" class="headerlink" title="大三（2022-2023）"></a>大三（2022-2023）</h4><h5 id="招新-amp-新生赛"><a href="#招新-amp-新生赛" class="headerlink" title="招新&amp;新生赛"></a>招新&amp;新生赛</h5><p>虽然但是，今年还是拉我去给新生画旅游的大饼（因为大伙这一年都没机会出去）</p><p>甚至用的还是同一套银川的图</p><p>​</p><p>22届新生明显没有21届那么夸张了，于是我们出题温和了不少，</p><p>我出了一个签到 + 一个去年没用上的MC题。</p><p>今年尝试把新生赛提前到了10月，结果是大家都被语法卡麻了</p><p>最后cc做出7题rk1，另外有足足5个题没人过（</p><p>MC题还是没人过（（（（悲</p><h5 id="比赛-amp-退役"><a href="#比赛-amp-退役" class="headerlink" title="比赛&amp;退役"></a>比赛&amp;退役</h5><p>今年是和去年一样的ICPC和CCPC全撞上的形势，也是同样的全线上形势（</p><p>基本最后一个赛季了，赛前把能拖的事情全都拖到了比赛结束后，作业能不写的就不写，疯狂鸽组员 and 画大饼（比赛完了我就来肝）</p><p>​</p><p>经过一番虚空赛站博弈之后，我们无脑选了前四场（桂林、威海、西安、合肥）</p><p>究其原因，还是想早点打完退役，然后该考研的考研该保研的保研该做项目的做项目了吧。</p><p>毕竟我们已经在算法竞赛上面投入了太多的时间。</p><blockquote><p> 说白了打算法竞赛就是网瘾少年，该电电了</p><p>​——何逊</p></blockquote><p>​</p><p>顺着XCPC的猫猫热潮，我们把队名改成了：<strong>猫猫滚脸 &#x2F; Power Over Face</strong></p><p>英文队名致敬了一下老会长（胡）那队（能力突出 &#x2F; Power Over Flow）</p><p>比赛结果：</p><ul><li>CCPC 桂林 银</li><li>CCPC 威海 铜</li><li>ICPC 西安 金</li><li>ICPC 合肥 ？</li></ul><p>桂林上来就开到原题（几乎原，一模一样的换根dp，还是最近做的），然后就跟队友说要抢首A，虽然没抢到</p><p>最后发现这是道银牌线上的题，运气非常好。</p><p>威海虽6但铜不谈。</p><p>西安网络流板子第一次发挥作用，封榜后三个人合力拱掉了金牌线上的数据结构题</p><p>封榜前37名，大致推测了一下最终是34名左右，非常悬</p><p>滚榜滚到我们后面几个队的时候一直在喊：给爷WA！WA！</p><p>最终停在了rank34，金牌倒数第二。</p><p><img src="http://lxtyin.ac.cn/img/xcpc_retire/7.png"></p><p>我直接原地宣布退役，合肥？合肥是什么</p><p>（当然打还是会去打的（</p><p>现在是第二天，我退役记已经快写完了</p><blockquote><p>upd：合肥rank38银，这下金尾银首都有了</p></blockquote><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这块地方不定期更新（退役了但没完全退（</p><table><thead><tr><th></th><th>ICPC</th><th>CCPC</th><th>浙江省赛</th></tr></thead><tbody><tr><td>大一</td><td>济南铁 + 银川铜</td><td>&#x2F;</td><td>铜</td></tr><tr><td>大二</td><td>上海铁 + 南京铜 + Final铁</td><td>桂林铁</td><td>金</td></tr><tr><td>大三</td><td>西安金 + 合肥银 + Final铁</td><td>桂林银 + 威海铜 + Final铁</td><td>金</td></tr><tr><td>大四</td><td>&#x2F;</td><td>秦皇岛？</td><td>&#x2F;</td></tr></tbody></table><p>总计：省1铜1金，国4铁3铜2银1金</p><p>之后也许还会去打一些比赛（如果有名额给我们），给学院多打几个牌子，有的话再更新；</p><p>两个dream：区域赛金牌和Codeforces红名</p><p>第一个已经达成，第二个进度 <code>2216/2400</code></p><p>在非训练状态下，CF想继续上分有点难了，不知道什么时候能够达成。</p><blockquote><p>upd：2023&#x2F;10&#x2F;10，没想到退役后又被教练抓去打了两把final，这下final三铁了（555</p></blockquote><p>​</p><hr><h4 id="感想-amp-建议"><a href="#感想-amp-建议" class="headerlink" title="感想&amp;建议"></a>感想&amp;建议</h4><h5 id="关于XCPC"><a href="#关于XCPC" class="headerlink" title="关于XCPC"></a>关于XCPC</h5><p>这是一个含金量高、难度大、性价比低、纯粹、超纲的竞赛。</p><p>关于XCPC含金量降低的说法我是不认可的，在前几年银川乱发牌的时候，含金量的确有所下降，但如今银川赛站已经不复存在。</p><p>现在的情况反而是一年比一年卷，往年的金银算法如今已经变成铜牌分界线了，</p><p>在竞技的角度看来，含金量只增不降。</p><p>从组织的角度来看emmm，看看银川、沈阳和大秦吧xdm</p><p>​</p><p>性价比低则是伴随着含金量提高而来的，你需要花几倍的时间才能拿到同级别的奖项，而在校内各项加分上却没有优势，也要承担付出很多却拿不到牌的风险。</p><p>当然，这只是校内的评价体系。</p><p>对于计算机专业的学生来说，出去之后，ACM的认可度会远超其他竞赛。因为它客观、纯粹，ACM奖牌能够直接反映你的算法水平和编码能力，其他大多所谓的“综合类”竞赛则不然。</p><p>这部分大家可以参考<a href="https://hukeqing.github.io/2020/12/21/acm/myACM/">胡kq的退役记</a>，他的评价比我更加详细，也更加锐气。</p><p>​</p><p>超纲即，ACM中的许多知识，在工业界看来是用不到的“屠龙术”</p><p>因为这是一项竞赛，要冲击高处，必然意味着一定程度上的脱离实际，这很正常。</p><p>会枚举数组就能写程序了吗？大部分情况下没错，就跟买菜不会用到微积分一样没错。</p><p>但当复杂算法和数据结构被需要时，你的“屠龙术”被用上了，就能体现你的竞争力。</p><p>退一万步讲，学会这些屠龙术也能让你对算法&#x2F;数据结构有更深层的理解，对STL也会有更深的理解。</p><blockquote><p>知识很难没用——群友</p></blockquote><p>拿最近一次大作业，仿制git为例，我能很快理解版本管理的实质是一棵主席树，变更文件发现的原理是哈希，能想到文本修改历史推测只需要跑个LCS。经过算法竞赛的磨练，这些算法和数据结构用在此处，在我看来就十分直观、显然了。</p><p>​</p><h5 id="XCPC给我带来什么"><a href="#XCPC给我带来什么" class="headerlink" title="XCPC给我带来什么"></a>XCPC给我带来什么</h5><p>代码实现能力（最直观、最直接的）</p><p>对算法、数据结构的理解和熟练运用能力</p><p>自学能力</p><p>抗压能力</p><p>团队合作能力</p><p>一些屠龙术</p><p>​</p><h5 id="XCPC没给我带来什么"><a href="#XCPC没给我带来什么" class="headerlink" title="XCPC没给我带来什么"></a>XCPC没给我带来什么</h5><p>对实际工程结构、体系的了解</p><p>需求分析&#x2F;市场营销技能</p><p>文档撰写&#x2F;ppt制作能力</p><p>规范的代码&#x2F;注释</p><p>软件工程&#x2F;项目开发流程的了解</p><p>​</p><p>写上面这些主要是想说明，ACM太纯粹了，然而现实的项目，解决实际问题会遇到很多其他乱起八糟的东西，不是一个cpp就能解决的——尽管它用到的算法可能只有二分</p><p>退役后要多多和现实项目接轨了。</p><p>​</p><h5 id="关于XCPC选手"><a href="#关于XCPC选手" class="headerlink" title="关于XCPC选手"></a>关于XCPC选手</h5><p>XCPC选手这一群体（主要指各种群友）是我见过最锐气的一批人。</p><p>20-21年的银川乱象，沈阳乱象，最近的大秦酒店风波，CCPC禁赛事件。</p><p>群友貌似天天塔塔开，一直在冲，一直不停。</p><p>他们冲到银川办不了regional，冲到EC Final变到上海，冲到CCPC撤销禁赛…</p><p>这个破烂比赛的含金量，真的是靠这些参赛选手们对作弊、藏私、暗箱操作零容忍的态度维护的，而不是靠哪一个主办方组织者。</p><p>希望群友们保持风骨，把冲塔风范传承下去。</p><p>​</p><h5 id="建议打ACM吗"><a href="#建议打ACM吗" class="headerlink" title="建议打ACM吗"></a>建议打ACM吗</h5><p>ACM能让你学到很多东西，我建议每个人都可以试试。</p><p>但如果以奖牌为目标的话，你需要认清自己的天赋和愿意付出的努力，再做权衡；</p><p>不可忽略的是：这个圈子里所有人都很卷，不能太高估自己的努力程度。</p><p>在付出大量时间和心血之前考虑清楚，自己到底合不合适。</p><p>如果你是零基础，要打，想拿牌，并且自认天赋不算太好的话，我建议不要再双开其他竞赛&#x2F;科研&#x2F;项目了，不然很难有一个理想的结果。</p><p>​</p><p><strong>那么放弃其他东西 All in acm，真的值得吗？</strong></p><p>贴一个回答：</p><p><img src="http://lxtyin.ac.cn/img/xcpc_retire/2.png"></p><p>​</p><p>它很适合我。</p><p>我知道其他比赛拿奖更快;</p><p>我知道学院挑战杯互联网+1.8倍加分;</p><p>我也知道导师眼里 成绩 &gt;&gt; 科研 &gt; 项目 &gt; 竞赛;</p><p>但我懒，单纯不想做那么多麻烦事，只想敲代码。</p><p>A题很爽，打比赛很爽，被锤烂了也很服气。</p><p><img src="http://lxtyin.ac.cn/img/xcpc_retire/1.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>退役记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++小记</title>
    <link href="/2022/11/02/2022-11-02-C++%E5%B0%8F%E8%AE%B0/"/>
    <url>/2022/11/02/2022-11-02-C++%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<hr><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这篇东西本来是大二上C艹课写的笔记，为了应付考试写了很多八股的、不太实用的内容。后续用C艹的过程中发现越陷越深，越学越发现不会C艹，于是重新捡起了这篇东西，把一些新写的东西放到了上面，之前写过的八股也留在下面没删除。</p><h3 id="结构体内存对齐"><a href="#结构体内存对齐" class="headerlink" title="结构体内存对齐"></a>结构体内存对齐</h3><ol><li>顺序分配</li><li>每个成员的首地址需要是自身大小的整数倍。</li><li>总大小需要是其中最大类型的整数倍。</li></ol><h3 id="匿名函数原理、闭包"><a href="#匿名函数原理、闭包" class="headerlink" title="匿名函数原理、闭包"></a>匿名函数原理、闭包</h3><p>假如有这样一个Lambda函数：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<span class="hljs-keyword">auto</span> func = [&amp;](<span class="hljs-type">int</span> x)&#123;<span class="hljs-keyword">return</span> x + a;&#125;;</code></pre></div><p>如果不是临时使用，而是把它作为一个 <code>function&lt;int(int)&gt;</code> 到处传的话，这个 <code>a</code> 在其他地方也能同样生效吗？</p><p>事实上，匿名函数会创建一个 <code>SomeAnonymousType</code> 类型的对象，它会<strong>直接存储</strong>捕获到的变量，如果使用引用方式捕获，存储的就是指针。</p><p>所以匿名函数的内存大小和捕获到的变量数有关，上述写法试图捕获<strong>可见域内所有</strong>变量，好在编译器有优化，实际上只会捕获用到的，所以大多数情况下我们使用没问题。</p><p>但还是要注意对局部变量的引用捕获，可能在使用时指针已经野了。</p><p>另外，<code>function</code> 和 <code>SomeAnonymousType</code> 并不是一个类型，<code>function</code> 是又一层封装，它把 <code>SomeAnonymousType</code> 存在了堆中并维护，故 <code>function</code> 的大小是个常量。</p><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><ul><li><code>#include</code> 指令是粗暴的将文件内容复制过来；（预编译期）</li><li>编译都是对<strong>单个文件</strong>进行的，需要在单个文件内自圆其说（用到的函数都有其声明）。</li><li>声明是声称了某个符号的存在，使得编译时即使它还没有完整定义也能用。</li><li>最后的链接阶段，才是将这些符号和其具体定义关联起来。</li></ul><p>因为两个头文件中的函数实现可能<strong>互相依赖</strong>，故通常使用定义实现分离的写法，不在头文件中写定义。</p><p>因为头文件引用可能<strong>循环套娃</strong> ，故常写 <code>#ifndef</code> 避免无限循环。</p><p>多个文件分别编译，但最后要进行链接，此时多个源文件中不能有重复定义，故通常不在头文件中写定义（头文件写定义，当头文件被多个源文件引用时，每个源文件中都有一份定义，链接时即报错）。</p><p>const，static只在单个文件中有效，故可以写在头文件中（不会被链接），但需注意static全局变量写在头文件中后，被多个文件引入时就不再是同一个变量了。</p><p>inline内联函数可以写在头文件中，因为它本质是将函数内容拷贝到调用的地方去；</p><p>类成员的定义可以写在头文件中，具体后续再理解（。。</p><h3 id="右值引用与移动语义"><a href="#右值引用与移动语义" class="headerlink" title="右值引用与移动语义"></a>右值引用与移动语义</h3><p>右值和左值的概念此处不赘述。</p><p>先看右值引用的经典作用：实现移动语义</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-type">char</span>* p;    <span class="hljs-built_in">Node</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str) &#123;        p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">255</span>];        <span class="hljs-built_in">memcpy</span>(p, str, <span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-built_in">Node</span>(Node&amp; t) &#123;        p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">255</span>];        <span class="hljs-built_in">memcpy</span>(p, t.p, <span class="hljs-built_in">strlen</span>(t.p) + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-built_in">Node</span>(Node&amp;&amp; t) &#123;        <span class="hljs-built_in">swap</span>(p, t.p);    &#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">Node <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, x.p);    <span class="hljs-function">Node <span class="hljs-title">y</span><span class="hljs-params">(move(x))</span></span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %s\n&quot;</span>, x.p, y.p);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">hello</span>(null) hello</code></pre></div><p>对于大部分类型来说，用右值构造还是左值构造并没有什么区别，但关键就在于，右值引用和左值引用可以<strong>作为不同的形参</strong>，实现重载。</p><p>一些含有资源的类（如 <code>string</code>，<code>vector</code>，这里的资源指它们自行从堆上申请来的内容）就可以利用右值引用，实现另一种构造：直接窃取资源而非拷贝的构造。</p><p>如同上面的 <code>Node</code> 类，在以右值做形参的拷贝构造函数中，它直接偷来了对方的指针，没有资源复制的过程，效率极高。</p><p>当然，此时对方应当放弃这个资源，否则共享一块资源就乱了，故这通常用于临时对象的转移。</p><p>这便是移动语义，它并不是对每种类型都有效的，一般是含资源的类自行重载了<strong>拷贝构造函数</strong>，自行定义了资源转移的方法，才能发挥移动语义的作用。</p><p>右值有一个特点，它没有“名”。右值引用变量仅仅只是限制了它只能绑定到右值，在绑定完成后，它有了名字，于是便和左值无异了（事实上，右值引用变量、形参就是一个左值）。</p><p>常左值引用也可以绑定到右值。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span>&amp;&amp; x = <span class="hljs-number">2</span>;<span class="hljs-function">Node&amp;&amp; <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<span class="hljs-function">Node <span class="hljs-title">y</span><span class="hljs-params">(func())</span></span>;</code></pre></div><p>如上 <code>func</code> 函数返回了一个右值引用，y 直接利用返回值进行构造，它就是一个右值。</p><p>如上定义了右值引用变量 x，令他引用2，这样 x 就和一般的左值变量一样了。</p><p>目前理解有限，我认为右值引用的主要意义就是作为形参或返回值，作为形参时会限制左值不能作为实参，作为返回值时可以作为真正的右值使用。</p><p>move函数就是将一个左值引用强制转换成了右值引用，因此宏观来看，上述代码 <code>Node y(move(x));</code> 就实现了资源移动的效果。</p><p><strong>引用折叠、万能引用</strong></p><p>C++中，不能直接创建引用的引用，但可以间接创建，间接的多层引用会被折叠，等价于一层引用。</p><p>对于模版形参 <code>T&amp;&amp;</code> 来说，由于可以进行类型推导， <code>T</code>既可以接收右值引用，也可以借由引用折叠特性，接受左值引用。同理，auto也可以当做万能引用（但我还没见过实际应用）。</p><p><strong>完美转发</strong></p><p>首先我们知道，不管实参是右值还是左值，一旦变成了形参，它就变成左值了（因为有了名），如果需要将右值在多层函数间传递，则每层都需要进行move。</p><p>对于可变参数来说，我们不清楚其中有哪些是右值、哪些是左值，不能统一进行move；std::forward提供了一种机制，仅在传入类型是右值时进行move。通常用法（也是我能想到的唯一用法？）：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T&amp;&amp;... args)</span> </span>&#123;<span class="hljs-built_in">fun2</span>(std::forward&lt;T&gt;(args)...);&#125;</code></pre></div><p>可以看到，forward 需要模版参数T，这就是自动推导得到的万能引用，从T的类型中可以得知实参到底是左值还是右值，从而让forward实现完美转发。</p><h3 id="const，引用和指针"><a href="#const，引用和指针" class="headerlink" title="const，引用和指针"></a>const，引用和指针</h3><h4 id="const，顶层与底层"><a href="#const，顶层与底层" class="headerlink" title="const，顶层与底层"></a>const，顶层与底层</h4><p>const 类型必须在定义时附上初始值；class中的const成员必须在初始化列表中有初始值；</p><p>分辨const修饰的对象：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-type">const</span> * <span class="hljs-type">const</span> p;<span class="hljs-comment">//上面有三个位置可能放const限定符，按照*划开，*左端为指针指向的类型，右端才是对这个指针的限定修饰；</span><span class="hljs-comment">//举例：</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p;<span class="hljs-comment">//p指向的是int常量，p本身不是常量，可以更改指向</span><span class="hljs-type">int</span> <span class="hljs-type">const</span> *p;<span class="hljs-comment">//和上条完全等价</span><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p;<span class="hljs-comment">//p指向的是int变量，p本身是一个常量，不能改变指向</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p;<span class="hljs-comment">//p指向int常量，且p本身是一个常量，不能改变指向</span></code></pre></div><p>按照上述方式划分清楚const的修饰对象即可，如果一定要顶层和底层const的概念的话：</p><p>通常，顶层const指本身为const，底层const指其指向的对象为const；</p><p>可见前两条为底层const，第三条为顶层const，第四条既是底层又是顶层const；</p><p>个人感觉顶层底层的概念把问题复杂化了。。。其实就是“这个变量本身是否为常量”</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//const用于函数</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x)</span></span>&#123;    <span class="hljs-comment">//表明这个x是不可变的，一般和引用传递同时使用以保护实参变量</span>&#125;<span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-title">find</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//修饰引用、指针型的返回值，加const意味着返回的值不能修改（不可作为左值）</span>    <span class="hljs-comment">//不太理解对非引用、指针型返回值加const的意义</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">compare</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;    <span class="hljs-comment">//const修饰整个函数，只能对成员函数（类中的函数）使用；</span>    <span class="hljs-comment">//意味着这个函数不能更改任何自身数据成员，也只能调用同被const修饰的方法。</span>&#125;</code></pre></div><p>另外提一句：返回值为非引用、指针的内置类型时，返回的值不能作为左值（当然），而返回的对象则可以作为左值，可以被赋值或者立即调用方法等，不过在这一行过后它会立刻析构（因为也没有变量指向它）。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">square <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">square</span>(x, y);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; <span class="hljs-built_in">f</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>).<span class="hljs-built_in">area</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><p>void*指针可以指向任意类型的对象，但因为没有存储对象类型，不能通过其修改对象；</p><h4 id="引用：变量的别名"><a href="#引用：变量的别名" class="headerlink" title="引用：变量的别名"></a>引用：变量的别名</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<span class="hljs-type">int</span> &amp;b = a;<span class="hljs-comment">//相当于a, b使用同一块存储区域，且都标记为了int类型，两者没有区别</span><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; c = a * <span class="hljs-number">2</span>;<span class="hljs-comment">//常量可以初始化成任意值，引用无意义</span><span class="hljs-type">int</span> &amp;d = <span class="hljs-number">42</span>;<span class="hljs-comment">//错误，不能将非常量引用绑定到常量</span></code></pre></div><p>对象作为参数时加入&amp;引用可以让传参更快（免去了拷贝的过程），对于内置类型，这样的加速无必要。</p><hr><h3 id="继承、多态"><a href="#继承、多态" class="headerlink" title="继承、多态"></a>继承、多态</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>子类继承了父类的所有非私有的成员和方法，除了以下几种：</p><ul><li>构造函数、析构函数、</li><li>重载的运算符</li><li>父类的友元函数</li></ul><p>子类在没有显示调用父类的构造函数时，会默认先调用一遍父类的无参构造函数；</p><p>注意此时父类的无参构造必须存在，否则会报错；</p><p>或者，在子类中显示地调用父类的构造函数，形如：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">square</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) : <span class="hljs-built_in">shape</span>(x, y) &#123;&#125;</code></pre></div><p>可以加 <code>final</code> 关键字阻止其他类继承此类</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Last</span> <span class="hljs-keyword">final</span>: <span class="hljs-keyword">public</span> base&#123;..&#125;</code></pre></div><h4 id="重载，重写，隐藏"><a href="#重载，重写，隐藏" class="headerlink" title="重载，重写，隐藏"></a>重载，重写，隐藏</h4><p>重载是同名但参数列表不同方法，依据参数列表决定调用哪个（仅返回值不同，不能构成重载，因为依然不能根据调用时传递的参数判断调用的是哪一版）；</p><p>隐藏是指子类中方法，会隐藏父类中同名的方法（<strong>即使参数列表不同</strong>），子类有一个find()方法后，再要通过这个子类调用它父类的名为find的方法，要使用作用域符号<code>::</code>；</p><p>重写指将父类中的方法定义为虚函数，然后子类的同名同参的方法可以覆盖父类中这一方法，相较于隐藏在父类方法中多写了一个virtual，和隐藏的区别在于：</p><ul><li>不加virtual时，通过父类指针&#x2F;引用调用方法，固定调用父类中的方法（因为是父类指针，隐藏时调用哪个完全看名字）；</li><li>加virtual时，通过父类指针&#x2F;引用调用方法，指向哪个类就调用哪个类的方法；</li></ul><p>重写可以加上一个 <code>override</code> 表示这个函数试图重写父类虚函数，它是一种标识符，标记后如果他没有重写（比如你自己写错名字了），编译器则会报错。主要作用是提醒程序员。</p><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>可以将子类对象转换为父类对象（派生方式必须为public），这完全可行，子类本身就包含了父类信息；</p><p>将父类对象转化为子类的对象，是不安全的，可以使用 <code>dynamic_cast</code> 进行父指针到子指针的转换，若转换失败返回空指针，可以用于检查类型。</p><h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><p>C++中，父类指针或引用可以指向子类对象，这会导致以下情况：</p><p>在通过<strong>父类指针&#x2F;引用</strong>调用一个<strong>虚函数</strong>时，按照上述原则，应该根据指针的指向决定调用的函数；</p><p>但在编译期，我们还不知道这个父类指针具体指向了哪个类，所以这次调用的函数版本不是在编译期决定的，而是在运行期才决定，所以被称为动态绑定。</p><p>或者换一个说法，父类指针的绑定对象是可以更改的，所以在编译期不能直接确定。</p><p>虚函数表（虚表）是属于类的，每个类都仅有一个，类对象中有指向该类虚表的指针。</p><p>虚表是一个指针数组，存储类中每个虚函数的指针，它或是指向重写的新定义，或是指向父类的定义（继承），总之，虚表可以直接查询该类对象调用某虚函数时，应当执行哪个定义。</p><p>虚表指针存储在对象的首部，在用父类指针指向子类对象时，通过父类指针调用，查到的就是子类的虚表，于是可以方便地实现多态。</p><h4 id="多态的含义"><a href="#多态的含义" class="headerlink" title="多态的含义"></a>多态的含义</h4><p>我们可以对“多种形式”的同一类物体进行同一操作，而无需在意他们的差异；</p><p>一个接口，多种实现；</p><hr><h3 id="构造函数和初始化列表"><a href="#构造函数和初始化列表" class="headerlink" title="构造函数和初始化列表"></a>构造函数和初始化列表</h3><p>类在构造时，任何类的成员对象（类对象），若没有被显式地构造，都会隐式地调用其缺省构造函数，包括父类构造也是这样隐式调用。而对于基础类型则不会这样，没初始化就是没初始化。</p><p>若未定义任何构造函数，则会合成一个Public的默认无参构造函数，它完全等价于 <code>A() &#123;&#125;;</code>，除了隐式构造成员对象（上述）外不做任何事情。注意：一旦人为定义了构造函数（哪怕是有参的，哪怕是私有的），这个无参构造函数就不会再自动合成了，此时这个类就没有了无参构造函数，无法用类似 <code>A a;</code> 的方式直接创建。</p><p>初始化列表的特殊用处在于：初始化const类型的成员变量。</p><p>直接在构造函数中为const类型赋值显然是不规范的，所以用到了初始化列表，可以认为它比构造函数“更早地”初始化了成员变量，const修饰的变量必须在初始化列表中初始化它</p><p>初始化列表中还可以使用类（或其父类）中的其他构造函数来初始化（委托构造函数）：</p><p>（且对于父类成员，只能使用父类构造函数来初始化）</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">shape</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">shape</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) : <span class="hljs-built_in">w</span>(x), <span class="hljs-built_in">h</span>(y) &#123;&#125;<span class="hljs-built_in">shape</span>(<span class="hljs-type">const</span> shape &amp;t) : <span class="hljs-built_in">shape</span>(t.w, t.h) &#123;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">area</span><span class="hljs-params">()</span></span>;<span class="hljs-keyword">private</span>:<span class="hljs-type">int</span> w, h;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">box</span> : <span class="hljs-keyword">public</span> shape &#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">box</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">shape</span>(x, x) &#123;&#125;&#125;;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">box</span> : <span class="hljs-keyword">public</span> shape &#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">box</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">shape</span>(x, x) &#123;&#125;    <span class="hljs-comment">//explicit box(int x) : shape(x, x) &#123;&#125; 加上explicit限定，禁止其隐式转换</span>&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;box t = <span class="hljs-number">3</span>;<span class="hljs-comment">//构造函数中若只有一个实参，可以隐式地将这个实参直接转化为类类型</span>&#125;</code></pre></div><hr><h3 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h3><p>在类的复制拷贝构造函数中参数一定要+引用，因为非引用的传参本就包含了拷贝过程，会造成递归调用。</p><p>一般也同时加上一个const来保护，这是一种典型的拷贝构造函数：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">student</span>(<span class="hljs-type">const</span> student &amp;x);&#125;;</code></pre></div><p>注意：写了拷贝构造函数的同时覆盖了默认的拷贝构造函数，依据上一节中的隐式转换规则，在初始化时直接使用等于号，也将隐式调用<strong>仅有一个参数</strong>的拷贝构造函数；</p><p>可以给构造函数加上 <code>explicit</code> 关键字来阻止上述隐式转换；</p><p>而实际上的 <code>=</code> 赋值运算符是对一个已经初始化完毕的对象重新赋值时调用的，以此区分，见下代码：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">box</span> : <span class="hljs-keyword">public</span> shape &#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">box</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">shape</span>(x, x) &#123;&#125;<span class="hljs-built_in">box</span>(<span class="hljs-type">const</span> box&amp; t) : <span class="hljs-built_in">box</span>(t.w + <span class="hljs-number">1</span>) &#123;&#125;<span class="hljs-comment">//修改过的拷贝构造函数</span><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> =(<span class="hljs-type">const</span> box&amp; t) &#123;<span class="hljs-comment">//赋值运算符</span>w = t.w;h = t.h;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-function">box <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;box b = a;<span class="hljs-comment">//无初值的对象初始化，看似是等于号，其实调用的是拷贝构造函数</span>cout &lt;&lt; b.<span class="hljs-built_in">area</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<span class="hljs-comment">//结果为36</span>b = a;<span class="hljs-comment">//有初值的对象，这里的等于号就是赋值运算符了</span>cout &lt;&lt; b.<span class="hljs-built_in">area</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<span class="hljs-comment">//结果为25</span>&#125;</code></pre></div><p>所以，拷贝构造函数除了直接调用之外，还会在用&#x3D;定义变量，传参，返回，初始化列表等等地方被调用，需要与operator&#x3D;辨别开来；</p><p>老规矩，operator&#x3D;和拷贝构造函数都有一个默认版本，自己定义后将默认版本覆盖</p><p>默认版本中，拷贝与赋值都是将所有成员一一对应赋值，对于指针成员，并不会为其开辟新的空间。</p><p>使用&#x3D;default显示地保留默认版本 </p><p><code>box() = default;</code></p><p>使用&#x3D;delete来删除默认版本，可以在不自定义的情况下阻止拷贝，赋值等等（析构不能被delete）</p><p> <code>box()  = delete</code></p><p>例如iostream类中就使用了上述方式阻止了拷贝和赋值。</p><hr><h3 id="Shared-ptr智能指针"><a href="#Shared-ptr智能指针" class="headerlink" title="Shared_ptr智能指针"></a>Shared_ptr智能指针</h3><p>这篇很好：<a href="https://blog.csdn.net/qq_29108585/article/details/78027867">https://blog.csdn.net/qq_29108585/article/details/78027867</a></p><p>当我们new一个对象时，会在堆中开辟一块空间，称之为$A$，这块空间的地址我们称为原始指针，new返回的即为此指针；</p><p>用原始指针初始化shared_ptr时，会在ptr中记录这个地址，同时开辟一块新的区域（可以这么理解）保存引用计数，这块区域称为$M$，ptr中也记录了$M$ 所在的地址；</p><p>当用ptr初始化或赋值另一个shared_ptr（假设为ptr2）时，ptr2不再会开辟一个新的$M$，而是和ptr指向同一个$M$，这个是他们的共同引用计数（这里没什么问题）</p><p>但如果用原始指针初始化或复制另一个shared_ptr时，就会出现另一个引用计数$M2$，并且两个引用计数都为1，这时任意一方计数归零时，都会直接回收对象的存储空间$A$，另一方则出大事；</p><p>这就是shared_ptr一些麻烦事的原因：</p><ul><li>不要重复用原始指针构造shared_ptr，而是用已经有的；</li><li>.get() 方法返回原始指针，不要用这个方法去赋值其他shared_ptr，原因同上；</li><li>不要混用指针和智能指针：智能指针不会对普通指针的引用计数，容易造成普通指针悬空；</li></ul><hr><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>在类 $A$ 中声明一个友元函数，则这个函数（全局函数或者其它类的成员函数）可以访问 $A$ 中的私有成员</p><p>在类 $A$ 中声明一个友元类 $B$，则 $B$ 中所有成员函数都可以访问 $A$ 的私有成员</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">shape</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">expend</span><span class="hljs-params">(shape x)</span></span>;<span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">box</span>;<span class="hljs-keyword">private</span>:<span class="hljs-type">int</span> width, height;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">box</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">areaof</span><span class="hljs-params">(shape x)</span> </span>&#123;<span class="hljs-keyword">return</span> x.width * x.height;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">expend</span><span class="hljs-params">(shape x)</span> </span>&#123;x.width++;x.height++;&#125;</code></pre></div><p>友元并不是类的成员，其声明不受访问控制符的影响（放在public还是private都可以），听说不能把私有成员函数声明为友元，我试了一下可以（？</p><h3 id="模板和泛型"><a href="#模板和泛型" class="headerlink" title="模板和泛型"></a>模板和泛型</h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;a, <span class="hljs-type">const</span> T &amp;b)</span></span>&#123;    <span class="hljs-keyword">return</span> a &lt; b;&#125;</code></pre></div><p>模板实际上就是将这一类程序员需要重复做的事情交给了编译器。</p><p>模板在定义时不生成代码，而是在使用处生成<strong>对应版本</strong>的模板定义（还是在编译期），因此模板实际上还是为每种（用到的）类型生成一个定义。</p><p>正因如此，对模板定义中 <code>T</code> 变量执行的操作，只要符合所有使用到的类型，即可通过编译。</p><p>模板也可以带有一些非类型的参数：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">unsigned</span> N, <span class="hljs-type">unsigned</span> M&gt;</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> a[N], <span class="hljs-type">const</span> <span class="hljs-type">char</span> b[M])</span></span>&#123;    ...&#125;<span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>); <span class="hljs-comment">//调用，同样根据实参推断</span></code></pre></div><p>typename 用在template中，和class完全一样（class是为了兼容历史代码而保留的，建议使用typename）；在模版定义中，typename还可以用于显式说明一个名称是类型名。对于依赖模版参数的嵌套名称，使用typename可以提前告诉编译器这是一个类型，而非一个变量。最好为所有依赖模版参数的嵌套名称都加上typename修饰。</p><p>例如 <code>T::abc</code>, 这里的 <code>abc</code> 可能是类型也可能是变量，使用typename显式地通知编译器以消除歧义。</p><h4 id="模板类"><a href="#模板类" class="headerlink" title="模板类"></a>模板类</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-comment">//也可以用typename，基本没有区别，typename一定能用</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123;    ...&#125;Array&lt;<span class="hljs-type">int</span>&gt; a;<span class="hljs-comment">//之后，Array永远要跟着一个&lt;&gt;</span></code></pre></div><p>定义可以分离，定义时语法如下：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-type">int</span> Array&lt;T&gt;::<span class="hljs-built_in">front</span>()&#123;...&#125;</code></pre></div><p>但，无论是模板函数还是模板类的成员，定义和声明都<strong>必须在同一个文件中</strong>。</p><p>原因是：模版只有在被使用时才会编译相应版本的代码（编译后的目标文件不存在模版的说法，只有许多种确定类型的代码），编译遇到一般的函数时，只需要有其声明，预留个指针以后再链接就好了。而编译遇到模版时，必须有其实现，供编译器立刻生成一个对应版本的代码。</p><p>不分离不一定会报错，若编译时遇到模版却没有其实现，也会留下空指针等着以后链接，如果恰好别的地方编译了相应版本的模版，也能链接上，不然会报链接错误。</p><h4 id="模版特化"><a href="#模版特化" class="headerlink" title="模版特化"></a>模版特化</h4><p>一套模版定义可能不适用于所有模版类型，模版特化是指对于特殊的模版类型，专门实现一种定义。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-type">bool</span> Compare&lt;T&gt;::<span class="hljs-built_in">equal</span>(T a, T b) &#123; <span class="hljs-keyword">return</span> a == b;&#125;<span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-comment">// 必须有</span><span class="hljs-type">bool</span> Compare&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">equal</span>(<span class="hljs-type">float</span> a, <span class="hljs-type">float</span> b) &#123; <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">abs</span>(a - b) &lt; <span class="hljs-number">10e-3</span>;&#125;</code></pre></div><p>有偏特化和全特化之分，偏特化即仅限定一部分类型。函数模版只能全特化，类模版可以偏特化。通常来说，函数模版的全特化可以用函数重载替代，因此比较少用。</p><p>特化所施加的限制也可以是这样：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span>&lt;T*&gt; &#123;...&#125;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span>&lt;T&amp;&gt; &#123;...&#125;</code></pre></div><p>不是限制类型，而是限制必须为指针或引用。</p><h4 id="可变参数模版"><a href="#可变参数模版" class="headerlink" title="可变参数模版"></a>可变参数模版</h4><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...T&gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T... args)</span> </span>&#123;    <span class="hljs-type">int</span> a[] = &#123;(args + <span class="hljs-number">10</span>)...&#125;;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-keyword">sizeof</span>...(args);i++) &#123;        cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    &#125;&#125;<span class="hljs-built_in">fun</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>);</code></pre></div><p>上面的模版写法和参数写法，我认为是一种特殊语法，套用就好。</p><p>关键在于怎么用。基础的用法 <code>args...</code> 将可变参数列表展开，展开的东西可以用作初始化列表、可以丢进下一个函数作可变参数，可以粗略理解为，展开的东西在代码里就是一串逗号相连的值（注意，这都是编译期执行的）</p><p>可以将 <code>args</code> 换成一个带有 <code>args</code> 的表达式，例如 <code>(args * 2)...</code>，也是一样展开，每个参数都按照同样的表达式形式展开（不计算，仅展开）</p><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>在函数的<strong>定义</strong>前加上<code>inline</code>可以让这个函数在编译时就“展开”到调用它的地方，让执行时效率更高</p><p><code>inline</code>是一种“用于实现的关键字“，必须和定义写在一起，放在声明旁边没有用</p><p>类中定义的成员函数默认为 <code>inline</code></p><hr><h3 id="Lamda表达式"><a href="#Lamda表达式" class="headerlink" title="Lamda表达式"></a>Lamda表达式</h3><p>Lamda表达式可以造一个临时的匿名函数，省去了声明的麻烦，而且在用完后立刻销毁，非常绿色；</p><p>语法：<code>[捕获参数]（参数列表）修饰符-&gt;返回类型&#123;函数体&#125;</code></p><ul><li>捕获参数：可以获取这个函数所在处的一些局部变量来用，例如：<ul><li><code>[var]</code> 按值传递方式获取 var 变量</li><li><code>[&amp;var]</code> 按引用传递方式获取 var 变量</li><li><code>[=]</code> 按值传递方式获取局部所有变量，<code>[&amp;]</code> 按引用传递获取局部所有变量</li><li><code>[=, &amp;var]</code> var按引用传递，其他所有按值传递</li><li>其他同理</li></ul></li><li>参数列表：就是参数列表，若无可以和 () 一起省略</li><li>修饰符：捕获参数时默认为const，加mutable修饰符可以取消这个const</li><li>返回类型：如果函数体只有一次return或返回类型为void，可以连<code>-&gt;</code>一同省略</li></ul><p>Lamda表达式常用于<code>sort</code>等STL方法时，方便地自定义一个临时函数</p><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><hr><h4 id="typedef、decltype和auto"><a href="#typedef、decltype和auto" class="headerlink" title="typedef、decltype和auto"></a>typedef、decltype和auto</h4><p>有几个需要注意的点：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">double</span> aaa, *bbb;<span class="hljs-comment">//对bbb的理解：其实是typedef double* bbb;</span><span class="hljs-comment">//bbb p &lt;=&gt; double *p</span><span class="hljs-keyword">using</span> bbb = <span class="hljs-type">double</span>*;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">decltype</span>(x) p;<span class="hljs-comment">//根据x的类型推断出一个类型；</span><span class="hljs-comment">//分两种情况：若x是一个变量，则推断出变量本身的类型；</span><span class="hljs-comment">//若x是表达式，则推断出表达式本身类型之后，再根据这个表达式能否作为左值，决定是否保留引用；</span><span class="hljs-type">int</span> x = <span class="hljs-number">3</span>;<span class="hljs-type">int</span> &amp;y = x;<span class="hljs-keyword">decltype</span>(x) <span class="hljs-comment">//推断为int</span><span class="hljs-keyword">decltype</span>(&amp;x) <span class="hljs-comment">// 推断为int*</span><span class="hljs-keyword">decltype</span>((x)) <span class="hljs-comment">//因为是表达式，而(x)是左值，所以被推断为了int&amp;，最特殊的情况</span><span class="hljs-keyword">decltype</span>(y) <span class="hljs-comment">//推断为int&amp;</span><span class="hljs-keyword">decltype</span>(x*<span class="hljs-number">1.5</span>) <span class="hljs-comment">// 推断为double（经测试，占用了8个字节）</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//decltype和auto都可以直接加上const修饰符</span><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> t = <span class="hljs-number">32</span>;</code></pre></div><h4 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z, <span class="hljs-type">double</span> d = <span class="hljs-number">2.0</span>, <span class="hljs-type">int</span> f = <span class="hljs-number">3</span>)</span></span>&#123;    <span class="hljs-comment">//可以使用默认的参数，在调用时可以不填写这一参数；</span>    <span class="hljs-comment">//默认参数必须都在最后面（即任意默认参数后不能再有非默认参数</span>    <span class="hljs-comment">//这样调用时非默认参数依然是按顺序对应的</span>    <span class="hljs-comment">//注意：默认参数和定义写在一起，单独声明时不管</span>&#125;</code></pre></div><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> x + y;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">int</span> (*p)(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) = add;<span class="hljs-comment">//这个函数指针可以指向任意参数相同，返回值相同的函数；</span>cout &lt;&lt; <span class="hljs-built_in">p</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<span class="hljs-comment">//直接用，结果是5</span>&#125;</code></pre></div><p>关于在类的成员函数内可以随意调用这个类（即使不是同一对象）的私有成员：</p><p>可以从作用域的角度来理解，私有成员的作用域仅在成员函数当中，类本身就是一个域。</p><h4 id="重载cin，-cout"><a href="#重载cin，-cout" class="headerlink" title="重载cin， cout"></a>重载cin， cout</h4><p>这两个东西的类型分别是<code>istream</code>和<code>ostream</code>，它们都是类；</p><p>这两种类的基本操作是 <code>&gt;&gt; &lt;&lt;</code> 两种运算符，返回值类型是其本身的引用，原理大概这样：</p><div class="code-wrapper"><pre><code class="hljs c++">istream&amp; <span class="hljs-keyword">operator</span> &gt;&gt;(<span class="hljs-type">int</span> &amp;x) &#123;<span class="hljs-comment">//读取x</span><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-comment">//当然这不是可以运行的代码，只是大概展示原理</span></code></pre></div><p>运算后返回了cin本身，所以可以连着&gt;&gt;；</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//试图用一般类的方式重载，失败</span>istream&amp; istream::<span class="hljs-keyword">operator</span> &gt;&gt;(<span class="hljs-type">int</span>&amp; x) &#123;<span class="hljs-built_in">scanf_s</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-comment">//用全局变量的方式重载，成功</span>istream&amp; <span class="hljs-keyword">operator</span> &gt;(istream&amp; f, <span class="hljs-type">int</span>&amp; x) &#123;<span class="hljs-built_in">scanf_s</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<span class="hljs-keyword">return</span> f;&#125;</code></pre></div><p>需要注意的是：传参和返回都一定要是引用类型，这两个类本身不支持传值拷贝</p><h4 id="C-风格的强制转换"><a href="#C-风格的强制转换" class="headerlink" title="C++风格的强制转换"></a>C++风格的强制转换</h4><p><code>static_cast&lt;类型&gt;(表达式)</code> C++风格的一般强制转换，暂且当做C语言的强制转换替代来用</p><p><code>const_cast&lt;类型&gt;(指针或引用)</code> 可以取消指针或引用中的底层常量性。也就是说，本来这个指针认为，它指向的内容是不可更改的，现在告诉它可以更改了。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;a;<span class="hljs-comment">//定义指向常量的指针，指向了一个变量，指针也将其视为常量，不可通过*p更改</span><span class="hljs-type">int</span> *q = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span> *&gt;(p);<span class="hljs-comment">//现在指针认为它指向的不是常量了</span>*q = <span class="hljs-number">4</span>;<span class="hljs-comment">//可行</span></code></pre></div><p><code>dynamic_cast&lt;类型&gt;(表达式)</code> 带有安全检查的强制转换，不能用于内置类型；</p><p>将子类转换为父类时，由于本身就是安全的，<code>dynamic_cast</code> 同 <code>static_cast</code> 一样；</p><p>将父类转换为子类时，<code>dynamic_cast</code> 会在转换失败时返回NULL，比 <code>static_cast</code> 更安全</p><h4 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h4><p><strong>#define A(x) #x</strong></p><p>#用于将x变成字符串，即”x”，因为字符串里面直接写的x不会被替换所以有这个语法</p><p><strong>#define A(x, y) x##y</strong></p><p>##用于连接两部分，因为xy直接写一起不会被替换所以有这个语法，也可以连接形参和普通字符，##左右可以有空格，都会被忽略。</p><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>new实际上包括operator new和placement new。operator new仅分配内存（相当于malloc），placement new即调用构造函数</p><p><strong>new (place) T(…)</strong></p><p>placement new的显示调用方法，不分配地址，直接在已有的地址place上构造。</p><p><strong>operator new</strong></p><p>可以全局重载或在类局部重载，例如</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>, size)</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size);&#125;</code></pre></div><p>针对类，可以显示地将new定义为私有或delete。</p><p>::xxx可以限定使用全局作用域下的xxx，例如 <code>::new</code> 显示地使用全局的operator new方法分配，跳过类的operator new使用全局的operator new。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高质量补题记录集</title>
    <link href="/2022/09/28/2022-09-28-%E9%AB%98%E8%B4%A8%E9%87%8F%E8%A1%A5%E9%A2%98%E8%AE%B0%E5%BD%95%E9%9B%86/"/>
    <url>/2022/09/28/2022-09-28-%E9%AB%98%E8%B4%A8%E9%87%8F%E8%A1%A5%E9%A2%98%E8%AE%B0%E5%BD%95%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h4 id="2022牛客第一场-J"><a href="#2022牛客第一场-J" class="headerlink" title="2022牛客第一场 J"></a>2022牛客第一场 J</h4><p><a href="https://ac.nowcoder.com/acm/contest/33186/J">Serval and Essay</a></p><p>一道不错的图论题</p><p>比较有价值的部分是图的合并，类似并查集，合并两点时可以使用其中一个点编号作为合并后的点集编号。</p><p>用启发式合并思想，让小集合向大集合合并，合并时将小集合上的连边转移到大集合上。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<span class="hljs-type">int</span> fa[maxn], siz[maxn], cnt[maxn];set&lt;<span class="hljs-type">int</span>&gt; nt[maxn], fm[maxn];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    <span class="hljs-keyword">if</span>(fa[x] == x) <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> fa[x] = <span class="hljs-built_in">find</span>(fa[x]);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cnt[i] = <span class="hljs-number">0</span>;        nt[i].<span class="hljs-built_in">clear</span>(), fm[i].<span class="hljs-built_in">clear</span>();        fa[i] = i, siz[i] = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> k; cin &gt;&gt; k;        cnt[i] = k;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)&#123;            <span class="hljs-type">int</span> x; cin &gt;&gt; x;            nt[x].<span class="hljs-built_in">insert</span>(i);            fm[i].<span class="hljs-built_in">insert</span>(x);        &#125;    &#125;    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q; <span class="hljs-comment">//存要合并的两个集合</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(cnt[i] == <span class="hljs-number">1</span>)&#123;            q.<span class="hljs-built_in">emplace</span>(i, *fm[i].<span class="hljs-built_in">begin</span>());        &#125;    &#125;    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;        <span class="hljs-keyword">auto</span> [x, y] = q.<span class="hljs-built_in">front</span>();        q.<span class="hljs-built_in">pop</span>();        <span class="hljs-comment">//merge</span>        x = <span class="hljs-built_in">find</span>(x), y = <span class="hljs-built_in">find</span>(y);        <span class="hljs-keyword">if</span>(x == y) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span>(siz[x] &gt; siz[y]) <span class="hljs-built_in">swap</span>(x, y);        fa[x] = y;        siz[y] += siz[x];        ans = <span class="hljs-built_in">max</span>(ans, siz[y]);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: nt[x])&#123;            <span class="hljs-keyword">if</span>(nt[y].<span class="hljs-built_in">count</span>(v))&#123;                cnt[v]--;                <span class="hljs-keyword">if</span>(cnt[v] == <span class="hljs-number">1</span>) q.<span class="hljs-built_in">emplace</span>(v, y);            nt[y].<span class="hljs-built_in">insert</span>(v);        &#125;    &#125;    <span class="hljs-type">static</span> <span class="hljs-type">int</span> cas = <span class="hljs-number">0</span>;    cout &lt;&lt; <span class="hljs-string">&quot;Case #&quot;</span> &lt;&lt; ++cas &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="2022牛客第三场B"><a href="#2022牛客第三场B" class="headerlink" title="2022牛客第三场B"></a>2022牛客第三场B</h4><p><a href="https://ac.nowcoder.com/acm/contest/33188/B">Boss</a></p><p>学到一个可删除堆的奇技淫巧，但这还不是关键</p><p>这里的最短路类似二分图和网络流中的“增广路”，路径代表的是一种<strong>转移方案</strong>，$a-b-c-d$ 这样的一条路径，实际上指将当前的人放到 $a$ 处，$a$ 中选取一个代价最小的人移到 $b$ 处…最后 $d$ 处多出一个人，最短路径即为将 $i$ 塞入的最小代价。</p><p>可以用一个set记录每个节点上已经有哪些人，记 $u,v$ 间的转移方案 ${dis,id}$，表示将 $id$ 这个人从 $u$ 转移到 $v$ 的代价为 $dis$，开 $K^2$ 个堆记录任意两点间的所有转移方案，在人员变动时维护。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">heap</span>&#123; <span class="hljs-comment">//奇技淫巧：可删除堆 常数优秀</span>    priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt; &gt; q1, q2;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x)</span> </span>&#123;q1.<span class="hljs-built_in">push</span>(x);&#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x)</span> </span>&#123;q2.<span class="hljs-built_in">push</span>(x);&#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">while</span>(!q1.<span class="hljs-built_in">empty</span>() &amp;&amp; !q2.<span class="hljs-built_in">empty</span>() &amp;&amp; q1.<span class="hljs-built_in">top</span>() == q2.<span class="hljs-built_in">top</span>())&#123;            q1.<span class="hljs-built_in">pop</span>();            q2.<span class="hljs-built_in">pop</span>();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-built_in">release</span>();        <span class="hljs-keyword">return</span> q1.<span class="hljs-built_in">empty</span>();    &#125;    <span class="hljs-function">T <span class="hljs-title">top</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-built_in">release</span>();        <span class="hljs-keyword">return</span> q1.<span class="hljs-built_in">top</span>();    &#125;&#125;;<span class="hljs-type">int</span> n, m;heap&lt;pair&lt;ll, <span class="hljs-type">int</span>&gt;&gt; tr[<span class="hljs-number">12</span>][<span class="hljs-number">12</span>]; <span class="hljs-comment">//tr[x][y] 从x到y的所有可行路径，&#123;dis, id&#125;</span>set&lt;<span class="hljs-type">int</span>&gt; nodes[<span class="hljs-number">12</span>]; <span class="hljs-comment">//存每个节点上所有的人</span>ll vol[maxn];ll cost[maxn][<span class="hljs-number">12</span>]; <span class="hljs-comment">//基础花费：cost[x][k] x这个人匹配第k个城市的代价</span><span class="hljs-function">ll <span class="hljs-title">move_dis</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123; <span class="hljs-comment">//转移代价：u这个人从x城切换到y城的代价</span>    <span class="hljs-keyword">return</span> cost[u][y] - cost[u][x];&#125;<span class="hljs-function">pair&lt;ll, <span class="hljs-type">int</span>&gt; <span class="hljs-title">min_dis</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123; <span class="hljs-comment">//获取当前从x转移到y代价最小的路径</span>    <span class="hljs-keyword">if</span>(tr[x][y].<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;INF, <span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">return</span> tr[x][y].<span class="hljs-built_in">top</span>();&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span>&#123; <span class="hljs-comment">//在k城添加一个人p，维护</span>    nodes[k].<span class="hljs-built_in">insert</span>(p);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-keyword">if</span>(i == k) <span class="hljs-keyword">continue</span>;        tr[k][i].<span class="hljs-built_in">push</span>(&#123;<span class="hljs-built_in">move_dis</span>(p, k, i), p&#125;);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span>&#123; <span class="hljs-comment">//从k城移除一个人p，维护</span>    nodes[k].<span class="hljs-built_in">erase</span>(p);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-keyword">if</span>(i == k) <span class="hljs-keyword">continue</span>;        tr[k][i].<span class="hljs-built_in">erase</span>(&#123;<span class="hljs-built_in">move_dis</span>(p, k, i), p&#125;);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) cin &gt;&gt; vol[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;            cin &gt;&gt; cost[i][j];        &#125;    &#125;    ll ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-comment">//先跑最短路，即最小的将当前i塞进去的代价</span>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(m+<span class="hljs-number">1</span>)</span></span>;        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">frm</span>(m+<span class="hljs-number">1</span>, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">inq</span><span class="hljs-params">(m+<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++) q.<span class="hljs-built_in">push</span>(j), d[j] = cost[i][j];        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;            <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();            q.<span class="hljs-built_in">pop</span>();            inq[u] = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">1</span>;v&lt;=m;v++)&#123;                <span class="hljs-keyword">if</span>(v == u) <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">auto</span> [dis, id] = <span class="hljs-built_in">min_dis</span>(u, v);                <span class="hljs-keyword">if</span>(d[v] &gt; d[u] + dis)&#123;                    d[v] = d[u] + dis;                    frm[v] = &#123;u, id&#125;;                    <span class="hljs-keyword">if</span>(!inq[v]) q.<span class="hljs-built_in">push</span>(v), inq[v] = <span class="hljs-literal">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-type">int</span> ed = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;            <span class="hljs-keyword">if</span>(nodes[j].<span class="hljs-built_in">size</span>() &gt;= vol[j]) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span>(!ed || d[j] &lt; d[ed]) ed = j;        &#125;        <span class="hljs-built_in">assert</span>(ed);        ans += d[ed];   <span class="hljs-comment">//记录将i这个人塞进去的转移路径，沿着路径每个节点的状态，同时维护堆</span>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;            <span class="hljs-keyword">auto</span> [fa, id] = frm[ed];            <span class="hljs-keyword">if</span>(!fa)&#123;                <span class="hljs-built_in">add</span>(ed, i);                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-built_in">remove</span>(fa, id);            <span class="hljs-built_in">add</span>(ed, id);            ed = fa;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="2022杭电第四场1002"><a href="#2022杭电第四场1002" class="headerlink" title="2022杭电第四场1002"></a>2022杭电第四场1002</h4><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7175">Link with Running</a></p><p>边权有两种：距离和价值，要求一条距离最短前提下的价值最大的路。（距离可以为0）</p><p>因为距离为0，一条无距离有价值的路实际上相当于一条负权边，无法用传统dijkstra解决。</p><p>解法：先仅按照距离dij跑出到每个点的最短距离，<strong>得到最短路径图</strong>，在最短路径图上，tarjian缩点去除可能存在的环，变成一个DAG，再在DAG上跑最长路即可。</p><ul><li><p>最短路径图即图上所有最短路径构成的图，可以从终点开始往前逆向跑，对于所有 $dis_v&#x3D;dis_u+w$ 的路径加入最短路径图，也可以直接顺着跑，得到的点数会更多（包含了到所有点的最短路）。</p></li><li><p>DAG上的最长路可以按拓扑序更新（即一个点需要在前驱都遍历后更新），也可以直接spfa。</p></li></ul><p>思路很简单，但是几层图换来换去代码属实调了很久，最后整出来这么一份非常结构化的代码，但还是很难直接拿去当图论模板..</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;    <span class="hljs-type">int</span> t, w, val;&#125;;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> E&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-type">int</span> n;    vector&lt;vector&lt;E&gt;&gt; vp;    <span class="hljs-built_in">Graph</span>(<span class="hljs-type">int</span> n): <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">vp</span>(n+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;E&gt;())&#123;&#125;;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">const</span> E &amp;e)</span></span>&#123; vp[x].<span class="hljs-built_in">push_back</span>(e);&#125;&#125;;<span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">dijkstra</span><span class="hljs-params">(Graph&lt;Edge&gt; &amp;g, <span class="hljs-type">int</span> st)</span></span>&#123;    <span class="hljs-keyword">using</span> pii = pair&lt;ll, <span class="hljs-type">int</span>&gt;;    <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">dis</span><span class="hljs-params">(g.n+<span class="hljs-number">1</span>, INF)</span></span>;    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; q;    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, st&#125;); dis[st] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;        pii uq = q.<span class="hljs-built_in">top</span>();        ll ud = uq.first, u = uq.second;        q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">if</span>(ud &gt; dis[u]) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">for</span>(Edge &amp;e: g.vp[u])&#123;            <span class="hljs-type">int</span> v = e.t;            <span class="hljs-keyword">if</span>(dis[v] &gt; dis[u] + e.w)&#123;                dis[v] = dis[u] + e.w;                q.<span class="hljs-built_in">push</span>(&#123;dis[v], v&#125;);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dis;&#125;<span class="hljs-comment">//获取最短路径图</span>Graph&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; <span class="hljs-built_in">pathGraph</span>(Graph&lt;Edge&gt; &amp;g, <span class="hljs-type">int</span> st)&#123;    <span class="hljs-keyword">auto</span> dis = <span class="hljs-built_in">dijkstra</span>(g, <span class="hljs-number">1</span>); <span class="hljs-comment">//计算最短路</span>    Graph&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; <span class="hljs-built_in">res</span>(g.n);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=g.n;i++)&#123;        <span class="hljs-keyword">for</span>(Edge &amp;e: g.vp[i])&#123;            <span class="hljs-type">int</span> v = e.t;            <span class="hljs-keyword">if</span>(dis[v] == dis[i] + e.w)&#123;                res.<span class="hljs-built_in">addEdge</span>(i, &#123;v, e.val&#125;);            &#125;        &#125;    &#125;    cout &lt;&lt; dis[g.n] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">namespace</span> Connect&#123;    <span class="hljs-type">int</span> scc[maxn], stk[maxn], h, scn;    <span class="hljs-type">int</span> dfn[maxn], low[maxn], dfc;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjian</span><span class="hljs-params">(Graph&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; &amp;g,<span class="hljs-type">int</span> p)</span></span>&#123;        dfn[p] = low[p] = ++dfc;        stk[++h] = p;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e: g.vp[p])&#123;            <span class="hljs-type">int</span> v = e.first;            <span class="hljs-keyword">if</span>(!dfn[v]) &#123;                <span class="hljs-built_in">tarjian</span>(g, v);                low[p] = <span class="hljs-built_in">min</span>(low[p], low[v]);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!scc[v]) &#123;                low[p] = <span class="hljs-built_in">min</span>(low[p], dfn[v]);            &#125;        &#125;        <span class="hljs-keyword">if</span>(low[p] == dfn[p])&#123;            ++scn;            <span class="hljs-keyword">while</span>(stk[h] != p) scc[stk[h--]] = scn;            scc[stk[h--]] = scn;        &#125;    &#125;    Graph&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; <span class="hljs-built_in">getDag</span>(Graph&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; &amp;g)&#123;        h = scn = dfc = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=g.n;i++) dfn[i] = scc[i] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=g.n;i++) <span class="hljs-keyword">if</span>(!scc[i]) <span class="hljs-built_in">tarjian</span>(g, i);        Graph&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; <span class="hljs-built_in">res</span>(scn);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=g.n;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e: g.vp[i])&#123;                <span class="hljs-type">int</span> v = e.first;                <span class="hljs-keyword">if</span>(scc[i] != scc[v])&#123;                    res.<span class="hljs-built_in">addEdge</span>(scc[i], &#123;scc[v], e.second&#125;);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n, m;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-function">Graph&lt;Edge&gt; <span class="hljs-title">g</span><span class="hljs-params">(n)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-type">int</span> x, y, e, p;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; e &gt;&gt; p;        g.<span class="hljs-built_in">addEdge</span>(x, &#123;y, e, p&#125;);    &#125;    <span class="hljs-keyword">auto</span> spg = <span class="hljs-built_in">pathGraph</span>(g, <span class="hljs-number">1</span>);    <span class="hljs-keyword">auto</span> dag = Connect::<span class="hljs-built_in">getDag</span>(spg);    <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">f</span><span class="hljs-params">(dag.n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">du</span><span class="hljs-params">(dag.n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=dag.n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e: dag.vp[i])&#123;            du[e.first]++;        &#125;    &#125;    queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=dag.n;i++) <span class="hljs-keyword">if</span>(du[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();        q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e: dag.vp[u])&#123;            <span class="hljs-type">int</span> v = e.first;            f[v] = <span class="hljs-built_in">max</span>(f[v], f[u] + e.second);            <span class="hljs-keyword">if</span>(--du[v] &lt;= <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(v);        &#125;    &#125;    cout &lt;&lt; f[Connect::scc[n]] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="2022杭电第四场1005"><a href="#2022杭电第四场1005" class="headerlink" title="2022杭电第四场1005"></a>2022杭电第四场1005</h4><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7178">Link with Level Editor II</a></p><p>矩阵+神奇双指针（对顶栈）</p><p>首先这题可以用矩阵维护一段区间的方案数，但矩阵并非一定可逆，故没法用前缀和搞。</p><p>比较容易想到的是线段树暴力维护矩阵区间乘，常数很大但是卡卡能过。</p><p>另有神奇的<strong>无需删除</strong>的双指针尺取（题解叫对顶栈）：</p><p><img src="http://lxtyin.ac.cn/img/other/2.png"></p><p>如图所示，双指针 $l,r$ 即为两个栈顶，右指针移动时将新元素加入右栈中；左指针移动时将栈顶元素弹出，接触到中间点时，将右栈的所有元素一一弹出并加入左栈，将右端点作为新的中点。</p><p>左栈中加入元素时记录该元素到中点的后缀和，这样在左栈弹出后，仍可以得知左栈的总和，和右栈和相加得到区间和（此题中为积）。</p><p>如此便可以 $O(n)$ 地做不带删除的尺取了！</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> lim;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">matrix</span>&#123;    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">21</span>, M = <span class="hljs-number">21</span>;    ll a[N][M];    <span class="hljs-built_in">matrix</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//单位矩阵</span>        <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a));        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++) a[i][i] = x;    &#125;    <span class="hljs-keyword">inline</span> matrix <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> matrix&amp; y) <span class="hljs-type">const</span>&#123;        matrix r = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; M; ++k) &#123;                ll t = a[i][k];                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; M; ++j)&#123;                    r.a[i][j] += t * y.a[k][j];                    <span class="hljs-keyword">if</span>(r.a[i][j] &gt; lim) r.a[i][j] = lim + <span class="hljs-number">1</span>;                &#125;            &#125;        <span class="hljs-keyword">return</span> r;    &#125;&#125;;matrix a[maxn], s[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n, m;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; lim;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> l; cin &gt;&gt; l;        a[i] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=l;j++)&#123;            <span class="hljs-type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;            a[i].a[x][y] = <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-function">matrix <span class="hljs-title">cur</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)&#123;        ll ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;            ans += s[l].a[<span class="hljs-number">1</span>][i] * cur.a[i][m];            <span class="hljs-keyword">if</span>(ans &gt; lim) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;;    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, mid = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>, r=<span class="hljs-number">1</span>; r&lt;=n; r++)&#123;        cur = cur * a[r];        <span class="hljs-keyword">while</span>(l == <span class="hljs-number">0</span> || !<span class="hljs-built_in">check</span>(l, r))&#123;            l++;            <span class="hljs-keyword">if</span>(l &gt; mid)&#123;                s[r] = a[r];                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=r<span class="hljs-number">-1</span>;i&gt;mid;i--) s[i] = a[i] * s[i+<span class="hljs-number">1</span>];                mid = r;                cur = <span class="hljs-number">1</span>;            &#125;        &#125;        ans = <span class="hljs-built_in">max</span>(ans, r - l + <span class="hljs-number">1</span>);    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="2022杭电第八场1002"><a href="#2022杭电第八场1002" class="headerlink" title="2022杭电第八场1002"></a>2022杭电第八场1002</h4><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7221">Darkmoon Faire</a></p><p>大力数据结构维护题。</p><p>从左往右推，设 $f_i$ 为前 $i$ 个位置划分好的方案数，接下来要转移到 $i+1$。</p><p>维护两个单调栈，一个递增一个递减，对于递增单调栈中相邻两个位置 $x,y$，可以知道 $(x,y]$ 这段作为起始位置时，最小值都为 $a_y$。那么就可以知道：这段区间中的所有奇数&#x2F;偶数位置都能满足最小值条件。</p><p>对于最大值条件也是同理，可以用两个线段树分别维护奇偶位置上的tag（满足条件数），同时满足两个条件的位置即可进行转移。</p><p>线段树中，维护每个区间的最大满足条件的数量（tag），和具有最大条件数量的位置的 $f_i$ 之和。对线段树的操作包括单点添加新的dp值，区间tag加1和减1（在单调栈中元素被pop时减）。</p><p>因为我们的操作能保证合理（只对具有tag1区间的减tag1，tag2一样），所以不需要记录区间具有两种条件的哪一种，只需要记录数量即可。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, a[maxn];ll f[maxn];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">segTree</span> &#123;    function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; fp; <span class="hljs-comment">//自带离散映射的线段树</span>    ll sum[maxn &lt;&lt; <span class="hljs-number">2</span>], mx[maxn &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-type">int</span> add[maxn &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;        add[p] = sum[p] = mx[p] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span>;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-built_in">build</span>(p * <span class="hljs-number">2</span>, l, mid);        <span class="hljs-built_in">build</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        sum[p] = <span class="hljs-number">0</span>, mx[p] = <span class="hljs-built_in">max</span>(mx[p * <span class="hljs-number">2</span>], mx[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]);        <span class="hljs-keyword">if</span>(mx[p] == mx[p * <span class="hljs-number">2</span>]) (sum[p] += sum[p * <span class="hljs-number">2</span>]) %= mode;        <span class="hljs-keyword">if</span>(mx[p] == mx[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]) (sum[p] += sum[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]) %= mode;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_add</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> d)</span> </span>&#123;        mx[p] += d;        add[p] += d;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        <span class="hljs-keyword">if</span>(add[p]) &#123;            <span class="hljs-built_in">push_add</span>(p * <span class="hljs-number">2</span>, add[p]);            <span class="hljs-built_in">push_add</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, add[p]);            add[p] = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addvalue</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, ll val)</span> </span>&#123;        <span class="hljs-keyword">if</span>(l == r) &#123;            (sum[p] += val) %= mode;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-built_in">push_down</span>(p);        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(pos &lt;= <span class="hljs-built_in">fp</span>(mid)) <span class="hljs-built_in">addvalue</span>(p * <span class="hljs-number">2</span>, l, mid, pos, val);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">addvalue</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, pos, val);        <span class="hljs-built_in">push_up</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> d)</span> </span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fp</span>(l) &gt; R || L &gt; <span class="hljs-built_in">fp</span>(r)) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(L &lt;= <span class="hljs-built_in">fp</span>(l) &amp;&amp; <span class="hljs-built_in">fp</span>(r) &lt;= R) &#123;            <span class="hljs-built_in">push_add</span>(p, d);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-built_in">push_down</span>(p);        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-built_in">modify</span>(p * <span class="hljs-number">2</span>, l, mid, L, R, d);        <span class="hljs-built_in">modify</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R, d);        <span class="hljs-built_in">push_up</span>(p);    &#125;    <span class="hljs-function">ll <span class="hljs-title">queryTot</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(mx[<span class="hljs-number">1</span>] == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> sum[<span class="hljs-number">1</span>];        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;st[<span class="hljs-number">2</span>];<span class="hljs-type">int</span> stk[<span class="hljs-number">2</span>][maxn], h[<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) cin &gt;&gt; a[i];    st[<span class="hljs-number">0</span>].fp = [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x;&#125;;    st[<span class="hljs-number">1</span>].fp = [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x - <span class="hljs-number">1</span>;&#125;;    <span class="hljs-type">int</span> hn = (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;    st[<span class="hljs-number">0</span>].<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn);    st[<span class="hljs-number">1</span>].<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn);    h[<span class="hljs-number">0</span>] = h[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    stk[<span class="hljs-number">1</span>][++h[<span class="hljs-number">1</span>]] = stk[<span class="hljs-number">0</span>][++h[<span class="hljs-number">0</span>]] = <span class="hljs-number">0</span>;    f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        st[i &amp; <span class="hljs-number">1</span>].<span class="hljs-built_in">addvalue</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn, i, f[i - <span class="hljs-number">1</span>]);        <span class="hljs-keyword">while</span>(h[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span> &amp;&amp; a[stk[<span class="hljs-number">0</span>][h[<span class="hljs-number">0</span>]]] &gt; a[i]) &#123;            <span class="hljs-type">int</span> f = stk[<span class="hljs-number">0</span>][h[<span class="hljs-number">0</span>]] &amp; <span class="hljs-number">1</span>;            st[f ^ <span class="hljs-number">1</span>].<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn, stk[<span class="hljs-number">0</span>][h[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, stk[<span class="hljs-number">0</span>][h[<span class="hljs-number">0</span>]], <span class="hljs-number">-1</span>);            h[<span class="hljs-number">0</span>]--;        &#125;        st[(i &amp; <span class="hljs-number">1</span>) ^ <span class="hljs-number">1</span>].<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn, stk[<span class="hljs-number">0</span>][h[<span class="hljs-number">0</span>]] + <span class="hljs-number">1</span>, i, <span class="hljs-number">1</span>);        stk[<span class="hljs-number">0</span>][++h[<span class="hljs-number">0</span>]] = i;        <span class="hljs-keyword">while</span>(h[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span> &amp;&amp; a[stk[<span class="hljs-number">1</span>][h[<span class="hljs-number">1</span>]]] &lt; a[i]) &#123;            <span class="hljs-type">int</span> f = stk[<span class="hljs-number">1</span>][h[<span class="hljs-number">1</span>]] &amp; <span class="hljs-number">1</span>;            st[f].<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn, stk[<span class="hljs-number">1</span>][h[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, stk[<span class="hljs-number">1</span>][h[<span class="hljs-number">1</span>]], <span class="hljs-number">-1</span>);            h[<span class="hljs-number">1</span>]--;        &#125;        st[i &amp; <span class="hljs-number">1</span>].<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, hn, stk[<span class="hljs-number">1</span>][h[<span class="hljs-number">1</span>]] + <span class="hljs-number">1</span>, i, <span class="hljs-number">1</span>);        stk[<span class="hljs-number">1</span>][++h[<span class="hljs-number">1</span>]] = i;        f[i] = (st[<span class="hljs-number">0</span>].<span class="hljs-built_in">queryTot</span>() + st[<span class="hljs-number">1</span>].<span class="hljs-built_in">queryTot</span>()) % mode;    &#125;    cout &lt;&lt; f[n] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="2022杭电第八场1009"><a href="#2022杭电第八场1009" class="headerlink" title="2022杭电第八场1009"></a>2022杭电第八场1009</h4><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=7228">Gilneas</a></p><p>感觉挺妙的一个线段树上概率处理+线段树合并</p><p>对于每个点 $u$，它连向子树的边中一定只存在一条有颜色。</p><p>考虑 $u$ 的这个子树中的每个操作，将它们按照时间排序，一个操作能为 $u$ 的连边作出贡献，当且仅当这个操作成功，且之后的操作都失败。</p><p>把操作按时间放到线段树上，区间维护 $sxp$ 表示区间内所有操作的 $1-p$ 乘积（全失败的概率），和 $sum$ 表示 $c_i\times p_i\times\prod_{j&gt;i}(1-p_{j})$ 的总和。即期望贡献。</p><p>这两个信息很好push_up。</p><p>那么对于每个点 $u$，将其子树的线段树合并起来之后取 $sum$ 即可得到它连儿子边的总贡献，注意还要考虑 $u$ 这个点本身的操作会将边权清空，计算sum时可以先将 $u$ 本身的操作的 $c_i$ 视为0加入线段树，处理贡献后再将 $c_i$ 改回来。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">segTree</span> &#123;    ll sum[maxn &lt;&lt; <span class="hljs-number">5</span>], sxp[maxn &lt;&lt; <span class="hljs-number">5</span>];    <span class="hljs-type">int</span> ls[maxn &lt;&lt; <span class="hljs-number">5</span>], rs[maxn &lt;&lt; <span class="hljs-number">5</span>];    <span class="hljs-type">int</span> tcnt = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newnode</span><span class="hljs-params">()</span> </span>&#123;        ++tcnt;        sum[tcnt] = <span class="hljs-number">0</span>;        sxp[tcnt] = <span class="hljs-number">1</span>;        ls[tcnt] = rs[tcnt] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> tcnt;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        sum[p] = (sum[ls[p]] * sxp[rs[p]] % mode + sum[rs[p]]) % mode;        sxp[p] = sxp[ls[p]] * sxp[rs[p]] % mode;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!x) <span class="hljs-keyword">return</span> y;        <span class="hljs-keyword">if</span>(!y) <span class="hljs-keyword">return</span> x;        <span class="hljs-built_in">assert</span>(l != r);        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        ls[x] = <span class="hljs-built_in">merge</span>(ls[x], ls[y], l, mid);        rs[x] = <span class="hljs-built_in">merge</span>(rs[x], rs[y], mid + <span class="hljs-number">1</span>, r);        <span class="hljs-built_in">push_up</span>(x);        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, ll pi, ll ci)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!p) p = <span class="hljs-built_in">newnode</span>();        <span class="hljs-keyword">if</span>(l == r) &#123;            sxp[p] = (<span class="hljs-number">1ll</span> - pi + mode) % mode;            sum[p] = pi * ci % mode;            <span class="hljs-keyword">return</span> p;        &#125;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(pos &lt;= mid) ls[p] = <span class="hljs-built_in">modify</span>(ls[p], l, mid, pos, pi, ci);        <span class="hljs-keyword">else</span> rs[p] = <span class="hljs-built_in">modify</span>(rs[p], mid + <span class="hljs-number">1</span>, r, pos, pi, ci);        <span class="hljs-built_in">push_up</span>(p);        <span class="hljs-keyword">return</span> p;    &#125;&#125;st;<span class="hljs-type">int</span> n, m;vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; opt[maxn];ll ans = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123; <span class="hljs-comment">//返回子树的线段树根节点</span>    <span class="hljs-type">int</span> rt = st.<span class="hljs-built_in">newnode</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> tup: opt[p]) &#123;        <span class="hljs-type">int</span> id = tup[<span class="hljs-number">0</span>], pi = tup[<span class="hljs-number">1</span>];        st.<span class="hljs-built_in">modify</span>(rt, <span class="hljs-number">1</span>, m, id, pi, <span class="hljs-number">0</span>);    &#125;     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : vp[p]) rt = st.<span class="hljs-built_in">merge</span>(rt, <span class="hljs-built_in">dfs</span>(v), <span class="hljs-number">1</span>, m);    (ans += st.sum[rt]) %= mode;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> tup : opt[p]) &#123;        <span class="hljs-type">int</span> id = tup[<span class="hljs-number">0</span>], pi = tup[<span class="hljs-number">1</span>], ci = tup[<span class="hljs-number">2</span>];        st.<span class="hljs-built_in">modify</span>(rt, <span class="hljs-number">1</span>, m, id, pi, ci);    &#125;    <span class="hljs-keyword">return</span> rt;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    st.tcnt = <span class="hljs-number">-1</span>;    st.<span class="hljs-built_in">newnode</span>(); <span class="hljs-comment">//初始化0点</span>    ans = <span class="hljs-number">0</span>;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        vp[i].<span class="hljs-built_in">clear</span>();        opt[i].<span class="hljs-built_in">clear</span>();    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++) &#123;        <span class="hljs-type">int</span> fa; cin &gt;&gt; fa;        vp[fa].<span class="hljs-built_in">push_back</span>(i);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++) &#123;        <span class="hljs-type">int</span> x, c, p;        cin &gt;&gt; x &gt;&gt; c &gt;&gt; p;        opt[x].<span class="hljs-built_in">push_back</span>(&#123;i, p, c&#125;);    &#125;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="2022杭电第九场1001"><a href="#2022杭电第九场1001" class="headerlink" title="2022杭电第九场1001"></a>2022杭电第九场1001</h4><p><a href="https://acm.dingbacode.com/showproblem.php?pid=7233">Arithmetic Subsequence</a></p><p>比较难想到是构造题</p><p>需要不包含任何等差数列，一个可以切入的思考点是：等差数列要么全是奇数&#x2F;偶数，要么在奇偶之间来回切换</p><p>如果把奇数放到一边，偶数放到另一边，那么必然不存在跨两边的等差数列，就可以分治求解了。</p><p>奇数部分可以集体-1，偶数部分可以集体除2，都不影响等差数列的存在性。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, a[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cdq</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;    <span class="hljs-keyword">if</span>(l + <span class="hljs-number">1</span> &gt;= r) <span class="hljs-keyword">return</span>;    <span class="hljs-type">int</span> m = l;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l;i &lt;= r;i++) <span class="hljs-keyword">if</span>(a[i] &amp; <span class="hljs-number">1</span>) <span class="hljs-built_in">swap</span>(a[m++], a[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l;i &lt; m;i++) a[i]--;    <span class="hljs-built_in">cdq</span>(l, m - <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = m;i &lt;= r;i++) a[i] /= <span class="hljs-number">2</span>;    <span class="hljs-built_in">cdq</span>(m, r);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l;i &lt; m;i++) a[i]++;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = m;i &lt;= r;i++) a[i] *= <span class="hljs-number">2</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) cin &gt;&gt; a[i];    <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>;i &lt;= n;i++) <span class="hljs-keyword">if</span>(a[i] == a[i - <span class="hljs-number">1</span>] &amp;&amp; a[i] == a[i - <span class="hljs-number">2</span>]) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-built_in">cdq</span>(<span class="hljs-number">1</span>, n);    cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;</code></pre></div><h4 id="2022杭电第十场1008"><a href="#2022杭电第十场1008" class="headerlink" title="2022杭电第十场1008"></a>2022杭电第十场1008</h4><p><a href="https://acm.dingbacode.com/showproblem.php?pid=7251">Minimum Diameter</a></p><p>对于静态森林，可以求出各个树的直径，将其他小直径的中点和最大直径的中点相连，答案易得。</p><p>所以问题转化为动态维护树上直径，操作只有连边</p><p>我们可以单开一个并查集记录每个树的直径以及直径两端点，合并两树时，只需考虑四个端点的两两组合，合并后的直径一定在它们当中。</p><p>使用LCT可以快速求出任意两点间距离，且支持森林连边操作。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LCT</span> &#123;    <span class="hljs-type">int</span> ch[maxn][<span class="hljs-number">2</span>], fa[maxn], siz[maxn], swp[maxn];    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">dir</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123; <span class="hljs-keyword">return</span> ch[fa[p]][<span class="hljs-number">1</span>] == p; &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123; siz[p] = <span class="hljs-number">1</span> + siz[ch[p][<span class="hljs-number">0</span>]] + siz[ch[p][<span class="hljs-number">1</span>]]; &#125;<span class="hljs-comment">//sum[p] = sum[ch[p][0]] ^ sum[ch[p][1]] ^ val[p]; &#125;</span>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">isroot</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123; <span class="hljs-keyword">return</span> fa[p] == <span class="hljs-number">0</span> || (ch[fa[p]][<span class="hljs-number">0</span>] != p &amp;&amp; ch[fa[p]][<span class="hljs-number">1</span>] != p); &#125; <span class="hljs-comment">//是否为splay的根（不是原树的根！）</span>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span>;        <span class="hljs-built_in">swap</span>(ch[p][<span class="hljs-number">0</span>], ch[p][<span class="hljs-number">1</span>]), swp[p] ^= <span class="hljs-number">1</span>;        <span class="hljs-comment">//        push_down(p);//调试用 立即下放所有懒标记</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        <span class="hljs-keyword">if</span>(swp[p]) &#123;            swp[p] = <span class="hljs-number">0</span>;            <span class="hljs-built_in">push_swap</span>(ch[p][<span class="hljs-number">0</span>]);            <span class="hljs-built_in">push_swap</span>(ch[p][<span class="hljs-number">1</span>]);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-comment">//出bug了必须首先来查rotate 注意变化前后顺序的问题 太麻了</span>        <span class="hljs-keyword">if</span>(fa[p] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-type">int</span> f = fa[p], ff = fa[f];        <span class="hljs-type">int</span> d = <span class="hljs-built_in">dir</span>(p), s = ch[p][d ^ <span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isroot</span>(f)) ch[ff][<span class="hljs-built_in">dir</span>(f)] = p;<span class="hljs-comment">//与普通splay不同之处：如果父亲节点已经是根节点，一定不能让ff认儿子</span>        fa[s] = f;        fa[p] = ff; ch[p][d ^ <span class="hljs-number">1</span>] = f;        fa[f] = p; ch[f][d] = s;        <span class="hljs-built_in">push_up</span>(f);<span class="hljs-comment">//最后一个节点的push_up在splay那</span>    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_all</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isroot</span>(p)) <span class="hljs-built_in">push_all</span>(fa[p]);        <span class="hljs-built_in">push_down</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-comment">//将p转到其所在splay（实链节点集合）的根节点</span>        <span class="hljs-built_in">push_all</span>(p);<span class="hljs-comment">//从顶向下push_down</span>        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isroot</span>(p)) &#123;            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isroot</span>(fa[p])) <span class="hljs-built_in">rotate</span>(<span class="hljs-built_in">dir</span>(p) == <span class="hljs-built_in">dir</span>(fa[p]) ? fa[p] : p);            <span class="hljs-built_in">rotate</span>(p);<span class="hljs-comment">//双旋，不管旋了父还是子，第二次旋转都要跟上，不然会假</span>        &#125;        <span class="hljs-built_in">push_up</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-comment">//打通p所在真实树的根节点到p的路径</span>        <span class="hljs-type">int</span> lst = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(p) &#123;            <span class="hljs-built_in">splay</span>(p);            ch[p][<span class="hljs-number">1</span>] = lst;            <span class="hljs-built_in">push_up</span>(p);            lst = p;            p = fa[p];        &#125;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeroot</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-comment">//p变为其所在真实树中的根节点（同时也是splay根）</span>        <span class="hljs-built_in">access</span>(p);        <span class="hljs-built_in">splay</span>(p);        <span class="hljs-built_in">push_swap</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findroot</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<span class="hljs-comment">//查找所在真实树的根节点，注意这个也会改变p所在splay结构</span>        <span class="hljs-built_in">access</span>(p);        <span class="hljs-built_in">splay</span>(p);        <span class="hljs-keyword">while</span>(ch[p][<span class="hljs-number">0</span>]) <span class="hljs-built_in">push_down</span>(p), p = ch[p][<span class="hljs-number">0</span>];        <span class="hljs-keyword">return</span> p;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-comment">//将x,y之间的路径剖出来作为splay，然后x作为原树根，y作为splay根</span>        <span class="hljs-built_in">makeroot</span>(x);        <span class="hljs-built_in">access</span>(y);        <span class="hljs-built_in">splay</span>(y);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-comment">//连边（虚边）</span>        <span class="hljs-built_in">makeroot</span>(x);        <span class="hljs-keyword">if</span>(x != <span class="hljs-built_in">findroot</span>(y)) fa[x] = y;<span class="hljs-comment">//注意，连虚边一定要让所在splay的根节点的fa连出去，这里x已经是splay根节点了而y不一定</span>    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-comment">//删边</span>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">findroot</span>(x) != <span class="hljs-built_in">findroot</span>(y)) <span class="hljs-keyword">return</span>;        <span class="hljs-built_in">split</span>(x, y);<span class="hljs-comment">//记牢此时x为原树根，y为splay根，原树根仅仅是深度最小的节点，完全可以有fa</span>        <span class="hljs-keyword">if</span>(fa[x] != y || ch[x][<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//要x,y之间有连边，就要它们在splay的中序遍历上相邻</span>        ch[y][<span class="hljs-number">0</span>] = fa[x] = <span class="hljs-number">0</span>;        <span class="hljs-built_in">push_up</span>(y);    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dist</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;        <span class="hljs-built_in">split</span>(x, y);        <span class="hljs-keyword">return</span> siz[y];    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++) ch[i][<span class="hljs-number">0</span>] = ch[i][<span class="hljs-number">1</span>] = fa[i] = swp[i] = <span class="hljs-number">0</span>;    &#125;&#125;lct;<span class="hljs-type">int</span> a[maxn], f[maxn];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">diameter</span> &#123;    <span class="hljs-type">int</span> x, y, d;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> diameter&amp; t)<span class="hljs-type">const</span> &#123;        <span class="hljs-keyword">return</span> d &lt; t.d;    &#125;&#125;d[maxn];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x == f[x]) <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> f[x] = <span class="hljs-built_in">find</span>(f[x]);&#125;<span class="hljs-type">int</span> cnt[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n, m;    cin &gt;&gt; n &gt;&gt; m;    lct.<span class="hljs-built_in">init</span>(n);    cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        f[i] = i;        lct.siz[i] = <span class="hljs-number">1</span>;        d[i] = &#123;i, i, <span class="hljs-number">0</span>&#125;;        cnt[i] = <span class="hljs-number">0</span>;        cnt[<span class="hljs-number">0</span>]++;    &#125;    <span class="hljs-type">int</span> mxd = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++) &#123;        <span class="hljs-type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;        <span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(x), fy = <span class="hljs-built_in">find</span>(y);        cnt[d[fx].d]--;        cnt[d[fy].d]--;        lct.<span class="hljs-built_in">link</span>(x, y);        diameter tmp = <span class="hljs-built_in">max</span>(d[fx], d[fy]);        tmp = <span class="hljs-built_in">max</span>(tmp, &#123;d[fx].x, d[fy].x, lct.<span class="hljs-built_in">dist</span>(d[fx].x, d[fy].x) - <span class="hljs-number">1</span>&#125;);        tmp = <span class="hljs-built_in">max</span>(tmp, &#123;d[fx].x, d[fy].y, lct.<span class="hljs-built_in">dist</span>(d[fx].x, d[fy].y) - <span class="hljs-number">1</span>&#125;);        tmp = <span class="hljs-built_in">max</span>(tmp, &#123;d[fx].y, d[fy].x, lct.<span class="hljs-built_in">dist</span>(d[fx].y, d[fy].x) - <span class="hljs-number">1</span>&#125;);        tmp = <span class="hljs-built_in">max</span>(tmp, &#123;d[fx].y, d[fy].y, lct.<span class="hljs-built_in">dist</span>(d[fx].y, d[fy].y) - <span class="hljs-number">1</span>&#125;);        f[fx] = fy;        d[fy] = tmp;        cnt[tmp.d]++;        mxd = <span class="hljs-built_in">max</span>(mxd, tmp.d);        <span class="hljs-comment">// for(auto x : alld) cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;</span>        <span class="hljs-comment">// cout &lt;&lt; &#x27;\n&#x27;;</span>        <span class="hljs-type">int</span> mx[<span class="hljs-number">4</span>], h = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;h &lt; <span class="hljs-number">3</span> &amp;&amp; i &lt;= cnt[mxd];i++) mx[++h] = mxd;        <span class="hljs-keyword">if</span>(mxd &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;h &lt; <span class="hljs-number">3</span> &amp;&amp; i &lt;= cnt[mxd - <span class="hljs-number">1</span>];i++) mx[++h] = mxd - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(mxd &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;h &lt; <span class="hljs-number">3</span> &amp;&amp; i &lt;= cnt[mxd - <span class="hljs-number">2</span>];i++) mx[++h] = mxd - <span class="hljs-number">2</span>;        <span class="hljs-type">int</span> ans = mx[<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span>(h &gt; <span class="hljs-number">1</span>) ans = <span class="hljs-built_in">max</span>(ans, (mx[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span> + (mx[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);        <span class="hljs-keyword">if</span>(h &gt; <span class="hljs-number">2</span>) ans = <span class="hljs-built_in">max</span>(ans, (mx[<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">2</span> + (mx[<span class="hljs-number">3</span>] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);        cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div><h4 id="COMPFEST-14-J-Journey"><a href="#COMPFEST-14-J-Journey" class="headerlink" title="COMPFEST 14 J. Journey"></a><a href="https://codeforces.com/contest/1725/problem/J">COMPFEST 14 J. Journey</a></h4><p>如果只有一个起点，答案即所有边权x2再减去树上的最长路径（直径）</p><p>现在可以取第二个起点，那么答案（要减去的部分）有两种情况：</p><ul><li>树上两条有单个点相交的路径</li><li>树上两条不相交的路径，再加上两路径之间的最大边x2</li></ul><p>对于第一种情况，考虑枚举交点，然后走四条链出去，这个比较好维护</p><p>第二种情况，枚举中间边，然后需要知道以这条边作为分割，上下两棵树的直径。</p><p>要维护这两个东西比较麻烦，具体如下：</p><div class="code-wrapper"><pre><code class="hljs C++">ll dia[maxn];   <span class="hljs-comment">// p这个子树的直径</span>ll dup[maxn];   <span class="hljs-comment">// 除去p子树的直径</span>ll dp[maxn][<span class="hljs-number">4</span>]; <span class="hljs-comment">// p向下最大的四条链</span>ll dp2[maxn][<span class="hljs-number">2</span>];<span class="hljs-comment">// p儿子中最大的两个直径</span>ll up[maxn];    <span class="hljs-comment">// p向上走的最长链</span></code></pre></div><p>首先一遍 dfs 求出 <code>dp, dp2, dia</code></p><p>然后再 dfs 第二遍，这一遍<strong>从上向下转移</strong></p><p>设当前跑到边 $u\rightarrow v$，边权 $w$</p><p><code>up[v]</code> 可以由 <code>up[u] + w</code>，以及 <code>u子树中除了v之外的最长链 + w</code> 转移来</p><p><code>dup[v]</code> 可以由 <code>dup[u]</code> 以及 <code>u子树中除了v之外的最大直径</code> 和 <code>u连出的链中除了v之外的最大两条链之和</code> 转移来</p><p>想到了这些就会发现题目可做了，然后就是分类讨论的事了（</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e6</span> + <span class="hljs-number">100</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> mode = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>; vector&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; vp[maxn];ll dia[maxn];   <span class="hljs-comment">// p子树的直径</span>ll dup[maxn];   <span class="hljs-comment">// 除去p子树的直径</span>ll dp[maxn][<span class="hljs-number">4</span>]; <span class="hljs-comment">// p向下最大的四条链</span>ll dp2[maxn][<span class="hljs-number">2</span>];<span class="hljs-comment">// p儿子中最大的两个直径</span>ll up[maxn];    <span class="hljs-comment">// 向上最长链</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add1to</span><span class="hljs-params">(<span class="hljs-type">int</span> p, ll val)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">4</span>;i++) &#123;        <span class="hljs-keyword">if</span>(dp[p][i] &lt; val) <span class="hljs-built_in">swap</span>(val, dp[p][i]);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add2to</span><span class="hljs-params">(<span class="hljs-type">int</span> p, ll val)</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">2</span>;i++) &#123;        <span class="hljs-keyword">if</span>(dp2[p][i] &lt; val) <span class="hljs-built_in">swap</span>(val, dp2[p][i]);    &#125;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span> </span>&#123;    dia[p] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [v, w] : vp[p]) &#123;        <span class="hljs-keyword">if</span>(v != fa) &#123;            <span class="hljs-built_in">dfs</span>(v, p);            <span class="hljs-built_in">add1to</span>(p, dp[v][<span class="hljs-number">0</span>] + w);            <span class="hljs-built_in">add2to</span>(p, dia[v]);            dia[p] = <span class="hljs-built_in">max</span>(dia[p], dia[v]);        &#125;    &#125;    dia[p] = <span class="hljs-built_in">max</span>(dia[p], dp[p][<span class="hljs-number">0</span>] + dp[p][<span class="hljs-number">1</span>]);&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa, ll&amp; res)</span> </span>&#123;    ll tmp;    <span class="hljs-built_in">add1to</span>(p, up[p]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [v, w] : vp[p]) &#123;        <span class="hljs-keyword">if</span>(v != fa) &#123;            up[v] = w + dp[p][dp[p][<span class="hljs-number">0</span>] == dp[v][<span class="hljs-number">0</span>] + w ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>];            ll mx1 = dp2[p][dp2[p][<span class="hljs-number">0</span>] == dia[v] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>];            ll mx2;            <span class="hljs-keyword">if</span>(dp[p][<span class="hljs-number">0</span>] == dp[v][<span class="hljs-number">0</span>] + w) mx2 = dp[p][<span class="hljs-number">1</span>] + dp[p][<span class="hljs-number">2</span>];            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[p][<span class="hljs-number">1</span>] == dp[v][<span class="hljs-number">0</span>] + w) mx2 = dp[p][<span class="hljs-number">0</span>] + dp[p][<span class="hljs-number">2</span>];            <span class="hljs-keyword">else</span> mx2 = dp[p][<span class="hljs-number">0</span>] + dp[p][<span class="hljs-number">1</span>];            dup[v] = <span class="hljs-built_in">max</span>(&#123;dup[p], mx1, mx2&#125;);             res = <span class="hljs-built_in">max</span>(res, dia[v] + dup[v] + <span class="hljs-number">2</span> * w);            <span class="hljs-built_in">dfs2</span>(v, p, res);        &#125;    &#125;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    ll ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++) &#123;        <span class="hljs-type">int</span> u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;        vp[u].<span class="hljs-built_in">emplace_back</span>(v, w);        vp[v].<span class="hljs-built_in">emplace_back</span>(u, w);        ans += w * <span class="hljs-number">2</span>;    &#125;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    ll res = <span class="hljs-number">0</span>;    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, res);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        <span class="hljs-keyword">if</span>(vp[i].<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">continue</span>;        res = <span class="hljs-built_in">max</span>(res, dp[i][<span class="hljs-number">0</span>] + dp[i][<span class="hljs-number">1</span>] + dp[i][<span class="hljs-number">2</span>] + dp[i][<span class="hljs-number">3</span>]);    &#125;    cout &lt;&lt; ans - res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; &#125;</code></pre></div><h4 id="2022-ICPC-网赛2-H"><a href="#2022-ICPC-网赛2-H" class="headerlink" title="2022 ICPC 网赛2 H"></a><a href="https://pintia.cn/problem-sets/1574060137151397888/problems/1574060247893606407">2022 ICPC 网赛2 H</a></h4><p>首先分别考虑贡献，因为这题中一个方案的贡献由所有 $u,v$ 间的路径长度（ $u,v$ 之间没有其他选中点）组成，故去考虑<strong>每一条路径</strong> 的贡献。</p><p>一条路径计入答案，当且仅当其两端点 $u,v$ 都选中，且路径中其他点都不被选中（仅计算被直接选择时的贡献，作为子路径时不考虑，这样能做到不重复不遗漏），然后我们再去考虑这个路径会被计算多少次。</p><p>此时其他点可选可不选，对于任意一点 $i$，它对这个路径产生贡献的次数都为 $2^{n-d-2}$，那么这条路径的总贡献为：$d(n-d+3)2^{n-d-2}$</p><p>有了这个式子，只需要枚举图中所有的路径计算和即可，但这显然不现实。</p><p>考虑换根dp，对于每个点记录其向上走和向下走的所有路径贡献和，如何转移？</p><p>注意到每条路径的式子形式类似 $xy2^y$，对于许多这样的式子和，要进行全体 <code>x+1</code> 等类似操作并维护是很容易的，只需要维护 $x2^y,y2^y,2^y$ 和作为辅助即可。</p><p>同理进行 <code>y-1</code> 等操作也不难，剩下的就是一个标准的换根dp了。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll x, ll p)</span> </span>&#123;    <span class="hljs-keyword">if</span>(p &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qpow</span>(<span class="hljs-built_in">qpow</span>(x, -p), mode - <span class="hljs-number">2</span>);    ll r = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(p &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span>(p &amp; <span class="hljs-number">1</span>) r = r * x % mode;        x = x * x % mode;        p /= <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> r;&#125;ll iv2 = <span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>, mode - <span class="hljs-number">2</span>);<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;    ll xxy, xy, yy, y;    <span class="hljs-built_in">node</span>() : <span class="hljs-built_in">xxy</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">xy</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">yy</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0</span>) &#123;&#125;;    <span class="hljs-built_in">node</span>(ll a, ll b) &#123;        y = <span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>, b);        yy = b * y % mode;        xy = a * y % mode;        xxy = b * xy % mode;    &#125;    node <span class="hljs-keyword">operator</span> +(<span class="hljs-type">const</span> node&amp; t) &#123;        node r = *<span class="hljs-keyword">this</span>;        (r.xxy += t.xxy) %= mode;        (r.xy += t.xy) %= mode;        (r.yy += t.yy) %= mode;        (r.y += t.y) %= mode;        <span class="hljs-keyword">return</span> r;    &#125;    node <span class="hljs-keyword">operator</span> -(<span class="hljs-type">const</span> node&amp; t) &#123;        node r = *<span class="hljs-keyword">this</span>;        (r.xxy -= t.xxy) %= mode;        (r.xy -= t.xy) %= mode;        (r.yy -= t.yy) %= mode;        (r.y -= t.y) %= mode;        <span class="hljs-keyword">return</span> r;    &#125;    <span class="hljs-function">node <span class="hljs-title">add1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-function">node <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;        r.xxy = (xxy + yy - xy - y + <span class="hljs-number">2</span> * mode) % mode * iv2 % mode;        r.yy = (yy - y + mode) * iv2 % mode;        r.xy = (xy + y) * iv2 % mode;        r.y = y * iv2 % mode;        <span class="hljs-keyword">return</span> r;    &#125;&#125;;<span class="hljs-type">int</span> n;vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];node dw[maxn], up[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span> </span>&#123;    dw[p] = <span class="hljs-built_in">node</span>(<span class="hljs-number">0</span>, n + <span class="hljs-number">3</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : vp[p]) &#123;        <span class="hljs-keyword">if</span>(v != fa) &#123;            <span class="hljs-built_in">dfs1</span>(v, p);            dw[p] = dw[p] + dw[v].<span class="hljs-built_in">add1</span>();        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : vp[p]) &#123;        <span class="hljs-keyword">if</span>(v != fa) &#123;            up[v] = (up[p] + dw[p] - dw[v].<span class="hljs-built_in">add1</span>()).<span class="hljs-built_in">add1</span>();            <span class="hljs-built_in">dfs2</span>(v, p);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++) &#123;        <span class="hljs-type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;        vp[x].<span class="hljs-built_in">push_back</span>(y);        vp[y].<span class="hljs-built_in">push_back</span>(x);    &#125;    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    ll ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) ans = (ans + (up[i] + dw[i] - <span class="hljs-built_in">node</span>(<span class="hljs-number">0</span>, n + <span class="hljs-number">3</span>)).xxy) % mode;    cout &lt;&lt; <span class="hljs-function">ans * <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-number">64</span>, mode - <span class="hljs-number">2</span>)</span> % mode &lt;&lt; &#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="2022-CCPC-威海-K"><a href="#2022-CCPC-威海-K" class="headerlink" title="2022 CCPC 威海 K"></a><a href="https://codeforces.com/gym/104023/problem/K">2022 CCPC 威海 K</a></h4><blockquote><p>题意：要求寻找区间 $[l, r](0&lt;l\le r)$ 的个数，满足给出的 $n$ 个条件，条件形式如下：</p><ul><li>1 $k$ $x$：可以在 $[l,r]$ 中找出 $k$ 个不同数，使得他们的和为 $x$</li><li>2 $k$ $x$：无法在 $[l,r]$ 中找出 $k$ 个不同数，使得他们的和为 $x$</li></ul></blockquote><p>首先注意到一点：对于任意区间 $[l,r]$，从中取 $k$ 个数的值域是连续的，最小值为 $\frac{(l+l+k-1)\times l}{2}$，最大值同理（式子不写了）</p><p>考虑第一种条件，我们可以找到这样一个区间： $[L,L+k-1]$ 总和为 $x$，或者 $[L,L+k]$，前 $k$ 个数和小于 $x$ 且后 $k$ 个数和大于 $x$。</p><p>条件一转化为：$[l,r]$ 必须包括这个区间，可以合并所有条件一得到 $l$ 的最大值和 $r$ 的最小值。</p><p>同理，条件二转化为 $[l,r]$ 必须不包括这个区间，然而这个东西在线段上比较难处理，可以在 $lOr$ 平面上考虑。</p><p>画个图发现就是求个矩形面积并，可以扫描线或者单调栈处理。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n; cin &gt;&gt; n;    ll L = <span class="hljs-number">2e9</span>, R = <span class="hljs-number">0</span>;    vector&lt;pii&gt; ban;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        <span class="hljs-type">int</span> opt, k, x;        cin &gt;&gt; opt &gt;&gt; k &gt;&gt; x;        ll l = <span class="hljs-number">1</span>, r = <span class="hljs-number">2e9</span>;        <span class="hljs-keyword">while</span>(l &lt; r) &#123;            ll mid = (l + r) / <span class="hljs-number">2</span>;            ll val = (mid + mid + k - <span class="hljs-number">1</span>) * k / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(val &gt;= x) r = mid;            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;        &#125;        r = l + k - <span class="hljs-number">1</span>;        ll val = (l + l + k - <span class="hljs-number">1</span>) * k / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(val != x) l--;        <span class="hljs-keyword">if</span>(opt == <span class="hljs-number">1</span>) &#123;            L = <span class="hljs-built_in">min</span>(L, l);            R = <span class="hljs-built_in">max</span>(R, r);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span>(l == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;            ban.<span class="hljs-built_in">emplace_back</span>(l, r);        &#125;    &#125;    <span class="hljs-keyword">if</span>(L == <span class="hljs-number">0</span>) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(ban.<span class="hljs-built_in">empty</span>()) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; [x, y] : ban) &#123;        <span class="hljs-keyword">if</span>(x &gt; L) x = L;        <span class="hljs-keyword">if</span>(y &lt; R) y = R;    &#125;    <span class="hljs-built_in">sort</span>(ban.<span class="hljs-built_in">begin</span>(), ban.<span class="hljs-built_in">end</span>(), [&amp;](pii&amp; a, pii&amp; b) &#123; <span class="hljs-keyword">return</span> a.second &lt; b.second;&#125;);    stack&lt;pii&gt; stk;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; [x, y] : ban) &#123;        <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">empty</span>() || x &gt; stk.<span class="hljs-built_in">top</span>().first) &#123;            stk.<span class="hljs-built_in">emplace</span>(x, y);        &#125;    &#125;    <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">top</span>().first &lt; L) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    ll ans = <span class="hljs-number">0</span>;    ll lst = stk.<span class="hljs-built_in">top</span>().second;    stk.<span class="hljs-built_in">pop</span>();    <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>()) &#123;        <span class="hljs-keyword">auto</span> [x, y] = stk.<span class="hljs-built_in">top</span>();        stk.<span class="hljs-built_in">pop</span>();        ans += (lst - y) * (L - x);        lst = y;    &#125;    ans += (lst - R) * L;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="2022-CCPC-威海-F"><a href="#2022-CCPC-威海-F" class="headerlink" title="2022 CCPC 威海 F"></a><a href="https://codeforces.com/gym/104023/problem/F">2022 CCPC 威海 F</a></h4><blockquote><p>题意：给出一个有向图，每个点有颜色 $c_i$ 和费用 $w_i$，走到一个未打标记的点时，需花费 $w_i$ 并打标记，随后你可以选择任意个颜色不同的节点 $j$，回收上面的标记并返还 $w_j$ 的费用。</p><p>问：对于每一对起点终点，初始需要多少钱才能抵达。 $n \le 300$</p></blockquote><p>显然当我们走到一个点时，会选择回收所有不同颜色的节点的费用，</p><p>那么对于一条路径，把它拆分为若干颜色段，走到每一段时都会回收前一段的费用，那么这段路径的代价就是<strong>MAX(每一段的费用和+下一段第一个点的费用，最后一段的费用)</strong></p><p>就变成了一个瓶颈路的问题。</p><p>具体做法：把原图划分为若干个同颜色的连通块，在每个连通块内部floyd求出两两间最短路，然后枚举块内的起点（$s$）和终点（$t$），再枚举终点向块外连的边（$t\rightarrow j$），在新图上建一条 $s\rightarrow j$ 的边。</p><p>在新图上枚举起点，朴素prim跑最小瓶颈路（$n^2$）</p><p>这样就将 “每一段的费用和+下一段第一个点的费用” 考虑完了，还需要考虑最后一段的费用，这个不能直接在块内连边，因为我们要求最小瓶颈路，边权不能“合成”。（这个词用的比较抽象，自行理解一下）</p><p>只需要在最后输出前，用块内其他点+块内距离松弛一次即可，同样因为边不能“合成”，松弛后的结果不能更新到最短路中，而应当直接输出。</p><div class="code-wrapper"><pre><code class="hljs C++">ll dis[<span class="hljs-number">303</span>][<span class="hljs-number">303</span>];<span class="hljs-type">int</span> col[<span class="hljs-number">303</span>], w[<span class="hljs-number">303</span>];<span class="hljs-type">bool</span> vis[<span class="hljs-number">303</span>]; vector&lt;<span class="hljs-type">int</span>&gt; vp1[<span class="hljs-number">303</span>];ll dis2[<span class="hljs-number">303</span>][<span class="hljs-number">303</span>]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, vector&lt;<span class="hljs-type">int</span>&gt;&amp; ls)</span> </span>&#123; <span class="hljs-comment">//染色</span>    vis[p] = <span class="hljs-literal">true</span>;    ls.<span class="hljs-built_in">push_back</span>(p);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : vp1[p]) &#123;        <span class="hljs-keyword">if</span>(!vis[v] &amp;&amp; col[v] == col[p]) &#123;            <span class="hljs-built_in">dfs</span>(v, ls);        &#125;    &#125;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n, m;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-built_in">fill</span>(dis[<span class="hljs-number">0</span>], dis[<span class="hljs-number">0</span>] + <span class="hljs-number">303</span> * <span class="hljs-number">303</span>, <span class="hljs-number">1e18</span>);    <span class="hljs-built_in">fill</span>(dis2[<span class="hljs-number">0</span>], dis2[<span class="hljs-number">0</span>] + <span class="hljs-number">303</span> * <span class="hljs-number">303</span>, <span class="hljs-number">1e18</span>);    <span class="hljs-built_in">fill</span>(vis, vis + n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        vp1[i].<span class="hljs-built_in">clear</span>();    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) cin &gt;&gt; col[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) cin &gt;&gt; w[i], dis[i][i] = w[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++) &#123;        <span class="hljs-type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;        vp1[x].<span class="hljs-built_in">push_back</span>(y);        vp1[y].<span class="hljs-built_in">push_back</span>(x);        dis[x][y] = dis[y][x] = w[x] + w[y];    &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        <span class="hljs-keyword">if</span>(!vis[i]) &#123;            vector&lt;<span class="hljs-type">int</span>&gt; ls;            <span class="hljs-built_in">dfs</span>(i, ls);            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k : ls) &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : ls) &#123;                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j : ls) &#123;                        <span class="hljs-keyword">if</span>(dis[i][k] + dis[k][j] - w[k] &lt; dis[i][j]) &#123;                            dis[i][j] = dis[j][i] = dis[i][k] + dis[k][j] - w[k];                        &#125;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : ls) &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j : ls) &#123;                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : vp1[j]) &#123;                        <span class="hljs-keyword">if</span>(col[j] != col[v]) &#123;                            dis2[i][v] = <span class="hljs-built_in">min</span>(dis2[i][v], dis[i][j] + w[v]);                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;     <span class="hljs-function">vector <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, vector&lt;ll&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">1e18</span>))</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        ans[i][i] = w[i];        <span class="hljs-built_in">fill</span>(vis, vis + n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cc = <span class="hljs-number">1</span>;cc &lt;= n;cc++) &#123; <span class="hljs-comment">//prim</span>            <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>; ans[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1e18</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++) &#123;                <span class="hljs-keyword">if</span>(!vis[j] &amp;&amp; ans[i][j] &lt; ans[i][p]) p = j;            &#125;            vis[p] = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>;v &lt;= n;v++) &#123;                ans[i][v] = <span class="hljs-built_in">min</span>(ans[i][v], <span class="hljs-built_in">max</span>(ans[i][p], dis2[p][v]));            &#125;        &#125;    &#125;     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++) &#123;            ll opt = ans[i][j];            <span class="hljs-comment">// 最后一步可以使用dis</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k &lt;= n;k++) &#123;                opt = <span class="hljs-built_in">min</span>(opt, <span class="hljs-built_in">max</span>(ans[i][k], dis[k][j]));            &#125;            <span class="hljs-keyword">if</span>(i == j) opt = <span class="hljs-number">0</span>;            cout &lt;&lt; opt &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[j == n];        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>牛客多校</tag>
      
      <tag>杭电多校</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 814 div.1 ABC</title>
    <link href="/2022/08/18/2022-08-18-Codeforces%20Round%20814%20div1%20ABC/"/>
    <url>/2022/08/18/2022-08-18-Codeforces%20Round%20814%20div1%20ABC/</url>
    
    <content type="html"><![CDATA[<h4 id="录播讲解链接-AB"><a href="#录播讲解链接-AB" class="headerlink" title="录播讲解链接(AB)"></a><a href="https://www.bilibili.com/video/BV1d14y147Ld?spm_id_from=333.999.0.0&vd_source=f3bceb9b12c557f0a9cdb5ac0d26fee6">录播讲解链接(AB)</a></h4><h4 id="A2-Burenka-and-Traditions-hard-version"><a href="#A2-Burenka-and-Traditions-hard-version" class="headerlink" title="A2. Burenka and Traditions (hard version)"></a><a href="https://codeforces.com/contest/1718/problem/A2">A2. Burenka and Traditions (hard version)</a></h4><p>只会进行长度为2或1的区间操作，因为更大的可以分解成小的且不会更劣。</p><p>考虑从左到右依次两两进行异或操作，每次都使得左侧数变为0，那么总操作次数最多是 $n$</p><p>如果其中包含一段异或和为0的区间，就可以省下一次操作，且仅有这种方式可以省操作，故目标变为划分出最多的异或为0的子段个数，异或前缀和+set即可。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-type">int</span> ans = n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    set&lt;<span class="hljs-type">int</span>&gt; pre;    pre.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>);    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        s ^= a[i];        <span class="hljs-keyword">if</span>(pre.<span class="hljs-built_in">count</span>(s))&#123;            pre.<span class="hljs-built_in">clear</span>();            s = <span class="hljs-number">0</span>;            ans--;        &#125;        pre.<span class="hljs-built_in">insert</span>(s);    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="B-Fibonacci-Strings"><a href="#B-Fibonacci-Strings" class="headerlink" title="B. Fibonacci Strings"></a><a href="https://codeforces.com/contest/1718/problem/B">B. Fibonacci Strings</a></h4><p>齐肯多夫定理：任意正整数都可以<strong>唯一</strong>分解成若干不连续的斐波那契数列项之和（不包括第一个1）。</p><p>分解方式也很简单，令 $n$ 不断减去最大的比 $n$ 小的斐波那契项即可。</p><p>这题我在写的时候还不知道这个定理，所以采用了一种贪心的方式诈胡了，即将所有的 $c_i$ 放入优先队列，从大到小枚举斐波那契项，每次取出最大的那个 $c_i$ 减去此项。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;ll f[<span class="hljs-number">75</span>], s[<span class="hljs-number">75</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    f[<span class="hljs-number">1</span>] = f[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;    s[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; s[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=<span class="hljs-number">70</span>;i++)&#123;        f[i] = f[i<span class="hljs-number">-1</span>] + f[i<span class="hljs-number">-2</span>];        s[i] = s[i<span class="hljs-number">-1</span>] + f[i];    &#125;    priority_queue&lt;pair&lt;ll, <span class="hljs-type">int</span>&gt;&gt; q;    cin &gt;&gt; n;    ll tot = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        ll x; cin &gt;&gt; x;        q.<span class="hljs-built_in">push</span>(&#123;x, i&#125;);        tot += x;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">70</span>;i++)&#123;        <span class="hljs-keyword">if</span>(s[i] &gt; tot) <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">if</span>(tot == s[i])&#123;            <span class="hljs-type">int</span> uid = <span class="hljs-number">-1</span>;            vector&lt;pair&lt;ll, <span class="hljs-type">int</span>&gt;&gt; tmp;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&gt;=<span class="hljs-number">1</span>;j--)&#123;                <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">empty</span>())&#123;                    cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;                    <span class="hljs-keyword">return</span>;                &#125;                <span class="hljs-keyword">auto</span> u = q.<span class="hljs-built_in">top</span>();                q.<span class="hljs-built_in">pop</span>();                <span class="hljs-keyword">if</span>(u.second == uid)&#123;                    tmp.<span class="hljs-built_in">push_back</span>(u);                    <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">empty</span>())&#123;                        cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;                        <span class="hljs-keyword">return</span>;                    &#125;                    u = q.<span class="hljs-built_in">top</span>();                    q.<span class="hljs-built_in">pop</span>();                &#125;                uid = u.second;                u.first -= f[j];                <span class="hljs-keyword">if</span>(u.first &lt; <span class="hljs-number">0</span>)&#123;                    cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;                    <span class="hljs-keyword">return</span>;                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(u.first != <span class="hljs-number">0</span>)&#123;                    q.<span class="hljs-built_in">push</span>(u);                &#125;                <span class="hljs-keyword">if</span>(!tmp.<span class="hljs-built_in">empty</span>())&#123;                    q.<span class="hljs-built_in">push</span>(tmp.<span class="hljs-built_in">back</span>());                    tmp.<span class="hljs-built_in">pop_back</span>();                &#125;            &#125;            cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;    <span class="hljs-keyword">return</span>;&#125;</code></pre></div><h4 id="C-Tonya-and-Burenka-179"><a href="#C-Tonya-and-Burenka-179" class="headerlink" title="C. Tonya and Burenka-179"></a><a href="https://codeforces.com/contest/1718/problem/C">C. Tonya and Burenka-179</a></h4><p>首先能想到，如果以 $n$ 的某个因数 $p$ 为步长去跳，会构成一个循环，每个数会重复 $p$ 次，因为任选起点，重复的一定比不重复的好（可以选取较大的部分重复）。</p><p>若 $kp$ 仍为 $n$ 的因数，以 $kp$ 为步长去跳显然会更好，因为涉及的元素严格为按 $p$ 跳的子集，可以选取较大部分的子集来重复。</p><p>故最终可选取的步长仅有 $n&#x2F;p$，其中 $p$ 为 $n$ 的质因数。</p><p>不同质因数的数量很少，就可以暴力set乱搞了。 </p><div class="code-wrapper"><pre><code class="hljs C++">ll pri[<span class="hljs-number">30</span>];ll sum[<span class="hljs-number">30</span>][maxn], a[maxn]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n, q;    cin &gt;&gt; n &gt;&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) cin &gt;&gt; a[i];    ll tmp = n, h = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;tmp &gt; <span class="hljs-number">1</span>;i++) &#123;        <span class="hljs-keyword">if</span>(tmp % i == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">while</span>(tmp % i == <span class="hljs-number">0</span>) tmp /= i;            pri[++h] = i;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= n;j++) sum[h][j] = <span class="hljs-number">0</span>;            <span class="hljs-type">int</span> d = n / i;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++) &#123;                sum[h][j % d] += a[j];              &#125;        &#125;    &#125;    multiset&lt;ll&gt; st[h + <span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= h;i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; n / pri[i];j++) &#123;            st[i].<span class="hljs-built_in">insert</span>(sum[i][j]);        &#125;    &#125;    ll ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= h;i++) ans = <span class="hljs-built_in">max</span>(ans, *(st[i].<span class="hljs-built_in">rbegin</span>()) * n / pri[i]);    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    <span class="hljs-keyword">while</span>(q-- &gt; <span class="hljs-number">0</span>) &#123;        ll x, y; cin &gt;&gt; x &gt;&gt; y;        ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= h;i++) &#123;            ll d = n / pri[i];            st[i].<span class="hljs-built_in">erase</span>(st[i].<span class="hljs-built_in">find</span>(sum[i][x % d]));            sum[i][x % d] += -a[x] + y;            st[i].<span class="hljs-built_in">insert</span>(sum[i][x % d]);            ans = <span class="hljs-built_in">max</span>(ans, *(st[i].<span class="hljs-built_in">rbegin</span>()) * d);        &#125;        a[x] = y;        cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简易对拍器</title>
    <link href="/2022/08/10/2022-08-10-%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D%E5%99%A8/"/>
    <url>/2022/08/10/2022-08-10-%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="Github项目地址"><a href="#Github项目地址" class="headerlink" title="Github项目地址"></a><a href="https://github.com/lxtyin/SimpleComparator">Github项目地址</a></h4><p>2021&#x2F;9&#x2F;23</p><h4 id="环境需求"><a href="#环境需求" class="headerlink" title="环境需求"></a>环境需求</h4><ul><li><p>仅支持windows</p></li><li><p>装有MinGW并且添加到环境变量（使用g++编译）</p></li></ul><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><ol><li>将两份程序（一般是你的不知道哪错了的程序和标答&#x2F;暴力解）扔进<code>program1.cpp</code>和<code>program2.cpp</code></li><li>在<code>generator.cpp</code>里写随机输入数据生成器，对应你的这道题目</li><li>双击<code>run.bat</code>运行，输入希望对拍的次数，等待对拍结果</li></ol><p>对拍结果完全一样显示 <strong>[Accepted]</strong></p><p>不同则会显示 <strong>[Wrong Answer]</strong></p><p>有不同时，会同时显示使两份程序结果不一样的数据，你就可以复制拿去debug了</p><p>同时所有结果都会保存在<code>result.txt</code>里，关掉控制台后仍然可以查看</p><p><img src="http://lxtyin.ac.cn/img/simplecomparator/1.png"></p><h3 id="2022-x2F-8-x2F-10更新"><a href="#2022-x2F-8-x2F-10更新" class="headerlink" title="2022&#x2F;8&#x2F;10更新"></a>2022&#x2F;8&#x2F;10更新</h3><ul><li><p>改了部分文件名，<code>constructor</code>被改成了<code>generator</code>，其他变更不影响使用</p></li><li><p>默认对比方式已忽略行末空格和回车。</p></li><li><p>现已支持special judge</p></li></ul><p>用法：同样方法放入程序和编写数据生成器之后，还需在 <code>work/special_judge.cpp</code> 中编写spj</p><p>spj必须包含头文件 <code>judge.h</code>，这个头文件提供了一些基础的api。</p><p>引用头文件后，你可以使用三个输入流，它们都为 ifstream。</p><p><code>inp</code> 从本组的输入数据中读取</p><p><code>ans1</code> 从 <code>program1</code> 的输出数据中读取</p><p><code>ans2</code> 从 <code>program2</code> 的输出数据中读取</p><p>判题之后，你需要给出评测结果，<code>judge.h</code> 提供了以下api，建议使用：</p><ul><li><p><code>AC();</code> 给出正确提示</p></li><li><p><code>WA();</code> 给出错误提示</p></li><li><p><code>display();</code> 显示数据，建议在答案错误时显示</p></li><li><p><code>color(int x);</code> 更改字体颜色，具体颜色对应值如下：<img src="https://ask.qcloudimg.com/http-save/yehe-7873581/mg9ppffbb6.png?imageView2/2/w/1620"></p></li><li><p><code>hint(const string &amp;s);</code> 以黄色字体给出提示信息</p></li><li><p><code>warn(const string &amp;s);</code> 以红色字体给出提示信息</p></li></ul><p>当然你也可以自由使用 <code>cout/printf</code> 等方式输出。</p><p>例如，下面是一个判断精度是否在 <code>1e-6</code> 以内spj</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;judge.h&quot;</span></span><span class="hljs-comment">// sample spj for accuracy within 1e-6</span><span class="hljs-comment">// input data can be read by inp(ifstream)</span><span class="hljs-comment">// program1 output can be read by ans1(ifstream), so as ans2.</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">double</span> as1, as2;    ans1 &gt;&gt; as1;    ans2 &gt;&gt; as2;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(as1 - as2) / as2 &lt; <span class="hljs-number">1e-6</span>) <span class="hljs-built_in">AC</span>();    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">WA</span>();        <span class="hljs-built_in">display</span>();        <span class="hljs-built_in">color</span>(YELLOW);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The accuracy is %.10f\n&quot;</span>, <span class="hljs-built_in">abs</span>(as1 - as2) / as2);        <span class="hljs-built_in">color</span>(WHITE);    &#125;    inp.<span class="hljs-built_in">close</span>();    ans1.<span class="hljs-built_in">close</span>();    ans2.<span class="hljs-built_in">close</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>效果如下：</p><p><img src="http://lxtyin.ac.cn/img/simplecomparator/2.png"></p>]]></content>
    
    
    <categories>
      
      <category>自制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>小项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 810 div.1 ABC</title>
    <link href="/2022/07/26/2022-07-26-Codeforces%20Round%20810%20div1%20ABC/"/>
    <url>/2022/07/26/2022-07-26-Codeforces%20Round%20810%20div1%20ABC/</url>
    
    <content type="html"><![CDATA[<h4 id="A-Color-the-Picture"><a href="#A-Color-the-Picture" class="headerlink" title="A. Color the Picture"></a><a href="https://codeforces.com/contest/1710/problem/A">A. Color the Picture</a></h4><p>观察发现同一个颜色必须呈整行或整列才能满足条件，且至少需要连续两行，计算一下每个颜色最多可以涂几行&#x2F;列即可，特判奇数行&#x2F;列时，所有颜色都仅能涂2行&#x2F;列的情况。</p><div class="code-wrapper"><pre><code class="hljs C++">ll n, m, k;ll a[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=k;i++) cin &gt;&gt; a[i];    ll s = <span class="hljs-number">0</span>;    <span class="hljs-type">bool</span> fg = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;        ll d = a[i] / n;        <span class="hljs-keyword">if</span>(d &gt; <span class="hljs-number">1</span>) s += d;        <span class="hljs-keyword">if</span>(d &gt; <span class="hljs-number">2</span>) fg = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">if</span>((fg || m % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &amp;&amp; s &gt;= m)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    s = <span class="hljs-number">0</span>;    fg = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;        ll d = a[i] / m;        <span class="hljs-keyword">if</span>(d &gt; <span class="hljs-number">1</span>) s += d;        <span class="hljs-keyword">if</span>(d &gt; <span class="hljs-number">2</span>) fg = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">if</span>((fg || n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &amp;&amp; s &gt;= n)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;&#125;</code></pre></div><h4 id="B-Rain"><a href="#B-Rain" class="headerlink" title="B. Rain"></a><a href="https://codeforces.com/contest/1710/problem/B">B. Rain</a></h4><p>首先预处理出每个位置上降水量的总值（离散化差分或数据结构），然后将所有降水按照左端点排序，枚举每个位置 $x$，二分找出第一个 删除之后，不能使得 $x$ 处降水量少于m的位置，显然这个点右侧的全都不合法。</p><p>同理再按照右端点排序搞一次，就把所有不合法的点筛去了。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;    ll x, p;    ll id;    ll sum;&#125;a[maxn], b[maxn]; ll n, m;map&lt;ll, ll&gt; d2;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    d2.<span class="hljs-built_in">clear</span>();    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        a[i].id = i;        cin &gt;&gt; a[i].x &gt;&gt; a[i].p;        d2[a[i].x-a[i].p+<span class="hljs-number">1</span>] += <span class="hljs-number">1</span>;        d2[a[i].x+<span class="hljs-number">1</span>] -= <span class="hljs-number">2</span>;        d2[a[i].x+a[i].p+<span class="hljs-number">1</span>] += <span class="hljs-number">1</span>;    &#125;    ll sum = <span class="hljs-number">0</span>;    vector&lt;pair&lt;ll, ll&gt;&gt; d11;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [p, c]: d2)&#123;        sum += c;        d11.<span class="hljs-built_in">emplace_back</span>(p, sum);    &#125;    sum = <span class="hljs-number">0</span>;    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+n+<span class="hljs-number">1</span>, [](node x, node y)&#123;        <span class="hljs-keyword">return</span> x.x &lt; y.x;    &#125;);    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">0</span>, j=<span class="hljs-number">1</span>;i&lt;d11.<span class="hljs-built_in">size</span>();i++)&#123;        <span class="hljs-keyword">while</span>(j &lt;= n &amp;&amp; d11[i].first &gt; a[j].x)&#123;            a[j].sum = sum + d11[i<span class="hljs-number">-1</span>].second * (a[j].x - d11[i<span class="hljs-number">-1</span>].first);            j++;        &#125;        sum += d11[i].second;        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>) sum += d11[i<span class="hljs-number">-1</span>].second * (d11[i].first - d11[i<span class="hljs-number">-1</span>].first - <span class="hljs-number">1</span>);        <span class="hljs-keyword">while</span>(j &lt;= n &amp;&amp; d11[i].first == a[j].x)&#123;            a[j].sum = sum;            j++;        &#125;    &#125;     <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+n+<span class="hljs-number">1</span>, [](node x, node y)&#123;        <span class="hljs-keyword">return</span> x.x - x.p + <span class="hljs-number">1</span> &lt; y.x - y.p + <span class="hljs-number">1</span>;    &#125;);    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++) b[i] = a[i];    <span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>, b+n+<span class="hljs-number">1</span>, [](node x, node y)&#123;        <span class="hljs-keyword">return</span> x.x + x.p - <span class="hljs-number">1</span> &lt; y.x + y.p - <span class="hljs-number">1</span>;    &#125;);     <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;    ll midel = <span class="hljs-number">1e9</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(a[i].sum &lt;= m) <span class="hljs-keyword">continue</span>;        ll d = a[i].sum - m;        ll p = <span class="hljs-built_in">lower_bound</span>(a+<span class="hljs-number">1</span>, a+n+<span class="hljs-number">1</span>, a[i].x - d + <span class="hljs-number">1</span>, [&amp;](node a, ll pos)&#123;            <span class="hljs-keyword">return</span> a.x - a.p + <span class="hljs-number">1</span> &lt;= pos;        &#125;) - a;        midel = <span class="hljs-built_in">min</span>(midel, p);    &#125;    <span class="hljs-keyword">for</span>(ll i=midel;i&lt;=n;i++) ans[a[i].id] = <span class="hljs-number">0</span>;     ll mxdel = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(b[i].sum &lt;= m) <span class="hljs-keyword">continue</span>;        ll d = b[i].sum - m;        ll p = <span class="hljs-built_in">lower_bound</span>(b+<span class="hljs-number">1</span>, b+n+<span class="hljs-number">1</span>, b[i].x+d<span class="hljs-number">-1</span>, [&amp;](node a, ll pos)&#123;            <span class="hljs-keyword">return</span> a.x + a.p - <span class="hljs-number">1</span> &lt; pos;        &#125;) - b;        mxdel = <span class="hljs-built_in">max</span>(mxdel, p<span class="hljs-number">-1</span>);    &#125;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=mxdel;i++) ans[b[i].id] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout &lt;&lt; ans[i];    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="C-XOR-Triangle"><a href="#C-XOR-Triangle" class="headerlink" title="C. XOR Triangle"></a><a href="https://codeforces.com/contest/1710/problem/C">C. XOR Triangle</a></h4><p>新的一种bitmask技巧：</p><p>设 $cnt_{i,j,k}$，定义是这样的：</p><p>当 $a,b,c$ 的第 $x$ 位分别为 $i,j,k$ 时，$cnt_{i,j,k}$ 就在 $x$ 位上为1，否则为0</p><p>例如对于下面的 $a,b,c$，有如下 $cnt$：<br>$$<br>cnt[011]:&amp;10000001\<br>a&amp;01010010\<br>b&amp;10010101\<br>c&amp;10111001<br>$$<br>即仅有 $abc&#x3D;011$ 的位置，$cnt_{011}$ 才为1</p><p>有了这种 $cnt$ 数组，就可以推断出一些东西：</p><p>$a&#x3D;\sum\sum cnt_{1jk}$（$a$ 中所有的 $1$ 不重复不遗漏的加起来）</p><p>$b&#x3D;\sum\sum cnt_{i1k}$</p><p>$a\bigoplus b&#x3D;\sum cnt_{01k}+\sum cnt_{10k}$</p><p>简单推断可得，题目的条件等价于：$cnt_{001}+cnt_{110}&gt;0$，$cnt_{011}+cnt_{100}&gt;0$，$cnt_{010}+cnt_{101}&gt;0$</p><p>设 $dp[i][j][k]$ 为前 $i$ 位，上限状态为 $j$，$cnt$ 状态为 $k$ 的方案数</p><p>$j$ 用三位表示 $a,b,c$ 三个数是否达到了上限，$k$ 用三位表示上述三组 $cnt$ 是否已经大于0，转移复杂度为 $O(8^3n)$</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">subset</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    <span class="hljs-type">int</span> k = x;    vector&lt;<span class="hljs-type">int</span>&gt; r;    <span class="hljs-keyword">while</span>(k &gt; <span class="hljs-number">0</span>)&#123;        r.<span class="hljs-built_in">push_back</span>(k);        k = (k - <span class="hljs-number">1</span>) &amp; x;    &#125;    r.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> r;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    string s;    cin &gt;&gt; s;    <span class="hljs-function">vector <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">8</span>, vector&lt;ll&gt;(<span class="hljs-number">8</span>, <span class="hljs-number">0</span>))</span></span>;    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: s)&#123;        <span class="hljs-type">int</span> curlim = (c == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">7</span>);        <span class="hljs-function">vector <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-number">8</span>, vector&lt;ll&gt;(<span class="hljs-number">8</span>, <span class="hljs-number">0</span>))</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> lim = <span class="hljs-number">0</span>; lim &lt; <span class="hljs-number">8</span>; lim++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> frm = <span class="hljs-number">0</span>; frm &lt; <span class="hljs-number">8</span>; frm++)&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> st: <span class="hljs-built_in">subset</span>(lim | curlim))&#123;                    <span class="hljs-type">int</span> nt = frm;                    <span class="hljs-keyword">if</span>(st == <span class="hljs-number">1</span> || st == <span class="hljs-number">6</span>)&#123;                        nt |= <span class="hljs-number">1</span>;                    &#125;                    <span class="hljs-keyword">if</span>(st == <span class="hljs-number">2</span> || st == <span class="hljs-number">5</span>)&#123;                        nt |= <span class="hljs-number">2</span>;                    &#125;                    <span class="hljs-keyword">if</span>(st == <span class="hljs-number">3</span> || st == <span class="hljs-number">4</span>)&#123;                        nt |= <span class="hljs-number">4</span>;                    &#125;                    (g[lim | (st ^ curlim)][nt] += f[lim][frm]) %= mode;                &#125;            &#125;        &#125;        f = g;    &#125;    ll ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) (ans += f[i][<span class="hljs-number">7</span>]) %= mode;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 131 D-F</title>
    <link href="/2022/07/09/2022-07-09-Educational%20Codeforces%20Round%20131/"/>
    <url>/2022/07/09/2022-07-09-Educational%20Codeforces%20Round%20131/</url>
    
    <content type="html"><![CDATA[<h4 id="D-Permutation-Restoration"><a href="#D-Permutation-Restoration" class="headerlink" title="D. Permutation Restoration"></a>D. Permutation Restoration</h4><blockquote><p>题意：原先有一个排列 $a(1…n)$，令 $b_i&#x3D;\lfloor i&#x2F;a_i \rfloor$。现在给出序列 $b$，要恢复排列 $a$</p></blockquote><p>首先可以根据 $b_i$ 得出 $a_i$ 的范围是 $(i&#x2F;(b_i+1), i&#x2F;b_i]$，由此得到了每个 $a_i$ 的取值区间，接下来要将 $1-n$ 分配给他们。</p><p>可以先按照区间的右端排序，按右端从小到大依次去取<strong>尽可能小的数</strong>，正确性显然。</p><p>取尽可能小的数可以用并查集。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m, f[maxn], ans[maxn];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">if</span>(x == f[x]) <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> f[x] = <span class="hljs-built_in">find</span>(f[x]);&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;    <span class="hljs-type">int</span> l, r, id;&#125;a[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        <span class="hljs-type">int</span> x; cin &gt;&gt; x;        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>) &#123;            a[i] = &#123;i + <span class="hljs-number">1</span>, n, i&#125;;        &#125; <span class="hljs-keyword">else</span> &#123;            a[i] = &#123;i / (x + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>, i / x, i&#125;;        &#125;    &#125;    <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>, [](node i, node j) &#123;<span class="hljs-keyword">return</span> i.r &lt; j.r;&#125;);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) f[i] = i;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(a[i].l);        ans[a[i].id] = t;        f[t] = t + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;</code></pre></div><h4 id="E-Text-Editor"><a href="#E-Text-Editor" class="headerlink" title="E. Text Editor"></a>E. Text Editor</h4><blockquote><p>题意：给出字符串 $s_1$ 和 $s_2$，初始光标在 $s_1$ 最后一个字符的右边，每次操作可以：</p><ul><li>将光标左移或右移一位</li><li>删除光标左侧字符</li><li>将光标移动到最前面（第一个字符左边）或最后面</li></ul><p>问最少多少次操作可以使 $s_1$ 变成 $s_2$</p></blockquote><p>要将 $s_1$ 变成 $s_2$ 只需要将多余字符删去即可，不难发现，从右往左边移动光标的同时可以顺带删除，而从左往右移动时，删除字符需要额外的一步操作。</p><p>显然我们不会反复进行操作3，可以将操作分为两段：先向左移删除一些字符，再跳到最前面向右移删除一些字符。</p><p>缩减操作次数主要靠两部分：尽量在左移时删除，和在中间保留一段无需访问的已经匹配上的子串。</p><p>解法：枚举从左向右移动的终点 $i$，同时维护前 $i$ 个字符能匹配的最大长度 $j$，那么前 $i$ 个字符可以任意选择匹配 $s_2$ 的前 $1…j$ 个字符。</p><p>假设选择匹配了前 $x$ 个，那么从 $s_2[x+1]$ 和 $s_1[i+1]$ 开始如果能匹配若干个字符，这些字符是无需访问的；剩下的就都是从右向左移动的部分了。</p><p>用 $i + i - k + n - (i + f_{i+1, k+1}) + 1$ 更新答案，其中 $f_{i, j}$ 表示 $s_1[i..]$ 和 $s_2[j..]$ 的最长公共前缀。</p><p>提前 $dp$ 预处理 $f_{i,j}$ 即可。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;string s1, s2;<span class="hljs-type">int</span> f[<span class="hljs-number">5003</span>][<span class="hljs-number">5003</span>]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n &gt;&gt; m;    cin &gt;&gt; s1 &gt;&gt; s2;    s1 = <span class="hljs-string">&#x27; &#x27;</span> + s1;    s2 = <span class="hljs-string">&#x27; &#x27;</span> + s2;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        <span class="hljs-keyword">if</span>(s1[i] == s2[j]) j++;        <span class="hljs-keyword">if</span>(i == n &amp;&amp; j &lt;= m) &#123;            cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= <span class="hljs-built_in">max</span>(n, m) + <span class="hljs-number">1</span>;i++) f[i][m + <span class="hljs-number">1</span>] = f[n + <span class="hljs-number">1</span>][i] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n;i &gt; <span class="hljs-number">0</span>;i--) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m;j &gt; <span class="hljs-number">0</span>;j--) &#123;            <span class="hljs-keyword">if</span>(s1[i] == s2[j]) f[i][j] = f[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> f[i][j] = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-type">int</span> ans = n - f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;i &lt;= n;i++) &#123;        <span class="hljs-keyword">if</span>(s1[i] == s2[j + <span class="hljs-number">1</span>]) j++;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k &lt;= j;k++) &#123;            ans = <span class="hljs-built_in">min</span>(ans, i + i - k + n - (i + f[i + <span class="hljs-number">1</span>][k + <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>);        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="F-Points"><a href="#F-Points" class="headerlink" title="F. Points"></a>F. Points</h4><blockquote><p>题意：$x$ 轴上有若干个点，任意三个点若满足 $i&lt;j&lt;k$ 且 $k-i\le d$，则它是一个优美的元组。</p><p>接下来将在空数轴上进行若干次操作，每次选取一个整数位置 $x$，若上面有点则将其删去，否则在此处添加点。</p><p>每次操作完成后要输出优美元组的总数，点的位置 $\le2\times 10^5$</p></blockquote><p>学习了t宝的神奇线段树。</p><p>不难想的部分：</p><p>每当在 $x$ 这个位置上操作，就查找区间 $[x-d, x-1]$ 和 $[x+1, x+d]$ 上点的个数，分别计算以 $x$ 为左、右端点的元组个数。</p><p>比较麻烦的是 $x$ 作为中间的元组数。</p><p>t宝的线段树维护了区间的这些内容：</p><ul><li>区间点个数（设为 $cr$）</li><li>向左移 $d$ 的区间中点的个数（设为 $cl$）</li><li>跨这两段区间，距离在 $d$ 以内的点对个数（设为 $sp$）。</li></ul><p>第三个即我们需要的信息，维护它：</p><p>对单个点来说 $sp&#x3D;cl\times cr$</p><p>合并 $a,b$ 两个区间（$a$ 在左）时，$sp&#x3D;sp_a+sp_b+cr_a\times cl_b$</p><p>画图看一下就明白了：合并的时候新产生的 $sp$ 只能是右边的左块和左边的右块之间的点对，其他的距离都在 $d$ 以上。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, d;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;    ll cr, cl, sp;    <span class="hljs-function">node <span class="hljs-title">merge</span><span class="hljs-params">(node x)</span> </span>&#123;        <span class="hljs-keyword">return</span> &#123;cr + x.cr, cl + x.cl, sp + x.sp + cr * x.cl&#125;;    &#125;&#125;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">segTree</span> &#123;    node t[maxn &lt;&lt; <span class="hljs-number">4</span>];    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;        t[p] = t[p * <span class="hljs-number">2</span>].<span class="hljs-built_in">merge</span>(t[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> adl, <span class="hljs-type">int</span> adr)</span> </span>&#123;        <span class="hljs-keyword">if</span>(l == r) &#123;            t[p].cl += adl;            t[p].cr += adr;            t[p].sp = t[p].cl * t[p].cr;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(pos &lt;= mid) <span class="hljs-built_in">modify</span>(p * <span class="hljs-number">2</span>, l, mid, pos, adl, adr);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, pos, adl, adr);        <span class="hljs-built_in">push_up</span>(p);    &#125;    <span class="hljs-function">node <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;        <span class="hljs-keyword">if</span>(l &gt; R || L &gt; r) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;        <span class="hljs-keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> t[p];        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        node res = <span class="hljs-built_in">query</span>(p * <span class="hljs-number">2</span>, l, mid, L, R);        res = res.<span class="hljs-built_in">merge</span>(<span class="hljs-built_in">query</span>(p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R));        <span class="hljs-keyword">return</span> res;    &#125;    &#125;segt; <span class="hljs-type">int</span> st[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n &gt;&gt; d;    ll ans = <span class="hljs-number">0</span>, mx = <span class="hljs-number">400000</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;        <span class="hljs-type">int</span> x; cin &gt;&gt; x;        <span class="hljs-type">int</span> f = st[x] ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;        st[x] ^= <span class="hljs-number">1</span>;        ll r = segt.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, mx, x + <span class="hljs-number">1</span>, x + d).cr;        ll l = segt.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, mx, x - d, x - <span class="hljs-number">1</span>).cr;        ans += (r * (r - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + l * (l - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) * f;        <span class="hljs-keyword">if</span>(d &gt; <span class="hljs-number">1</span>) ans += segt.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, mx, x + <span class="hljs-number">1</span>, x + d - <span class="hljs-number">1</span>).sp * f;        segt.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, mx, x, <span class="hljs-number">0</span>, f);        segt.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, mx, x + d, f, <span class="hljs-number">0</span>);        cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python笔记</title>
    <link href="/2022/06/17/2022-06-17-python%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/06/17/2022-06-17-python%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="python特点"><a href="#python特点" class="headerlink" title="python特点"></a>python特点</h3><p>我用下来的最大感受是：很多情况下，py和编写者之间需要达成某种约定，编写者只要按照“正常”的格式来写代码，py就能解释。无需关注py怎么处理奇怪的输入：它会报错。</p><p>写python的时候就像是说自然语言，习惯了严谨程序代码后去写py会感到很不适应：这是怎么跑通的？这会不会太智能了？</p><p>以我目前的认知看来，py是不严谨，经不起推敲的（或者说，要想正确地解释py如何运行，需要在逻辑中加入一大堆的特判）</p><p>总之，学python（尤其是pandas这种库）时，深挖会发现它没有一个 简单合理的逻辑，它大多数逻辑都是通过反复的特判来符合我们的自然直觉。</p><h3 id="一些语法"><a href="#一些语法" class="headerlink" title="一些语法"></a>一些语法</h3><ul><li>列表解析式 <code>[i*i for i in range(1, 10) if i % 2 == 0]</code><ul><li>可以多层 <code>[m+n for m in [&#39;ABC&#39;, &#39;DEF&#39;] for n in m]</code></li><li>可以多值 <code>[m+n for m, n in dic.items()]</code>，dic为字典</li></ul></li><li>列表解析式能生成列表，其实是用到了生成器表达式<ul><li><code>g = (i*i for i in range(1, 10) if i % 2 == 0)</code></li><li>创建的 <code>g</code> 是一个生成器对象，上面被转化为了列表，它并不实际存储数据，而是存储规则，且也是可迭代的：</li><li><code>for i in g:</code> 使用生成器遍历，内存使用效率更高。</li></ul></li></ul><p>按自然语言理解即可</p><ul><li><p>允许连续不等式 <code>if a &lt; b &lt; c: ...</code>，<code>if a &lt; b &gt; c: ...</code></p></li><li><p>python中每个对象都有真&#x2F;假的固有属性，都可以用于条件判断，空的容器，数字0，None都被视为假；</p></li><li><p>and和or这种逻辑运算，返回的是<strong>操作对象</strong>，即确定表达式值的对象</p></li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-number">2</span> <span class="hljs-keyword">or</span> <span class="hljs-number">3</span> &gt;&gt;&gt; <span class="hljs-number">2</span> <span class="hljs-comment">#2就已经确定表达式为true</span><span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">4</span> &gt;&gt;&gt; <span class="hljs-number">4</span> <span class="hljs-comment">#4才能确定表达式为true</span>[] <span class="hljs-keyword">or</span> &#123;&#125; &gt;&gt;&gt; &#123;&#125; <span class="hljs-comment">#&#123;&#125;确定了表达式为false</span>[] <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &gt;&gt;&gt; [] <span class="hljs-comment">#[]就已经确定了表达式为false</span><span class="hljs-number">2</span> <span class="hljs-keyword">and</span> [] &gt;&gt;&gt; [] <span class="hljs-comment">#[]确定了表达式为false</span></code></pre></div><ul><li>使用 is 判断两个变量是否为同一对象</li><li>使用 in 判断容器中有无某值</li></ul><h3 id="一些好用的处理函数"><a href="#一些好用的处理函数" class="headerlink" title="一些好用的处理函数"></a>一些好用的处理函数</h3><p><code>map(func, arr)</code> 将可迭代对象的每个元素丢进func函数处理一遍，返回一个可迭代的map对象</p><p><code>filter(func, arr)</code> 将可迭代对象的每个元素丢进func函数判断一遍，仅保留返回值为true的元素，返回filter对象</p><p><code>reduce(func, arr)</code> 将可迭代对象第1,2个元素丢进func，得到的结果再和第3个元素丢进func…如此执行到尾，得到结果。</p><ul><li><code>reduce</code> 在python3中必须导入 <code>from functools import reduce</code></li></ul><p><code>sorted(arr, key=, reverse=)</code>  将可迭代对象排序后返回一个列表，默认递增，可传入函数key，用每个元素丢进key后的返回值来作为关键字排序。注意这里的key和reverse都是默认的命名关键字参数，指定时需给出名称</p><p>这里只能给出key函数，如果想像C++那样自定义比较函数的话，可以用到 <code>functools.cmp_to_key(comp)</code> 传入comp为一个两参数的函数，这个函数需要返回这两参数的比较结果（&gt;0，&#x3D;&#x3D;0，&lt;0），而<code>cmp_to_key</code> 能非常神奇地根据给出的比较函数，返回一个值函数，这个值函数将我们需要比较的元素映射到一个可比较的对象，它们的偏序关系是相同的。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<span class="hljs-keyword">def</span> <span class="hljs-title function_">comp</span>(<span class="hljs-params">x, y</span>):    <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>] - y[<span class="hljs-number">1</span>]ls.sort(key=functools.cmp_to_key(comp))</code></pre></div><p>注意comp的返回值是int，不能返回True和False</p><p><code>zip(a, b, c)</code> 将任意数量个可迭代对象的元素一一拼成元组，组成一个可迭代的zip对象返回</p><p>内置函数 <code>len, sum, max, min</code>，适用于大多数对象</p><ul><li>像诸如map对象，filter对象，dict_item等等这种中间过程对象往往不能用这些内置函数，先转化为list比较好</li></ul><h3 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h3><h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><div class="code-wrapper"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]b = a  <span class="hljs-comment">#a，b为同一对象</span>b = a[:] <span class="hljs-comment">#使用切片索引即为拷贝，不同对象</span>b = a.copy() <span class="hljs-comment">#拷贝</span>c = a + b    <span class="hljs-comment">#合并</span>a.extend(b)  <span class="hljs-comment">#合并（扩展）</span>c = a * <span class="hljs-number">3</span>  <span class="hljs-comment">#重复</span>a.index(<span class="hljs-number">3</span>) <span class="hljs-comment">#第一个值为3的位置（返回下标）</span>a.count(<span class="hljs-number">3</span>)a.sort(key = )a.reverse()</code></pre></div><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>大多内容和列表相同，但字符串<strong>不可变</strong></p><div class="code-wrapper"><pre><code class="hljs python">s = <span class="hljs-string">&quot;abcde&quot;</span>s.index(<span class="hljs-string">&#x27;cd&#x27;</span>) <span class="hljs-comment">#可以直接寻找子串索引，返回的是起始位置</span>s.find(<span class="hljs-string">&#x27;cd&#x27;</span>) <span class="hljs-comment">#同index，但不会报错而是返回-1</span>s = <span class="hljs-string">&quot;I am %d years old.&quot;</span>%(<span class="hljs-number">10</span>)   <span class="hljs-comment">#字符串格式化，规则和C的print大多相同</span><span class="hljs-string">&#x27;&#123;0&#125; is &#123;1:&lt;8.3f&#125;.&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;tyj&#x27;</span>, <span class="hljs-string">&#x27;3.14159&#x27;</span>) <span class="hljs-comment">#format格式化，&#123;&#125;中:后的部分为格式化规则，和上条相同，:前为序号，指定使用format中的第几个参数</span>s.strip(<span class="hljs-string">&#x27;a&#x27;</span>)<span class="hljs-comment">#去除两端的所有&#x27;a&#x27;（默认空格）</span>s.replace(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;de&#x27;</span>)    <span class="hljs-comment">#替换</span></code></pre></div><p>字符串连接，可以省略+号，如<code>&quot;abc&quot; &#39;der&#39; = &#39;abcder&#39;</code></p><p>略记格式化规则：</p><ul><li>最后一个字符表示类型，f为浮点数，d为整数，s为字符串等</li><li><code>x.y</code> 中x表示占据的宽度，y表示有效位数（浮点数下为小数点后位数）</li><li>前面加 <code>#^</code> 表示使用#填充空格，中间对齐（不填#默认使用空格填充），<code>&lt;&gt;</code> 分别为向左&#x2F;右对齐</li></ul><p>各种转换替换函数没啥特别的 在此处不记录</p><div class="code-wrapper"><pre><code class="hljs python">s = <span class="hljs-string">&quot;ababb abb bac&quot;</span>s.split(<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment">#分割时前后和aa之间的空字符串会保留</span><span class="hljs-string">&#x27;,&#x27;</span>.join([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])</code></pre></div><p><code>str()</code> 强转字符串：遵循目标print出来是什么样，转成字符串就是什么样</p><h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h5><p>可以不加括号地表示一个元组，例如：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span><span class="hljs-meta">&gt;&gt;&gt; </span>a(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">#输出时总是有括号的</span><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">1</span>, <span class="hljs-comment">#单个值的元组，在后面加上,以区分</span>(<span class="hljs-number">1</span>,)</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a, b, c = <span class="hljs-number">2</span>+<span class="hljs-number">3</span>, <span class="hljs-string">&quot;ds&quot;</span>, <span class="hljs-number">2313</span><span class="hljs-meta">&gt;&gt;&gt; </span>a, b, c(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;ds&#x27;</span>, <span class="hljs-number">2313</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>b<span class="hljs-string">&#x27;ds&#x27;</span></code></pre></div><p>这样可以同时给多个变量赋值，函数返回时也可以直接这样返回多个结果，本质上是因为都转化成了tuple</p><h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h5><p>字典是无序，可变的，本质是<strong>散列</strong></p><p>字典的Key不一定要是字符串，可以是任意<strong>不可变</strong>的数据类型。</p><p><code>dic.values(), dic.keys(), dic.items()</code> 都返回可迭代对象，但注意他们都不是列表。</p><p>遍历 <code>dic.items()</code> 得到的是键值对元组</p><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><p>集合是无序，可变，不重复的，可以存放不同类型的数据，本质也是<strong>散列</strong></p><p>集合中<strong>不能存储可变对象</strong>，和字典的Key是一个道理，哈希值不能变。</p><div class="code-wrapper"><pre><code class="hljs python">a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>&#125;      <span class="hljs-comment">#自动去重</span>a = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">#从列表转化而来</span>a.add(<span class="hljs-string">&#x27;3&#x27;</span>)a.remove(<span class="hljs-number">2</span>)a &amp; b<span class="hljs-comment">#交并差对称差</span>a | ba - ba ^ b</code></pre></div><p>判断字典，集合中有无元素都可以用 in 操作符方便地完成。</p><p>不可变集合 <code> frozenset</code></p><h3 id="可变、不可变类型"><a href="#可变、不可变类型" class="headerlink" title="可变、不可变类型"></a>可变、不可变类型</h3><p>可以认为，python中一般的数据类型（int，tuple，string等）都是直接存储，而list和字典是可变对象，可以把list看成一个“指针”，而字典是一个哈希表</p><p>具体表现为：</p><ul><li><p>在函数形参中使用list，它相当于“引用传递”，修改形参会同时修改实参的值</p><ul><li>list可以通过切片索引修改内容，但是如果切片索引作为右值，它是拷贝而非引用，如：<code>a = [1, 2, 3], b = a[0:2]</code>，b是a中内容的拷贝而非引用。</li></ul></li><li><p>tuple元组是一个<strong>不可变</strong>的数据类型，但是：</p></li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>t = (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>t[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;X&#x27;</span><span class="hljs-meta">&gt;&gt;&gt; </span>t[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;Y&#x27;</span><span class="hljs-meta">&gt;&gt;&gt; </span>t(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, [<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>])</code></pre></div><p>这里，tuple还是指向同一个对象，没有变动，而这个对象本身可以更改，是合理的。宏观上看来，不可变对象包含可变对象，则还是可变的。</p><ul><li>字典不可使用可变对象作为key值，也不能使用包含可变对象的元组作为key值，具体而言，一个对象作为key值需要它是可hash的</li></ul><p>为什么说int，string都是不可变的？</p><ul><li>区分变量和对象，<code>str = &quot;asd&quot;</code>，str是变量，”asd”才是字符串对象，这个对象是不可改变的</li><li>可以令 <code>str = &quot;asd&quot;.replace(&#39;a&#39;, &#39;A&#39;)</code>，但这样其实是让str这个变量指向了另一个字符串对象，并没有修改 “asd” 本身的值</li><li><code>int</code> 居然也是个不可变对象，我们在令 <code>b = a</code> 时，它们指向的是同一个对象，而在单独修改b时，如 <code>b = 20</code>，其实是让b指向了一个新的int对象<code>20</code></li><li><code>str[0] = &#39;A&#39;</code> 是错误的，总结一下：我们可以直接给这个变量重新赋值到另一个对象，但不能修改这个不可变对象本身。</li><li>更进一步，我们可以认为所有不可变对象其实都是固定的常量，比如让完全不想关的两个int一番操作后都等于2，<strong>他们也是同一个对象。</strong></li><li>注意可变对象，例如 <code>ndarray</code>，执行 <code>a += 1</code> 与 <code>a = a + 1</code> 是两码事。前者是改变了 <code>a</code> 所指的对象，后者是让 <code>a</code> 指向了一个新对象。</li></ul><p>常见的不可变对象还有元组，不可变集合(<code>frozenset</code>)</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>py的函数可以在任何地方定义，且函数也可以作为一个普通对象存储。</p><h5 id="值传递-amp-引用传递"><a href="#值传递-amp-引用传递" class="headerlink" title="值传递&amp;引用传递"></a>值传递&amp;引用传递</h5><p>python有时值传递，有时引用传递这样的说法肯定是无法接受的</p><p>其实python压根就没管值传递还是引用传递，出现各种情况的原因，来自于数据类型的可变性不同。</p><p>假如形参是 $x$，实参是 $a$，那么python在传参的时候就是无脑 <code>x=a</code></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">b</span>):    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b))    b = <span class="hljs-number">10</span>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b))a = <span class="hljs-number">20</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))f(a)<span class="hljs-built_in">print</span>(a, <span class="hljs-built_in">id</span>(a))</code></pre></div><p>这个程序跑一下，会发现：</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">2322675729232</span><span class="hljs-number">2322675729232</span><span class="hljs-number">2322675728912</span><span class="hljs-symbol">20 </span><span class="hljs-number">2322675729232</span></code></pre></div><p>a传参到b之后，我们发现b与a仍然有同一id（指向同样对象），然后给b赋值，按照上文中的知识，我们知道其实b是指向了一个新对象20，int对象本身是不可变的。所以造成了看起来是值传递的现象。</p><p>如果传递的是一个可变对象，就需要注意：首先传递过去后，形参b和a指向同一个对象，b[0] &#x3D; 1这样的操作可以修改这个对象，但类似b &#x3D; [2, 3]这样的操作，其实是让b这个引用变量更改了引用对象，从此之后它和a再没有关联了。</p><p>可以这么认为：python的变量全都可以看做是<strong>指针</strong>，它们指向一个具体对象。</p><h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><p>同样可以使用默认参数，默认参数需在必选参数后面</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">power</span>(<span class="hljs-params">x, p = <span class="hljs-number">2</span>, m = <span class="hljs-number">7</span></span>):    ...</code></pre></div><p>调用时可以直接指定参数位置，可以不必顺序一致</p><div class="code-wrapper"><pre><code class="hljs python">power(m = <span class="hljs-number">9</span>, x = <span class="hljs-number">2</span>)</code></pre></div><p>而依据我们上面所说的py参数传递特性，如果我们在默认参数这里使用可变对象的话：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">appd</span>(<span class="hljs-params">ls = []</span>):    ls.append(<span class="hljs-string">&#x27;a&#x27;</span>)    <span class="hljs-keyword">return</span> ls<span class="hljs-built_in">print</span>(appd())<span class="hljs-built_in">print</span>(appd())<span class="hljs-comment">#结果：</span><span class="hljs-meta">&gt;&gt;&gt; </span>[<span class="hljs-string">&#x27;a&#x27;</span>]    [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>]</code></pre></div><p>事实上，作为默认参数的列表对象一开始就被确定了，就是<strong>这个</strong>[]，调用时始终令ls &#x3D; 此默认对象，如果修改了这个对象，未来的默认参数也相当于被更改。</p><h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><p>可以用这样的方式定义一个可变长参数，它将参数组装为一个元组</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">*lls</span>):    <span class="hljs-built_in">print</span>(lls)func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</code></pre></div><p>这里疑似出现返祖现象（*</p><p>如果我们尝试探究这个*的具体意义的话：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(*[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span></code></pre></div><p>尝试输出 <code>type(*[1, 2, 3, 4])</code> 会得到一个报错，指明type不能传入多个参数</p><p>我理解*这个操作符能将列表拆开，在<strong>代码中</strong>散成 <code>1, 2, 3, 4</code> 的形式，可以拿去填充函数参数，如下：</p><div class="code-wrapper"><pre><code class="hljs python">a, b, c = *[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]  <span class="hljs-comment">#错！</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a, b, c</span>):    ...func(*[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])   <span class="hljs-comment">#对！</span></code></pre></div><h5 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h5><p>可以用这种方式定义一个关键字参数，它将参数组装成一个字典</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">**kw</span>):    <span class="hljs-built_in">print</span>(kw)func(age=<span class="hljs-number">2</span>, city=<span class="hljs-string">&#x27;hz&#x27;</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>&#123;<span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-string">&#x27;hz&#x27;</span>&#125;</code></pre></div><p>注意传递参数时，key值不需要加引号，会自动加上，我理解为语法糖</p><p>和上文的*类似，可以对字典进行**操作，将其展开成 <code>name = &#39;tyj&#39;, age = 20</code>：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">**kw</span>):    <span class="hljs-built_in">print</span>(kw)dic = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;tyj&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>&#125;func(**dic)<span class="hljs-meta">&gt;&gt;&gt; </span>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;tyj&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>&#125;</code></pre></div><h5 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h5><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a, b, *, city, name=<span class="hljs-string">&#x27;ttt&#x27;</span></span>):    ...func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, city=<span class="hljs-string">&#x27;hz&#x27;</span>, name=<span class="hljs-string">&#x27;tyj&#x27;</span>) <span class="hljs-comment">#city是命名关键字参数，必须指定</span></code></pre></div><p>以*或者可变参数作为分割，后面的都是命名关键字参数，它不再是随意的，而是必须的，可以有缺省值，传递时必须指定参数名</p><h5 id="应该没人这么写吧"><a href="#应该没人这么写吧" class="headerlink" title="应该没人这么写吧"></a>应该没人这么写吧</h5><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a, b, c=<span class="hljs-number">0</span>, *args, name, city=<span class="hljs-string">&#x27;hz&#x27;</span>, age, **kw</span>)</code></pre></div><p>必选参数，默认参数，可变参数&#x2F;*，命名关键字参数，关键字参数，必须是这个顺序</p><p>我的理解是：</p><ul><li>可变参数或*将普通参数和命名参数分割开来</li><li>普通参数和命名参数部分都可以有缺省值，普通参数的缺省值必须靠右</li><li>传递时依然从左往右传，上例中，优先给c传参，然后再是可变的args</li><li>可变参数的传递以命名的参数为终止</li><li>命名参数部分和左边同理，不过因为有名字作为索引，缺省值的位置和传入顺序都随意</li><li>**kw这个参数必须在最后，传入的参数如果在前面没有对应key值就直接塞进kw</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">*args, **kw</span>)</code></pre></div><p>这样的函数即可传入任意参数</p><h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><p>python在语法上<strong>不支持重载</strong>，我们可以传入可变的参数，再分类讨论</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>注意点：</p><ul><li><p><code>read</code> 返回所有字符组成的字符串</p></li><li><p><code>readline</code> 返回一行字符串</p></li><li><p><code>readlines</code> 返回字符串列表，每项为一行</p></li><li><p><code>write</code> 只能写入字符串</p></li><li><p><code>writelines</code> 可以写入字符串或字符串列表，但他并不会自动加换行</p></li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#os库基本操作</span>os.mkdir(path)   <span class="hljs-comment">#创建空文件夹</span>os.rmdir(path) <span class="hljs-comment">#只能删除空目录</span>os.listdir(path) <span class="hljs-comment">#返回列表 包含path下所有文件(夹)名</span>os.remove(path)  <span class="hljs-comment">#删除文件</span>os.rename(path)  <span class="hljs-comment">#删除文件</span>os.getcwd()      <span class="hljs-comment">#获取当前工作路径</span>os.walk(path) <span class="hljs-comment">#返回一个生成器，可以递归遍历path下所有文件，元素格式为(当前路径, [子目录], [子文件])</span><span class="hljs-comment">#os.path主要包含一些路径字符串操作</span>os.path.join(path, name): 在路径字符串后接name，能自动处理末尾的斜杠os.path.abspath(path): 返回path对应文件的绝对路径os.path.isfile(path)和os.path.isdir(path)函数分别检验给出的路径是一个文件还是目录。os.path.exists(path): 用来检验给出的路径是否真地存在os.path.split(path): 将path最后的文件（夹）和前面的路径名分开返回os.path.splitext(): 分离文件名与扩展名，返回的前面文件名是包括路径的os.path.basename(path): 返回path最后的文件（夹）名os.path.dirname(path): 返回path中的文件夹路径（即若最后是文件就去掉），参数填__file__获得当前工作路径os.path.getsize(name): 获得文件大小，如果name是目录返回<span class="hljs-number">0L</span>    <span class="hljs-comment">#shutil包含一些其他的文件操作</span>shutil.copy(src, dst)shutil.copytree(src, dst)shutil.move(src, dst)<span class="hljs-comment">#压缩等，略过</span><span class="hljs-comment">#pickle序列化</span>dumps(obj) <span class="hljs-comment">#返回序列化对象</span>loads(pic_obj) <span class="hljs-comment">#反序列化</span>dump(obj, file) <span class="hljs-comment">#序列化到文件，必须是wb的文件</span>load(file) <span class="hljs-comment">#将文件反序列化，必须是rb的文件</span></code></pre></div><h3 id="模块和包"><a href="#模块和包" class="headerlink" title="模块和包"></a>模块和包</h3><p>注意点：</p><ul><li><p><code>dir()</code> 可以以列表方式返回模块中的所有内容</p></li><li><p>包本身也是一个模块，其内容即 <code>__init__.py</code> 的内容</p></li><li><p>模块引入后，其中的变量和函数都可使用</p></li></ul><h5 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h5><ul><li><p><code>seed(x)</code> 设置种子</p></li><li><p><code>random()</code> 返回[0, 1)之间的浮点数</p></li><li><p><code>randint(a, b)</code> 返回[a, b]之间的整数（注意右端包含）</p></li><li><p><code>randrange(from, to, step)</code> 在这个range内随机一个，参数规则同range</p></li><li><p><code>uniform(a b)</code> 返回[a, b]之间的浮点数，如果b&gt;a能自动交换，但 <code>randint</code> 会报错</p></li><li><p><code>choice(seq)</code> 从序列中随机抽取一个</p></li><li><p><code>shuffle(seq)</code> 将序列随机打乱顺序，注意是原地打乱而非返回</p></li></ul><h5 id="math模块"><a href="#math模块" class="headerlink" title="math模块"></a>math模块</h5><ul><li><p><code>sin cos</code> 输入都是弧度值</p></li><li><p><code>radians</code> 角度转弧度</p></li><li><p><code>degrees</code> 弧度转角度</p></li><li><p><code>exp(x)</code> $e^x$ </p></li><li><p><code>log(x, base=e)</code></p></li></ul><h3 id="py面向对象"><a href="#py面向对象" class="headerlink" title="py面向对象"></a>py面向对象</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">node</span>:    name = <span class="hljs-string">&quot;lx&quot;</span>             <span class="hljs-comment">#此处声明的，既是静态变量（类成员），也是对象的成员</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, s</span>):        self.x = s        self.y = s        self.__z = s        self.name = <span class="hljs-string">&#x27;asd&#x27;</span>   <span class="hljs-comment">#成员和类变量同名，通过对象调用则为成员，通过类调用则为类变量</span>        name = <span class="hljs-string">&quot;23&quot;</span>         <span class="hljs-comment">#仅为此域内的一个name变量，和类无关</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">size</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">return</span> self.x * self.y</code></pre></div><p>！需要注意，python的类成员和对象成员不是定死的，而是<strong>随时可以新定义</strong>的，规范起见最好所有成员都在init中定义。</p><p>使用时，<strong>通过对象调用的就是对象成员，通过类名调用的就是类成员。</strong></p><p>两个下划线开头的变量自动认为是私有变量，其他均为公有。</p><p>所有成员函数，第一个参数必须为self（调用时无视）</p><p>修改成员必须使用&lt;对象名&#x2F;类名&gt;.成员名，这样才能辨别是类成员还是对象成员，直接写 <code>name=&#39;23&#39;</code>无效</p><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">shape</span>(<span class="hljs-title class_ inherited__">node</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, s, d</span>):    node.__init__(self, s)    self.z = d   <span class="hljs-keyword">def</span> <span class="hljs-title function_">size</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().size() + <span class="hljs-number">2</span>;//通过<span class="hljs-built_in">super</span>调用其父类函数</code></pre></div><h5 id="允许多类继承"><a href="#允许多类继承" class="headerlink" title="允许多类继承"></a>允许多类继承</h5><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">shape</span>(node1, node2, node3):</code></pre></div><p>python在调用函数方面简单很多，逻辑就是：在当前类中找这个函数，没有就去父类中找，有多个父类时，找的顺序是<strong>深度优先，从左到右</strong>，这种找的逻辑自然构成了重写和多态。</p><p><code>isinstance(obj, clas)</code> 判断obj是否是type或继承自type的实例</p><p><code>issubclass(clas1, clas2)</code> 判断clas1是不是clas2的子类</p><h5 id="Magic-Method"><a href="#Magic-Method" class="headerlink" title="Magic Method"></a>Magic Method</h5><p>python中有许多 <code>__init__</code> 形式的内置函数，可以自行实现。</p><p><code>__del__</code>：析构时调用</p><p><code>__getitem__</code>：相当于重载[]</p><p><code>__call__</code>：类可以像方法一样调用</p><p><code>__len__</code>：可以使用len()</p><p>等等</p><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>python是一个弱类型语言，我们不需要用统一的父类指针，就能统一指定多种对象了，然后对它们都调用同名方法，自然就形成了多态</p><p>其实这是动态语言的“鸭子类型”特性，一个东西只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p><p>所以只要保证方法同名 甚至不需要继承也能实现多态？</p><h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><p>用的最多是的ndarray，多维数组</p><p>它本质上是一个一维数组加上了每一维的长度信息</p><h5 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h5><p>核心是<strong>向右对齐</strong></p><p>例如：<code>shape(5, 3, 4)</code> 可以与 <code>shape(5， 3， 1)</code> 运算，从右边开始逐个对齐，未对齐的那一方必须为1，将自动复制以匹配。</p><p>例：<code>shape(5, 3, 4)</code> 还可以与 <code>shape(3, 1)</code>, <code>shape(5, 1, 1)</code> 运算，但不能和 <code>shape(5, 3, 2)</code>，<code>shape(5, 3)</code> 运算。</p><h5 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h5><p>ndarray索引方式及其强大，但一些较复杂的操作不易于理解。</p><p>首先我个人认为从图表（二维、三维图表）的角度理解ndarray的各种操作非常困难，我会通过“索引集合”（自己编的名字）的角度去理解。</p><p>即：例如，对于一个四维的ndarray，我认为它是一个大集合，用 <code>(x, y, z, k)</code> 索引其中的单个元素，索引共有四维。</p><p>同时，我们也只需要关注最常用的用法，Python还是一门实用语言，一些过于偏怪的写法此处就不深究了。</p><h6 id="切片索引"><a href="#切片索引" class="headerlink" title="切片索引"></a>切片索引</h6><p>和列表类似，但有所不同。列表的切片<strong>作为右值时</strong>是拷贝，而数组切片仍然是<strong>引用</strong>。</p><p>在一个维度上用单值，会压缩掉这一维</p><div class="code-wrapper"><pre><code class="hljs python">a <span class="hljs-comment"># shape(4, 3, 5)</span>a[:, <span class="hljs-number">0</span>:<span class="hljs-number">2</span>, <span class="hljs-number">0</span>:<span class="hljs-number">4</span>] <span class="hljs-comment"># shape(4, 2, 4)</span>a[:, :, <span class="hljs-number">0</span>] <span class="hljs-comment"># shape(4, 3)</span></code></pre></div><h6 id="整数序列"><a href="#整数序列" class="headerlink" title="整数序列"></a>整数序列</h6><p>在某一维索引上传入一个整数序列，即在这一维单独选取这几个索引出来，注意这种方式<strong>作右值是拷贝</strong>而非引用</p><div class="code-wrapper"><pre><code class="hljs python">a <span class="hljs-comment"># shape(4, 3, 5)</span>a[..., [<span class="hljs-number">0</span>, <span class="hljs-number">3</span>]] <span class="hljs-comment"># shape(4, 3, 2)</span>a[..., [<span class="hljs-number">0</span>]] <span class="hljs-comment"># shape(4, 3, 1) 不压维</span></code></pre></div><p>同时在多个维度上使用整数序列，效果<strong>并不是</strong>它们的组合，不常用，为避免将简洁的问题复杂化，暂且跳过。</p><h6 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h6><p>可以输入一个bool数组，这个数组的shape应该与原数组shape<strong>靠左对齐</strong>，例如：</p><div class="code-wrapper"><pre><code class="hljs python">a <span class="hljs-comment"># shape(4, 3, 5)</span>b <span class="hljs-comment"># bool shape(4, 3)</span>a[b] <span class="hljs-comment"># shape(x, 5)</span></code></pre></div><p>如上所示，布尔数组与前两位匹配，则它可以对前两维进行筛选，选出 $x$ 个布尔数组中值为True的索引（对），缩为一维，结果的shape为 <code>(x, 5)</code>。</p><p>注意，这里虽然对齐逻辑和广播有些类似，但索引并没有广播机制，shape必须能严格向左对齐才行。</p><p>需要注意，布尔数组与整数序列索引<strong>作为右值时是复制</strong>，但<strong>作为左值时，仍然为引用</strong>。不管他们索引出来的形状多么奇怪，他们仍然是原数组的印象，修改可以直接反映到原数组中。</p><p>布尔数组索引最常见的用法就是对原数组做筛选：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> # shape(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<span class="hljs-attribute">a</span>[a &gt; <span class="hljs-number">2</span>] = <span class="hljs-number">1</span># 将a中所有大于<span class="hljs-number">2</span>的元素变为<span class="hljs-number">1</span><span class="hljs-attribute">a</span>[a[..., <span class="hljs-number">0</span>] == <span class="hljs-number">1</span>] = <span class="hljs-number">2</span># 最后一维视为整体操作</code></pre></div><h6 id="混合索引"><a href="#混合索引" class="headerlink" title="混合索引"></a>混合索引</h6><p>暂时没遇到什么实用写法。</p><h5 id="ufunc"><a href="#ufunc" class="headerlink" title="ufunc"></a>ufunc</h5><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>arr = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>brr = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>arr + brrarray([<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>arr + <span class="hljs-number">5</span>array([<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>arr &gt; <span class="hljs-number">2</span>array([<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>])</code></pre></div><p>ndarray可以进行大多基础运算（<code>+-*/%乘方取余求反等</code>），效果为每个元素都运算一次，也可以进行数组-数值间的运算，会先将数值视作同等大小的数组（这个特性叫广播）。</p><p>广播特性还体现在：矩阵与一个较低维矩阵运算，会自动扩展小矩阵成一个大矩阵再运算。</p><p>有了这个搞法，结合布尔数组索引，就可以写出下面这种看起来玄学的代码：</p><div class="code-wrapper"><pre><code class="hljs python">arr[arr &gt; <span class="hljs-number">5</span>] = <span class="hljs-number">0</span> <span class="hljs-comment">#将arr中大于5的元素都变成0</span></code></pre></div><p>还有一些函数 <code>sin, cos, sqrt, exp, log, floor, ceil, round</code></p><p><code>sum, max, min, mean(均值), std(标准差)</code> 等，可以直接运用到数组上</p><p>统计类ufunc可以指定<strong>axis</strong>，表示在哪一个维度上统计，例如：</p><div class="code-wrapper"><pre><code class="hljs python">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>][<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]np.<span class="hljs-built_in">sum</span>(a, axis = <span class="hljs-number">0</span>)[<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]<span class="hljs-comment"># axis = 0即将0这一维度压掉，将其他维一样，第0维不一样的合并</span></code></pre></div><p>自定义ufunc：写一个单值的函数func，然后使用</p><div class="code-wrapper"><pre><code class="hljs python">myufunc = np.frompyfunc(func, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">#后两个参数为func参数个数，返回值个数</span></code></pre></div><p>func应用到单值上比较简单，应用到多值ufunc的此处暂略</p><h5 id="any"><a href="#any" class="headerlink" title="any"></a>any</h5><p><code>np.any(arr, axis=?)</code></p><p>应用在一个bool数组arr上，若其中有True则返回True。</p><p>指定axis：例如axis &#x3D; 1，每个含有True的行是True，其他行为False，返回一个bool数组。在做筛选时非常有用。</p><h5 id="矩阵-x2F-向量"><a href="#矩阵-x2F-向量" class="headerlink" title="矩阵&#x2F;向量"></a>矩阵&#x2F;向量</h5><p>一般不使用np的matrix对象，因为ndarray就足够</p><p>向量点乘（内积）：<code>np.dot(m1, m2)</code> 或 <code>@</code> 运算符</p><p>向量叉乘（外积）：<code>np.cross(m1, m2)</code></p><p>矩阵乘法使用 <code>@</code> 运算符，其他<code>+-*乘方</code>运算符均为元素间运算</p><p>矩阵转置 <code>a.T</code></p><p>排序：<code>np.sort(a, axis=1)</code> 默认每行一次排序，可以指定<code>axis=None</code> 将所有元素排序成一维数组。注意这里的sort是<strong>返回数组而非原地修改</strong>，列表的sort是原地修改。</p><p><code>np.argsort</code> 返回的是每个元素排序后的下标，如果每行排一次序，下标即为列号。</p><h3 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h3><p><a href="https://blog.csdn.net/qsx123432/article/details/111415998">https://blog.csdn.net/qsx123432/article/details/111415998</a></p><h5 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h5><p>拥有索引<code>index</code>和值<code>value</code>，可以看做一个字典，索引可以是任何类型</p><p>构建：</p><p><code>Series([....])</code> 通过列表构建，默认索引为自增的数字</p><p><code>Series(index=[..], data=[..])</code></p><p>它的索引和值都可以像列表一样有不同类型的数据，也可以指定dtype</p><h5 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h5><p>表格型数据结构，是共用index的多个Series，每个Series作为一列，有一个列名。</p><p>构建：</p><p><code>DataFrame([[1, 2], [1, 3], [1, 4]])</code> 通过可迭代对象构建，默认索引和列名都为自增的整数。</p><p><code>DataFrame(&#123;...&#125;, index=)</code> 通过字典构建，列名为字典的key，<strong>值为列表表示一列数据</strong>，若值为单个值，则必须指定index（值会重复多次）。</p><p>可以指定columns等指定列名。</p><p>索引：</p><p>DataFrame通常是先进行列索引（通过columns索引），他可以<code>df.age</code>也可以<code>df[&#39;age&#39;]</code>，得到的是一个Series，再通过index索引单元格。</p><p>索引列时可以给出一个列表，指定多列，返回就不是Series而是子表格了</p><p>可以进行行切片索引，得到一个子表格，但不能索引单行，也不支持同时索引：</p><div class="code-wrapper"><pre><code class="hljs python">df[<span class="hljs-number">0</span>] <span class="hljs-comment">#错（除非columns中有个整数0）</span>df[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>] <span class="hljs-comment">#对</span>df[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;age&#x27;</span>] <span class="hljs-comment">#错</span>df[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>][<span class="hljs-string">&#x27;age&#x27;</span>] <span class="hljs-comment">#对，但返回的是Series</span>df[<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-string">&#x27;c&#x27;</span>]    <span class="hljs-comment">#对 index不为整数也可以切片索引，但这样是末端包含的</span></code></pre></div><p>要同时索引，只能用专用的切片语法：</p><p><code>df.ix[0:1, &#39;age&#39;]</code>、<code>df.ix[2, 1:2]</code> 等</p><p>这套规则看起来很垃圾，但也是为了避免冲突和歧义，这样如果索引的是单个值，则认为是列索引，切片则认为是行索引，要同时索引则必须使用ix，总体上是没有歧义的。</p><p>更明确一点可以用<code>df.loc[行索引]</code>…这就完全不会有歧义了，使用单值还是切片还是啥的都行。</p><h5 id="布尔索引-1"><a href="#布尔索引-1" class="headerlink" title="布尔索引"></a>布尔索引</h5><p>和numpy类似，Series和DataFrame都可以和数值做一些运算，如：</p><p><code>df &gt; 4</code> </p><p>这个东西的返回结果还是一个表格，就是把df当中满足&gt;4的元素改成True，其他改成False（Series同理）</p><p><code>df[&#39;B&#39;] &gt; 4</code></p><p>它返回一个Series，满足条件的index下为True</p><p>然后就可以用它们来索引：</p><p><code>df[df &gt; 4] = 9</code></p><p>这里其实提供了三个特性：df可以用一个同Index同Columns，内容为Bool的表格来索引，返回的也是一个表格（是df的部分引用，没引用到的地方为NaN），对这个引用赋值，即对非NaN的部分赋值。。。</p><p>DataFrame可以使用布尔Series索引，相当于行索引返回子表格（引用），故也可直接更改</p><p><code>df[df[&#39;B&#39;] &gt; 2] = 9</code> 一行全都改成9</p><h5 id="统计方法"><a href="#统计方法" class="headerlink" title="统计方法"></a>统计方法</h5><p><code>df.mean(axis=0)</code> 看做二维数组，默认是按列聚集，返回series，原来的columns改成index。若<code>axis=1</code>（按行聚集）则index不变，聚集后dataframe变成series</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>总的来说，调用方式有几种（以match为例）：</p><ul><li><code>re.match(模式串， 匹配串)</code></li><li><code>re.match(pattern对象， 匹配串)</code></li><li><code> pattern对象 = re.compile(模式串)</code> <code>pattern对象.match(匹配串)</code></li></ul><p>re的匹配结果有点乱…</p><p>先说一下<strong>匹配对象</strong>：其中包括了匹配结果的字符串，以及该串在原串中的位置等信息</p><p><code>匹配对象.group()</code> 或 <code>group(0)</code> 返回匹配到的整个串，<code>group(1)/group(name)</code> 可以定向返回此次匹配中某个组的匹配结果</p><p><code>groups()</code> 把所有组的匹配结果打包成元组返回，没有组则返回<strong>空</strong></p><p>分组的圆括号是可以嵌套的，不影响，顺序按照左括号先后顺序。</p><ul><li><p>match：必须从开头开始匹配，返回第一个匹配对象</p></li><li><p>search：返回第一个匹配对象</p></li><li><p>findall：找到所有匹配结果</p><ul><li>若有多个分组，则返回所有匹配对象<code>groups()</code>组成的列表</li><li>若有一个分组，则不再打包元组，将所有匹配对象该组的匹配结果组成列表返回</li><li>否则则返回所有匹配到的整个串组成的列表</li></ul></li><li><p>finditer：返回一个可迭代对象，其中每个元素是一个匹配对象</p></li><li><p>sub：替换 将匹配的所有串替换为另一个串，或按照一个函数替换，函数的参数为匹配对象</p><ul><li>替代字符串中可以写\d，表示使用第d组的匹配结果</li><li>注意参数中替代字符串或函数写在前面</li></ul></li><li><p>split：简单粗暴地将所有匹配的串删除，剩下的部分拆开来作为列表返回</p></li></ul><h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><p>大一寒假简单看过爬虫但没看明白 这次突然感觉爬虫简单了很多</p><h4 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h4><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.request <span class="hljs-keyword">as</span> ururl = <span class="hljs-string">&quot;https://m.huiyi8.com/fengjing/zuimei/&quot;</span>headers = &#123;    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">r&#x27;Mozilla/5.0 (windows NT 6.3; WOW64) l\</span><span class="hljs-string">    ApplewebKit/537.36(KHTML, like Gecko) Chrome/43.0.235&#x27;</span>&#125;req = ur.Request(url, headers = headers)page = ur.urlopen(req).read()page = page.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-comment">#解码 格式规范化？</span></code></pre></div><p>核心是urlopen，它直接打开一个url，然后返回一个response对象，这个对象可以直接read得到网页html源码</p><p>urlopen所用的url可以直接是网页地址，也可以进行一些包装，Request方法能将一些别的信息包到这个url当中形成一个请求，包括提交的内容，网页头等，返回结果是一个请求类型（不再是字符串了，urlopen当然也可以打开请求类型）。</p><p>读到的page解码一下，就和网页上按F12看到的html源代码一样了，是一大坨字符串，随后可以用正则表达式或者BeautifulSoup截取其中的信息。</p><h4 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h4><p>接上述代码，BeautifulSoup可以帮我们把html字符串再解释一下，变得更容易读取。</p><div class="code-wrapper"><pre><code class="hljs python">soup = BeautifulSoup(page, <span class="hljs-string">&#x27;html.parser&#x27;</span>) <span class="hljs-comment">#直接解释page 变成一个soup对象</span></code></pre></div><p>soup中最主要的是<strong>Tag</strong>对象，即网页上的一个个标签，可以直接soup.p得到第一个p标签，也可soup.findAll(‘p’)返回所有p标签（和列表形式差不多但不是列表），findAll后面有<code>**kwargs</code>可以加上各种属性的限制条件，如<code>findAll(&#39;p&#39;, id=&#39;link&#39;)</code></p><p>标签对象可以<code>tag.attrs</code>获得其中所有属性，以字典形式</p><p>也可以直接<code>tag[&#39;src&#39;]</code>，把tag本身当做一个字典来取</p><p>tag也有子tag，可以用.content或.children遍历所有子tag，.descendants遍历所有子孙tag，还有各种父节点，兄弟节点差不多略过不谈</p><p>tag.string可以获取到tag下（子孙）的文本，因为文本不放在标签内部。若子孙中有多个文本，返回None。还有tag.strings，它返回所有子文本的可迭代对象</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理复习笔记</title>
    <link href="/2022/06/07/2022-06-07-%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/06/07/2022-06-07-%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><em>个人理解部分用斜体标出 勿轻易全信</em></p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="字长定义"><a href="#字长定义" class="headerlink" title="字长定义"></a>字长定义</h4><p>存储字长：一个存储单元位数，一般指主存。</p><p>机器字长：计算机能直接处理的二进制数据的位数，为CPU内部寄存器的位数。</p><p>数据字长，指令字长：存储一个数据&#x2F;指令的字长，<strong>早期计算机</strong>一般上述字长都相等，一个存储单元恰能存储一个数据或指令，现代计算机可以不相等，数据和指令字长常常是可变的，可以多次取数组成一个数据或指令。</p><p>地址长度一般小于数据字长&#x2F;指令字长，CPU中，PC、MAR为地址长度，MDR、IR等等都是数据长度，IR存储当前执行指令，包含操作码+地址。</p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>数据总线：双向传输，位数称为<strong>总线宽度</strong>，与存储字长，机器字长有关。<em>CPU中的MDR与其相连。</em></p><p>地址总线：由CPU指出欲访问的存储地址&#x2F;设备地址，是单向传输的，<em>CPU中的MAR与其相连，其位数等于MAR位数</em>。</p><p>控制总线：由CPU发出命令，也可由其他设备对CPU发出请求，故单个控制总线是单向的，但控制总线总体上是双向的。</p><h4 id="判优"><a href="#判优" class="headerlink" title="判优"></a>判优</h4><h5 id="链式查询："><a href="#链式查询：" class="headerlink" title="链式查询："></a>链式查询：</h5><p>离得越近越先获得总线控制权，实现简单，但对故障敏感，低优先级的设备很难获得控制权。</p><h5 id="计时器定时查询："><a href="#计时器定时查询：" class="headerlink" title="计时器定时查询："></a>计时器定时查询：</h5><p>即用一个计数器依次枚举每一个设备，加了一道设备地址线，当设备地址线的内容和设备地址相符时，它获得控制权。各个设备的优先级相等，也可以通过程序设定计数器初始值。它控制复杂，设备地址线需要$log_2n$ 根，但对故障敏感度降低。</p><h5 id="独立请求方式："><a href="#独立请求方式：" class="headerlink" title="独立请求方式："></a>独立请求方式：</h5><p>每个设备有独立的请求线和同意线，优先级完全由程序设定，控制灵活但复杂，且需要 $2n$ 根额外的线。</p><h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><h5 id="同步通信："><a href="#同步通信：" class="headerlink" title="同步通信："></a>同步通信：</h5><p> 以时钟的上升和下降沿为信号进行操作，必须在规定的时钟周期内完成规定的操作。</p><h5 id="异步通信："><a href="#异步通信：" class="headerlink" title="异步通信："></a>异步通信：</h5><ul><li>不互锁：发出信号后，等待一段时间就关闭信号，也要求对方在这段时间里必须收到。</li><li>半互锁：主模块发出请求信号，等待回答再关闭信号。从模块发出回答信号，等待一段时间后关闭回答信号。不必等待请求关闭。</li><li>全互锁：主模块既要等待回答，从模块也要等待请求关闭。</li></ul><h5 id="异步串行通信："><a href="#异步串行通信：" class="headerlink" title="异步串行通信："></a>异步串行通信：</h5><p><a href="https://blog.csdn.net/weixin_39653320/article/details/111105213">https://blog.csdn.net/weixin_39653320/article/details/111105213</a></p><p>传输的数据包括起始位，数据，[校验位]和终止位，起始位为低电平，终止位为高电平，数据由低位到高位传送。</p><p>空闲时始终为高电平，当接受到一个低电平时，代表数据开始传输了，此时初始化并启动接收方的时钟，做到与数据传输同步，随后每隔一个周期读取一位数据。（<em><strong>异步串行在数据内的位上是同步的，多个数据间是异步的</strong></em>）</p><p>通信时数据长度是不固定的，故双方必须就传输的数据格式达成协议。</p><p>一个字符传输完成后，终止位让线路回到高电平，随后若有空闲位，同样需要是高电平。接到低电平时即为下一个传输的字符。</p><h5 id="同步串行通信："><a href="#同步串行通信：" class="headerlink" title="同步串行通信："></a>同步串行通信：</h5><p>严格在系统时钟的前沿开始发送，接收方在系统时钟的后沿判别。</p><p>同步通信也需要一个起始标记，但因为数据之间也是同步时钟的，故对一个数据块只需要一个起始标记（异步通信每个字符都需要起始标记），传输速率很高。</p><p>简单概括：异步通信对时序要求不严格，允许速度差异较大的设备和谐工作，每接收一个字符都需要靠起始位来对准时钟，而同步通信可以传输一大段数据（数据块）后再根据起始位调整，对时序要求更严格。</p><h5 id="半同步通信："><a href="#半同步通信：" class="headerlink" title="半同步通信："></a>半同步通信：</h5><p>让同步通信也能接收速度较慢的模块。</p><p>模块如果在规定的时间里未能完成任务（如发送数据），则发送一个等待信号，对方的同步也将延迟一个周期。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>带宽：bps、Bps，每秒传输的数据位数</p><p>波特率：每秒传输的数据位数。</p><p>比特率：每秒传输的有效数据位数。</p><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><h4 id="按字-x2F-字节寻址"><a href="#按字-x2F-字节寻址" class="headerlink" title="按字&#x2F;字节寻址"></a>按字&#x2F;字节寻址</h4><p><em>按字&#x2F;字节寻址的区别就是最小编址单位，按字寻址时，无需保留对字节的编址，也无法寻址到具体字节</em></p><h4 id="存储器的效验"><a href="#存储器的效验" class="headerlink" title="存储器的效验"></a>存储器的效验</h4><p>汉明码中有配奇或配偶之分，配奇即新加入的位C要使得组内共有奇数个1。</p><h4 id="提高访存速度的措施"><a href="#提高访存速度的措施" class="headerlink" title="提高访存速度的措施"></a>提高访存速度的措施</h4><p>单体多字系统：在一个存取周期里读出多个连续的字，当指令或数据不连续时无效。</p><p>多体并行系统：有多个存储体，每个存储体都拥有独立的MAR和MDR，可以同时存取。</p><ul><li><p>高位交叉编址，连续的数据地址仅在低位上不同，存放在同一个存储体内（不去考虑边缘等情况），请求不同存储体内数据的源可以同时存取，但单一请求没法加速，取出 $n$ 个字需要 $nT$ 的时间（$T$ 为存取周期）。</p></li><li><p>低位交叉编址，连续的数据会交叉循环地存放在各个存储体中，这样不利于存储器的扩充，但请求一段连续数据时，可以让各个存储体同时取数，大大提高了效率。各个存储体取数时需要错开一个总线传输周期，详见书上的图，连续取出 $n$ 个字需要 $T+(n-1)t$ 的时间（$t$ 为总线传输周期）。</p></li></ul><h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p>原理和哈希一样，略过不谈，看符号：</p><p>主存块数 $2^m$，cache块数 $2^c$，一块内的可编址单位数（字或字节）$2^b$，标记字块补全cache中没有的主存块信息，即剩下的 $t&#x3D;m-c$</p><p>主存地址：$tcb$，其中 $m&#x3D;t+c$</p><p>如果分组，一组中有 $2^r$ 块，那么共有 $2^q&#x3D;2^c&#x2F;2^r$ 组，$q&#x3D;c-r$</p><p>主存块号的后 $q$ 位决定其组号，其余都是标记位， $t&#x3D;m-q$</p><p>主存地址：$tqb$，其中 $m&#x3D;t+q$，它相对于不分组的就是将 $c$ 中的 $r$ 位挪到了 $t$ 上。</p><h4 id="辅存"><a href="#辅存" class="headerlink" title="辅存"></a>辅存</h4><p>道距：$P$，道密度：$D_t&#x3D;\frac{1}{P}$，注意道距是两个道之间半径的差，而内径外径通常指直径。</p><p>位密度：单位长度磁道记录的信息总量，各个磁道的信息总量相同但半径不同，所以位密度是不均匀的，一般以最内道为磁盘的位密度。$D_b&#x3D;\frac{f_t}{\pi d_{min}}$，$f_t$ 即为每一道的信息量。</p><p>平均等待时间：磁道旋转到指定位置需要的平均时间，$t_{wa}&#x3D;\frac{旋转一圈时间}{2}$，</p><p>平均寻址时间：平均找道时间和平均等待时间之和。</p><p><strong>数据传输率：</strong>指单个磁道每秒传输的信息量（单位同bps、Bps），而非整个磁盘的传输量。</p><p>记录面：一般 $n$ 块磁盘，有 $2n$ 个记录面，若上下两面不记就有 $2n-2$ 个</p><p>柱面：指不同记录面上，相同半径的磁道组成的圆柱。多少个磁道就有多少个柱面。</p><h3 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h3><h4 id="IO接口"><a href="#IO接口" class="headerlink" title="IO接口"></a>IO接口</h4><p>接口：两种硬件之间的连接电路，或是两种软件之间的逻辑边界。</p><p>IO接口主要功能：选址功能，传送命令功能，传输数据功能，反映IO设备状态功能</p><p>基本组成：数据线，设备选择线，命令线，状态线</p><h4 id="IO设备编址"><a href="#IO设备编址" class="headerlink" title="IO设备编址"></a>IO设备编址</h4><p>给设备编址就是为其分配编号（设备码，地址码）的过程。</p><p>编址后可以由设备码直接指出设备号（具体设备名），随后通过接口电路选择设备。</p><p>编址方式有两种：</p><ul><li>统一编址：指定哪些地址代表设备地址，哪些代表主存地址，这种方式减少了主存的可用空间。</li><li>不统一编址：需要使用专门的指令，仅在这些指令下地址码被看做设备地址。</li></ul><h4 id="信息传送控制"><a href="#信息传送控制" class="headerlink" title="信息传送控制"></a>信息传送控制</h4><h5 id="程序查询方式："><a href="#程序查询方式：" class="headerlink" title="程序查询方式："></a>程序查询方式：</h5><p>CPU不断查询设备是否做好准备，要求设备内置一个表示就绪状态的标记。效率低下。</p><h5 id="程序中断方式："><a href="#程序中断方式：" class="headerlink" title="程序中断方式："></a>程序中断方式：</h5><p>CPU执行”启动设备“命令后，不管他，继续执行程序。</p><p>设备接到启动命令，便自行准备，准备就绪后（$D&#x3D;1$），发出中断请求（$INTR&#x3D;1$）。</p><p>CPU在每条指令执行结束后（此时状态稳定），检查所有的设备有无中断请求，如果有，就像调用函数一样跳转到对应设备的中断服务程序。</p><p>各个设备的请求还需要经过排队器（一个组合逻辑电路）或排队软件以确定是哪个设备最终获得中断权，随后产生中断相应信号（$INTA$）将排队器的输出送到编码器转化为<strong>中断向量</strong>，可以理解为对设备的编码。可以在这个中断向量所示地址内存放一个无条件转移到中断服务程序入口的指令。这样CPU只需要将中断向量送入PC即可。</p><p>中断服务程序首先会进行现场保护，将CPU内各个寄存器的状态都保留下来。注意<strong>对程序断点的保存（PC）不由中断服务程序完成</strong>，因为到服务程序时PC值已经被改变了，断点会在CPU的中断周期中，<code>中断向量-&gt;PC</code> 前自动入栈（由隐指令，或者说硬件完成），随后进行设备服务，恢复现场，返回断点。</p><p>CPU还有一个允许中断（$EINT$）标志，在中断周期，程序断点保存后，这个标志置为0（关中断），暂不允许其他中断的发生。<strong>若CPU不允许中断嵌套，这个标志将在中断返回后置为1，否则它将在中断服务程序现场保存完毕后就置为1</strong>，只要不导致现场混乱即可嵌套中断服务程序。</p><p>中断屏蔽：也可用于处理中断优先级，每个中断源都有一个屏蔽标志（$MASK$），仅当此标志为0时，$INTR$ 才能等于1。当一个设备被允许中断，他会根据自身的屏蔽字，将一些其他设备的屏蔽标志设为1。</p><p>屏蔽字存放在屏蔽寄存器中，改变屏蔽字即可改变优先级，例如 $A$ 的屏蔽字中不包含 $B$，而 $B$ 的屏蔽字包含 $A$，那么 $B$ 请求中断时，哪怕 $A$ 正在执行也会被打断，但反之不行。</p><p>总结一下中断发生的条件&#x2F;顺序：</p><ol><li>$(D&#x3D;1)+(MASK&#x3D;0)-&gt;INTR&#x3D;1-&gt;进入排队器$</li><li>$(排队器选中)+(EINT&#x3D;1)-&gt;INTA信号，进入中断响应$</li><li>$INTA$ 将排队器输出送到编码器 $-&gt; 中断向量$</li></ol><p>书上P199图5.43不错</p><h5 id="DMA方式："><a href="#DMA方式：" class="headerlink" title="DMA方式："></a>DMA方式：</h5><p>Direct Memory Access 直接存储器访存，效率最高</p><p>在存储器和高速IO设备之间架设了一条直接通路，无需通过CPU。其中使用DMA接口（通道）作为一个小CPU，完成一些基本的读写功能。</p><p>DMA和CPU同时访问主存时，DMA优先，CPU需将总线控制权让出，因为高速IO设备的信息很容易流失。</p><p>具体的三种方法见书P203的图。</p><h3 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h3><p>默认按字寻址？</p><p>如变址寻址，基址寻址这样的寻址方式，如果有专用的寄存器，则可以隐含其地址；如果没有专用的，则需指定一个基&#x2F;变址寄存器，那么指令中也需要加入寄存器地址。</p><p>本章不只研究传统计算机，存在地址长度大于存储字长的情况（可以用双字长指令）。</p><p><em>同一格式的指令如果只有一种寻址方式，就不需要寻址特征位了。</em></p><h3 id="CPU的结构和功能"><a href="#CPU的结构和功能" class="headerlink" title="CPU的结构和功能"></a>CPU的结构和功能</h3><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>取值周期：注意PC+1是在取值周期的最后一步，它是一个信号，由CU发出直接令PC+1，不需要经ALU什么的</p><p>间址周期：注意IR，它存放当前的指令，在取值周期要将MDR送入IR，间址周期中，检查IR是否包含间址特征，如果包含则将<strong>MDR</strong>中的地址码部分传入MAR…因为IR一般不可随意读取（详见书P381的图，没有IR到总线的门）。获得实际地址后，还要将MDR传入IR一次来更新IR为当前执行的命令。（此处数据流书</p><p>写入主存时，似乎都是先发出写命令，再将要写的数据送入MDR？</p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>都可以选择使用两位符号位，高位符号位不移动进行算术移位，左移时低符号位复制高符号位</p><h5 id="原码一位乘："><a href="#原码一位乘：" class="headerlink" title="原码一位乘："></a>原码一位乘：</h5><p><a href="https://blog.csdn.net/qq_43355372/article/details/100139844">https://blog.csdn.net/qq_43355372/article/details/100139844</a></p><p>对于机器而言，每次都将部分积和乘数同时左移，部分积的低位正好可以放到乘数寄存器的高位上，乘数每次都取最后一位即可。</p><p>另设一个寄存器 $C$ 来计数，整体过程是：部分积从0开始，<code>+ 右移</code> 重复到所有乘数被移出。</p><p>最终部分积和乘数两个寄存器共同作为结果，两数符号位异或作为最后符号位。</p><p>注意点：运算过程中可能溢出到符号位上，但不影响，此处都进行<strong>逻辑移位</strong>，高位（符号位）补0。</p><h5 id="补码乘法："><a href="#补码乘法：" class="headerlink" title="补码乘法："></a>补码乘法：</h5><p>当乘数是正数时，直接按照原码一位乘方式计算（因为被乘数只涉及加减运算，在补码下无论正负都正确）</p><p>当乘数是负数时，可以将其补码拆分，如 <code>1.0101 = 1.0000 + 0.0101</code>，随后用正数部分相乘，结果再加上被乘数乘以 <code>-1</code> 的结果</p><p>注意点：通常采取双符号位，最高位为真实符号，进行<strong>算术移位</strong>，最高位保持不变，第二符号位跟着移动，补位按照补码方式补。</p><h5 id="Booth算法："><a href="#Booth算法：" class="headerlink" title="Booth算法："></a>Booth算法：</h5><p>无需对符号位分类讨论的补码乘法。</p><p>具体过程见书</p><p>注意点：乘数的<strong>符号位</strong>也参与运算，被乘数同样采用双符号位，总体过程是 $+\to$ ，重复到所有乘数被移出，但最后的符号位不用移出（$+$ 比 $\to$ 多一次）</p><h5 id="恢复余数法："><a href="#恢复余数法：" class="headerlink" title="恢复余数法："></a>恢复余数法：</h5><p>总体过程：<code>- 上商 [恢复] 左移</code>，重复到商够了后恢复好为止（商要和被除数位数一样）</p><h5 id="加减交替法："><a href="#加减交替法：" class="headerlink" title="加减交替法："></a>加减交替法：</h5><p>总体过程：<code>-/+ 上商 左移</code> ，重复到商够为止</p><h5 id="补码除法："><a href="#补码除法：" class="headerlink" title="补码除法："></a>补码除法：</h5><p>先根据 $x$ 与 $y$ 是否同号，加或者减 $y$</p><p>再：<code>上商 左移 +/-</code> 重复直到最后一次左移，给末尾商恒置1</p><p>上商时根据余数和 $y$ 的符号，相同上1不同上0，随后的 <code>+/-</code> 也根据此，若上了1则减 $y$，反之加 $y$</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法分析设计课复习补充</title>
    <link href="/2022/06/07/2022-06-07-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0%E8%A1%A5%E5%85%85/"/>
    <url>/2022/06/07/2022-06-07-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h3 id="复杂度的严谨定义"><a href="#复杂度的严谨定义" class="headerlink" title="复杂度的严谨定义"></a>复杂度的严谨定义</h3><p>复杂度有三种表示：$O,\Omega,\Theta$</p><p>其中 $O$ 表达的是上界，定义为：</p><p>函数复杂度 $f(n)&#x3D; O(g(n))$，仅当存在一个边界 $n_0$ 和常数 $c$，使得对于所有$n&gt;n_0$，满足 $f(n)\le cg(n)$。</p><p>这个定义有极限的想法，我们可以得到 $2n^2&#x3D;O(n^2)$，也有 $2n^2&#x3D;O(n^3)$，上不封顶，但第二个式子没什么意义。</p><p>这里的等号是一个单向等号。</p><p>$\Omega$ 表达的是下界，定义和上文类似，大变成小：</p><p>有 $2n^2&#x3D;\Omega(n)$， $\sqrt{n}&#x3D;\Omega(logn)$</p><p>平时我们所说的复杂度是 $\Theta$，它是上述两者的交。</p><p>另外还有 $o$ 和 $\omega$，分别对应上述两种将大于等于改成大于、小于 </p><p>严谨证明一个复杂度，需要分别证明 $O$ 和 $\Omega$</p><h4 id="证明方法"><a href="#证明方法" class="headerlink" title="证明方法"></a>证明方法</h4><h5 id="代入法（Subtitution-Method）推断"><a href="#代入法（Subtitution-Method）推断" class="headerlink" title="代入法（Subtitution Method）推断"></a>代入法（Subtitution Method）推断</h5><p>例如：对于一个递归的式子 $T(n)&#x3D;4T(n&#x2F;2)+n$，要求它的复杂度</p><p>运用数学归纳法，首先有 $T(1)&#x3D;1$</p><p>然后猜测一个复杂度上界：$O(n^2)$，假设对于 $k&lt;n$， $T(k)\le ck^2$ 都成立，要证明 $T(n)\le cn^2$</p><p>代入：<br>$$<br>\begin{align}<br>T(n)&amp;&#x3D;4T(n&#x2F;2)+n \<br>&amp;\le4c(n&#x2F;2)^2+n \<br>&amp;&#x3D;cn^2+n<br>\end{align}<br>$$<br>证明失败…</p><h5 id="递归树法"><a href="#递归树法" class="headerlink" title="递归树法"></a>递归树法</h5><p>画出递归树，然后计算每一层的操作次数，列出一个级数式子计算。</p><h5 id="主方法"><a href="#主方法" class="headerlink" title="主方法"></a>主方法</h5><p>将上述函数式写成：$T(n) &#x3D; aT(n&#x2F;b)+f(n)$</p><p>主方法观察两个部分哪部分起到主要作用，复杂度取决于较大者</p><ul><li><p>若 $f(n)\lt n^{log_b{a}}$，则总复杂度为 $\Theta(n^{log_b{a}})$</p><ul><li>更准确的定义为 $f(n)&#x3D;O(n^{log_b{a}-d}),d&gt;0$，即 $f(n)$ 以某个更小的复杂度为上界，那么总体复杂度就取决于 $n^{log_b{a}}$</li></ul></li><li><p>若 $f(n) &#x3D;\Theta(n^{log_b{a}})$，则总复杂度为 $\Theta(n^{log_b{a}}lgn)$</p><ul><li>两边同级别，则总体复杂度乘上一个系数因子</li></ul></li><li><p>若 $f(n)\gt n^{log_b{a}}$，则总复杂度为 $\Theta(f(n))$</p><ul><li>更准确的定义为 $f(n)&#x3D;\Omega(n^{log_b{a}+d}),d&gt;0$，即 $f(n)$ 以某个更大的复杂度为下界，那么总体复杂度就取决于 $f(n)$</li></ul></li></ul><p>可以知道树的高度为 $log_bn$，叶子节点共有即 $a^{log_bn}$ 个，它等于 $n^{log_ba}$（两边同时取对数可得）</p><p>其他证明略过</p><p>但这种情况无法使用主方法：$T(n)&#x3D;2T(n&#x2F;2)+nlogn$</p><p>$n^{log_b{a}}&#x3D;n$，$f(n)&#x3D;nlogn$，$f(n)$ 是渐进大于 $n$，而不是多项式大于 $n$ 的。看似是第三类，但实际上无法找到一个 $n^{1+d}$ 作为 $f(n)$ 的下界，加一点就在多项式上超过 $f(n)$ 了。而它们又显然不是同一级别，不能用第二类。</p><p>但是可以感性理解&#x2F;其他方法，得到最终复杂度确实是 $nlogn$ 的</p><h4 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h4><p>朴素复杂度为 $n^3$</p><p>考虑分治：将矩阵划为四份，每份独立相乘后再相加，$T(n)&#x3D;8T(n&#x2F;2)+4(n&#x2F;2)^2$，复杂度仍为 $n^3$</p><p>可以采用各种结合相乘的方式，把相乘次数压到7次，虽然需要18次相加，但总复杂度能降到 $n^{2.81}$（具体乘法应该不用记）</p><p>目前最优的矩阵乘法可以做到 $n^{2.376}$</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>快排是就地算法，它不需要临时的数组（缓存），所以产生了这么写法，本质都差不多（</p><p>随机快拍的期望复杂度证明：</p><p>设 $T(n)$ 为规模 $n$ 的随机快排的期望复杂度。</p><p>有 $T(n)&#x3D;(\sum_{k&#x3D;0}^{n-1}T(k)+T(n-k-1)+\Theta(n))&#x2F;n$</p><p>即 $T(n)&#x3D;\frac{2}{n}\sum T(k)+\Theta(n)$</p><p>此时再用数学归纳法，可以假设 $T(k)\le cklogk$</p><p>$\sum_2^{n-1} klogk$ 放缩后得到 $\le \frac{1}{2}n^2logn-\frac{1}{8}n^2$ </p><p>即可得到 $T(n)\le cnlogn$</p><p>快排的效率通常是归并的两倍左右，且即便在有缓存的情况下依然有优势。</p><p>基于比较的排序最优复杂度是 $nlogn$</p><p>计数排序，桶排序等非比较排序可以做到 $O(n)$，但都不是就地算法，且需要满足一些条件。</p><p><strong>计数排序：</strong>对所有数计数，计入 $cnt$ 数组，然后对这个 $cnt$ 数组求前缀和，此时 $cnt_i$ 表示大小为 $i$ 的数的最坏排名，再从原数组从尾到头扫一遍，每个数 $i$ 都取 $cnt_i$ 作为排名，随后将 $cnt_i$ 减一。</p><p>假设最大值为 $max$，则复杂度为 $\Theta (max+n)$</p><p><strong>基数排序：</strong>在 $max$ 比较大时，从低位到高位依次以当前位上的值为key进行一次计数排序。</p><p>如果直接按照 $b$ 进制来分位，复杂度为 $log_{b}max(n+b)$，显然如果按十进制来分，计数排序部分只需要用10大小的数组，是有点浪费的。</p><p>我们希望左边尽可能小，而右边也控制在线性，那么取 $b&#x3D;n$ 即为最优解。</p><p>若要取 $2^r$ 为一位，则 $r&#x3D;log_2n$</p><p><strong>桶排序：</strong>桶排序要求数据基本是均匀的，才能保证复杂度。</p><p>它先按最高位，将 $n$ 个数据放入 $n$ 个桶中，每个桶基本有差不多 $O(1)$ 个数据，故对桶内排序基本也是 $O(1)$ 的，然后再将各个桶连接起来。</p><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>哈希函数的选取，希望能将键均匀的映射到所有地址上。</p><p>且不希望<strong>取值的规律性导致映射规律性</strong></p><p>故一般取模值为质数，使得数和模数互质。（取模策略）</p><p>对于计算机中用 $w$ 位保存的数，还可以乘以一个奇数，让它超过 $2^w$ 自然溢出，取最后数 $w$ 位中的 $r$ 位作为哈希值。这相当于乘奇数，对 $2^w$ 取模，乘数与模数互质，它能遍历到所有可能的结果，且运算会比取模更快。</p><p>解决冲突：</p><ul><li><p>链表法</p><ul><li>装载因子（装载的比例 $n&#x2F;m$）为 $a$ 时，查找失败的期望次数为 $1+a$</li><li>查找成功的期望有相同的渐进边界，但严格边界比较难算。</li></ul></li><li><p>开放地址法</p><ul><li>连续编号，容易聚集，导致搜索效率下降</li><li>双哈希，好</li><li>装载因子为 $a$ 时，开放地址法查找的期望次数是 $1&#x2F;(1-a)$</li></ul></li></ul><h4 id="全域哈希"><a href="#全域哈希" class="headerlink" title="全域哈希"></a>全域哈希</h4><p>如果被别人知道了我们使用的哈希函数，对方就可以构造一组全部冲突的数据，很容易卡。</p><p>全域哈希即在程序运行之前，随机选取哈希函数，使得对于任何构造的数据，冲突的概率仍然是 $1&#x2F;m$（假设哈希表有 $m$ 个槽）</p><p>随机选取的哈希函数需要满足这样的条件：假设哈希函数库为 $H$，对于任意不相同的 $x，y$，$H$ 当中恰好存在 $H&#x2F;m$ 个函数使得它们冲突。</p><p>构造者不知道我们会随机到那一个函数，那么对于任意的数据，冲突的概率即 $(H&#x2F;m)&#x2F;H&#x3D;1&#x2F;m$</p><h5 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h5><p>将键值 $k$ 转化为 $m$ 进制数，假设转化后一共有 $r+1$ 位，表示为 $k&#x3D;&lt;k_0,k_1,…k_r&gt;$</p><p>对每一位取随机值 $a_i\in[0,m)$，哈希值 $h(k)&#x3D;\sum a_i\times k_i$，对 $a$ 的不同取值决定了不同的哈希函数，共有 $m^{r+1}$ 种。</p><h5 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h5><p>暂时跳过</p><h4 id="完全哈希"><a href="#完全哈希" class="headerlink" title="完全哈希"></a>完全哈希</h4><p>没看懂 先跳了</p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>随机构建：类似快速排序的方式，对整个序列进行partition到左右两部分。</p><p>随机构建的期望树高：是 $logn$ 的，比较直观证明略</p><p>红黑树：</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>随机构建：类似快拍方式，随机选取一个点作为中间，然后隔断到两边向下构建，复杂度同快排</p><p>随机构建的期望树高为 $log_2n$，证明太麻烦跳了（这个感觉完全可以感性理解…）</p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>性质：</p><ul><li>根节点是黑的，叶子节点（NIL节点）是黑色</li><li>没有连续的红节点</li><li>根节点到任意叶子节点（NIL）节点的路径上黑色节点数相同</li></ul><p>为什么要有NIL节点？它和插入有关，详见下文。</p><p>红黑树本质是2-3-4树（一种逻辑结构）的一种实现，有一个红儿子的黑节点为实际的3节点，有两个红儿子即为4节点。</p><p>可以把红节点都向上压一层，和它的黑父节点放在一排，就能看出红黑树其实是一个2-3-4树，黑色节点数平衡其实是在2-3-4树上的节点平衡。当然满足了黑色节点平衡，总节点不平衡也不会夸张到哪里去了。</p><p>$n$ 个节点的红黑树树高有 $h\le2log_2(n+1)$，如果压成2-3-4树，则 $h’\ge h&#x2F;2$</p><p>插入：</p><p>首先将新数据视为红色节点按普通二叉搜索树方式插入，这样不会违反性质3。</p><p>但倘若我们在一个红色节点的一边插入，另一边已经有个黑色节点，那么插入后还是会违反性质3的。</p><p>所以有NIL节点的存在，它要求红色点哪怕只有一个儿子，另一边算上NIL，也要纳入性质3的考量。事实上，这样要求后红节点已经不可能出现只有一个儿子的情况了，插入便能保存性质。</p><p>插入后具体的旋转和改色不再赘述。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆（普通二叉堆）的插入平均复杂度是 $O(1)$ 的（基于概率的期望是 $O(1)$，最坏还是可以卡到 $log$），取数是 $log$，构建和合并都是 $O(n)$，手写堆维护一下下标即可任意修改。</p><p>二项队列：做到了 $O(logn)$ 的堆合并，平均插入也是 $O(1)$，算法很妙，此处不赘述</p><p>斐波那契堆：实现比较复杂，常数也大，但是有 $O(1)$ 的插入</p><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>握手定理：无向图度数和等于边数x2</p><p>最小生成树中也包含最优子结构（任取一部分点，子图的MST包含在总图的MST中）</p><p>Prime：</p><p>朴素复杂度 $V^2$</p><p>使用手写二叉堆，一个节点最多修改 $Ei$ 次（最短距离最多被更新 $E_i$ 次），故复杂度为 $ElogV$</p><p>若使用优先队列，无法直接修改，必须都插入，则队中最多 $O(E)$ 个元素，复杂度 $ElogE$</p><p>斐波那契堆下为 $E+VlogV$</p><p>Kruskal：$ElogE+ (V+E) \alpha(V)$，$\alpha$ 为并查集复杂度</p><p>最短路中也包含最优子结构（最短路径的一部分也是最短路径）</p><p>Dijkstra：复杂度和各种优化复杂度都和Prime同理</p><p>Bellman-Ford：复杂度 $O(VE)$，扩展 $n-1$ 轮后若还有可松弛的边，则有负环。</p><h5 id="全源最短路："><a href="#全源最短路：" class="headerlink" title="全源最短路："></a>全源最短路：</h5><p>非最优的dp做法：</p><p>将松弛理解为矩阵相乘，相乘的定义改为两两相加取 $min$，相乘的两个矩阵分别表示当前 $i$ 到 $j$ 的最短距离，和 $i$ 连 $j$ 的边长，将二者相乘一次即做一次扩展，乘 $n-1$ 次即可得到全源最短路。</p><p>复杂度 $n^4$，运用矩阵快速幂（在这个相乘意义下仍有结合律）可以有 $n^3logn$</p><p>floyd：也是动态规划，$f_{k,i,j}$ 表示仅经过前 $k$ 个节点，从 $i$ 到达 $j$ 的最短路径，先枚举松弛中点，复杂度 $n^3$</p><p>Johnson：见acm笔记</p><blockquote><p>Floyd的多源最短路 $O(n^3)$，很容易想到，如果进行 $n$ 次Dijkstra也不过 $O(nmlogm)$，但是不能处理负权边</p><p>有没有什么办法修改一下边权强行跑dij呢？</p><ul><li>如果我们给每个节点随便加一个点权 $h_i$，把连接 $u→v$ 的边权改为 $w+h_u-h_v$</li><li>那么原图中任意一条路径 $s→x_1→x_2→..x_n→t$ 长度为 $w_{s,x1}+w_{x1,x2}+..w_{x_n,t}$</li><li>而在新图中，这条路的长度为 $w_{s,x1}+w_{x1,x2}+..w_{x_n,t}+h_s-h_t$</li><li>可以发现 $s,t$ 间的任一一条路径长度都仅仅只是加上了始末节点的 $h$ 值差，与路径无关（有没有想到势能）</li><li>所以在这个新图中找到的最短路也是老图中的最短路，值减去 $h_s-h_t$ 即可</li></ul><p>上述我们说明了可以给节点加上任意权值，修改边权后不影响最短路</p><p>现在还需要修改后的边权都不为负，这样我们才能跑Dijkstra</p><p>也就是要求任意 $w+h_u-h_v \ge 0$，即 $h_v \le h_u +w$ （最短路！）</p><p>所以，$h$ 数组是任意源点出发的最短路即可</p><p>Johnson多源最短路的流程也就很明确了：</p><ul><li>随便找个点，跑一遍单源最短路，得到最短路数组 $h$</li><li>依据 $h$，修改所有边权</li><li>再对每个节点跑一遍Dijkstra，得到多源最短路</li></ul><p>为了方便判负环，第一步可以建一个0号节点，和所有点连长度为0的边，然后Bellman-Ford跑第一遍最短路顺便判负环。</p><p>预处理复杂度 $O(nm)$，，总复杂度 $O(nmlogm)$，在费用流中也有应用</p></blockquote><h3 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h3><p>割的概念：割是两个点集 $(A,B)$，其中源点在 $A$，汇点在 $B$</p><p>割的容量定义为：从 $A$ 到 $B$ 的所有边容量之和，最小割即选取 $(A,B)$ 使得割的容量最小。</p><p>重点理解：割是点集而非边集，虽然它对应了一个边集</p><p>在任何一个流 $f$ 下选取任何一个割 $(A,B)$，流的流量都等于割中 $A\to B$ 的流量减去 $B\to A$ 的流量，且$val(f)\le cap(A,B)$，因为要减去 $B\to A$ 的流量。</p><p>最大流等于最小割，同时若 $val(f)&#x3D;cap(A,B)$，则它们为最大流和最小割。</p><p>Ford-Fulkerson算法：即不断寻找增广路，扩展，直到没有增广路为止。</p><p>具体找增广路的方式有EK，Dinic等算法</p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>概念：贪心选择（局部最优选择达到全局最优）</p><p>两个要素：最优子结构（和dp一样），贪心选择性质（需要作出选择时，只选看起来最优的，并期望局部最优推出全局最优）</p><p>备忘录方法（自顶向下，即记搜），自底向上（一般dp，用的最多）</p><h5 id="活动选择问题："><a href="#活动选择问题：" class="headerlink" title="活动选择问题："></a>活动选择问题：</h5><p>即给出若干个活动的开始结束时间，只有一个场地可使用，求最多能进行几个活动。</p><p>首先按照结束时间排序</p><p>dp搞法：$f_{i,j}$ 表示在 $i$ 活动结束后，$j$ 活动开始前最多进行多少个活动</p><p>$f_{i,j}\leftarrow f_{i,k}+f_{k,j}+1$</p><p>贪心：选择第一个结束的活动，再不断往后选最早结束不冲突的活动</p><p>步骤：</p><ul><li><p>将优化问题转化为一个我们做出选择，只剩下一个子问题要解决的问题。</p></li><li><p>证明总是有一个最优解做出贪婪的选择，这样贪婪的选择总是安全的。</p></li><li><p>证明了子问题的贪婪选择和最优解能导出问题的最佳解决方案。</p></li><li><p>做出贪婪的选择，自上而下解决问题。</p></li><li><p>可能需要对输入进行预处理</p></li></ul><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>问题的解空间理论：</p><p>问题的解空间即我们在穷举时的搜索空间，<em>解空间需要包含所有正确的解，好的解空间应该尽可能减少错误解和重复解</em></p><p>问题的解的表示方式和解释隐含了解空间及其大小</p><p>解空间一般用解空间树的方式组织，根节点到叶子结点的路径构成了一个可能解。</p><p>剪枝即在没有完全得出当前解时，预先判断当前的解空间子树中是否包含最优解，若必不包含则可以直接回溯，不必再搜。</p><p>剪枝包括通过约束条件减去得不到正确解的子树，和通过目标函数减去得不到最优解的子树</p><p>解向量：即解的表示方法</p><p>一些经典的NPC问题：</p><ul><li><p>旅行商问题（TSP）</p></li><li><p>装箱问题（背包问题）</p><ul><li>此处有个重大误区，即<strong>标准</strong>时间复杂度的定义：</li><li>将<strong>数据规模</strong>严谨定义为保存数据需要的位数，如 32bit 的 $n$ 个元素的数组，数据规模为 $32n$</li><li>在这种定义下，大多传统算法不受影响，如冒泡排序可能变成 $32^2n^2$，不影响复杂度</li><li>但在数论场合，一个整数 $x$ 的实际大小是随着其二进制位数指数增长的，例如跑一半的质数判断，在传统复杂度下为 $O(n)$，标准复杂度下为 $O(2^n)$</li><li>这种在传统复杂度为多项式但在标准复杂度下非多项式的称为<strong>伪多项式时间</strong></li><li>背包问题 $O(nd)$，$d$ 为容量，是一个数，在标准复杂度意义下它已经是指数增长的了，故背包问题为NPC</li></ul></li><li><p>作业调度问题</p></li><li><p>最大团问题</p></li></ul><p>等等等等</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>2c9fa93e0b0d283c9d0f6b386b00eff25bcfb10e</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>重排原理：优先选取分支数少的特征来走，这样剪枝能剪得多一些</p><p>效率分析：要考虑计算约束条件和目标函数的代价，折中选取剪枝。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符编码</title>
    <link href="/2022/05/04/2022-05-04-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    <url>/2022/05/04/2022-05-04-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>不得不花时间重新理一遍，太乱了</p><p><strong>仅个人理解，未经求证，警惕</strong></p><h4 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h4><ul><li><p>在C++中直接用 “” 来包裹字符串，它相当于是什么编码？</p><ul><li>就是你这个cpp文件的编码，例如用GBK格式编写代码后运行，<code>&quot;strlen(&quot;中文&quot;)&quot;</code> 的值为4；在utf-8格式下编写运行 这个值就为6</li></ul></li><li><p>路径字符串用什么编码能正确打开文件？</p><ul><li>windows下是GBK，因为windows系统是GBK编码的，也就是说，所有的这些路径名，文件名在系统内部都是GBK格式的，要和它们匹配上就要用GBK编码的字符串。</li><li>举例：如果我的cpp是utf-8保存的，使用 <code>ifstream fin(&quot;中文.txt&quot;)</code> 就没法正确打开，因为这个”中文.txt”字符串是utf-8编码的，需要转成GBK。</li><li>系统编码无法更改（你当然不能把windows内部所有字符串都转换一遍），只能在涉及到路径字符串时留意，格外转换一遍。</li></ul></li><li><p>输出乱码了</p><ul><li>以最简单的为例：windows下小黑框输出。cout其实也啥都不管，只把字节一个个扔给控制台，控制台采用系统编码方式来<strong>翻译</strong>成字符，所以一般utf-8格式的cpp直接cout &lt;&lt; “中文”都会乱码，控制台有很多办法切换编码方式。</li></ul></li><li><p>读写文件</p><ul><li>它们什么都不管，只管把字节一个个读入或写出，那么你读的文件是什么编码，读到的字符串就是什么编码，写同理。</li></ul></li><li><p>关于复制粘贴</p><ul><li>我理解复制保存的是具体的字符而不是字节流，所以粘贴到哪里去都不会乱码</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Global Round 20 A-F,H</title>
    <link href="/2022/04/23/2022-04-23-Codeforces%20Global%20Round%2020%20A-F1,H/"/>
    <url>/2022/04/23/2022-04-23-Codeforces%20Global%20Round%2020%20A-F1,H/</url>
    
    <content type="html"><![CDATA[<p>连续一个月掉小分，这把终于上大分了 好耶！</p><h4 id="A-Log-Chopping"><a href="#A-Log-Chopping" class="headerlink" title="A. Log Chopping"></a>A. Log Chopping</h4><blockquote><p>题意：现在有 $n$ 个木棍，第 $i$ 根长度为 $a_i$，Alice和Bob两人轮流操作，可以选择一根木棍将其切成两半，且两半的长度都需要是&gt;1的整数。最后无法操作的人失败，问谁获胜。</p></blockquote><p>虚假博弈，显然能切的次数是固定的，最终会全变成长度为1的木棍，判断能切的奇偶性即可。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> x; cin &gt;&gt; x;        sum += x - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-string">&quot;errorgorn\n&quot;</span>;    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;maomao90\n&quot;</span>;&#125;</code></pre></div><h4 id="B-I-love-AAAB"><a href="#B-I-love-AAAB" class="headerlink" title="B. I love AAAB"></a>B. I love AAAB</h4><blockquote><p>题意：你有一个字符串（初始为空），操作：可以在其中任意位置插入一段形如”AA…AB”的字符串，A的数量至少为1。给定目标串b，问操作任意次，能否构造出串b。</p></blockquote><p>类似括号序，出现一个B时前面要至少找到一个A与其匹配，那么从左到右扫一遍，将A视为1，B视为-1，看有无前缀和小于0即可。注意特判：不存在B也是不行的。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    string s;    cin &gt;&gt; s;    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;A&#x27;</span>) sum++;        <span class="hljs-keyword">else</span> sum--;        <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>)&#123;            cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">back</span>() != <span class="hljs-string">&#x27;B&#x27;</span>)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;&#125;</code></pre></div><h4 id="C-Unequal-Array"><a href="#C-Unequal-Array" class="headerlink" title="C. Unequal Array"></a>C. Unequal Array</h4><blockquote><p>题意：给出一个序列 $a$，其质量定义为其中 $a_i&#x3D;a_{i+1}$ 的元素个数，现在你可以进行操作：选取两个相邻元素，将它们修改为任意的 $x$。问：最少多少次操作可以使得序列的”质量”小于等于1</p></blockquote><p>不难发现，执行这个操作只能改变本来满足的 $a_i&#x3D;a_{i+1}$ 的位置移动，而无法直接消除。那么我们找到原序列最早和最晚出现的相邻点，只有将这两对相邻点不断逼近后合为一对，才能满足条件。那么答案即为这两对相邻点之间的距离（注意边界和0）</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-type">int</span> mi = <span class="hljs-number">0</span>, mx = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-keyword">if</span>(a[i] == a[i+<span class="hljs-number">1</span>])&#123;            <span class="hljs-keyword">if</span>(!mi) mi = i;            mx = i;        &#125;    &#125;    <span class="hljs-keyword">if</span>(mx == mi) cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-built_in">max</span>(mx-mi<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="D-Cyclic-Rotation"><a href="#D-Cyclic-Rotation" class="headerlink" title="D. Cyclic Rotation"></a>D. Cyclic Rotation</h4><blockquote><p>题意：给出一个序列 $a$ 和它的重新排列 $b$，有一种操作：选取两个相同元素，将左边的移动到另一个右边。问能否对序列 $a$ 进行任意次操作，使其变为 $b$？</p></blockquote><p>模拟，我们从最末端开始考虑，$a$ 和 $b$ 的末尾元素必须相同，设他们末尾都为 $x$， $a$ 末尾连续的 $x$ 数量必须少于 $b$ 末尾连续 $x$ 的数量。这样才有可能从 $a$ 前面拿若干个 $x$ 到末尾来使得他们末尾。记录每种数被拿的次数。考虑完后，将他们末尾的 $x$ 都删掉，继续处理下一个末尾。</p><p>遇到 $a$ 和 $b$ 末尾不相同时，如果 $a$ 的末尾恰好”被拿过“，就可以忽略 $a$ 中这个末尾，记得让计数-1。如果没有被拿过，那么NO</p><p>还有一点：当 $a$ 的末尾连续 $x$ 长度大于 $b$ 末尾连续 $x$ 长度时，如果 $x$ 可以被拿走一些也是可行的，不用直接NO。</p><p>这样模拟能执行到最后就是YES</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn], b[maxn];<span class="hljs-type">int</span> rem[maxn], del[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) rem[i] = del[i] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i], rem[a[i]]++;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; b[i], tmp[b[i]]++;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">if</span>(tmp[i] != rem[i])&#123;        cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-type">int</span> r1 = n, j = n;    <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">while</span>(a[r1] != b[j])&#123;            <span class="hljs-keyword">if</span>(r1&gt;<span class="hljs-number">0</span> &amp;&amp; del[a[r1]]) del[a[r1]]--, r1--;            <span class="hljs-keyword">else</span>&#123;                cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;        &#125;        <span class="hljs-type">int</span> lena = <span class="hljs-number">1</span>, lenb = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=r1<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;            <span class="hljs-keyword">if</span>(a[i] != a[r1])&#123;                lena = r1 - i;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=j<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;            <span class="hljs-keyword">if</span>(b[i] != b[j])&#123;                lenb = j - i;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(lena &gt; lenb)&#123;            <span class="hljs-keyword">if</span>(lena - del[a[r1]] &gt; lenb)&#123;                cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;            del[a[r1]] -= lena - lenb;            r1 -= lena;            j -= lenb;        &#125;<span class="hljs-keyword">else</span>&#123;            del[a[r1]] += lenb - lena;            r1 -= lena;            j -= lenb;        &#125;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;&#125;</code></pre></div><h4 id="E-notepad-exe"><a href="#E-notepad-exe" class="headerlink" title="E. notepad.exe"></a>E. notepad.exe</h4><blockquote><p>题意：交互题，有一台打字机和若干个字符串，这些字符串是未知的，你可以指定最大打印宽度 $w$，打印机将按顺序打印这些字符串，两串之间需要一个空格，当行宽度不够即会换行，最终会返回你打印的行数 $h$。你需要用至多 $n+30$ 次询问，输出可能的最小打印面积（$w\times h$）</p></blockquote><p>首先容易想到的是，可以二分找到一行能打下所有字符串的最小宽度 $w_1$，此时最小打印面积为 <code>字符串总长+n-1个空格</code></p><p>然后去想，如果要打印两行使得答案更优，那么这个字符串必须差不多能正好分成等长的两半，这样就能贪一个空格。只需要尝试 $\lfloor w_1&#x2F;2\rfloor$ 的宽度即可，宽度更大则不可能更优，更小则不可能两行打印完。</p><p>同理，尝试三行，四行…尝试第 $i$ 行即询问宽度 $\lfloor w_1&#x2F;i\rfloor$，更新答案。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; x &lt;&lt; endl;    cout.<span class="hljs-built_in">flush</span>();    <span class="hljs-type">int</span> r; cin &gt;&gt; r;    <span class="hljs-keyword">return</span> r;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">4000000</span>;    <span class="hljs-keyword">while</span>(l &lt; r)&#123;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">query</span>(mid) == <span class="hljs-number">1</span>)&#123;            r = mid;        &#125;<span class="hljs-keyword">else</span>&#123;            l = mid+<span class="hljs-number">1</span>;        &#125;    &#125;    ll ans = l;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> h = <span class="hljs-built_in">query</span>(l / i);        <span class="hljs-keyword">if</span>(h == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;        ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-number">1ll</span> * h * (l / i));    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; ans &lt;&lt; endl;    cout.<span class="hljs-built_in">flush</span>();&#125;</code></pre></div><h4 id="F-Array-Shuffling-amp-Checker-for-Array-Shuffling"><a href="#F-Array-Shuffling-amp-Checker-for-Array-Shuffling" class="headerlink" title="F. Array Shuffling &amp; Checker for Array Shuffling"></a>F. Array Shuffling &amp; Checker for Array Shuffling</h4><blockquote><p>题意：给出一个序列 $a$，你需要将其打乱，使得其复原需要的最少交换次数尽可能多。</p><p>F1：构造一个打乱后的序列。</p><p>F2：给定打乱后的序列，判断其是否满足条件（写个spj）</p></blockquote><p>首先要将问题简化，注意到这题其实 $a$ 的顺序是不影响打乱方案的（写代码的时候要管，但逻辑上不影响结果），我们可以将 $a$ 中相同的元素都放在一起</p><p>再进一步，对于每一种元素，记录其出现的次数，将所有元素按照出现次数排序。每个元素都依次放到下一个元素的出现位置上（有空缺，先不管），最后一个元素去填补所有空缺。这样似乎能贪心地让序列尽可能乱。</p><p>严谨地考虑：假设我们有了打乱后的序列 $b$，现在将每个 $a_i$ 向 $b_i$ 连边，那么我们发现复原的过程其实是一个走环的过程（任何排列其实都构成若干个环，不过因为我们这里有重复元素，不是几个独立环的组合，但复原过程还是可以拆成走若干次环）</p><p>对于一个长度为 $l$ 的环，将其复原到位需要 $l-1$ 次，那么可以想到，环越少，复原需要的次数就越多。</p><p>假设出现次数最多的元素出现了 $x$ 次，那么显然环不可能少于 $x$ 个，上述构造方案恰恰可以令环数仅为 $x$（即除了出现最多的那个元素涉及的环之外，不存在其他环）</p><p>F2就是这个结论，将最多的那个元素删去后，拓扑判断是否存在环即可。</p><p>F1：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">sss</span>&#123;    vector&lt;<span class="hljs-type">int</span>&gt; pos;    <span class="hljs-type">int</span> val;&#125;s[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) s[i].pos.<span class="hljs-built_in">clear</span>(), s[i].val = i;    <span class="hljs-type">int</span> mxa = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; a[i];        s[a[i]].pos.<span class="hljs-built_in">push_back</span>(i);    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;    <span class="hljs-built_in">sort</span>(s+<span class="hljs-number">1</span>, s+n+<span class="hljs-number">1</span>, [](sss x, sss y)&#123;        <span class="hljs-keyword">return</span> x.pos.<span class="hljs-built_in">size</span>() &lt; y.pos.<span class="hljs-built_in">size</span>();    &#125;);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-keyword">if</span>(s[i].pos.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;s[i].pos.<span class="hljs-built_in">size</span>();j++)&#123;            ans[s[i+<span class="hljs-number">1</span>].pos[j]] = s[i].val;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">if</span>(!ans[i]) ans[i] = s[n].val;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;</code></pre></div><p>F2：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn], b[maxn];<span class="hljs-type">int</span> cnt[maxn];<span class="hljs-type">int</span> mxp;vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cnt[i] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        vp[i].<span class="hljs-built_in">clear</span>();        cin &gt;&gt; a[i];        cnt[a[i]]++;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; b[i];    mxp = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">if</span>(cnt[i] &gt; cnt[mxp]) mxp = i;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">du</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(a[i] == mxp || b[i] == mxp) <span class="hljs-keyword">continue</span>;        vp[a[i]].<span class="hljs-built_in">push_back</span>(b[i]);        du[b[i]]++;    &#125;    queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">if</span>(du[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;        <span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>();        q.<span class="hljs-built_in">pop</span>();        ans++;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;            du[v]--;            <span class="hljs-keyword">if</span>(du[v] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(v);        &#125;    &#125;    <span class="hljs-keyword">if</span>(ans == n) cout &lt;&lt; <span class="hljs-string">&quot;AC\n&quot;</span>;    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;WA\n&quot;</span>;&#125;</code></pre></div><h4 id="H-Zigu-Zagu"><a href="#H-Zigu-Zagu" class="headerlink" title="H. Zigu Zagu"></a>H. Zigu Zagu</h4><blockquote><p>题意：有一个01字符串，你可以操作：选择一段01交互出现的区间（不存在连续0或连续1），删去这个区间。有Q个询问，每次询问 $s[l..r]$ 这个子串需要最少几次操作使得其被删为空。</p></blockquote><p>贪心地考虑不难发现，一定删尽可能长的区间，我们可以首先把整串拆成几个可删的区间。</p><p>决策点在于：如果先删去中间的一个形如 <code>0...1</code> 或 <code>1...0</code>的区间，就能使两端区间合并，从而减少删的次数。</p><p>我们用一个区间的结尾来标记（指代）这个区间，区间的开头即为上一个区间的结尾（不然上一个区间应该扩展）</p><p>比如我用 <code>01101</code> 表示这样的一个整串：<code>..0 0..1 1..1 1..0 0..1</code></p><p> 即当我删去一个1时，如果前一位为0，这个0会自动和下一位合并，相当于一同被删去。也就是说，我们有删1，删0，删01，删10这四种操作</p><p>那么删除需要的次数即为0和1中较多的那个数！</p><p>最后考虑一下边界即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> sum[maxn][<span class="hljs-number">2</span>];string s;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;    s = <span class="hljs-string">&#x27; &#x27;</span> + s;    s += s.<span class="hljs-built_in">back</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        sum[i][<span class="hljs-number">0</span>] = sum[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];        sum[i][<span class="hljs-number">1</span>] = sum[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span>(s[i] == s[i+<span class="hljs-number">1</span>]) sum[i][s[i]-<span class="hljs-string">&#x27;0&#x27;</span>]++;    &#125;    <span class="hljs-keyword">while</span>(m--)&#123;        <span class="hljs-type">int</span> l, r;        cin &gt;&gt; l &gt;&gt; r;        cout &lt;&lt; <span class="hljs-built_in">max</span>(sum[r<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]-sum[l<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], sum[r<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]-sum[l<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]) + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 783 div.1 ABC (div2.CDE)</title>
    <link href="/2022/04/20/2022-04-20-Codeforces%20Round%20783%20div1%20ABC/"/>
    <url>/2022/04/20/2022-04-20-Codeforces%20Round%20783%20div1%20ABC/</url>
    
    <content type="html"><![CDATA[<h4 id="A-Make-it-Increasing"><a href="#A-Make-it-Increasing" class="headerlink" title="A. Make it Increasing"></a>A. Make it Increasing</h4><blockquote><p>题意：给出一个整数序列 $a$，现有另一个全为0的序列 $b$，每次操作可以选取一个位置，使得 $b_i$ 加上或减去 $a_i$，问最少多少次操作可以使得 $b$ 序列严格递增。数据范围 $n\le10^3$</p></blockquote><p>数据范围允许我们考虑 $n^2$，首先可以贪心地想到，肯定会有一个位置保持为0，那么就可以枚举这个0的位置，然后往两边贪心即可。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;ll a[maxn], b[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    ll ans = <span class="hljs-number">1e18</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        ll sum = <span class="hljs-number">0</span>;        b[i] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">1</span>;j--)&#123;            ll k = <span class="hljs-built_in">abs</span>(b[j+<span class="hljs-number">1</span>]) / a[j] + <span class="hljs-number">1</span>;            sum += k;            b[j] = -k * a[j];        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;            ll k = <span class="hljs-built_in">abs</span>(b[j<span class="hljs-number">-1</span>]) / a[j] + <span class="hljs-number">1</span>;            sum += k;            b[j] = k * a[j];        &#125;        ans = <span class="hljs-built_in">min</span>(ans, sum);    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="B-Optimal-Partition"><a href="#B-Optimal-Partition" class="headerlink" title="B. Optimal Partition"></a>B. Optimal Partition</h4><blockquote><p>题意：给出一个序列 $a$，可以将其分成若干个连续的子区间，每个子区间的贡献是：</p><ul><li>$r−l+1\quad if s&gt;0,$</li><li>$0\quad if s&#x3D;0,$</li><li>$−(r−l+1)\quad if s&lt;0.$</li></ul><p>求总贡献的最小值</p></blockquote><p>考虑 $dp$，$dp_i$ 表示前 $i$ 个数的答案，它可以从几个方面转移过来：</p><ul><li>最后一段划分的区间和为负，它不优于将所有数单独拆出来，$dp_i&#x3D;dp_{i-1}+val_i$</li><li>最后一段划分的区间和为0，其实仔细想一下会发现，肯定能把它拆成两半使得它更优：<ul><li>区间长度为偶数，划分为等长两段，一边大于0则另一边小于0，或者都等于0，显然不会更劣</li><li>区间长度为奇数，划分为左段（小一点）和右段，如果右段大于0则划分更优；如果右端小于0，则左段大于0，尝试将中间值挪到左段去，如果左段扔大于0则划分更优，否则左段小于0，则右端大于0，那么去掉中间值后，两边都大于0，显然还是更优的。</li><li>所以只需考虑单个数为0的情况，同样满足 $dp_i&#x3D;dp_{i-1}+val_i$</li></ul></li><li>最后一段划分的区间和为正，那么 $dp_i$ 可以从若干个前面的 $j$ 转移过来，满足 $val[j+1,i]\gt0$，有 $dp_i&#x3D;dp_j+i-j$<ul><li>可以通过前缀和快速计算 $val[j+1,i]$，我们用数据结构维护每个前缀和下的 $dp_j-j$ 的最大值，查询比当前前缀和小的所有前缀和下的 $dp_j-j$ 最大值即可转移</li><li>前缀和范围很大，可以提前预处理然后离散化</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn], f[maxn], rk[maxn];pair&lt;ll, <span class="hljs-type">int</span>&gt; sum[maxn];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">fwt</span>&#123;<span class="hljs-comment">//FenWick Tree</span>    <span class="hljs-type">int</span> t[maxn];    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> ad)</span></span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=p;i&lt;=n+<span class="hljs-number">1</span>;i+=i&amp;-i) t[i] = <span class="hljs-built_in">max</span>(t[i], ad);&#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mx</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;        <span class="hljs-type">int</span> r = <span class="hljs-number">-1e9</span>;        <span class="hljs-keyword">while</span>(p &gt; <span class="hljs-number">0</span>)&#123;            r = <span class="hljs-built_in">max</span>(r, t[p]);            p -= p &amp; -p;        &#125;        <span class="hljs-keyword">return</span> r;    &#125;&#125;bt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;i++) bt.t[i] = <span class="hljs-number">-1e9</span>;    sum[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; a[i];        sum[i] = &#123;sum[i<span class="hljs-number">-1</span>].first+a[i], i&#125;;    &#125;    <span class="hljs-built_in">sort</span>(sum, sum+n+<span class="hljs-number">1</span>);    <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || sum[i].first != sum[i<span class="hljs-number">-1</span>].first) ++tot;        rk[sum[i].second] = tot;    &#125;    bt.<span class="hljs-built_in">add</span>(rk[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        f[i] = f[i<span class="hljs-number">-1</span>] + (a[i] &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : a[i] &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);        f[i] = <span class="hljs-built_in">max</span>(f[i], bt.<span class="hljs-built_in">mx</span>(rk[i]<span class="hljs-number">-1</span>) + i);        bt.<span class="hljs-built_in">add</span>(rk[i], f[i] - i);    &#125;    cout &lt;&lt; f[n] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="C-Half-Queen-Cover"><a href="#C-Half-Queen-Cover" class="headerlink" title="C. Half Queen Cover"></a>C. Half Queen Cover</h4><blockquote><p>题意：有一个 $n\times n$ 的棋盘，棋子“半皇后”可以控制其同一排，同一列，同一左上-右下对角线上的所有格子，问最少多少个半皇后可以控制整个棋盘。</p></blockquote><p>构造题，单纯看结论会感到莫名其妙，不知思路从哪来</p><p>提供一种思考过程：想让棋子数量少，就需要尽可能减少棋子控制范围的重复，理想情况下应该有：每行仅有一个棋子，每列仅有一个棋子，每对角线也仅有一个棋子。即除了不可避免的交叉之外不重复。</p><p>接下来考虑这种理想情况能否实现，大概会摸出这样的图：</p><p><img src="/img/bed/other/1.png"></p><p>这里一共使用了5个棋子，发现中间区域还没能填满，那么就继续扩张，假设左上放置 $x$ 个棋子，右下放置 $y$ 个棋子，那么中间部分能占据的完整矩形范围为 $max(x,y)$， 即 $x+y+max(x,y)\ge n$，此时为最优解。</p><p>我们当然要让 $x,y$ 之间差不超过1…</p><div class="code-wrapper"><pre><code class="hljs C++"></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022浙江省赛总结</title>
    <link href="/2022/04/16/2022-04-16-2022%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9B/"/>
    <url>/2022/04/16/2022-04-16-2022%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>好耶！</p><p><img src="http://lxtyin.ac.cn/img/other/gold.png"></p><p>进大学第一把济南后 空间发了块铁锭，于是呼应一下</p><hr><p>开局队友把三个签到题（ABC）都1A了，只有我写L先看假题愣了一会，又数组开小wa一发，然后忘记sort又wa一发，3A（或成为本场最高罚时）</p><p>这时榜上中间区域一片空白，于是开始找题做，先读D再读了E，跑过苦痛之路的我一眼读懂了E的题意，然而不会</p><p>然后队友喂了M题意，感觉是个恶心的模拟，但仔细一想发现其实只需要统计黑色块个数和白色块个数（中心的），然后列个方程解一下就可以了</p><p>G题第一眼是dp，仔细看了一下发现是个纯纯的最短路，但根本不记得朴素dij的存在，只知道 $mlogm$，感觉 $10^6log10^6$ + double运算 + 1s时限有点顶，但是莽了一发就过了，赛后发现朴素dij可以非常稳的 $n^2$，感觉是运气好数据造水了，这题应该能卡我们的。</p><p>然后两个人开始折磨I题，想了很多思路奇怪的思路，最后整合了一下发现偶数必败，那么只需要判一下初始为奇数时是否为回文串就可以了，多组询问，马拉车或者哈希预处理一下即可</p><p>最后是我和yfy啃F主席树磨细节，hty单挑J，轮流上机调&#x2F;不会了打印&#x2F;下机想，这个过程中我们采用了一个正确的策略：写伪代码。在纸上理清思路，上机的时候直接对着纸上写的抄，基本不卡，机时利用率很高。先后过掉这两个题，因为都卡了挺久，在纸上也造了一波数据，调出后都是1发A，最后9题收尾 rk6</p><p>剩下十分钟时间在快乐的乱搞E题苦痛之路的随机化写法，当然没写过</p><hr><p>去年省赛铜尾，差点没铜，被高中学弟暴打，今年有块金了，虽然只是省赛（而且zju放水），但看到了进步，还是很爽的</p><p>这场感受到了做题策略的重要性，如果还是之前那样，等一题a出来再写下一题，这场可能只有8题甚至7题。一来一个人占着机子一直调，未必比下来冷静一下想清楚再写快；二来避免了魔怔现象（前几场比赛我们都出现了一道题交十几发的现象，很大程度上是因为没有留充足的思考时间，写好了就交。如果是在纸上写伪代码的话，等队友写的过程中就很可能发现小bug，大大减小出错概率）</p><p>总结：团队acm竞赛当中想做到 1+1+1&#x3D;4 是基本不可能的，因为你们只有一台机器，事实上能做到1+1+1&#x3D;2 就已经相当不错，关键在于对机时的利用，一定要会写伪代码，等队友的时候把边界什么的想清楚，上机不浪费时间。然后写卡住了的时候迅速让出机位给队友写，同时自己下机去理清楚，争取下次上机一步到位。</p><p>然后在独立思考和讨论之间要做取舍，唯一的原则就是怎么清楚怎么来，大量讨论而少独立深思的话可能造成1+1+1&#x3D;0.5 的效果</p>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>省赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树剖/dsu on tree/线段树合并【雨天的尾巴】</title>
    <link href="/2022/04/13/2022-04-13-%E9%9B%A8%E5%A4%A9%E7%9A%84%E5%B0%BE%E5%B7%B4/"/>
    <url>/2022/04/13/2022-04-13-%E9%9B%A8%E5%A4%A9%E7%9A%84%E5%B0%BE%E5%B7%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="Vani有约会-雨天的尾巴"><a href="#Vani有约会-雨天的尾巴" class="headerlink" title="[Vani有约会]雨天的尾巴"></a>[Vani有约会]雨天的尾巴</h3><p><a href="https://www.luogu.com.cn/problem/P4556">题目链接</a></p><p>一道好板子 甚至能当三个板子（</p><h5 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h5><div class="code-wrapper"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; add[maxn], del[maxn];vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];<span class="hljs-type">int</span> dep[maxn], siz[maxn], son[maxn];<span class="hljs-type">int</span> fat[maxn], top[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> dp)</span></span>&#123;    fat[p] = fa;    dep[p] = dp;    son[p] = <span class="hljs-number">0</span>;    siz[p] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">dfs1</span>(v, p, dp+<span class="hljs-number">1</span>);        siz[p] += siz[v];        <span class="hljs-keyword">if</span>(siz[v] &gt; siz[son[p]]) son[p] = v;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> _top)</span></span>&#123;    top[p] = _top;    <span class="hljs-keyword">if</span>(son[p]) <span class="hljs-built_in">dfs2</span>(son[p], p, _top);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v != fa &amp;&amp; v != son[p])&#123;            <span class="hljs-built_in">dfs2</span>(v, p, v);        &#125;    &#125;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">segTree</span>&#123;    <span class="hljs-type">int</span> mx[maxn &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;        mx[p] = <span class="hljs-built_in">max</span>(mx[p*<span class="hljs-number">2</span>], mx[p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> d)</span></span>&#123;        <span class="hljs-keyword">if</span>(l == r)&#123;            mx[p] += d;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(pos &lt;= mid) <span class="hljs-built_in">modify</span>(p*<span class="hljs-number">2</span>, l, mid, pos, d);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r, pos, d);        <span class="hljs-built_in">pushUp</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;        <span class="hljs-keyword">if</span>(mx[p] &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> l;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(mx[p*<span class="hljs-number">2</span>] &gt;= mx[p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(p*<span class="hljs-number">2</span>, l, mid);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r);    &#125;&#125;st;<span class="hljs-type">int</span> n, q;<span class="hljs-type">int</span> ans[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calcu</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w: add[p]) st.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>, w, <span class="hljs-number">1</span>);    ans[p] = st.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w: del[p]) st.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>, w, <span class="hljs-number">-1</span>);    <span class="hljs-keyword">if</span>(son[p]) <span class="hljs-built_in">calcu</span>(son[p], p);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v != fa &amp;&amp; v != son[p]) <span class="hljs-built_in">calcu</span>(v, p);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        vp[x].<span class="hljs-built_in">emplace_back</span>(y);        vp[y].<span class="hljs-built_in">emplace_back</span>(x);    &#125;    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;        <span class="hljs-type">int</span> x, y, w;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;        <span class="hljs-keyword">while</span>(top[x] != top[y])&#123;            <span class="hljs-keyword">if</span>(dep[top[x]] &gt; dep[top[y]])&#123;                add[top[x]].<span class="hljs-built_in">emplace_back</span>(w);                del[x].<span class="hljs-built_in">emplace_back</span>(w);                x = fat[top[x]];            &#125;<span class="hljs-keyword">else</span>&#123;                add[top[y]].<span class="hljs-built_in">emplace_back</span>(w);                del[y].<span class="hljs-built_in">emplace_back</span>(w);                y = fat[top[y]];            &#125;        &#125;        <span class="hljs-keyword">if</span>(dep[x] &gt; dep[y]) <span class="hljs-built_in">swap</span>(x, y);        add[x].<span class="hljs-built_in">emplace_back</span>(w);        del[y].<span class="hljs-built_in">emplace_back</span>(w);    &#125;    <span class="hljs-built_in">calcu</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h5 id="dsu-on-tree"><a href="#dsu-on-tree" class="headerlink" title="dsu on tree"></a>dsu on tree</h5><div class="code-wrapper"><pre><code class="hljs c++">vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; tag[maxn];vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];<span class="hljs-type">int</span> f[maxn][<span class="hljs-number">23</span>], dep[maxn], siz[maxn], mxson[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span></span>&#123;    f[p][<span class="hljs-number">0</span>] = fa;    dep[p] = dep[fa] + <span class="hljs-number">1</span>;    mxson[p] = <span class="hljs-number">0</span>;    siz[p] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">dfs</span>(v, p);        siz[p] += siz[v];        <span class="hljs-keyword">if</span>(siz[v] &gt; siz[mxson[p]]) mxson[p] = v;    &#125;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">segTree</span>&#123;    <span class="hljs-type">int</span> mx[maxn &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;        mx[p] = <span class="hljs-built_in">max</span>(mx[p*<span class="hljs-number">2</span>], mx[p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> d)</span></span>&#123;        <span class="hljs-keyword">if</span>(l == r)&#123;            mx[p] += d;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(pos &lt;= mid) <span class="hljs-built_in">modify</span>(p*<span class="hljs-number">2</span>, l, mid, pos, d);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r, pos, d);        <span class="hljs-built_in">pushUp</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;        <span class="hljs-keyword">if</span>(mx[p] &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> l;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(mx[p*<span class="hljs-number">2</span>] &gt;= mx[p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(p*<span class="hljs-number">2</span>, l, mid);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r);    &#125;&#125;st;<span class="hljs-type">int</span> n, q;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calcu</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> d)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> pi: tag[p])&#123;        st.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>, pi.first, pi.second * d);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v != fa)&#123;            <span class="hljs-built_in">calcu</span>(v, p, d);        &#125;    &#125;&#125;<span class="hljs-type">int</span> ans[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> save)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v != fa &amp;&amp; v != mxson[p])&#123;            <span class="hljs-built_in">work</span>(v, p, <span class="hljs-number">0</span>);        &#125;    &#125;    <span class="hljs-keyword">if</span>(mxson[p]) <span class="hljs-built_in">work</span>(mxson[p], p, <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v != fa &amp;&amp; v != mxson[p])&#123;            <span class="hljs-built_in">calcu</span>(v, p, <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> pi: tag[p])&#123;        st.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>, pi.first, pi.second);    &#125;    ans[p] = st.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>);    <span class="hljs-keyword">if</span>(!save) <span class="hljs-built_in">calcu</span>(p, fa, <span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        vp[x].<span class="hljs-built_in">emplace_back</span>(y);        vp[y].<span class="hljs-built_in">emplace_back</span>(x);    &#125;    dep[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">20</span>;k++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;            f[i][k] = f[f[i][k<span class="hljs-number">-1</span>]][k<span class="hljs-number">-1</span>];        &#125;    &#125;    <span class="hljs-keyword">auto</span> lca = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)&#123;        <span class="hljs-keyword">if</span>(dep[x] &lt; dep[y]) <span class="hljs-built_in">swap</span>(x, y);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">20</span>;k&gt;=<span class="hljs-number">0</span>;k--)&#123;            <span class="hljs-keyword">if</span>(dep[f[x][k]] &gt;= dep[y]) x = f[x][k];        &#125;        <span class="hljs-keyword">if</span>(x == y) <span class="hljs-keyword">return</span> x;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">20</span>;k&gt;=<span class="hljs-number">0</span>;k--)&#123;            <span class="hljs-keyword">if</span>(f[x][k] != f[y][k])&#123;                x = f[x][k], y = f[y][k];            &#125;        &#125;        <span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];    &#125;;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;        <span class="hljs-type">int</span> x, y, w;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;        <span class="hljs-type">int</span> l = <span class="hljs-built_in">lca</span>(x, y);        tag[x].<span class="hljs-built_in">emplace_back</span>(w, <span class="hljs-number">1</span>);        tag[y].<span class="hljs-built_in">emplace_back</span>(w, <span class="hljs-number">1</span>);        tag[l].<span class="hljs-built_in">emplace_back</span>(w, <span class="hljs-number">-1</span>);        tag[f[l][<span class="hljs-number">0</span>]].<span class="hljs-built_in">emplace_back</span>(w, <span class="hljs-number">-1</span>);    &#125;    <span class="hljs-built_in">work</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;&#125;</code></pre></div><h5 id="线段树合并"><a href="#线段树合并" class="headerlink" title="线段树合并"></a>线段树合并</h5><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegTree</span>&#123;    <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> mx[maxn &lt;&lt; <span class="hljs-number">5</span>], ls[maxn &lt;&lt; <span class="hljs-number">5</span>], rs[maxn &lt;&lt; <span class="hljs-number">5</span>], mxp[maxn &lt;&lt; <span class="hljs-number">5</span>];    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;        mx[<span class="hljs-number">0</span>] = <span class="hljs-number">-1e9</span>;<span class="hljs-comment">//注意可能pushup不存在的节点</span>        <span class="hljs-keyword">if</span>(mx[ls[p]] &gt;= mx[rs[p]])&#123;            mx[p] = mx[ls[p]];            mxp[p] = mxp[ls[p]];        &#125;<span class="hljs-keyword">else</span>&#123;            mx[p] = mx[rs[p]];            mxp[p] = mxp[rs[p]];        &#125;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> d)</span></span>&#123;        <span class="hljs-keyword">if</span>(!p) p = ++tot;        <span class="hljs-keyword">if</span>(l == r)&#123;            mx[p] += d;            mxp[p] = l;            <span class="hljs-keyword">return</span> p;        &#125;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(pos &lt;= mid) ls[p] = <span class="hljs-built_in">modify</span>(ls[p], l, mid, pos, d);        <span class="hljs-keyword">else</span> rs[p] = <span class="hljs-built_in">modify</span>(rs[p], mid+<span class="hljs-number">1</span>, r, pos, d);        <span class="hljs-built_in">push_up</span>(p);        <span class="hljs-keyword">return</span> p;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<span class="hljs-comment">//返回合并后的节点，替代式合并，合并后a这棵线段树就没用了</span>        <span class="hljs-keyword">if</span>(!x) <span class="hljs-keyword">return</span> y;        <span class="hljs-keyword">if</span>(!y) <span class="hljs-keyword">return</span> x;<span class="hljs-comment">//都没有同样return 0</span>        <span class="hljs-keyword">if</span>(l == r)&#123;            mx[x] += mx[y];            mxp[x] = l;            <span class="hljs-keyword">return</span> x;        &#125;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        ls[x] = <span class="hljs-built_in">merge</span>(ls[x], ls[y], l, mid);        rs[x] = <span class="hljs-built_in">merge</span>(rs[x], rs[y], mid+<span class="hljs-number">1</span>, r);        <span class="hljs-built_in">push_up</span>(x);        <span class="hljs-keyword">return</span> x;    &#125;&#125;st;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; tag[maxn];vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];<span class="hljs-type">int</span> f[maxn][<span class="hljs-number">23</span>], dep[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span></span>&#123;    f[p][<span class="hljs-number">0</span>] = fa;    dep[p] = dep[fa] + <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;        <span class="hljs-built_in">dfs</span>(v, p);    &#125;&#125;<span class="hljs-type">int</span> ans[maxn];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span></span>&#123;    <span class="hljs-type">int</span> rt = ++st.tot;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> pi: tag[p]) st.<span class="hljs-built_in">modify</span>(rt, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>, pi.first, pi.second);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;        rt = st.<span class="hljs-built_in">merge</span>(rt, <span class="hljs-built_in">dfs2</span>(v, p), <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>);    &#125;    <span class="hljs-keyword">if</span>(st.mx[rt] == <span class="hljs-number">0</span>) ans[p] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">else</span> ans[p] = st.mxp[rt];    <span class="hljs-keyword">return</span> rt;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n, q;    cin &gt;&gt; n &gt;&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        vp[x].<span class="hljs-built_in">emplace_back</span>(y);        vp[y].<span class="hljs-built_in">emplace_back</span>(x);    &#125;    dep[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">20</span>;k++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;            f[i][k] = f[f[i][k<span class="hljs-number">-1</span>]][k<span class="hljs-number">-1</span>];        &#125;    &#125;    <span class="hljs-keyword">auto</span> lca = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)&#123;        <span class="hljs-keyword">if</span>(dep[x] &lt; dep[y]) <span class="hljs-built_in">swap</span>(x, y);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">20</span>;k&gt;=<span class="hljs-number">0</span>;k--)&#123;            <span class="hljs-keyword">if</span>(dep[f[x][k]] &gt;= dep[y]) x = f[x][k];        &#125;        <span class="hljs-keyword">if</span>(x == y) <span class="hljs-keyword">return</span> x;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">20</span>;k&gt;=<span class="hljs-number">0</span>;k--)&#123;            <span class="hljs-keyword">if</span>(f[x][k] != f[y][k])&#123;                x = f[x][k], y = f[y][k];            &#125;        &#125;        <span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];    &#125;;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;        <span class="hljs-type">int</span> x, y, w;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;        <span class="hljs-type">int</span> l = <span class="hljs-built_in">lca</span>(x, y);        tag[x].<span class="hljs-built_in">emplace_back</span>(w, <span class="hljs-number">1</span>);        tag[y].<span class="hljs-built_in">emplace_back</span>(w, <span class="hljs-number">1</span>);        tag[l].<span class="hljs-built_in">emplace_back</span>(w, <span class="hljs-number">-1</span>);        tag[f[l][<span class="hljs-number">0</span>]].<span class="hljs-built_in">emplace_back</span>(w, <span class="hljs-number">-1</span>);    &#125;    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板子</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Atcoder Beginner 246 EFG</title>
    <link href="/2022/04/11/2022-04-11-Atcoder%20ABC%20247%20EFG/"/>
    <url>/2022/04/11/2022-04-11-Atcoder%20ABC%20247%20EFG/</url>
    
    <content type="html"><![CDATA[<h4 id="E-Max-Min"><a href="#E-Max-Min" class="headerlink" title="E - Max Min"></a>E - Max Min</h4><blockquote><p>题意：给出一个序列，问有多少个子区间满足 $max&#x3D;X$ 且 $min&#x3D;Y$ </p></blockquote><p>我的解法（下面还有另一种神仙解法：</p><p>枚举区间的左端点，然后二分区间的右端点，二分两次，分别找<strong>第一个使得区间max&gt;X或min&lt;Y**的右端点，和**第一个使得区间max&gt;&#x3D;X且min&lt;&#x3D;Y</strong>的右端点。简单来说就是找第一个达到要求的位置和第一个超出要求范围的位置。这两个位置相减即可得到合法右端点的数量。</p><p>求区间max和min自然是用st表</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, X, Y;<span class="hljs-type">int</span> mx[maxn][<span class="hljs-number">32</span>], mi[maxn][<span class="hljs-number">32</span>];<span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;    <span class="hljs-keyword">if</span>(r &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1e9</span>, <span class="hljs-number">-1e9</span>);    <span class="hljs-type">int</span> k = <span class="hljs-built_in">log</span>(r - l + <span class="hljs-number">1</span>) / <span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-built_in">max</span>(mx[l][k], mx[r-(<span class="hljs-number">1</span>&lt;&lt;k)+<span class="hljs-number">1</span>][k]), <span class="hljs-built_in">min</span>(mi[l][k], mi[r-(<span class="hljs-number">1</span>&lt;&lt;k)+<span class="hljs-number">1</span>][k]));&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; X &gt;&gt; Y;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; mx[i][<span class="hljs-number">0</span>];        mi[i][<span class="hljs-number">0</span>] = mx[i][<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">20</span>;k++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+(<span class="hljs-number">1</span>&lt;&lt;k)<span class="hljs-number">-1</span>&lt;=n;i++)&#123;            mi[i][k] = <span class="hljs-built_in">min</span>(mi[i][k<span class="hljs-number">-1</span>], mi[i+(<span class="hljs-number">1</span>&lt;&lt;(k<span class="hljs-number">-1</span>))][k<span class="hljs-number">-1</span>]);            mx[i][k] = <span class="hljs-built_in">max</span>(mx[i][k<span class="hljs-number">-1</span>], mx[i+(<span class="hljs-number">1</span>&lt;&lt;(k<span class="hljs-number">-1</span>))][k<span class="hljs-number">-1</span>]);        &#125;    &#125;    ll ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> l = i, r = n + <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(mi[i][<span class="hljs-number">0</span>] &gt; X || mi[i][<span class="hljs-number">0</span>] &lt; Y) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">while</span>(l &lt; r)&#123;            <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">get</span>(i, mid);            <span class="hljs-keyword">if</span>(p.first &gt; X || p.second &lt; Y)&#123;                r = mid;            &#125;<span class="hljs-keyword">else</span>&#123;                l = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-type">int</span> rp = l;        l = i, r = n + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(l &lt; r)&#123;            <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">get</span>(i, mid);            <span class="hljs-keyword">if</span>(p.first &gt;= X &amp;&amp; p.second &lt;= Y)&#123;                r = mid;            &#125;<span class="hljs-keyword">else</span>&#123;                l = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-type">int</span> lp = l;        ans += <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, rp - lp);    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><p>神仙解法：</p><p>我们可以很轻易的计算出 $max\le X$ 且 $min\ge Y$ 的区间个数，找到所有值在 $[X,Y]$ 范围内的数，把他们连成的区间计算一下就好，假设这样的区间个数为 $g(X,Y)$</p><p>容斥一下，答案即：$g(X,Y)-g(X-1,Y)-g(X,Y-1)+g(X-1,Y-1)$</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, a[maxn];<span class="hljs-function">ll <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;    ll cnt = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(y &lt;= a[i] &amp;&amp; a[i] &lt;= x)&#123;            cnt++;        &#125;<span class="hljs-keyword">else</span>&#123;            ans += (cnt * (cnt + <span class="hljs-number">1</span>)) / <span class="hljs-number">2</span>;            cnt = <span class="hljs-number">0</span>;        &#125;    &#125;    ans += (cnt * (cnt + <span class="hljs-number">1</span>)) / <span class="hljs-number">2</span>;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> x, y;    cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    cout &lt;&lt; <span class="hljs-built_in">g</span>(x, y) - <span class="hljs-built_in">g</span>(x<span class="hljs-number">-1</span>, y) - <span class="hljs-built_in">g</span>(x, y+<span class="hljs-number">1</span>) + <span class="hljs-built_in">g</span>(x<span class="hljs-number">-1</span>, y+<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="F-Cards"><a href="#F-Cards" class="headerlink" title="F - Cards"></a>F - Cards</h4><blockquote><p>题意：有 $n$ 张卡片，每张卡片正面和背面各有一个数字，保证其中数字 $1..n$ 各出现两次，问现在有多少种取卡片的方案，使得取到的卡片包含每一种数字。</p></blockquote><p>如果两个数字出现在同一张卡片上，我们就将它们连边，这样构造出来的图每个点的度数都为2，那就意味着这个图可以被分为若干个互不干涉的简单环。</p><p>那么问题就变成了：一个包含 $x$ 个节点的环中，每条边可以选或不选，有多少中选法使得相邻两边至少有一条选中。</p><p>考虑一下递推这个问题：假设已经有 $x-1$ 条边的环了，考虑在1,2号边之间插入新的边（哪里都一样），如果1,2都选，则这条新边可选可不选，否则新必边须选。除此之外，还需要加上1,2都不选（不包括在 $x-1$ 的情况内），新边选的情况。</p><p>限制1,2都选或都不选的情况数，就等于 $x-2$ 条边的环的情况数（1,2条可以看做同一条边）</p><p>那么就有：$f_x&#x3D;f_{x-1}+f_{x-2}$，容易递推</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, a[maxn], b[maxn];<span class="hljs-type">int</span> t[maxn], vis[maxn];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;    <span class="hljs-keyword">if</span>(vis[p]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    vis[p] = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(t[p]) + <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; b[i];        t[a[i]] = b[i];    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;    f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    f[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++) f[i] = (f[i<span class="hljs-number">-1</span>] + f[i<span class="hljs-number">-2</span>]) % mode;    ll ans = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(!vis[i])&#123;            <span class="hljs-type">int</span> cnt = <span class="hljs-built_in">dfs</span>(i);            ans = ans * f[cnt] % mode;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="G-Dream-Team"><a href="#G-Dream-Team" class="headerlink" title="G - Dream Team"></a>G - Dream Team</h4><blockquote><p>题意：有 $n$ 个人，每个人有所在城市 $A_i$，所选学科 $B_i$，能力 $C_i$，现要从中挑选 $k$ 个人组成梦之队，要求所有选择的人城市各部相同，学科各不相同。问对于每一个可能的 $k$，梦之队的能力总和最大值是多少。</p><ul><li>$1≤N≤3×10^4$</li><li>$1 \leq A_i,B_i \leq 150$</li><li>$1 \leq C_i \leq 10^9$</li></ul></blockquote><p><code>一眼150，鉴定为暴力</code></p><p>考虑费用流，从起点向每个 $A$ 容量为1的边，从每个 $B$ 向终点连容量为1的边，限制了每个城市和学科都只能选一次，然后对于每个人，将 $A_i$ 和 $B_i$ 之间连一条费用为 $C_i$ ，容量为1的边。然后跑费用流就可以了。</p><p>因为网络流是逐路径增广的，边流量又都为1，那么每次增广就相当于增加了一个人数，记录每次增广后的最小费用即可。</p><p>可以将费用改为 $-C_i$，计算最小费用流后取反即可。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//板子</span><span class="hljs-keyword">namespace</span> Flow&#123;    <span class="hljs-type">int</span> n, st, ed;    ll dis[maxn], h[maxn], pre[maxn];<span class="hljs-comment">//记录最短路中连向它的边号</span>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;        <span class="hljs-type">int</span> fr, to, nt;        ll w, c;        <span class="hljs-function">ll <span class="hljs-title">dis</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123;<span class="hljs-comment">//获取修正后的边权</span>            <span class="hljs-keyword">return</span> c + h[fr] - h[to];        &#125;    &#125;e[maxn &lt;&lt; <span class="hljs-number">1</span>];    <span class="hljs-type">int</span> head[maxn], ecnt = <span class="hljs-number">1</span>;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> cnt)</span></span>&#123;        n = cnt, st = s, ed = t;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) head[i] = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, ll w, ll c)</span></span>&#123;        e[++ecnt] = &#123;x, y, head[x], w, c&#125;;        head[x] = ecnt;        e[++ecnt] = &#123;y, x, head[y], <span class="hljs-number">0</span>, -c&#125;;        head[y] = ecnt;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;        queue&lt;<span class="hljs-type">int</span>&gt; q; q.<span class="hljs-built_in">push</span>(st);        h[st] = <span class="hljs-number">0</span>; vis[st] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;            <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();            vis[u] = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].nt)&#123;                <span class="hljs-type">int</span> v = e[i].to;                <span class="hljs-keyword">if</span>(e[i].w &gt; <span class="hljs-number">0</span> &amp;&amp; h[v] &gt; h[u] + e[i].c)&#123;                    h[v] = h[u] + e[i].c;                    <span class="hljs-keyword">if</span>(!vis[v]) vis[v] = <span class="hljs-literal">true</span>, q.<span class="hljs-built_in">push</span>(v);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dij</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;            ll t, dis;            <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &gt;(<span class="hljs-type">const</span> node &amp;x)<span class="hljs-type">const</span>&#123;                <span class="hljs-keyword">return</span> dis &gt; x.dis;            &#125;        &#125;;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) dis[i] = INF;        dis[st] = <span class="hljs-number">0</span>;        priority_queue&lt;node, vector&lt;node&gt;, greater&lt;&gt; &gt; q;        q.<span class="hljs-built_in">push</span>(&#123;st, <span class="hljs-number">0</span>&#125;);        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;            node u = q.<span class="hljs-built_in">top</span>();            q.<span class="hljs-built_in">pop</span>();            <span class="hljs-keyword">if</span>(u.dis &gt; dis[u.t]) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u.t];i;i=e[i].nt)&#123;                <span class="hljs-type">int</span> v = e[i].to;                <span class="hljs-keyword">if</span>(e[i].w &gt; <span class="hljs-number">0</span> &amp;&amp; dis[v] &gt; dis[u.t] + e[i].<span class="hljs-built_in">dis</span>())&#123;                    dis[v] = dis[u.t] + e[i].<span class="hljs-built_in">dis</span>();                    pre[v] = i;                    q.<span class="hljs-built_in">push</span>(&#123;v, dis[v]&#125;);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dis[ed] &lt; INF;    &#125;    vector&lt;ll&gt; ans;    <span class="hljs-function">pair&lt;ll, ll&gt; <span class="hljs-title">calcu</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-built_in">spfa</span>();        ll answ = <span class="hljs-number">0</span>, ansc = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">dij</span>())&#123;            ll minf = INF;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=ed;i!=st;i=e[pre[i]].fr) minf = <span class="hljs-built_in">min</span>(minf, e[pre[i]].w);            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=ed;i!=st;i=e[pre[i]].fr)&#123;                e[pre[i]].w -= minf;                e[pre[i] ^ <span class="hljs-number">1</span>].w += minf;                ansc += e[pre[i]].c * minf;            &#125;            answ += minf;            ans.<span class="hljs-built_in">push_back</span>(-ansc);            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) h[i] += dis[i];        &#125;        <span class="hljs-keyword">return</span> &#123;answ, ansc&#125;;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;        cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;        <span class="hljs-keyword">for</span>(ll x: ans) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    Flow::<span class="hljs-built_in">init</span>(<span class="hljs-number">301</span>, <span class="hljs-number">302</span>, <span class="hljs-number">302</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">151</span>;i&lt;=<span class="hljs-number">300</span>;i++) Flow::<span class="hljs-built_in">add</span>(i, <span class="hljs-number">302</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">150</span>;i++) Flow::<span class="hljs-built_in">add</span>(<span class="hljs-number">301</span>, i, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        Flow::<span class="hljs-built_in">add</span>(a, <span class="hljs-number">150</span>+b, <span class="hljs-number">1</span>, -c);    &#125;    Flow::<span class="hljs-built_in">calcu</span>();    Flow::<span class="hljs-built_in">print</span>();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>Atcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 126 A-F</title>
    <link href="/2022/04/10/2022-04-10-Educational%20Codeforces%20Round%20126/"/>
    <url>/2022/04/10/2022-04-10-Educational%20Codeforces%20Round%20126/</url>
    
    <content type="html"><![CDATA[<h4 id="A-Array-Balancing"><a href="#A-Array-Balancing" class="headerlink" title="A. Array Balancing"></a>A. Array Balancing</h4><blockquote><p>题意：给出序列 $a$ 和 $b$，可以任意交换相同位置的 $a_i,b_i$ ，求 $\sum|a_i-a_{i-1}|+|b_i-b_{i-1}|$ 的最小值</p></blockquote><p>显然，把小的放一边，大的放另一边一定最优。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn], b[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; b[i];        <span class="hljs-keyword">if</span>(b[i] &gt; a[i]) <span class="hljs-built_in">swap</span>(b[i], a[i]);    &#125;    ll ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) &#123;        ans += <span class="hljs-built_in">abs</span>(a[i] - a[i+<span class="hljs-number">1</span>]);        ans += <span class="hljs-built_in">abs</span>(b[i] - b[i+<span class="hljs-number">1</span>]);    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="B-Getting-Zero"><a href="#B-Getting-Zero" class="headerlink" title="B. Getting Zero"></a>B. Getting Zero</h4><blockquote><p>题意：给出一个数字，你可以对其进行下面的操作：</p><ul><li>$x&#x3D;x\times2 \mod 32768$</li><li>$x&#x3D;x+1\mod 32768$</li></ul><p>求最少多少次操作可以使 $x$ 变成0</p></blockquote><p>第一个操作相当于二进制下右移一位并舍弃最高位，加法就是末尾+1，我们希望把所有1都舍弃掉，那么要么通过加1进位的方式消1，要么直接右移消1。不论如何，一定是先做加法再做乘法更优。</p><p>$32768&#x3D;2^{15}$，所以15次内一定能够完成，那么只要暴力枚举做加法的次数即可。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calcu</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    x %= <span class="hljs-number">32768</span>;    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x != <span class="hljs-number">0</span>)&#123;        x = x * <span class="hljs-number">2</span> % <span class="hljs-number">32768</span>;        a++;    &#125;    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> x; cin &gt;&gt; x;        <span class="hljs-type">int</span> r = <span class="hljs-built_in">calcu</span>(x);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=r;k++)&#123;            r = <span class="hljs-built_in">min</span>(r, <span class="hljs-built_in">calcu</span>(x+k)+k);        &#125;        cout &lt;&lt; r &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[<span class="hljs-number">1</span> == n];    &#125;&#125;</code></pre></div><h4 id="C-Water-the-Trees"><a href="#C-Water-the-Trees" class="headerlink" title="C. Water the Trees"></a>C. Water the Trees</h4><blockquote><p>题意：现在有 $n$ 棵树，每棵树有一个初始高度，接下来若干天，每天可以选择一棵树浇水使其增长 $x$，如果是奇数天则 $x&#x3D;1$，偶数天 $x&#x3D;2$。也可以不浇水。求最少多少天可以使得所有树一样高。</p></blockquote><p>万恶的模拟题</p><p>首先，要么使所有树都涨 $max$，要么都涨到 $max+1$，涨到 $max+2$ 及以上一定不如前两种，分别计算一下</p><p>假设一共进行了 $k$ 次偶数浇水，那么进行 $sum-2\times k$ 次奇数浇水，则最大的天数是 $max(2\times k,2\times(sum-2\times k)-1)$</p><p>画出这两个函数，交点差不多是 $(2\times sum+1)&#x2F;6$，那么取 $k$ 为这个值左右小范围内暴力计算即可。</p><p>注意还需要额外计算一下最多可以浇偶数水的次数，$k$ 不能超过这个值。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn], b[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i], mx = <span class="hljs-built_in">max</span>(mx, a[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        b[i] = mx - a[i] + <span class="hljs-number">1</span>;        a[i] = mx - a[i];    &#125;    ll mxk = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        mxk += a[i] / <span class="hljs-number">2</span>;        sum += a[i];    &#125;    ll ans = <span class="hljs-number">1e18</span>;    ll j = sum - <span class="hljs-number">2</span> * mxk;    ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">max</span>(<span class="hljs-number">2</span>*mxk, <span class="hljs-number">2</span>*j<span class="hljs-number">-1</span>));    <span class="hljs-keyword">for</span>(ll k = <span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>, sum/<span class="hljs-number">3</span><span class="hljs-number">-30</span>); k&lt;=<span class="hljs-built_in">min</span>(mxk, sum/<span class="hljs-number">3</span>+<span class="hljs-number">30</span>); k++)&#123;        j = sum - <span class="hljs-number">2</span> * k;        ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">max</span>(<span class="hljs-number">2</span>*k, <span class="hljs-number">2</span>*j<span class="hljs-number">-1</span>));    &#125;    mxk = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        mxk += b[i] / <span class="hljs-number">2</span>;        sum += b[i];    &#125;    j = sum - <span class="hljs-number">2</span> * mxk;    ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">max</span>(<span class="hljs-number">2</span>*mxk, <span class="hljs-number">2</span>*j<span class="hljs-number">-1</span>));    <span class="hljs-keyword">for</span>(ll k = <span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>, sum/<span class="hljs-number">3</span><span class="hljs-number">-30</span>); k&lt;=<span class="hljs-built_in">min</span>(mxk, sum/<span class="hljs-number">3</span>+<span class="hljs-number">30</span>); k++)&#123;        j = sum - <span class="hljs-number">2</span> * k;        ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">max</span>(<span class="hljs-number">2</span>*k, <span class="hljs-number">2</span>*j<span class="hljs-number">-1</span>));    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="D-Progressions-Covering"><a href="#D-Progressions-Covering" class="headerlink" title="D. Progressions Covering"></a>D. Progressions Covering</h4><blockquote><p>题意：现有个序列 $a$，你需要在另一个空序列上进行如下操作：</p><ul><li>选择一段长度为 $m$ 的 $[l,r]$，使得它们从 $l$ 到 $r$ 分别加上1,2,3…m</li><li>注意 $[l,r]$ 不能超出边界</li></ul><p>问最少多少次操作可以使得你的序列每一个位置都大于 $a$ 序列</p></blockquote><p>首先可以想到两个端点上要操作的次数是确定的</p><p>如果正着考虑，会比较难判，比如下面这种：</p><div class="code-wrapper"><pre><code class="hljs c++">m = <span class="hljs-number">3</span>a = <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span></code></pre></div><p>处理6的时候，可以让左端点处于0这个位置（尽管这里不需要再增加），让6获得最大的增长速度，这种策略让正着做变得非常复杂。</p><p>所以倒着做就行了（</p><p>具体而言，我们可以维护一个二阶差分数组，在那上面做单点修改，思路应该不难，可能写起来有点细节，具体看代码。</p><p>注意跑到边界的时候要特判</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;ll a[maxn], dd[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n/<span class="hljs-number">2</span>;i++) <span class="hljs-built_in">swap</span>(a[i], a[n-i+<span class="hljs-number">1</span>]);    ll s = <span class="hljs-number">0</span>, d = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>, mxd = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        d += dd[i];        s += d;        ll k = <span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>, (a[i] - s + m - <span class="hljs-number">1</span>) / m);        <span class="hljs-keyword">if</span>(i+m &gt; n+<span class="hljs-number">1</span>)&#123;            mxd = <span class="hljs-built_in">max</span>((a[i] - s + n - i) / (n - i + <span class="hljs-number">1</span>), mxd);            <span class="hljs-keyword">continue</span>;        &#125;        ans += k;        dd[i+<span class="hljs-number">1</span>] -= (m + <span class="hljs-number">1</span>) * k;        dd[i+m+<span class="hljs-number">1</span>] += k;        d += m * k;        s += m * k;    &#125;    cout &lt;&lt; ans + mxd &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="E-Narrow-Components"><a href="#E-Narrow-Components" class="headerlink" title="E. Narrow Components"></a>E. Narrow Components</h4><blockquote><p>题意：给出一个三行，$n$ 列的矩阵，其中0表示不可走的地块，1表示可以走的地块，接下来有若干个询问，每次问 $[l,r]$ 列组成的子矩阵中有多少个联通块。</p></blockquote><p>考虑前缀和，求 $[l,r]$ 上的联通块个数首先拿 $sum_r-sum_{l-1}$，然后处理边界，左右两边<strong>每有一对不同的联通块相连</strong>，就将答案加上1</p><p>边界左边的点所属的联通块可以在搞前缀和的时候顺便处理出来，边界右边的点，只有 <code>101</code> 的情况需要多考虑，可以先预处理出每一个 <code>101</code> 的列往右走，到哪一列能够合并起来（或者无法合并），解决查询的时候如果它们合并的点在查询区间之内，则属于同一联通块，否则属于两个联通块。</p><p>预处理这个情况可以用并查集，每个 <code>101</code> 的列指向它右边一列，<code>111</code> 的列指向自身，其他列指向n+1。这一列的祖先即为其第一次合并的位置。</p><p>写起来也比较麻烦（最近的题怎么全都带点模拟），看代码吧..</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;string s[<span class="hljs-number">3</span>];<span class="hljs-type">int</span> f[maxn], st[<span class="hljs-number">3</span>][maxn];<span class="hljs-type">int</span> nxt[maxn];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    <span class="hljs-keyword">if</span>(nxt[x] == x) <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> nxt[x] = <span class="hljs-built_in">find</span>(nxt[x]);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    cin &gt;&gt; s[<span class="hljs-number">0</span>] &gt;&gt; s[<span class="hljs-number">1</span>] &gt;&gt; s[<span class="hljs-number">2</span>];    <span class="hljs-type">int</span> tag = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;        <span class="hljs-keyword">if</span>(s[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;            f[<span class="hljs-number">0</span>]++, st[i][<span class="hljs-number">0</span>] = ++tag;            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span> &amp;&amp; st[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]) st[i][<span class="hljs-number">0</span>] = st[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], f[<span class="hljs-number">0</span>]--;        &#125;    &#125;    nxt[n+<span class="hljs-number">1</span>] = n+<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; s[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;        <span class="hljs-keyword">if</span>(s[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) nxt[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">else</span> nxt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    &#125;<span class="hljs-keyword">else</span> nxt[<span class="hljs-number">0</span>] = n+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        f[i] = f[i<span class="hljs-number">-1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">3</span>;k++)&#123;            <span class="hljs-keyword">if</span>(s[k][i] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;                <span class="hljs-keyword">if</span>(s[k][i<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) st[k][i] = st[k][i<span class="hljs-number">-1</span>];                <span class="hljs-keyword">else</span>&#123;                    st[k][i] = ++tag;                    f[i]++;                &#125;            &#125;        &#125;        set&lt;<span class="hljs-type">int</span>&gt; cnt, caf;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">3</span>;k++)&#123;            <span class="hljs-keyword">if</span>(st[k][i])&#123;                cnt.<span class="hljs-built_in">insert</span>(st[k][i]);                <span class="hljs-keyword">if</span>(k != <span class="hljs-number">0</span> &amp;&amp; st[k<span class="hljs-number">-1</span>][i]) st[k][i] = st[k<span class="hljs-number">-1</span>][i];                caf.<span class="hljs-built_in">insert</span>(st[k][i]);            &#125;        &#125;        f[i] -= cnt.<span class="hljs-built_in">size</span>() - caf.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>][i] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; s[<span class="hljs-number">2</span>][i] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;            <span class="hljs-keyword">if</span>(s[<span class="hljs-number">1</span>][i] == <span class="hljs-string">&#x27;1&#x27;</span>) nxt[i] = i;            <span class="hljs-keyword">else</span> nxt[i] = i+<span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span> nxt[i] = n+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-type">int</span> Q;    cin &gt;&gt; Q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=Q;i++)&#123;        <span class="hljs-type">int</span> l, r;        cin &gt;&gt; l &gt;&gt; r;        l--, r--;        <span class="hljs-keyword">if</span>(l == <span class="hljs-number">0</span>)&#123;            cout &lt;&lt; f[r] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-type">int</span> ans = f[r] - f[l<span class="hljs-number">-1</span>];        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tg</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">3</span>;k++)&#123;            <span class="hljs-keyword">if</span>(s[k][l] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;                tg[k] = k+<span class="hljs-number">1</span>;                <span class="hljs-keyword">if</span>(k !=<span class="hljs-number">0</span> &amp;&amp; tg[k<span class="hljs-number">-1</span>]) tg[k] = tg[k<span class="hljs-number">-1</span>];            &#125;        &#125;        <span class="hljs-keyword">if</span>(tg[<span class="hljs-number">0</span>] &amp;&amp; tg[<span class="hljs-number">2</span>] &amp;&amp; <span class="hljs-built_in">find</span>(l) &lt;= r) tg[<span class="hljs-number">2</span>] = tg[<span class="hljs-number">0</span>];        set&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; cnt;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">3</span>;k++) <span class="hljs-keyword">if</span>(st[k][l<span class="hljs-number">-1</span>] &amp;&amp; tg[k])            cnt.<span class="hljs-built_in">insert</span>(&#123;st[k][l<span class="hljs-number">-1</span>], tg[k]&#125;);        ans += cnt.<span class="hljs-built_in">size</span>();        cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div><h4 id="F-Teleporters"><a href="#F-Teleporters" class="headerlink" title="F. Teleporters"></a>F. Teleporters</h4><blockquote><p>题意：人在坐标轴0点处，x轴上有若干个点 $a_1…a_n$，接下来每次可以走向一个点，消耗能量为 $len^2$，我希望用至多 $m$ 能量走到 $a_n$ ，问至少需要额外添加几个点。</p></blockquote><p>题目相当于给出若干个差值 $d_i$，每次可以选择将一个差值拆开成两份，最少多少刀可以使得 $\sum d^2$ 小于 $m$</p><p>首先需要注意的是：每一刀都将最大值切一半并不是最优的，如果选择对一个 $d$ 切两刀，那么三等分是最优的。</p><p>设 $cos(d,k)$ 为将 $d$ 切成 $k$ 份的最小花费，那么如果要对这个 $d$ 多切一刀，收益应该是 $cos(d,k)-cos(d,k+1)$</p><p>唯一的策略是每次都选取收益最大的一刀去切，题目范围不允许我们暴力枚举每一刀，所以考虑二分。</p><p>二分刀数不好做，我们依然不知道每一刀切在哪。</p><p>观察注意到切每一刀的收益是递减的，那么可以考虑二分切的最小收益，假设最小收益为 $k$，那么所有收益大于等于 $k$ 的刀都要切。</p><p>那么继续对每一个西瓜再次二分，对其切第 $m$ 刀的收益为 $cos(d,m-1)-cod(d,m)$，可以容易二分出每个西瓜切的次数，计算出切的总刀数和总花费。</p><p>这样我们就能得出切的最小收益（假设为 $k$），此时总花费为 $sum$，注意在这种意义下，所有收益大于等于 $k$ 的刀都要切，其中可能有若干收益恰好为 $k$ 的刀，默认是全切的。</p><p>这样二分只能得出：收益 $\ge k$ 的刀全切能满足条件，且仅切收益 $\gt k$ 的无法满足条件，收益恰为 $k$ 的刀切几次，还需另外判断。</p><p>全切时总花费为 $sum$，少切一刀增加 $k$ 的花费，那么可以少切 $(m-sum)&#x2F;k$ 刀。</p><div class="code-wrapper"><pre><code class="hljs c++">ll n, m;ll a[maxn];<span class="hljs-function">ll <span class="hljs-title">cos</span><span class="hljs-params">(ll d, ll k)</span></span>&#123;    ll t = d / k;    ll md = d % k;    <span class="hljs-keyword">return</span> md * (t + <span class="hljs-number">1</span>) * (t + <span class="hljs-number">1</span>) + (k - md) * t * t;&#125;ll cnt;<span class="hljs-function">ll <span class="hljs-title">calcu</span><span class="hljs-params">(ll mi)</span></span>&#123;<span class="hljs-comment">//最小收益 只有收益&gt;=mi的刀才切</span>    ll res = <span class="hljs-number">0</span>;    cnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        ll l = <span class="hljs-number">1</span>, r = a[i];        <span class="hljs-keyword">while</span>(l &lt; r)&#123;            ll mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cos</span>(a[i], mid<span class="hljs-number">-1</span>) - <span class="hljs-built_in">cos</span>(a[i], mid) &gt;= mi)&#123;                l = mid;            &#125;<span class="hljs-keyword">else</span>&#123;                r = mid - <span class="hljs-number">1</span>;            &#125;        &#125;        cnt += l - <span class="hljs-number">1</span>;        res += <span class="hljs-built_in">cos</span>(a[i], l);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--) a[i] = a[i] - a[i<span class="hljs-number">-1</span>];    cin &gt;&gt; m;    ll l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e18</span>;    <span class="hljs-keyword">while</span>(l &lt; r)&#123;        ll mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">calcu</span>(mid) &lt;= m)&#123;            l = mid;        &#125;<span class="hljs-keyword">else</span>&#123;            r = mid - <span class="hljs-number">1</span>;        &#125;    &#125;    ll res = m - <span class="hljs-built_in">calcu</span>(l);    cout &lt;&lt; cnt - res / l &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 781 div.2 CDE</title>
    <link href="/2022/04/09/2022-04-09-Codeforces%20Round%20781%20div.2%20CDE/"/>
    <url>/2022/04/09/2022-04-09-Codeforces%20Round%20781%20div.2%20CDE/</url>
    
    <content type="html"><![CDATA[<h4 id="C-Tree-Infection"><a href="#C-Tree-Infection" class="headerlink" title="C. Tree Infection"></a>C. Tree Infection</h4><p>题意：给定一棵树，一开始所有节点都是未传染的状态，接下来每一秒，可以手动传染一个新节点，同时已经被传染的节点会传染它的一个兄弟节点。问最短多少秒能够传染所有节点。</p><p>首先容易发现，这个树并没有什么用，我们可以把连同一个父节点的点分成一组，组与组之间是无关的。</p><p>看起来是个简单题了，$n$ 秒内一定能传染完，那么模拟即可。然而这个模拟还是有点恶心的，不要想 $O(n)$ 解法了，搞个优先队列暴力搞，每次选取剩余最大的一组感染就行了。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> du[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) du[i] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> x;        cin &gt;&gt; x;        du[x]++;    &#125;    du[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-built_in">sort</span>(du, du+n+<span class="hljs-number">1</span>, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;() );    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(!du[i]) <span class="hljs-keyword">break</span>;        k++;    &#125;    priority_queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(!du[i]) <span class="hljs-keyword">break</span>;        <span class="hljs-type">int</span> r = du[i] - (k - i);        <span class="hljs-keyword">if</span>(r &gt; <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(r);    &#125;    <span class="hljs-type">int</span> ad = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;        <span class="hljs-type">int</span> p = q.<span class="hljs-built_in">top</span>();        q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">if</span>(p &lt;= ad) <span class="hljs-keyword">break</span>;        p--;        ad++;        q.<span class="hljs-built_in">push</span>(p);    &#125;    cout &lt;&lt; k + ad &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="D-GCD-Guess"><a href="#D-GCD-Guess" class="headerlink" title="D. GCD Guess"></a>D. GCD Guess</h4><p>题意：交互题，需要去猜一个数字 $x$，每次交互可以输入两个不同的正整数 $a,b$，会得到 $gcd(x+a,x+b)$ 的结果，需要在30次内猜出。</p><p>30次这个数字告诉我们，不是二分就是二进制…</p><p>解：按位考虑，假设我们已经知道 $x$ 的前 $i$ 位的值了（假设为 $pre_i$），现在猜第 $i+1$ 位的情况，我们可以先让前面 $i$ 位全部清零（在加 $a,b$ 时处理掉前面的影响），然后取 $a,b$ 分别为 $2^{i}$ 和 $2^i+2^{i+1}$，这样如果 $x$ 第 $i$ 位为1，得到的结果即为 $2^{i+1}$</p><p>举例：</p><div class="code-wrapper"><pre><code class="hljs markdown">.....?0000<span class="hljs-bullet">+</span>    10000<span class="hljs-bullet">+</span>   110000如果?为1，则gcd结果必为：<span class="hljs-code">100000</span><span class="hljs-code">否则结果必为：</span><span class="hljs-code"> 10000</span></code></pre></div><p>构造方法应该不止这一种。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1000003</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;    cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl;    cout.<span class="hljs-built_in">flush</span>();    <span class="hljs-type">int</span> r; cin &gt;&gt; r;<span class="hljs-comment">//int r = __gcd(1000000000+x, 1000000000+y);</span>    <span class="hljs-comment">//交互题可以这样测试</span>    <span class="hljs-keyword">return</span> r;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, xf = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">30</span>;i++)&#123;        <span class="hljs-type">int</span> s = <span class="hljs-built_in">query</span>(xf + <span class="hljs-number">1</span>, xf + <span class="hljs-number">1</span> + (<span class="hljs-number">1</span>&lt;&lt;i));        <span class="hljs-keyword">if</span>(s == (<span class="hljs-number">1</span>&lt;&lt;i))&#123;            x |= (<span class="hljs-number">1</span> &lt;&lt; (i<span class="hljs-number">-1</span>));        &#125;<span class="hljs-keyword">else</span>&#123;            xf |= (<span class="hljs-number">1</span> &lt;&lt; (i<span class="hljs-number">-1</span>));        &#125;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="E-MinimizOR"><a href="#E-MinimizOR" class="headerlink" title="E. MinimizOR"></a>E. MinimizOR</h4><p>题意：给出一个数列，若干次询问，每次询问 $[l,r]$ 之间，两两或结果的最小值是多少。</p><p>结论：对于任意一个区间来说，只需要考虑最小的31个数两两或的结果即可（数字小于 $2^{30}$）。</p><p>思路：要算一个区间的两两或最小值，肯定是从高位到低位贪心地去考虑，高位能取0就取0，一定最优。</p><p>考虑当前最高位上1和0的个数：</p><ul><li>全是1：这个高位对后续抉择没有影响，这一位必定是1</li><li>至少2个0：之后必定在这些高位为0的数字中选择，也就是选取较小的那一部分</li><li>有一个0：这个高位必定是1，继续考虑下一位。但需注意：下次遇到情况二时，高位为0的部分就不一定是最小值了，假设已经出现了 $k$ 次情况3，那么可能出现 $k$ 个比高位为0的还小的数。</li><li>显然，这个 $k$ 至多为30，那么其实最终或最小的两个值一定出在前31小值内。</li></ul><p>写一写感受一下，可选范围是不断缩小的，每枚举一位，下边界最多会移动1，那么最终结果就在前31小内。</p><p>结论证明完了，处理这个就很暴力了：线段树维护区间前31小值，每次询问的时候计算31*31种结果，复杂度两个log，能过。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, a[maxn];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegTree</span>&#123;    vector&lt;<span class="hljs-type">int</span>&gt; mi[maxn &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;res, vector&lt;<span class="hljs-type">int</span>&gt; x, vector&lt;<span class="hljs-type">int</span>&gt; y)</span></span>&#123;        res.<span class="hljs-built_in">clear</span>();        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(l &lt; x.<span class="hljs-built_in">size</span>() &amp;&amp; r &lt; y.<span class="hljs-built_in">size</span>() &amp;&amp; res.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">31</span>)&#123;            <span class="hljs-keyword">if</span>(x[l] &lt; y[r]) res.<span class="hljs-built_in">push_back</span>(x[l++]);            <span class="hljs-keyword">else</span> res.<span class="hljs-built_in">push_back</span>(y[r++]);        &#125;        <span class="hljs-keyword">while</span>(l &lt; x.<span class="hljs-built_in">size</span>() &amp;&amp; res.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">31</span>) res.<span class="hljs-built_in">push_back</span>(x[l++]);        <span class="hljs-keyword">while</span>(r &lt; y.<span class="hljs-built_in">size</span>() &amp;&amp; res.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">31</span>) res.<span class="hljs-built_in">push_back</span>(y[r++]);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;        <span class="hljs-keyword">if</span>(l == r)&#123;            mi[p].<span class="hljs-built_in">clear</span>();            mi[p].<span class="hljs-built_in">push_back</span>(a[l]);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-built_in">build</span>(p*<span class="hljs-number">2</span>, l, mid);        <span class="hljs-built_in">build</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r);        <span class="hljs-built_in">merge</span>(mi[p], mi[p*<span class="hljs-number">2</span>], mi[p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span></span>&#123;        <span class="hljs-keyword">if</span>(l &gt; R || L &gt; r) <span class="hljs-keyword">return</span> &#123;&#125;;        <span class="hljs-keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> mi[p];        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        vector&lt;<span class="hljs-type">int</span>&gt; res;        <span class="hljs-built_in">merge</span>(res, <span class="hljs-built_in">query</span>(p*<span class="hljs-number">2</span>, l, mid, L, R), <span class="hljs-built_in">query</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r, L, R));        <span class="hljs-keyword">return</span> res;    &#125;&#125;st;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    st.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);    <span class="hljs-type">int</span> Q;    cin &gt;&gt; Q;    <span class="hljs-keyword">while</span>(Q--)&#123;        <span class="hljs-type">int</span> l, r;        cin &gt;&gt; l &gt;&gt; r;        <span class="hljs-keyword">auto</span> res = st.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r);        <span class="hljs-type">int</span> ans = <span class="hljs-number">2e9</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;res.<span class="hljs-built_in">size</span>();i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;res.<span class="hljs-built_in">size</span>();j++)&#123;                ans = <span class="hljs-built_in">min</span>(ans, res[i] | res[j]);            &#125;        &#125;        cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div><p>解法二：</p><p>更加直观一些，建立可持久化字典树，复杂度同样也是两个log</p><p>查询的时候，也是根据左右儿子的数量：如果0有多个，无脑走0；如果0恰好有1个，那么就走1，同时把这个0号节点记录下来。至多记录31个，最后把这31个节点重新拿过来暴力一下即可。</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Atcoder Beginner 246 FG EX</title>
    <link href="/2022/04/07/2022-04-07-Atcoder%20ABC%20246%20FG%20EX%20-%20%E5%89%AF%E6%9C%AC/"/>
    <url>/2022/04/07/2022-04-07-Atcoder%20ABC%20246%20FG%20EX%20-%20%E5%89%AF%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h4 id="F-typewriter"><a href="#F-typewriter" class="headerlink" title="F - typewriter"></a>F - typewriter</h4><p>题意：给出 $n$ 个字符串和一个长度 $L$，接下来你可以任选一个字符串，并且只用这个串内有的字符来打字（不限制字符顺序，数量），问可以打出多少中长度为 $L$ 的字符串。数据范围 $N&lt;18$，$L&lt;10^9$</p><p><strong>第一种想法</strong>（没a）：可以暴力枚举所选的字符集，一共 $2^{26}$ 种情况，先预处理出每一种字符在哪些给定的串中出现（bitmask），把所选的字符集的出现位置与一下，如果与的结果不为0说明这一字符集是可选的，就加上使用这个字符集的答案。为了避免重复，还要求这个字符集内的每一个字符都必须用到。假设字符集有 $k$ 个，那么答案就是将 $L$ 个位置分配给 $k$ 个字符，每个字符必须分配到至少一个位置。</p><p>本以为这个应该是一个公式解决，但查了一下发现是第二类斯特林数，递推也要 $O(L)$，目前我没法记录这个值。</p><p><strong>第二种做法</strong>：暴力容斥，枚举选取了哪些串，计算使用同时被这些串所拥有的字符集的答案，如果选择了奇数个串答案就加上，否则答案就减去。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll x, ll p)</span></span>&#123;    ll r = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(p &gt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">if</span>(p &amp; <span class="hljs-number">1</span>) r = r * x % mode;        x = x * x % mode;        p /= <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> r;&#125;<span class="hljs-type">int</span> vis[<span class="hljs-number">27</span>];ll res[<span class="hljs-number">27</span>], ans = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n, l;    cin &gt;&gt; n &gt;&gt; l;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">26</span>;i++) res[i] = <span class="hljs-built_in">qpow</span>(i, l);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        string s;        cin &gt;&gt; s;        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: s) vis[i] |= (<span class="hljs-number">1</span> &lt;&lt; (c - <span class="hljs-string">&#x27;a&#x27;</span>));    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)&#123;        <span class="hljs-type">int</span> st = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">26</span>) - <span class="hljs-number">1</span>, f = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;            <span class="hljs-keyword">if</span>(i &amp; (<span class="hljs-number">1</span> &lt;&lt; (k<span class="hljs-number">-1</span>)))&#123;                st = st &amp; vis[k];                f *= <span class="hljs-number">-1</span>;            &#125;        &#125;        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">26</span>;k++) <span class="hljs-keyword">if</span>(st &amp; (<span class="hljs-number">1</span> &lt;&lt; k)) cnt++;        (ans += f * res[cnt]) %= mode;    &#125;    cout &lt;&lt; (ans % mode + mode) % mode &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="G-Game-on-Tree-3"><a href="#G-Game-on-Tree-3" class="headerlink" title="G - Game on Tree 3"></a>G - Game on Tree 3</h4><p>题意：有一棵树，每个点有权值。Alice和Bob在玩游戏，一开始Bob在树根节点上，接下来轮流行动：</p><ul><li>Alice选择任意一个节点，将其权值清零</li><li>Bob选择一条相邻的边，移动到一棵子树上（不可返回）</li></ul><p>Bob可以随时结束游戏，问Bob能走到的最大点权是多少（Alice会让这个值尽可能小）</p><p>首先二分答案，假设答案为 $k$，那么Alice就要在Bob走到任意大于 $k$ 的节点之前，清空这些节点。</p><p>再考虑树上dp，设 $dp[i]$ 表示：当Bob走到 $i$ 这个子树上后，Alice需要在这个子树上操作至少多少次才能阻止Bob</p><p>这么设置状态的原因是Alice可以提前处理一些比较远的点（在Bob目前没有威胁时）</p><p>转移时：$dp[u] &#x3D; \sum dp[v]-1+(val[v]&gt;k)$</p><p>如果 $dp[1]&gt;1$，说明Alice无法阻止Bob，继续二分调整答案。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, val[maxn];vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];<span class="hljs-type">int</span> f[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> lim)</span></span>&#123;    f[p] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v != fa)&#123;            <span class="hljs-built_in">dfs</span>(v, p, lim);            f[p] += <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, f[v]<span class="hljs-number">-1</span>) + (val[v] &gt; lim);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) cin &gt;&gt; val[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> u, v;        cin &gt;&gt; u &gt;&gt; v;        vp[u].<span class="hljs-built_in">push_back</span>(v);        vp[v].<span class="hljs-built_in">push_back</span>(u);    &#125;    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e9</span>;    <span class="hljs-keyword">while</span>(l &lt; r)&#123;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, mid);        <span class="hljs-keyword">if</span>(f[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span>)&#123;            l = mid + <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            r = mid;        &#125;    &#125;    cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="Ex-01-Queries"><a href="#Ex-01-Queries" class="headerlink" title="Ex - 01? Queries"></a>Ex - 01? Queries</h4><p>题意：给出一个长度为 $n$ 的序列，仅包含 <code>0,1,?</code>，接下来有 $Q$ 次操作，每次选择一个位置，将其修改为<code>0,1,?</code>中的一个，然后问你：当前序列包含多少种不同的子序列，<code>?</code> 可以视为 <code>0</code> 或 <code>1</code></p><p>先不考虑修改，单独对一个序列如何求解：</p><p>设 $dp[i][0&#x2F;1]$ 表示前 $i$ 位上，末尾为 $0&#x2F;1$ 的子序列个数，转移时：</p><ul><li>若 $s[i]&#x3D;0$，则 $dp[i][0]&#x3D;dp[i-1][0]+dp[i-1][1]+1$，否则 $dp[i][0]&#x3D;dp[i-1][0]$</li><li>若 $s[i]&#x3D;1$，则 $dp[i][1]&#x3D;dp[i-1][0]+dp[i-1][1]+1$，否则 $dp[i][1]&#x3D;dp[i-1][1]$</li></ul><p><code>?</code> 则两者均成立</p><p>这种对子序列的dp没怎么见过，感觉挺玄妙的，以 $dp[i][0]&#x3D;dp[i-1][0]+dp[i-1][1]+1$ 为例，我的理解的思路是：</p><ul><li>先继承上一位的结果： $dp[i-1][0]$</li><li>然后对上一位的每一个子序列，都在末尾加上一个0，即加上：$dp[i-1][0]+dp[i-1][1]+1$（包括空串加0）</li><li>然后减去重复部分，显然，上述第一部分是完全被第二部分包含的，那么直接把第一部分去掉即可。</li></ul><p>有了这个dp式子之后呢？怎么处理询问？</p><p>这个dp形式比较简单，可以考虑用矩阵来表示，还是以当前位为0举例：<br>$$<br>\left[<br>\begin{matrix}<br>dp[i-1][0] &amp; dp[i-1][1] &amp; 1 \<br>\end{matrix}<br>\right]<br>\times<br>\left[<br>\begin{matrix}<br>1 &amp; 0 &amp; 0 \<br>1 &amp; 1 &amp; 0 \<br>1 &amp; 0 &amp; 1<br>\end{matrix}<br>\right]<br>&#x3D;<br>\left[<br>\begin{matrix}<br>dp[i][0] &amp; dp[i][1] &amp; 1 \<br>\end{matrix}<br>\right]<br>$$<br>同样可以把1和？表示成矩阵。我们要做单点修改矩阵值，查询整段矩阵乘积，可以用线段树维护。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mat</span>&#123;    <span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];    mat <span class="hljs-keyword">operator</span> *(<span class="hljs-type">const</span> mat &amp;t)<span class="hljs-type">const</span>&#123;        mat res = &#123;&#125;;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;j++)&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">3</span>;k++)&#123;                    (res.a[i][j] += <span class="hljs-number">1ll</span> * a[i][k] * t.a[k][j] % mode) %= mode;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;<span class="hljs-type">const</span> mat m[<span class="hljs-number">3</span>] = &#123;        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,         <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,         <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,         <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,         <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,         <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,         <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;;map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; fff&#123;&#123;<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-number">2</span>&#125;&#125;;string s;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">segTree</span>&#123;    mat sum[maxn &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;        sum[p] = sum[p*<span class="hljs-number">2</span>] * sum[p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>];    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> t)</span></span>&#123;        <span class="hljs-keyword">if</span>(l == r)&#123;            sum[p] = m[t];            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(pos &lt;= mid) <span class="hljs-built_in">modify</span>(p*<span class="hljs-number">2</span>, l, mid, pos, t);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r, pos, t);        <span class="hljs-built_in">push_up</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;        <span class="hljs-keyword">if</span>(l == r)&#123;            sum[p] = m[fff[s[l<span class="hljs-number">-1</span>]]];            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-built_in">build</span>(p*<span class="hljs-number">2</span>, l, mid);        <span class="hljs-built_in">build</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r);        <span class="hljs-built_in">push_up</span>(p);    &#125;&#125;segt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n, q;    cin &gt;&gt; n &gt;&gt; q;    cin &gt;&gt; s;    segt.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;        <span class="hljs-type">int</span> x; <span class="hljs-type">char</span> c;        cin &gt;&gt; x &gt;&gt; c;        segt.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, x, fff[c]);        mat res = mat&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,                      <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,                      <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125; * segt.sum[<span class="hljs-number">1</span>];        cout &lt;&lt; (<span class="hljs-number">1ll</span> * res.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + res.a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]) % mode &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>Atcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解后缀自动机</title>
    <link href="/2022/04/04/2022-04-04-%E7%90%86%E8%A7%A3%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <url>/2022/04/04/2022-04-04-%E7%90%86%E8%A7%A3%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h4 id="2022-x2F-4-x2F-4"><a href="#2022-x2F-4-x2F-4" class="headerlink" title="2022&#x2F;4&#x2F;4"></a>2022&#x2F;4&#x2F;4</h4><p>重新看了一遍</p><p>我确信此时此刻我已经完全看懂了 可惜这里地方太小写不下</p><hr><p>专门对克隆节点这一地方做了一张图 希望未来的我还能看得懂 <code>Orz</code></p><p><img src="http://lxtyin.ac.cn/img/other/string/SAM.png"></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SAM</tag>
      
      <tag>字符串</tag>
      
      <tag>抽象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git进阶</title>
    <link href="/2022/04/02/2022-04-02-git%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/04/02/2022-04-02-git%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="git存储原理"><a href="#git存储原理" class="headerlink" title="git存储原理"></a>git存储原理</h4><p>git的存储比我想象的暴力的多（</p><p>自己尝试了一下发现，先提交一个10M的压缩包上去，<code>.git</code> 文件的大小是10M多一点</p><p>然后随便改这个压缩包的一点字符，再提交一次，<code>.git</code> 变成20M了…</p><p>我曾一直以为它有什么神奇的办法可以记录任意类型文件的修改量，没想到它只是整个拷贝…</p><p>并且所有版本信息都存储在<code>.git</code>中，分支，提交节点什么的只是存储索引，因此git能够很快地创建和切换分支，我认为这也是一种空间换时间的做法。至少它在创新新分支时没有整个拷贝。</p><hr><p>不过仔细一想，又发现这样存储文件，其实占用并不会特别大。git对每个文件单独暴力地存所有版本，在节点信息中，记录每个文件所在的版本号。上述例子中我用了一个压缩包作为单独的文件，但在实际工作中，其实很少会出现10M大小的单个文件，更多的是大量小文件的组合。修改一处，也只是会创建一个小文件的副本罢了。</p><h4 id="git存储实现"><a href="#git存储实现" class="headerlink" title="git存储实现"></a>git存储实现</h4><p>粗略写一下大体概念，细节不重要（</p><p>首先，git对每个单独的文件暴力存储所有修改版本，每个版本有一ID（哈希生成的40位数），这些版本的实际数据存放在 <code>.git/object</code> 中，每个文件夹是一个两位数，里面有文件名38位的文件，存放实际数据。这些东西就是<strong>数据对象</strong>（blob）</p><p>每个文件夹作为一个<strong>树对象</strong>，树对象仅存储其目录下数据对象和子树对象的ID（当然是对应版本的），这样下来，最终的每个commit节点只需要存储一个树对象ID，和其父节点ID即可。</p><p>而分支仅仅只是指向commit节点的指针，因此git能很快地建立分支</p><h5 id="git如何发现你的修改"><a href="#git如何发现你的修改" class="headerlink" title="git如何发现你的修改"></a>git如何发现你的修改</h5><p>这一点也比我想的暴力：直接对比当前工作区中的文件和commit节点中的文件是否一致。</p><p>当然也没那么暴力，还记得git存储的文件ID是通过哈希生成的吗，既然如此，只需要对比哈希值就可以了。</p><h5 id="追踪变更历史"><a href="#追踪变更历史" class="headerlink" title="追踪变更历史"></a>追踪变更历史</h5><p>追踪变更历史这个东西，直观上来讲就是及其不严谨的…</p><p>试验了一下确实如此，<code>git log</code> 这条命令，在<strong>文件重命名</strong>，<strong>文件移动路径</strong>，以及<strong>修改其路径上任意文件夹名</strong>时，都会导致其变更历史丢失。</p><p>由此可以简单猜测：git其实只是利用了树对象，记录了一个特定路径的文件的提交历史，在日常不频繁更改文件名和路径的情况下，这一命令才能正常追溯。</p><h4 id="git-Diff原理"><a href="#git-Diff原理" class="headerlink" title="git Diff原理"></a>git Diff原理</h4><p>这里细化到一个问题：给你两段代码 $X$ 和 $Y$，如何仅根据这两串代码最后的样子推断出 $X$ 是怎么修改到 $Y$ 的，当然方案有很多，git Diff希望找出最优的，最优的原则基本有以下几条，按重要程度排序：</p><ul><li>修改量尽可能少，</li><li>同类修改（增加删除）尽可能多相邻</li><li>修改尽可能符合语法</li></ul><p>先不考虑最后一条，然后我们可以把问题想的简单点：假设程序员只会一行一行地修改代码，拿怕他只改了一个字符，我们也认为他修改了一行</p><p>这样把一片代码抽象成一个字符串，一行代表一个字符，我们要从S1通过删除字符，添加字符，变换到S2。</p><p>我直接贴：<a href="https://zhuanlan.zhihu.com/p/67024353">https://zhuanlan.zhihu.com/p/67024353</a> 建模很妙，可以n^2dp求解</p><p>至于第二条，我觉得不需要太过严谨，其实只需要简单规定一下优先级即可：优先删除，再是插入</p><p>第三条感觉严谨来说也很难搞，<del>不如不管了</del></p><h4 id="暂存区，工作区"><a href="#暂存区，工作区" class="headerlink" title="暂存区，工作区"></a>暂存区，工作区</h4><p>git add将工作区中的修改内容提交到暂存区，git commit将暂存区内容提交，保存为一个新的节点。</p><p>在切换分支，合并分支等过程中，必须要保证工作区clean，不然麻烦事很多</p><p>创建分支的话不影响（因为本地工作区不用动）</p><h4 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h4><p>我的理解中，git是按照commit作为节点存放的，每个节点有其内容，父节点</p><p>所谓branch只是一个指向commit的指针。两个branch之间有祖孙关系，它们就很容易合并，否则需要进行一个三节点的合并：两个待合并的branch和它们的LCA</p><p>三节点合并成功之后，会产生一个新的节点，它有两个父亲</p><p>合并如果遇到冲突，暂不会产生节点，而是直接在你的工作区中修改，不冲突的部分合并完成，冲突的部分会在文件中打上特殊标记，长这样：</p><div class="code-wrapper"><pre><code class="hljs asciidoc">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<span class="hljs-section">b</span><span class="hljs-section">=======</span>a&gt;&gt;&gt;&gt;&gt;&gt;&gt; br1</code></pre></div><p>你可以手动地去文件中删除这些标记，改到你希望的样子，然后手动提交产生一个新节点。</p><h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><p><code>ssh -T git@github.com</code> 中有哪些信息：</p><p>这条命令中的github.com即github网站的地址，它是一个git服务器</p><p>其中git是一个公用的用户，他记录了你的ssh公钥（我们写到github上的公钥）</p><p>我们连接时就是通过这个公用的用户git来传输的？</p><p>这条命令就是测试能否和github建立ssh连接</p><h4 id="git服务器"><a href="#git服务器" class="headerlink" title="git服务器"></a>git服务器</h4><p>我们自己本地的git仓库和服务端的git仓库是不一样的，服务端的git仓库是一个裸仓库，仅保存了版本信息，没有工作区。</p><p>创建一个裸仓库：</p><div class="code-wrapper"><pre><code class="hljs bash">git init --bare</code></pre></div><p>裸仓库中无法查看提交的文件</p><p>向一个非裸仓库push会报错</p><p>如果想要搭建一个可以查看文件的git服务端，一个可行的办法是使用钩子(hook)，在接受到提交时，自动的转向另一个非裸仓库，再从这个裸库中pull一遍。现在这个页面就是通过这种方式部署的</p><h4 id="git实操"><a href="#git实操" class="headerlink" title="git实操"></a>git实操</h4><p>这部分是实习的时候，发现自己实际操作非常手生，在公司记了一些</p><p><strong>fast-forward</strong>，即向前合并，跟进当前分支的最新提交，不会产生冲突，不会产生合并节点。</p><p><strong>git pull &#x3D; git fetch + git merge</strong>，注意是merge而不是fast-forward，可以pull有分歧的分支（例如自己的开发分支完成后，主分支已经有新的东西了），然后在本地解决冲突。</p><p><strong>cherry pick</strong> 单独提取一个commit的修改内容并应用。cherry-pick实际上是也是一个三路Merge，此时LCA视为目标commit的上一个commit。也就是说，以此LCA为基，我们的当前commit也视为是基于这个LCA修改的，这样来合并，当然也要解决冲突。<br>再理一下：Base是目标commit的上一个commit，可能导致冲突的是当前commit和目标commit，各自相对Base的更改内容的不同之处。</p><p><strong>track</strong>，git的每个本地分支都追踪一个远程分支，在本地创建的分支，提交时需要推送上去形成一个新分支并追踪；远程的分支拉取到本地时，需要在本地创建一个分支并追踪。git pull之类的操作默认拉取追踪的分支。</p><p><strong>HEAD</strong>，即当前分支，工作区所在的分支。</p><p>git通常都是在各个分支间进行切换操作，如果要切换到某个commit处，最好相应地创建一个分支（smartgit里的提示，基于commit的commit容易丢失。）</p><p><strong>submodule</strong>：子模块自己管自己的，主模块中，.gitmodules记录了子模块的本地路径和远程url，并在index中记录了子模块的状态（当前commitid），可以认为主模块git仅追踪了子模块的状态，而不追踪子模块的文件。子模块commitid发生变化时，主模块也会worktree not clean（主模块中的记录与实际子模块id不一致）。<br>git pull默认仅更新主模块，包括了主模块中记录的子模块id，而不会直接更新子模块，因此在主模块pull之后，可能仍然是worktree not clean的状态，因为拉新后主模块记录id与子模块实际id不同了。</p><p>git pull支持递归拉新。</p><p>子模块中的远程分支，主模块是不知道的，子模块的远程有所更新并不会被主模块捕捉到，子模块需要自己去拉远程。</p><p>实际操作中会遇到更新了子模块，同时又要拉父模块的情况，此时可以先将子模块内容提交，然后回退（到父模块中记录的那个节点），使得父模块work tree clean，然后拉父模块，再切换子模块到最新节点。父模块只是fast-forward时，似乎也可以在work tree not clean的情况下直接pull。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>版本控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Atcoder Beginner 245 G</title>
    <link href="/2022/03/31/2022-03-31-Atcoder%20ABC%20245%20G/"/>
    <url>/2022/03/31/2022-03-31-Atcoder%20ABC%20245%20G/</url>
    
    <content type="html"><![CDATA[<h4 id="G-Foreign-Friends"><a href="#G-Foreign-Friends" class="headerlink" title="G - Foreign Friends"></a>G - Foreign Friends</h4><p>题意：给出一个带边权的无向图，每个点有一个颜色，其中还有若干个特殊点。现在要求输出：每个点前往一个颜色与自己不同的特殊点的最短距离</p><p>解法：首先不考虑颜色，这个题就是一个魔改的dij，初始将所有特殊点加入队列跑一遍即可。</p><p>然后我们考虑颜色，可以将颜色按照二进制位拆开，枚举每一位，将所有<strong>在这一位上为0的特殊点</strong>加入队列跑一遍dij，并且更新<strong>在这一位上为1的点</strong>的答案。同样反过来也这么搞一遍</p><p>两个颜色不同，则它们至少有一位二进制是不同的（废话</p><p>所以任意点距离不同颜色的特殊点之间的最短路一定会被算到。</p><p>复杂度 $O(logn*dij)$</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m, K, L;<span class="hljs-type">int</span> a[maxn], b[maxn];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;    <span class="hljs-type">int</span> t;    ll dis;    <span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> x, ll y): <span class="hljs-built_in">t</span>(x), <span class="hljs-built_in">dis</span>(y)&#123;&#125;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &gt;(<span class="hljs-type">const</span> node &amp;p)<span class="hljs-type">const</span>&#123;        <span class="hljs-keyword">return</span> dis &gt; p.dis;    &#125;&#125;;vector&lt;node&gt; vp[maxn];ll dis[maxn], ans[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span></span>&#123;    priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt; &gt; q;    <span class="hljs-built_in">fill</span>(dis, dis+n+<span class="hljs-number">1</span>, <span class="hljs-number">1e18</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;L;i++)&#123;        <span class="hljs-keyword">if</span>((a[b[i]] &gt;&gt; k &amp; <span class="hljs-number">1</span>) == x)&#123;            q.<span class="hljs-built_in">push</span>(&#123;b[i], <span class="hljs-number">0</span>&#125;);            dis[b[i]] = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;        node u = q.<span class="hljs-built_in">top</span>();        q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">if</span>(dis[u.t] &lt; u.dis) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span>((a[u.t] &gt;&gt; k &amp; <span class="hljs-number">1</span>) == (x^<span class="hljs-number">1</span>)) ans[u.t] = <span class="hljs-built_in">min</span>(ans[u.t], dis[u.t]);        <span class="hljs-keyword">for</span>(node e: vp[u.t])&#123;            <span class="hljs-type">int</span> v = e.t;            <span class="hljs-keyword">if</span>(dis[v] &gt; dis[u.t] + e.dis)&#123;                dis[v] = dis[u.t] + e.dis;                q.<span class="hljs-built_in">emplace</span>(v, dis[v]);            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; K &gt;&gt; L;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;L;i++) cin &gt;&gt; b[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-type">int</span> u, v, d;        cin &gt;&gt; u &gt;&gt; v &gt;&gt; d;        vp[u].<span class="hljs-built_in">emplace_back</span>(v, d);        vp[v].<span class="hljs-built_in">emplace_back</span>(u, d);    &#125;    <span class="hljs-built_in">fill</span>(ans, ans+n+<span class="hljs-number">1</span>, <span class="hljs-number">1e18</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">17</span>;k&gt;=<span class="hljs-number">0</span>;k--)&#123;        <span class="hljs-built_in">dij</span>(k, <span class="hljs-number">0</span>);        <span class="hljs-built_in">dij</span>(k, <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout &lt;&lt; (ans[i] &gt; (ll)<span class="hljs-number">1e17</span> ? <span class="hljs-number">-1</span> : ans[i]) &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>Atcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 779 div.2 D2F</title>
    <link href="/2022/03/29/2022-03-29-Codeforces%20Round%20779%20div.2%20D2E/"/>
    <url>/2022/03/29/2022-03-29-Codeforces%20Round%20779%20div.2%20D2E/</url>
    
    <content type="html"><![CDATA[<h4 id="D2-388535-Hard-Version"><a href="#D2-388535-Hard-Version" class="headerlink" title="D2. 388535 (Hard Version)"></a>D2. 388535 (Hard Version)</h4><p>题意：给出两个数 $l,r$ 和一个数字集合 $a$，有某个 $x$，使得 $[l,r]$ 范围内的这些数分别异或上 $x$ 之后，结果恰好能组成序列 $a$。要求找到一个合法的 $x$，保证有解。</p><p>对于每一位去考虑：如果在某一个二进制位上，两边集合0和1的个数不相等，比如 $l…r$ 中共有3个0，2个1；序列 $a$ 中共有2个0，3个1，那么必须要让数量对调，可以直接得出 $x$ 在这一二进制位上必为1。不能对调则这一位上必为0</p><p>从高位到低位依次进行，每次把 $l,r$ 和 $a$ 分别分为高位为0和1的四组，然后根据数量对应上，分开递归向下求解。</p><p><strong>但</strong>如果两边集合0和1的个数全部相等呢？那么在这一位上，无法确定取0还是取1，有没有可能都可以呢？</p><p>接下来证明：在<strong>最高位处</strong>，如果0和1的个数相等，不论怎么取，都不影响解的存在。</p><p>因为 $l,r$ 是一个连续的区间，我们考虑最高位为1的分界线，其实也就是 $l,r$ 的中点（因为要0和1一样多）</p><p>随便举个例子：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">l</span>=<span class="hljs-number">5</span>   <span class="hljs-number">0101</span><span class="hljs-attribute">6</span>     <span class="hljs-number">0110</span><span class="hljs-attribute">7</span>     <span class="hljs-number">0111</span><span class="hljs-attribute">8</span>     <span class="hljs-number">1000</span><span class="hljs-attribute">9</span>     <span class="hljs-number">1001</span><span class="hljs-attribute">r</span>=<span class="hljs-number">10</span>  <span class="hljs-number">1010</span></code></pre></div><p>在最高位上，我们遇到了0和1个数相等的情况，将它们分为两组，我们发现后面的位置上数字恰好是相反的。</p><p>因为一个是从000开始加，另一个是从111开始减，当然是完全相反的。</p><p>也就是说，此时对调这两组分配给 $a$ 的方式，仅仅只是让后续答案对调，该有解还是有解，不用担心此处取值的伏笔。另外，分配到 $a$ 的子 $l,r$ 仍然是连续的。我们只需要在最高位处做完之后把最高位抹去，后续仍然满足这个条件。</p><p>具体实现上，先将 $a$ 插入字典树，然后递归向下求解会比较方便</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;    <span class="hljs-type">int</span> cnt;    <span class="hljs-type">int</span> ch[<span class="hljs-number">2</span>];&#125;t[maxn &lt;&lt; <span class="hljs-number">5</span>];<span class="hljs-type">int</span> tcnt = <span class="hljs-number">1</span>; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    <span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">17</span>;k&gt;=<span class="hljs-number">0</span>;k--)&#123;        <span class="hljs-type">int</span> v = (x &gt;&gt; k) &amp; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(!t[p].ch[v])&#123;            t[p].ch[v] = ++tcnt;            t[tcnt].cnt = <span class="hljs-number">0</span>;            t[tcnt].ch[<span class="hljs-number">0</span>] = t[tcnt].ch[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;        &#125;        p = t[p].ch[v];        t[p].cnt++;    &#125;&#125; <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> lv, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;    <span class="hljs-keyword">if</span>(lv &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-type">int</span> mid = r;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;i++)&#123;        <span class="hljs-keyword">if</span>((i &gt;&gt; lv) &amp; <span class="hljs-number">1</span>)&#123;            mid = i<span class="hljs-number">-1</span>;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span>(mid-l+<span class="hljs-number">1</span> == t[t[p].ch[<span class="hljs-number">0</span>]].cnt)&#123;        <span class="hljs-keyword">if</span>(mid &gt;= l) <span class="hljs-built_in">work</span>(t[p].ch[<span class="hljs-number">0</span>], lv<span class="hljs-number">-1</span>, l, mid);        <span class="hljs-keyword">if</span>(mid &lt; r) <span class="hljs-built_in">work</span>(t[p].ch[<span class="hljs-number">1</span>], lv<span class="hljs-number">-1</span>, (mid+<span class="hljs-number">1</span>)^(<span class="hljs-number">1</span>&lt;&lt;lv), r^(<span class="hljs-number">1</span>&lt;&lt;lv));    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">if</span>(mid &gt;= l) <span class="hljs-built_in">work</span>(t[p].ch[<span class="hljs-number">1</span>], lv<span class="hljs-number">-1</span>, l, mid);        <span class="hljs-keyword">if</span>(mid &lt; r) <span class="hljs-built_in">work</span>(t[p].ch[<span class="hljs-number">0</span>], lv<span class="hljs-number">-1</span>, (mid+<span class="hljs-number">1</span>)^(<span class="hljs-number">1</span>&lt;&lt;lv), r^(<span class="hljs-number">1</span>&lt;&lt;lv));        ans |= (<span class="hljs-number">1</span> &lt;&lt; lv);    &#125;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    tcnt = <span class="hljs-number">1</span>;    ans = <span class="hljs-number">0</span>;    t[<span class="hljs-number">1</span>].ch[<span class="hljs-number">0</span>] = t[<span class="hljs-number">1</span>].ch[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;     <span class="hljs-type">int</span> l, r;    cin &gt;&gt; l &gt;&gt; r;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;i++)&#123;        <span class="hljs-type">int</span> x; cin &gt;&gt; x;        <span class="hljs-built_in">insert</span>(x);    &#125;    <span class="hljs-built_in">work</span>(<span class="hljs-number">1</span>, <span class="hljs-number">17</span>, l, r);    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="E-Gojou-and-Matrix-Game"><a href="#E-Gojou-and-Matrix-Game" class="headerlink" title="E. Gojou and Matrix Game"></a>E. Gojou and Matrix Game</h4><p>题意：有一个 $n\times n$ 的网格，每个格子上有一个分数 $1…n^2$，不重复。接下来两个人玩游戏，第一名玩家首先占据 $sx, sy$ 格，随后轮流选择格子占据，要求满足以下条件：</p><ul><li>选取的格子距离另一名玩家上次占据的格子的曼哈顿距离不超过 $k$</li><li>可以重复占据，每次占据都能获得该格子上的分数（可重复获得）</li></ul><p>请问对于每个起始坐标 $sx,sy$，玩 $10^{100}$ 轮，谁能获胜？</p><p>首先不难发现，分数是不重复的，那么分数最高的格子只有一个，谁先占到谁就赢了。</p><p>游戏规则是不能选取距对方上次选取位置 $k$ 格以内的，双方有可能互相僵持，都占不到最高分的点</p><p>那么再去考虑次高分的位置：如果次高分的控制范围内包括了最高分，那么这也是一个先手必胜点（即使对方跟你僵持都拿不到最高，但你拿的是次高，所以也是必胜）。否则这就是先手必败点。</p><p>如此考虑下去，我们发现：对于一个包含 $x$ 分的点来说，只要它的掌控范围内包含了所有比 $x$ 大的必胜点，$x$ 就是必胜点。否则为必败点。</p><hr><p>另外再给出一种博弈论常用的思路：如果我选择了分数为 $x$ 的点后，对方不得不选择分数小于 $x$ 的点，那么我就是必胜的，因为我可以继续选择当前点，这个逻辑在双方都进行最优策略下是完全正确的。</p><hr><p>那么问题就变成了如何判断。我们按照权值从大到小枚举，每遇到一个必胜点，都将它的位置丢进一个集合，只要集合中是否存在到当前枚举点距离 $\gt k$ 的位置就可以了。</p><p>当然暴力判断怎么样都是 $n^3$ 的，此处又有一个神奇的“放宽解空间”思想：</p><p>想判断 $|i-i’|+|j-j’|\le k$ ，它等价于 $max(|i+j-(i’+j’)|, |i-j-(i’-j’)|)$</p><p>然后就只需要记录 $i+j$，$i-j$ 的最大最小值即可…</p><p>难想…</p><p>本质上是放宽了解空间，使得更容易维护</p><p>感觉这种东西都挺难发现的，记一下吧（</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 117</title>
    <link href="/2022/03/23/2022-03-23-Educational%20Codeforces%20Round%20125/"/>
    <url>/2022/03/23/2022-03-23-Educational%20Codeforces%20Round%20125/</url>
    
    <content type="html"><![CDATA[<h4 id="D-For-Gamers-By-Gamers"><a href="#D-For-Gamers-By-Gamers" class="headerlink" title="D. For Gamers. By Gamers."></a>D. For Gamers. By Gamers.</h4><p>题意：玩家有 $C$ 块钱，可以从酒馆中招募随从，每个随从有攻击力 $d_i$，生命 $h_i$，花费 $c_i$ 块钱。接下来有若干轮战斗，每轮战斗有一个敌人，攻击力 $D_j$，生命 $H_j$。每轮相互独立（钱也独立），玩家可以招募若干个<strong>相同</strong>随从来和怪物战斗，但要求己方没有随从会死亡。问每一轮战斗需要花费至少多少金币</p><p>战斗不是回合制的，双方连续攻击。</p><p>解：因为是双方连续攻击，所以两个怪物战斗，我放胜利的条件即 $H&#x2F;d\lt h&#x2F;D$，换算一下即：$H\times D\lt h\times d$</p><p>那么每个怪物的战斗力都可以直接用其攻击乘上生命来衡量。</p><p>如果购买多个随从同时作战，因为要求不能死任何一个，所以相当于攻击力可叠加，但生命值不能叠加。其实战斗力是完全等比例增长的。</p><p>那么就变成了一个背包问题，但数据范围显然不允许 $n^2$，这时发现题目又有一个条件：只能购买相同随从。</p><p>那么在背包转移时，只需要枚举每个随从花费金币的倍数去更新即可。复杂度是经典调和级数 $O(nlogn)$</p><p>最后每轮询问二分找一下大于这个怪物战斗力的最小花费（</p><div class="code-wrapper"><pre><code class="hljs c++">ll n, m;ll mxc[maxn], f[maxn]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    ll C;    cin &gt;&gt; n &gt;&gt; C;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        ll c, x, y;        cin &gt;&gt; c &gt;&gt; x &gt;&gt; y;        f[c] = <span class="hljs-built_in">max</span>(f[c], x * y);    &#125;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=C;i++)&#123;        f[i] = <span class="hljs-built_in">max</span>(f[i], f[i<span class="hljs-number">-1</span>]);        <span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">2</span>;j*i&lt;=C;j++)&#123;            f[j*i] = <span class="hljs-built_in">max</span>(f[j*i], f[i] * j);        &#125;    &#125;     cin &gt;&gt; m;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        ll x, y;        cin &gt;&gt; x &gt;&gt; y;        <span class="hljs-keyword">if</span>(f[C] &lt;= x * y)&#123;            cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == m];            <span class="hljs-keyword">continue</span>;        &#125;        ll p = <span class="hljs-built_in">lower_bound</span>(f+<span class="hljs-number">1</span>, f+C+<span class="hljs-number">1</span>, x * y + <span class="hljs-number">1</span>) - f;        cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == m];    &#125;&#125;</code></pre></div><h4 id="E-Star-MST"><a href="#E-Star-MST" class="headerlink" title="E. Star MST"></a>E. Star MST</h4><p>题意：对于 $n$ 个节点的完全图，每条边不超过 $m$，如果所有和1相连的边能构成最小生成树，那么这个完全图是好的。请问一共有多少种好的完全图？</p><p>从kruskal角度考虑：在我们依次将边插入时，除了1以外不能存在其他联通块，否则即不是最小生成树。</p><p>设 $dp[i][j]$ 为已经将小于等于 $j$ 的所有边插入，此时1的联通块大小为 $i$ 的答案。</p><p>转移时，插入所有长度为 $j+1$ 的边，枚举有多少个点因此并入联通块了（假设有 $k$ 个），那么一共有 $C_{n-i}^{k}$ 种取法，并入后新增的边数为 $k\times(k-1)&#x2F;2+i\times k$，其中 $k$ 条确定长度为 $j+1$ 了，另外的边长度可以在 $[j+1，m]$ 之间任选。</p><p>转移：$dp[i+k][j+1]+&#x3D;dp[i][k]\times C_{n-i}^k\times(m-j)^{k\times (k-1)&#x2F;2+(i-1)\times k}$</p><div class="code-wrapper"><pre><code class="hljs c++">ll n, m;ll f[<span class="hljs-number">300</span>][<span class="hljs-number">300</span>]; <span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll x, ll p)</span></span>&#123;    ll r = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(p &gt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">if</span>(p &amp; <span class="hljs-number">1</span>) r = r * x % mode;        x = x * x % mode;        p /= <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> r;&#125; <span class="hljs-function">ll <span class="hljs-title">inv</span><span class="hljs-params">(ll x)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">qpow</span>(x, mode<span class="hljs-number">-2</span>);&#125;ll jc[maxn];<span class="hljs-function">ll <span class="hljs-title">C</span><span class="hljs-params">(ll n, ll m)</span></span>&#123;    <span class="hljs-keyword">return</span> jc[n] * <span class="hljs-built_in">inv</span>(jc[m] * jc[n-m] % mode) % mode;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    jc[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1000</span>;i++) jc[i] = jc[i<span class="hljs-number">-1</span>] * i % mode;     cin &gt;&gt; n &gt;&gt; m;    f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;i+k&lt;=n;k++)&#123;                (f[i+k][j+<span class="hljs-number">1</span>] += f[i][j] * <span class="hljs-built_in">C</span>(n-i, k) % mode * <span class="hljs-built_in">qpow</span>(m-j, k*(k<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span> + (i<span class="hljs-number">-1</span>)*k) % mode) %= mode;            &#125;        &#125;    &#125;    cout &lt;&lt; f[n][m] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="F-Words-on-Tree"><a href="#F-Words-on-Tree" class="headerlink" title="F. Words on Tree"></a>F. Words on Tree</h4><p>写的稀碎，看看思路就好，代码别看了（</p><p>题意：现在有一棵树，每个点上有一个字符，给定了若干个限制条件，形如 $x,y,s$，表示树上 $x$ 到 $y$ 的路径上的字符连起来必须是 $s$ 或者 $s$ 的反串。你需要填写树上的字符使得所有限制条件都被满足。</p><p>既然有限制条件，并且这个限制条件显然是二选一，我们肯定要往2-SAT方向去想</p><p>对每个限制条件建两个点，一个表示字符正着放，另一个表示反着放。问题是怎么连边，似乎怎么连都得 $n^2$ 条边</p><p>这里的关键在于：并不需要把所有约束条件都表示出来，只要一个约束条件已经被已有约束包含，就可以忽略它</p><p>具体而言，我们在每一个节点处<strong>随便</strong>选取一个涉及这个节点的约束条件，那么可以确定这个节点一定是两种字符之一，我们称这个被选择的约束条件为哨兵。</p><p>对于任意两个有重复部分的约束条件，它们都去和哨兵建立联系，它们两个之间的约束关系也就通过哨兵建立了。                                                                                                                                                                               </p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn], vp2[maxn];<span class="hljs-type">int</span> dep[maxn], fa[maxn], bin[maxn];<span class="hljs-type">char</span> chr[maxn][<span class="hljs-number">2</span>]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> f)</span></span>&#123;    fa[p] = f;    dep[p] = dep[f] + <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v != f) <span class="hljs-built_in">dfs</span>(v, p);    &#125;&#125; <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getPath</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;    vector&lt;<span class="hljs-type">int</span>&gt; r1, r2;    <span class="hljs-keyword">while</span>(u != v)&#123;        <span class="hljs-keyword">if</span>(dep[u] &gt; dep[v]) r1.<span class="hljs-built_in">push_back</span>(u), u = fa[u];        <span class="hljs-keyword">else</span> r2.<span class="hljs-built_in">push_back</span>(v), v = fa[v];    &#125;    r1.<span class="hljs-built_in">push_back</span>(u);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=(<span class="hljs-type">int</span>)r2.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) r1.<span class="hljs-built_in">push_back</span>(r2[i]);    <span class="hljs-keyword">return</span> r1;&#125; <span class="hljs-type">int</span> dfn[maxn], low[maxn], bel[maxn], dfcnt = <span class="hljs-number">0</span>;stack&lt;<span class="hljs-type">int</span>&gt; stk;<span class="hljs-type">int</span> belid = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjian</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;    dfn[p] = low[p] = ++dfcnt;    stk.<span class="hljs-built_in">push</span>(p);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp2[p])&#123;        <span class="hljs-keyword">if</span>(!dfn[v]) <span class="hljs-built_in">tarjian</span>(v);        <span class="hljs-keyword">if</span>(!bel[v]) low[p] = <span class="hljs-built_in">min</span>(low[p], low[v]);    &#125;    <span class="hljs-keyword">if</span>(dfn[p] == low[p])&#123;        bel[p] = ++belid;        <span class="hljs-keyword">while</span>(stk.<span class="hljs-built_in">top</span>() != p)&#123;            bel[stk.<span class="hljs-built_in">top</span>()] = belid;            stk.<span class="hljs-built_in">pop</span>();        &#125;        stk.<span class="hljs-built_in">pop</span>();    &#125;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        vp[x].<span class="hljs-built_in">push_back</span>(y);        vp[y].<span class="hljs-built_in">push_back</span>(x);    &#125;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">query</span>&#123;        <span class="hljs-type">int</span> x, y;        string s;    &#125;;    <span class="hljs-function">vector&lt;query&gt; <span class="hljs-title">qr</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-type">int</span> x, y;        string s;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; s;        qr[i] = &#123;x, y, s&#125;;        <span class="hljs-keyword">auto</span> l = <span class="hljs-built_in">getPath</span>(x, y);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;l.<span class="hljs-built_in">size</span>();j++)&#123;            <span class="hljs-keyword">if</span>(!bin[l[j]])&#123;                chr[l[j]][<span class="hljs-number">0</span>] = s[j];                chr[l[j]][<span class="hljs-number">1</span>] = s[s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>-j];                bin[l[j]] = i;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        string s = qr[i].s;        <span class="hljs-keyword">auto</span> l = <span class="hljs-built_in">getPath</span>(qr[i].x, qr[i].y);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;l.<span class="hljs-built_in">size</span>();j++)&#123;            <span class="hljs-type">char</span> mc[<span class="hljs-number">2</span>] = &#123;s[j], s[s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>-j]&#125;;            <span class="hljs-type">char</span> *yc = chr[l[j]];            <span class="hljs-type">int</span> yj = bin[l[j]];            <span class="hljs-keyword">if</span>(yj == i) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span>(yc[<span class="hljs-number">0</span>] == yc[<span class="hljs-number">1</span>] &amp;&amp; mc[<span class="hljs-number">0</span>] == mc[<span class="hljs-number">1</span>] &amp;&amp; yc[<span class="hljs-number">0</span>] == mc[<span class="hljs-number">0</span>]) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span>(yc[<span class="hljs-number">0</span>] == yc[<span class="hljs-number">1</span>])&#123;                <span class="hljs-keyword">if</span>(mc[<span class="hljs-number">0</span>] != yc[<span class="hljs-number">0</span>] &amp;&amp; mc[<span class="hljs-number">1</span>] != yc[<span class="hljs-number">0</span>])&#123;                    cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;                    <span class="hljs-keyword">return</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">if</span>(mc[<span class="hljs-number">0</span>] == yc[<span class="hljs-number">0</span>]) vp2[m+i].<span class="hljs-built_in">push_back</span>(i);                    <span class="hljs-keyword">else</span> vp2[i].<span class="hljs-built_in">push_back</span>(m+i);                &#125;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mc[<span class="hljs-number">0</span>] == mc[<span class="hljs-number">1</span>])&#123;                <span class="hljs-keyword">if</span>(mc[<span class="hljs-number">0</span>] != yc[<span class="hljs-number">0</span>] &amp;&amp; mc[<span class="hljs-number">0</span>] != yc[<span class="hljs-number">1</span>])&#123;                    cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;                    <span class="hljs-keyword">return</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">if</span>(mc[<span class="hljs-number">0</span>] == yc[<span class="hljs-number">0</span>]) vp2[yj+m].<span class="hljs-built_in">push_back</span>(yj);                    <span class="hljs-keyword">else</span> vp2[yj].<span class="hljs-built_in">push_back</span>(yj+m);                &#125;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-type">bool</span> fd = <span class="hljs-literal">false</span>;                 <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;<span class="hljs-number">2</span>;u++)&#123;                    <span class="hljs-keyword">if</span>(mc[u] != yc[<span class="hljs-number">0</span>] &amp;&amp; mc[u] != yc[<span class="hljs-number">1</span>])&#123;                        vp2[i+m*u].<span class="hljs-built_in">push_back</span>(i+m*(u^<span class="hljs-number">1</span>));                    &#125;                &#125;                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;<span class="hljs-number">2</span>;u++)&#123;                    <span class="hljs-keyword">if</span>(yc[u] != mc[<span class="hljs-number">0</span>] &amp;&amp; yc[u] != mc[<span class="hljs-number">1</span>])&#123;                        vp2[yj+m*u].<span class="hljs-built_in">push_back</span>(yj+m*(u^<span class="hljs-number">1</span>));                    &#125;                &#125;                 <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;<span class="hljs-number">2</span>;u++)&#123;                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;<span class="hljs-number">2</span>;v++)&#123;                        <span class="hljs-keyword">if</span>(mc[u] == yc[v])&#123;                            fd = <span class="hljs-literal">true</span>;                            vp2[i+m*u].<span class="hljs-built_in">push_back</span>(yj+m*v);                            vp2[yj+m*v].<span class="hljs-built_in">push_back</span>(i+m*u);                        &#125;                    &#125;                &#125;                <span class="hljs-keyword">if</span>(!fd)&#123;                    cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;                    <span class="hljs-keyword">return</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*m;i++) <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjian</span>(i);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-keyword">if</span>(bel[i] == bel[i+m])&#123;            cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cs</span><span class="hljs-params">(m+<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-keyword">if</span>(bel[i] &lt; bel[i+m]) cs[i] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">else</span> cs[i] = <span class="hljs-number">1</span>;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(!bin[i]) cout &lt;&lt; <span class="hljs-string">&#x27;a&#x27;</span>;        <span class="hljs-keyword">else</span> cout &lt;&lt; chr[i][cs[bin[i]]];    &#125;    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022浙江工商大学acm校赛总结</title>
    <link href="/2022/03/14/2022-03-05-2022%E6%B5%99%E6%B1%9F%E5%B7%A5%E5%95%86%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9B/"/>
    <url>/2022/03/14/2022-03-05-2022%E6%B5%99%E6%B1%9F%E5%B7%A5%E5%95%86%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>开局首先乱开选到了炸弹题，快速想了个bfs搞法后就开始写了，连wa三发之后发现不对劲，仔细想了一下发现思路是假的，这个时候已经半个小时了，榜上两个签到题已经被过穿，我还只有一个-3，开局稀碎</p><p>然后选择先把代码存起来去写签到，回文子序列属于经典的那种cfA题，平时会打cf的新生写这个应该不需要5分钟（</p><p>质因数分解题 我还稍微卡了一会 数学属实是碰的太少了</p><p>搞完两个签到回去搞炸弹题，重新想了一下发现是个缩点，抄一波tarjian板子过掉</p><p>然后就开始了大寄特寄的0号题，一个sb最短路+路径计数，硬是找不到wa点，造的数据都过，交上去全是wa。再结合这个题目描述（直观看起来是无向图但是没有明说；边权只写了上限没有写下界；数据规模允许 $n^2$），总之存在诸多疑点，那么dij换成spfa试了试，无向图改有向图试试，同时改试试… 于是对 $n$ 项疑点开始 $2^n$ 爆搜式提交，然而都没有过（我现在还不知道为什么wa）</p><p>此时的情况非常不妙，这个0号题已经过了十几个人了，差不多是所有大二三 + 一些新生，感觉非常危，但硬wa也没什么办法，于是弃题去搞别的了</p><p>很快发现取石子是个诈骗题，直接输出Alice，没关同步流还T一发</p><p>然后发现一棵刻入DNA的线段树，快速切掉没有什么压力</p><p>接着是那个函数题，看错题目绕了一会，回过神来发现其实开个优先队列乱搞就行了，$nlogn$ 没有什么问题</p><p>到这个时候差不多还有四十分钟，我做了个错误的决定：继续回去卡那个最短路…于是又是交了一堆wa，中途简单看了一下字符串题和dp题，字符串题面稀碎，没读明白；dp题想了个有点复杂的搞法，感觉时间来不及而且不一定对，就回去wa最短路了…一直wa到比赛结束，最后-19没搞出来，但场上一共过了差不多20个，快变成签到了。</p><p>最后6题rk3，没打过大一爷，非常不满意（寄，主要是该写出来的没写出来</p><p>总结一下，感觉心态还有点问题，一wa就容易乱交，另外弃题弃的不够彻底，dp题不一定能搞出来，但那个字符串，稍微花点时间读明白的话就会发现是个sb字典树，最后时间不重新回去卡最短路的话，这个也应该能出来（虽然出来了还是打不过大一爷，orz</p><h2 id="补题："><a href="#补题：" class="headerlink" title="补题："></a>补题：</h2><h4 id="Dwendwen给大佬分组"><a href="#Dwendwen给大佬分组" class="headerlink" title="Dwendwen给大佬分组"></a>Dwendwen给大佬分组</h4><p>众所周知，实验室的同学们都是大佬。现在实验室共有N位大佬，为了发挥大佬们的辐射能力，Dwendwen准备按座位将其分为k个学习小组。</p><p>为了简化问题，我们假设实验室的座位是一种长度为N（N个座位）的线状结构，坐在第i个位置的大佬有影响力ai。在不能调整座位的前提下，Dwendwen需要将大佬们分为k组，其中每个组内的大佬都是座位连续的。一个小组的战斗力为小组所有大佬中，最大影响力与最小影响力之差，即max(a)-min(a)。</p><p>现在Dwendwen希望让实验室k个小组的总战斗力最大化，你能帮帮他吗？</p><h5 id="Input"><a href="#Input" class="headerlink" title="Input:"></a>Input:</h5><p>第一行为两个空格分割的整数N(1≤N≤10000)和k(1≤k≤N)，分别表示实验室人数和小组个数。</p><p>第二行为N个空格分割的正整数，第i个数字ai(1≤ai≤500000)为坐在第i个位置的大佬的影响力。</p><h5 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h5><p>实验室所有小组的总战斗力的最大值。</p><h5 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h5><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">1</span><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span></code></pre></div><h5 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h5><div class="code-wrapper"><pre><code class="hljs">4</code></pre></div><p>先是朴素的 $n^3$ dp做法，$dp[i][j]$ 表示前 $i$ 个数，分成 $j$ 组的最大答案</p><p>转移有 $dp[i][j] &#x3D; dp[k][j-1]+max(a[k+1..i])-min(a[k+1..i])$，枚举这个 $k$</p><p>第一反应是拿某种单调队列来优化掉这一维 $k$，但是比较难搞</p><p>题解给了个不错的思路：放宽解空间</p><p>也就是说，我们可以把题意转换一下，转换后多了一些无意义的解，并不影响答案，但是能让优化变得更简单</p><p>本题的权值是 $max-min$，典中典，我们可以把它改成<strong>任意两数相减</strong>，显然最大的结果仍然是 $max-min$</p><p>那么转移时，考虑新加进来的 $a[i]$ 的成分：</p><ul><li>不参与加减运算，$dp[i][j] &#x3D; dp[i-1][j]$</li><li>作为被减数，$dp[i][j] &#x3D; dp[k][j-1]+a[k+1]-a[i]$，这里相当于在枚举减数</li><li>作为减数，$dp[i][j]&#x3D;dp[k][j-1]+a[i]-a[k+1]$，相当于枚举被减数</li></ul><p>可以发现，我们只需要知道 $dp[k][j-1]+a[k+1]$ 的最大值，以及 $dp[k][j-1]-a[k+1]$ 的最大值，就能做到 $O(1)$ 转移了</p><p>这两个值沿途记录一下即可，不难维护。</p><hr><p>再写另一种理解方式：</p><p>原题中，一个区间的权值是 $max-min$，那么可以发现，如果一个区间的边界元素不是其最大或最小值，那么把这个边界元素丢给隔壁区间一定不会更差。</p><p>所以最后我们其实是把整个数组分成了两种区间：两端分别是极大极小值的区间，和放哪都一样的区间（可以忽略的区间）</p><p>那么 $dp$ 转移的思路也比较清晰了（dp含义和上文相同）：</p><ul><li>当前元素不是区间的边界（在区间内部或者被忽略），$dp[i][j] &#x3D; dp[i-1][j]$</li><li>当前元素是区间边界，且是极小值，$dp[i][j] &#x3D; dp[k][j-1]+a[k+1]-a[i]$</li><li>当前元素是区间边界，且是极大值，$dp[i][j]&#x3D;dp[k][j-1]+a[i]-a[k+1]$</li></ul><p>就和上面的转移方程是一样的。</p><p>最后，这个题的数据范围是 $10^4$，滚动数组优化一下空间。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn];ll f[<span class="hljs-number">10003</span>][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-type">int</span> mxa = a[<span class="hljs-number">1</span>], mia = a[<span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        mxa = <span class="hljs-built_in">max</span>(mxa, a[i]);        mia = <span class="hljs-built_in">min</span>(mia, a[i]);        f[i][<span class="hljs-number">1</span>] = mxa - mia;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">2</span>;k&lt;=m;k++)&#123;        <span class="hljs-type">int</span> nw = k % <span class="hljs-number">2</span>;        f[k<span class="hljs-number">-1</span>][nw] = <span class="hljs-number">0</span>;        ll mx = f[k<span class="hljs-number">-1</span>][nw^<span class="hljs-number">1</span>] + a[k], mi = a[k] - f[k<span class="hljs-number">-1</span>][nw^<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k;i&lt;=n;i++)&#123;            f[i][nw] = <span class="hljs-built_in">max</span>(&#123;f[i<span class="hljs-number">-1</span>][nw], mx - a[i], a[i] - mi&#125;);            mx = <span class="hljs-built_in">max</span>(mx, f[i][nw^<span class="hljs-number">1</span>] + a[i+<span class="hljs-number">1</span>]);            mi = <span class="hljs-built_in">min</span>(mi, a[i+<span class="hljs-number">1</span>] - f[i][nw^<span class="hljs-number">1</span>]);        &#125;    &#125;    cout &lt;&lt; f[n][m%<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>校赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 774 div.2 DEF</title>
    <link href="/2022/03/05/2022-03-05-Codeforces%20Round%20774%20div.2%20DEF/"/>
    <url>/2022/03/05/2022-03-05-Codeforces%20Round%20774%20div.2%20DEF/</url>
    
    <content type="html"><![CDATA[<h4 id="D-Weight-the-Tree"><a href="#D-Weight-the-Tree" class="headerlink" title="D. Weight the Tree"></a>D. Weight the Tree</h4><p>题意：给定一棵树，每个节点有一权重 $w_i$，若一个节点的权值等于其相邻点的权值之和，则这个节点是好的。现在你可以为每个，使得好的点数量最多，在这基础上，还要使得总权值最小，输出赋值方案。</p><p>首先想到，除了 $n&#x3D;2$ 的情况，相邻两个点不可能都是好的</p><p>对于不好的点，肯定让它为1（$w_i\ge1$），那么好的点的权值一定等于其度数，我们要选上一些不相邻的点使得它<strong>好</strong>。</p><p>考虑树上dp，$dp[i,0&#x2F;1]$ 表示以 $i$ 为根节点的子树，选&#x2F;不选根节点时的最优解。这里比较难想的一点在于，解居然包括了两个信息：好节点数量和总权值。似乎和通常的dp不太一样，但仔细想想是没问题的，因为两个解仍然可以排序：先按照好节点数，再按照总权值。</p><p>当前节点选，则其子节点都不能选，当前节点不选，则其子节点任意。</p><p>最后要输出方案，从上往下跑一遍就可以了：每个节点的 $dp[i,1]$ 和 $dp[i, 0]$ 比较一下，确定当前点是否选，如果其父节点选了，则强制这个点不选，这样往下搜下去就能确定方案了，</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, du[maxn];vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];<span class="hljs-type">int</span> f[maxn][<span class="hljs-number">2</span>], g[maxn][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">chose</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    <span class="hljs-keyword">if</span>(f[x][<span class="hljs-number">1</span>] == f[x][<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> g[x][<span class="hljs-number">1</span>] &lt; g[x][<span class="hljs-number">0</span>];    <span class="hljs-keyword">return</span> f[x][<span class="hljs-number">1</span>] &gt; f[x][<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa = <span class="hljs-number">-1</span>)</span></span>&#123;    f[p][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, f[p][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    g[p][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, g[p][<span class="hljs-number">1</span>] = du[p];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v != fa)&#123;            <span class="hljs-built_in">dfs</span>(v, p);            f[p][<span class="hljs-number">1</span>] += f[v][<span class="hljs-number">0</span>];            g[p][<span class="hljs-number">1</span>] += g[v][<span class="hljs-number">0</span>];            <span class="hljs-type">int</span> cs = <span class="hljs-built_in">chose</span>(v);            f[p][<span class="hljs-number">0</span>] += f[v][cs];            g[p][<span class="hljs-number">0</span>] += g[v][cs];        &#125;    &#125;&#125;<span class="hljs-type">int</span> ans[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getans</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> cs)</span></span>&#123;    ans[p] = cs ? du[p] : <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v: vp[p])&#123;        <span class="hljs-keyword">if</span>(v != fa)&#123;            <span class="hljs-keyword">if</span>(cs) <span class="hljs-built_in">getans</span>(v, p, <span class="hljs-number">0</span>);            <span class="hljs-keyword">else</span> <span class="hljs-built_in">getans</span>(v, p, <span class="hljs-built_in">chose</span>(v));        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;2 2\n1 1\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        du[x]++, du[y]++;        vp[x].<span class="hljs-built_in">emplace_back</span>(y);        vp[y].<span class="hljs-built_in">emplace_back</span>(x);    &#125;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);    <span class="hljs-type">int</span> cs = <span class="hljs-built_in">chose</span>(<span class="hljs-number">1</span>);    <span class="hljs-built_in">getans</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, cs);    cout &lt;&lt; f[<span class="hljs-number">1</span>][cs] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; g[<span class="hljs-number">1</span>][cs] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;</code></pre></div><h4 id="E-Power-Board"><a href="#E-Power-Board" class="headerlink" title="E. Power Board"></a>E. Power Board</h4><p>题意：给出一个 $n\times m$ 的图，$(i,j)$ 点上的数字为 $i^j$ ，请问这个图里有多少个不同的数字？</p><p><a href="https://codeforces.com/blog/entry/100584">没法比题解写的更清楚了</a>（摆</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">bool</span> vis[maxn &lt;&lt; <span class="hljs-number">5</span>];<span class="hljs-type">int</span> cnt[<span class="hljs-number">32</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">23</span>;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;            <span class="hljs-keyword">if</span>(!vis[i * j])&#123;                vis[i * j] = <span class="hljs-literal">true</span>;                tot++;            &#125;        &#125;        cnt[i] = tot;    &#125;    <span class="hljs-built_in">fill</span>(vis, vis+n+<span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);    ll ans = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(!vis[i])&#123;            <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(ll j=i;j&lt;=n;j*=i)&#123;                vis[j] = <span class="hljs-literal">true</span>;                k++;            &#125;            ans += cnt[k];        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="F-Playing-Around-the-Table"><a href="#F-Playing-Around-the-Table" class="headerlink" title="F. Playing Around the Table"></a>F. Playing Around the Table</h4><p>题意：有 $n$ 名玩家坐成一个环，一共有 $n^2$ 张卡牌，$1-n$ 每种卡牌各 $n$ 张，开局每名玩家持有其中 $n$ 张，接下来进行游戏：每轮中，每名玩家交给下一名玩家一张卡牌（所有人同时进行），如果玩家 $i$ 的所有卡牌都为 $i$，则其“牢固”。现要你构造一种游戏方案，至多 $n^2-n$ 轮，使得每名玩家都“牢固”。</p><p>一开始有个暴力的想法，每轮每个人都直接找一个不属于自己的卡牌传出去，然而这样显然会遇到死循环的情况。</p><p>全变成一样的不好搞，能不能先全变成不一样的呢？也就是让每个人都拥有1到n的所有卡牌。</p><p>这个比较好搞，每次每人都找一张自己有重复的卡牌交出去，如果自己没有重复的，就把上一个人传过来的交出去，这样最终一定能满足。</p><p>第一步能在可接受的步数内完成吗？对于每一种卡牌，考虑其最坏的情况：初始所有这张牌都在一个人手上，那么根据上述传递方案，这张牌一共会被传递 $1+2+…+n-1$ 次，即 $\frac{n\times(n-1)}{2}$ 次，那么一共 $n$ 张牌，一轮能传递 $n$ 次，总轮次不会超过 $\frac{n\times(n-1)}{2}$。</p><p>现在所有人的牌都是 $1..n$ 了，下一步怎么搞都行</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<span class="hljs-type">int</span> cnt[<span class="hljs-number">103</span>][<span class="hljs-number">103</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;            <span class="hljs-type">int</span> x; cin &gt;&gt; x;            cnt[i][x]++;        &#125;    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pass</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;            pass[i] = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;                <span class="hljs-keyword">if</span>(cnt[i][j] &gt; <span class="hljs-number">1</span>)&#123;                    pass[i] = j;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">if</span>(pass[i] == <span class="hljs-number">0</span>) pass[i] = pass[(i<span class="hljs-number">-1</span>+n<span class="hljs-number">-1</span>)%n+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">if</span>(pass[i] == <span class="hljs-number">0</span>) pass[i] = pass[(i<span class="hljs-number">-1</span>+n<span class="hljs-number">-1</span>)%n+<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span>(pass[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;            cnt[i][pass[i]]--;            cnt[i%n+<span class="hljs-number">1</span>][pass[i]]++;        &#125;        ans.<span class="hljs-built_in">push_back</span>(pass);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;n;k++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d=k;d&gt;=<span class="hljs-number">1</span>;d--)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;                pass[i] = (i + d - <span class="hljs-number">1</span>) % n + <span class="hljs-number">1</span>;            &#125;            ans.<span class="hljs-built_in">push_back</span>(pass);        &#125;    &#125;    cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ps: ans)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;ps.<span class="hljs-built_in">size</span>();i++) cout &lt;&lt; ps[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == ps.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 773 div.2 F</title>
    <link href="/2022/02/23/2022-02-20-Codeforces%20Round%20773%20div.2%20F/"/>
    <url>/2022/02/23/2022-02-20-Codeforces%20Round%20773%20div.2%20F/</url>
    
    <content type="html"><![CDATA[<h4 id="F-Two-Arrays"><a href="#F-Two-Arrays" class="headerlink" title="F. Two Arrays"></a>F. Two Arrays</h4><p>题意：给出 $n$ 个数组，每个数组都有 $m$ 个不同元素，有权值 $w_i$，我们称两个不包含相同元素的数组<strong>是匹配的</strong>，要求匹配的数组对当中， $w_i+w_j$ 的最小值（$n\le10^5,m\le5,a_i\le10^9$）</p><p><strong>奇技淫巧：</strong></p><p>哈希，我们可以把 $w$ 映射到一个很小的范围上去（比如1000以内），可能会产生冲突，但要导致最终结果出错，当前仅当作为答案选取的两个数组 $i,j$ 中的至多10个不同元素映射产生了冲突，可以估计，产生冲突的概率是很小的。</p><p>这样我们就将 $w$ 的值域压缩到了一个很小的范围。</p><p>这个冲突概率大概是1%左右，为了避免运气不好，可以卡个时多次跑，取最小ans</p><p><strong>解法一：</strong></p><p>首先考虑bitset的 $n^2$ 暴力</p><p>先将所有数组按照 $w$ 排序</p><p>对每个权值，用bitset记录它在哪些数组上出现过</p><p>然后暴力枚举每个数组，把它的元素出现过的位置或起来</p><p>然后取最早的从未出现的位置，更新答案。</p><p>复杂度 $O(n^2m&#x2F;64)$，值域压缩后，空间复杂度 $10000\times n$（）</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;    <span class="hljs-type">int</span> v[<span class="hljs-number">6</span>];    <span class="hljs-type">int</span> w;&#125;a[maxn];bitset&lt;maxn&gt; t[<span class="hljs-number">13335</span>], p; <span class="hljs-type">int</span> n, m;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;            cin &gt;&gt; a[i].v[j];            a[i].v[j] %= <span class="hljs-number">13335</span>;        &#125;        cin &gt;&gt; a[i].w;    &#125;    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+n+<span class="hljs-number">1</span>, [](node x, node y)&#123; <span class="hljs-keyword">return</span> x.w &lt; y.w;&#125;);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++) t[a[i].v[j]][i<span class="hljs-number">-1</span>] = <span class="hljs-literal">true</span>;     ll ans = <span class="hljs-number">1e18</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        p = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++) p |= t[a[i].v[j]];        <span class="hljs-type">int</span> pos = <span class="hljs-number">1</span> + (~p)._Find_first();        <span class="hljs-keyword">if</span>(pos &lt; i &amp;&amp; pos &gt; <span class="hljs-number">0</span>) ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-number">1ll</span> * a[pos].w + a[i].w);    &#125;        <span class="hljs-keyword">if</span>(ans &gt; (ll)<span class="hljs-number">1e17</span>) ans = <span class="hljs-number">-1</span>;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><p><strong>解法二：</strong></p><p>同样压缩值域，狠一点直接压缩到20</p><p>这样我们就可以用一个int来表示一个数组</p><p>然后问题就转换为了：有 $n$ 个数对： $a_i,w_i$ ，要求一个数对 $i,j$，满足 $a_i&amp;a_j$ 为0，使 $w_i+wj$ 最大</p><p>然后似乎可以SOSDP？</p><p><strong>解法三（正解）：</strong></p><p>如果要无概率呢？</p><p>我们需要一个东西来快速<strong>判断一段区间内有无数组能和一个新数组匹配</strong></p><p>考虑两个数组 $a,b$，如何判断它们能否匹配，当然可以简单地扫一遍，但这不能扩展</p><p>先说结论：我们把 $a$ 的所有子集都存进一个set，然后对于 $b$ 的每个子集，如果它在 $a$ 中出现过：</p><ul><li>如果这个子集有奇数个元素，记1</li><li>如果这个子集有偶数个元素，记-1</li></ul><p>可以预想，假设 $a$ 与 $b$ 共有 $k$ 个相同元素，它们重复的子集个数则有 $2^k$ 个，去掉空集，奇数子集将比偶数子集多一个。</p><p>那么这么计数得到的结果一定是1，除非 $a$ 与 $b$ <strong>完全不同</strong>，结果才为0</p><p>这样下来，如果我们要拿 $b$ 和 $a_1,a_2…a_t$ 这 $t$ 个数组匹配，就只需要把这 $m$ 个数组的所有子集加入集合（不去重），然后再拿 $b$ 去按上述方式计数，如果 $b$ 和所有 $a$ 都无法匹配，计数结果即为 $t$</p><p>不过如果这里我们用mutiset的话，复杂度为 $O(n\times2^m\times log(n\times2^m))$ ，有点难以接受，可以用字典树来统计每个集合出现了多少次。</p><p>最后的解法：</p><p>先将数组们按照 $w$ 排序，然后用双指针 $l,r$，先不断将 $r$ 右移，找到第一个可以和前 $r-1$ 个数匹配的位置，然后将 $l$ 从这个 $r$ 的位置不断左移，直到 $r$ 不能再和前 $l$ 个数组匹配为止。</p><p>这样我们就找到了第一组解，因为 $w$ 是排序好的，后续 $l$ 不需要再向右移动，右移 $r$ 的过程中发现前 $l$  个数组与 $r$ 不匹配了，就将 $l$ 左移，然后更新答案。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> Tire&#123;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tire</span>&#123;        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; ch;        <span class="hljs-type">int</span> num;    &#125;t[<span class="hljs-number">3200020</span>];    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> ad)</span></span>&#123;        <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:arr)&#123;            <span class="hljs-keyword">if</span>(!t[p].ch.<span class="hljs-built_in">count</span>(v)) t[p].ch[v] = ++cnt;            p = t[p].ch[v];        &#125;        t[p].num += ad;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span></span>&#123;        <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:arr)&#123;            <span class="hljs-keyword">if</span>(!t[p].ch.<span class="hljs-built_in">count</span>(v)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            p = t[p].ch[v];        &#125;        <span class="hljs-keyword">return</span> t[p].num;    &#125;&#125; <span class="hljs-type">int</span> n, m;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;    vector&lt;<span class="hljs-type">int</span>&gt; v;    <span class="hljs-type">int</span> w;&#125;a[maxn]; vector&lt;<span class="hljs-type">int</span>&gt; csd;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> p, vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> ad)</span></span>&#123;    <span class="hljs-keyword">if</span>(p &gt;= arr.<span class="hljs-built_in">size</span>())&#123;        <span class="hljs-keyword">if</span>(csd.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(ad &gt; <span class="hljs-number">0</span>) Tire::<span class="hljs-built_in">insert</span>(csd, <span class="hljs-number">1</span>);        <span class="hljs-keyword">else</span> Tire::<span class="hljs-built_in">insert</span>(csd, <span class="hljs-number">-1</span>);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-built_in">add</span>(p+<span class="hljs-number">1</span>, arr, ad);    csd.<span class="hljs-built_in">push_back</span>(arr[p]);    <span class="hljs-built_in">add</span>(p+<span class="hljs-number">1</span>, arr, ad);    csd.<span class="hljs-built_in">pop_back</span>();&#125; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calcu</span><span class="hljs-params">(<span class="hljs-type">int</span> p, vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span></span>&#123;    <span class="hljs-keyword">if</span>(p &gt;= arr.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> Tire::<span class="hljs-built_in">query</span>(csd) * ((csd.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>);    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;    res += <span class="hljs-built_in">calcu</span>(p+<span class="hljs-number">1</span>, arr);    csd.<span class="hljs-built_in">push_back</span>(arr[p]);    res += <span class="hljs-built_in">calcu</span>(p+<span class="hljs-number">1</span>, arr);    csd.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-keyword">return</span> res;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        a[i].v.<span class="hljs-built_in">resize</span>(m);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;            cin &gt;&gt; a[i].v[j<span class="hljs-number">-1</span>];        &#125;        <span class="hljs-built_in">sort</span>(a[i].v.<span class="hljs-built_in">begin</span>(), a[i].v.<span class="hljs-built_in">end</span>());        cin &gt;&gt; a[i].w;    &#125;    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+n+<span class="hljs-number">1</span>, [](node &amp;x, node &amp;y)&#123; <span class="hljs-keyword">return</span> x.w &lt; y.w;&#125;);    <span class="hljs-type">int</span> l, r = n + <span class="hljs-number">1</span>, ans = <span class="hljs-number">2e9</span> + <span class="hljs-number">1</span>;     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">calcu</span>(<span class="hljs-number">0</span>, a[i].v) == i<span class="hljs-number">-1</span>)&#123;            <span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, a[i].v, <span class="hljs-number">1</span>);        &#125;<span class="hljs-keyword">else</span>&#123;            l = i<span class="hljs-number">-1</span>, r = i+<span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">calcu</span>(<span class="hljs-number">0</span>, a[i].v) != l)&#123;                <span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, a[l].v, <span class="hljs-number">-1</span>);                ans = <span class="hljs-built_in">min</span>(ans, a[i].w + a[l].w);                l--;            &#125;            <span class="hljs-keyword">break</span>;        &#125;    &#125;     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=r;i&lt;=n &amp;&amp; l&gt;<span class="hljs-number">0</span>;i++)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">calcu</span>(<span class="hljs-number">0</span>, a[i].v) != l)&#123;            <span class="hljs-keyword">while</span>(l &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">calcu</span>(<span class="hljs-number">0</span>, a[i].v) != l)&#123;                <span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, a[l].v, <span class="hljs-number">-1</span>);                ans = <span class="hljs-built_in">min</span>(ans, a[i].w + a[l].w);                l--;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(ans &gt; (<span class="hljs-type">int</span>)<span class="hljs-number">2e9</span>) ans = <span class="hljs-number">-1</span>;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 772 div.2 A-F</title>
    <link href="/2022/02/20/2022-02-20-Codeforces%20Round%20772%20div.2/"/>
    <url>/2022/02/20/2022-02-20-Codeforces%20Round%20772%20div.2/</url>
    
    <content type="html"><![CDATA[<h4 id="A-Min-Or-Sum"><a href="#A-Min-Or-Sum" class="headerlink" title="A. Min Or Sum"></a>A. Min Or Sum</h4><p>题意：有一个数组 $a$，你可以进行任意次操作：取两个数 $a_i,a_j$，将这两个数分别改为 $x,y$，要求 $a_i|a_j&#x3D;x|y$ 问可能得到数组总和最小值。</p><p>我们显然可以把二进制中每一位上多余的部分全部删光，只留一个，答案即所有数或起来</p><div class="code-wrapper"><pre><code class="hljs c++">ll n, m;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    ll ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        ll x; cin &gt;&gt; x;        ans |= x;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="B-Avoid-Local-Maximums"><a href="#B-Avoid-Local-Maximums" class="headerlink" title="B. Avoid Local Maximums"></a>B. Avoid Local Maximums</h4><p>题意：给一个数组 $a$，每次操作将任一个数修改为任意其他数，问至少操作几次，使得数组中不存在山峰（“山峰”即 $a_i &gt;a_{i-1}$ 且 $a_i &gt; a_{i+1}$ ）</p><p>我们可以把每个山峰都抹平，使之变成它两侧的较小值，但还有一种情况：两个山峰相邻（即下标相差2），那么可以把中间位置抬高到两山峰中的较大值，一次性消除两个山峰，模拟即可。</p><div class="code-wrapper"><pre><code class="hljs c++">ll n, m;<span class="hljs-type">int</span> a[maxn]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    vector&lt;<span class="hljs-type">int</span>&gt; f;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;i++)&#123;        <span class="hljs-keyword">if</span>(a[i] &gt; a[i<span class="hljs-number">-1</span>] &amp;&amp; a[i] &gt; a[i+<span class="hljs-number">1</span>]) f.<span class="hljs-built_in">push_back</span>(i);    &#125;    ll ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;f.<span class="hljs-built_in">size</span>();i++)&#123;        <span class="hljs-keyword">if</span>(i != f.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> &amp;&amp; f[i] == f[i+<span class="hljs-number">1</span>] - <span class="hljs-number">2</span>)&#123;            a[f[i] + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(a[f[i]], a[f[i] + <span class="hljs-number">2</span>]);            ans++, i++;        &#125;<span class="hljs-keyword">else</span>&#123;            a[f[i]] = <span class="hljs-built_in">max</span>(a[f[i]<span class="hljs-number">-1</span>], a[f[i]+<span class="hljs-number">1</span>]);            ans++;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];&#125;</code></pre></div><h4 id="C-Differential-Sorting"><a href="#C-Differential-Sorting" class="headerlink" title="C. Differential Sorting"></a>C. Differential Sorting</h4><p>题意：给一个数组 $a$，每次操作可以选择三个位置 $x,y,z(x&lt;y&lt;z)$，使得 $a_x$ 变为 $a_y-a_z$，要求构造一种操作方案，使得整个数组单调不降。</p><p>显然，最后两位是无法修改的，那么如果最后两位是递增的，一定不成立</p><p>排除这种情况后，此时 $a_n$ 为最大值，如果 $a_n&lt;0$，$a_{n-2}$ 必然比 $a_{n-1}$ 大，一定不行</p><p>现在有 $a_n\ge0$，我们向前枚举，后面的部分已经有序，那么直接拿 $a_{i+1}-a_n$ 得到 $a_i$，就能使 $a_i$ 越来越小。 </p><div class="code-wrapper"><pre><code class="hljs c++">ll n, m;ll a[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-type">bool</span> f = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-keyword">if</span>(a[i] &gt; a[i+<span class="hljs-number">1</span>])&#123;            f = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span>(f)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">max</span>(a[n], a[n<span class="hljs-number">-1</span>]) &lt; <span class="hljs-number">0</span> || a[n] &lt; a[n<span class="hljs-number">-1</span>])&#123;        cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;     cout &lt;&lt; n<span class="hljs-number">-2</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; i+<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div><h4 id="D-Infinite-Set"><a href="#D-Infinite-Set" class="headerlink" title="D. Infinite Set"></a>D. Infinite Set</h4><p>题意：有一个集合 $a$，初始有一些数，如果 $x$ 在集合中，那么 $2x+1$ 和 $4x$ 都在集合中，现在问集合中小于 $2^p$ 的数共有多少个？（$p\le2\times10^5$）</p><p>首先我们把问题简化：$2x+1$ 其实就是在 $x$ 的二进制表示下添个1，$4x$ 就是添两个0</p><p>对任一个 $x$​ 而言，我们不断的对它进行上面两种操作，产生的新数字是不会重复的。</p><p>设 $f_i$ 表示二进制最高位为 $i$ 的数的个数，那么有递推式 $f_i &#x3D; f_{i-1}+f_{i-2}$</p><p>为了方便处理，首先把本质相同的 $a_i$ 去掉（只保留一个），即如果 $a_j$ 的二进制可以表示为 $a_i+00100..$ 则 $a_j$ 和 $a_i$ 本质相同，后面的 $00100$ 要求是由 $1$ 和 $00$ 组成的串，判重可以用01字典树完成。</p><p>这样我们把本质不同的数先加入 $f$ 数组，就得到了初值，随后dp即可。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn], cnt[maxn];ll f[maxn];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">tire</span>&#123;    <span class="hljs-type">int</span> ch[<span class="hljs-number">2</span>];    <span class="hljs-type">bool</span> end;&#125;t[maxn &lt;&lt; <span class="hljs-number">5</span>];<span class="hljs-type">int</span> tcnt = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mxk</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    <span class="hljs-type">int</span> mxk = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">0</span>)&#123;        x /= <span class="hljs-number">2</span>;        mxk++;    &#125;    <span class="hljs-keyword">return</span> mxk;&#125; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;    vector&lt;<span class="hljs-type">int</span>&gt; vp;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">mxk</span>(x);i&gt;=<span class="hljs-number">1</span>;i--)&#123;        <span class="hljs-type">int</span> v = (x &gt;&gt; (i<span class="hljs-number">-1</span>)) &amp; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(!t[p].ch[v]) t[p].ch[v] = ++tcnt;        p = t[p].ch[v];        vp.<span class="hljs-built_in">push_back</span>(p);    &#125;    <span class="hljs-keyword">if</span>(t[p].end) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    t[p].end = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">if</span>(vp.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=vp.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;        <span class="hljs-keyword">if</span>(i != vp.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> &amp;&amp; t[vp[i]].end) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-type">int</span> v = x % <span class="hljs-number">2</span>;        x /= <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(v) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">0</span> &amp;&amp; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) x /= <span class="hljs-number">2</span>, i--;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+n+<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">add</span>(a[i]))&#123;            cnt[<span class="hljs-built_in">mxk</span>(a[i])]++;        &#125;    &#125;    ll tot = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">1</span>) f[i] = (f[i<span class="hljs-number">-1</span>] + f[i<span class="hljs-number">-2</span>]) % mode;        (f[i] += cnt[i]) %= mode;        tot = (tot + f[i]) % mode;<span class="hljs-comment">//        cout &lt;&lt; f[i] &lt;&lt; &#x27;\n&#x27;;</span>    &#125;    cout &lt;&lt; tot &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="E-Cars"><a href="#E-Cars" class="headerlink" title="E. Cars"></a>E. Cars</h4><p>题意：$x$ 轴上有 $n$ 辆车，每辆车有位置和朝向，不知道他们的具体情况，但知道 $m$ 条信息：</p><ul><li>$i,j$ 两辆车方向相反，接下来会撞上</li><li>$i,j$ 两辆车方向相反，但是会越来越远</li></ul><p>要输出所有车的情况，或者输出-1表示不存在这种情况</p><p>方向和位置信息一起考虑比较复杂，我们分开考虑：</p><p>首先任意一对关系，都说明他们的方向相反，我们在 $i,j$ 之间连一条边，得到一张图之后染色，判断方向是否存在冲突。</p><p>因为左右对称性，第一辆车的方向是无所谓的，我们假设第一辆车的方向是 $L$，然后再跑一次这张图，这次可以根据两个相邻点的方向和它们之间的关系，判断谁在谁左边。假设 $i$ 在 $j$ 左边，那么在一个新的图中让 $i$ 向 $j$ 连一条有向边。</p><p>构成的这个新图中，如果存在环即不存在答案。</p><p>随后按照拓扑序给每个节点分配位置即可。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; vp[maxn];vector&lt;<span class="hljs-type">int</span>&gt; vp2[maxn];<span class="hljs-type">int</span> col[maxn]; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> c)</span></span>&#123;    col[p] = c;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:vp[p])&#123;        <span class="hljs-keyword">if</span>(col[v.first])&#123;            <span class="hljs-keyword">if</span>(col[v.first] == <span class="hljs-number">3</span> - c) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(v.first, <span class="hljs-number">3</span> - c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125; <span class="hljs-type">bool</span> vis[maxn];<span class="hljs-type">int</span> du[maxn], dir[maxn], pos[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> d)</span></span>&#123;    <span class="hljs-keyword">if</span>(vis[p]) <span class="hljs-keyword">return</span>;    dir[p] = d;    vis[p] = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:vp[p])&#123;        <span class="hljs-keyword">if</span>(v.second == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span>(d == <span class="hljs-number">1</span>) vp2[v.first].<span class="hljs-built_in">push_back</span>(p), du[p]++;            <span class="hljs-keyword">else</span> vp2[p].<span class="hljs-built_in">push_back</span>(v.first), du[v.first]++;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(d == <span class="hljs-number">0</span>) vp2[v.first].<span class="hljs-built_in">push_back</span>(p), du[p]++;            <span class="hljs-keyword">else</span> vp2[p].<span class="hljs-built_in">push_back</span>(v.first), du[v.first]++;        &#125;        <span class="hljs-built_in">dfs2</span>(v.first, d ^ <span class="hljs-number">1</span>);    &#125;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-type">int</span> t, x, y;        cin &gt;&gt; t &gt;&gt; x &gt;&gt; y;        vp[x].<span class="hljs-built_in">emplace_back</span>(y, t);        vp[y].<span class="hljs-built_in">emplace_back</span>(x, t);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(!col[i] &amp;&amp; !<span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">1</span>))&#123;            cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">dfs2</span>(i, <span class="hljs-number">1</span>);     queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">if</span>(!du[i]) q.<span class="hljs-built_in">push</span>(i);    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;        <span class="hljs-type">int</span> p = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();        pos[p] = ++tot;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:vp2[p])&#123;            du[v]--;            <span class="hljs-keyword">if</span>(du[v] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(v);        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(!pos[i])&#123;            cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;LR&quot;</span>[dir[i]] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; pos[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div><h4 id="F-Closest-Pair"><a href="#F-Closest-Pair" class="headerlink" title="F. Closest Pair"></a>F. Closest Pair</h4><p>题意：有 $n$ 个点，每个点有坐标 $x_i$（$x_i$ 保证有序） 和权值 $w_i$，接下来有一堆询问，每次问 $[l, r]$ 这段点中，点对 $i,j$ 的 $|x_ i-x_j|\times(w_i+w_j)$ 的最小值。</p><p>这道题的思维比较巧妙</p><p>在一段区间中，如果 $i,j$ 这个点对是值最小的点对，那么 $i,j$ 之间一定不存在另一个 $w_k$ 介于 $w_i, w_j$ 之间（不然最小值就是 $i,k$ 了）</p><p>所以对于每个点 $i$，取它左右两端第一个 $w_j&lt;w_i$ 的 $j$，答案一定在这 $2n$ 个点对当中。</p><p>这样问题就转换为了：有 $2n$ 条带权的线段，每次询问一个区间，问这个区间包含的线段的最大值是多少。</p><p>离线+线段树维护最小值即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegTree</span>&#123;    ll mi[maxn &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;        mi[p] = <span class="hljs-built_in">min</span>(mi[p*<span class="hljs-number">2</span>], mi[p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pos, ll to)</span></span>&#123;        <span class="hljs-keyword">if</span>(l == r)&#123;            mi[p] = <span class="hljs-built_in">min</span>(mi[p], to);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(pos &lt;= mid) <span class="hljs-built_in">modify</span>(p*<span class="hljs-number">2</span>, l, mid, pos, to);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r, pos, to);        <span class="hljs-built_in">push_up</span>(p);    &#125;    <span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span></span>&#123;        <span class="hljs-keyword">if</span>(R &lt; l || r &lt; L) <span class="hljs-keyword">return</span> <span class="hljs-number">4e18</span>;        <span class="hljs-keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> mi[p];        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">query</span>(p*<span class="hljs-number">2</span>, l, mid, L, R), <span class="hljs-built_in">query</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r, L, R));    &#125;&#125;segt; vector&lt;pair&lt;<span class="hljs-type">int</span>, ll&gt;&gt; seg[maxn];vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; qr[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n, q;    cin &gt;&gt; n &gt;&gt; q;    <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">x</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span>, <span class="hljs-title">w</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; x[i] &gt;&gt; w[i];    &#125;    <span class="hljs-built_in">fill</span>(segt.mi, segt.mi + (maxn &lt;&lt; <span class="hljs-number">2</span>), <span class="hljs-number">4e18</span>);    stack&lt;<span class="hljs-type">int</span>&gt; st;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; w[i] &lt;= w[st.<span class="hljs-built_in">top</span>()])&#123;            seg[i].<span class="hljs-built_in">emplace_back</span>(st.<span class="hljs-built_in">top</span>(), (w[i] + w[st.<span class="hljs-built_in">top</span>()]) * (x[i] - x[st.<span class="hljs-built_in">top</span>()]));<span class="hljs-comment">//            cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; st.top() &lt;&lt; &#x27;\n&#x27;;</span>            st.<span class="hljs-built_in">pop</span>();        &#125;        <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">empty</span>())&#123;            seg[i].<span class="hljs-built_in">emplace_back</span>(st.<span class="hljs-built_in">top</span>(), (w[i] + w[st.<span class="hljs-built_in">top</span>()]) * (x[i] - x[st.<span class="hljs-built_in">top</span>()]));<span class="hljs-comment">//            cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; st.top() &lt;&lt; &#x27;\n&#x27;;</span>        &#125;        st.<span class="hljs-built_in">push</span>(i);    &#125;     <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">ans</span><span class="hljs-params">(q+<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;        <span class="hljs-type">int</span> l, r; cin &gt;&gt; l &gt;&gt; r;        qr[r].<span class="hljs-built_in">emplace_back</span>(l, i);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:seg[i])            segt.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, v.first, v.second);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:qr[i])&#123;            ans[v.second] = segt.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, v.first, n);        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 770 div.2 EF</title>
    <link href="/2022/02/06/2022-02-06-Codeforces%20Round%20770%20div.2%20EF/"/>
    <url>/2022/02/06/2022-02-06-Codeforces%20Round%20770%20div.2%20EF/</url>
    
    <content type="html"><![CDATA[<h4 id="E-Fair-Share"><a href="#E-Fair-Share" class="headerlink" title="E. Fair Share"></a>E. Fair Share</h4><p>题意：有 $n$ 组物品，第 $i$ 组有 $m_i$ 个，每个物品有一个编号，保证每种物品出现偶数次，每组物品有偶数个，要求将所有物品划分为两组，使得一组中有每种物品各一半，每组物品各一半。 </p><p>首先将问题抽象出来，组别和物品类别其实没有什么区别，都是物品的属性；</p><p>建图：左边点表示组别，右边点表示类别，$i$ 组中包含物品 $j$，则连边 $i,j$</p><p>因为保证了物品出现偶数次，一组也有偶数个物品，那么这张图必然存在若干条欧拉回路</p><p>寻找欧拉回路，对于每条欧拉回路，如果一条边是由左到右遍历，则分至 $L$ 组，否则分至 $R$ 组，由于欧拉回路的性质（一个点的入次数和出次数相等，这样一定能保证恰好均分）</p><p>然后我发现我好像从来没写过欧拉回路，想当然的写了一波TLE了一页（</p><p>关键在于，欧拉回路标记vis的是边而不是点，一个点可能遍历多次，如果还是每遍历到一个点就去遍历它的所有连边，即使有vis标记忽略已经走过的边，还是会变成 $n^2$ </p><p>需要记录每个店最后一次遍历的边是哪条，下次再跑直接从这开始即可。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;    <span class="hljs-type">int</span> x, y, pj, vis;&#125;e[maxn];<span class="hljs-type">int</span> ecnt = <span class="hljs-number">0</span>;vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];<span class="hljs-type">int</span> lst[maxn];string ans[maxn]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=lst[p];j&lt;vp[p].<span class="hljs-built_in">size</span>();j=lst[p])&#123;        <span class="hljs-type">int</span> i = vp[p][j];        lst[p] = j+<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(e[i].vis) <span class="hljs-keyword">continue</span>;        e[i].vis = <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(p &lt;= n)&#123;            ans[e[i].x][e[i].pj] = <span class="hljs-string">&#x27;L&#x27;</span>;            <span class="hljs-built_in">dfs</span>(e[i].y);        &#125;<span class="hljs-keyword">else</span>&#123;            ans[e[i].x][e[i].pj] = <span class="hljs-string">&#x27;R&#x27;</span>;            <span class="hljs-built_in">dfs</span>(e[i].x);        &#125;    &#125;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; lsh;    <span class="hljs-type">int</span> tot = n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; m;        ans[i] = <span class="hljs-built_in">string</span>(m, <span class="hljs-string">&#x27;\0&#x27;</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;            <span class="hljs-type">int</span> x; cin &gt;&gt; x;            <span class="hljs-keyword">if</span>(!lsh[x]) lsh[x] = ++tot;            e[++ecnt] = &#123;i, lsh[x], j, <span class="hljs-number">0</span>&#125;;            vp[lsh[x]].<span class="hljs-built_in">push_back</span>(ecnt);            vp[i].<span class="hljs-built_in">push_back</span>(ecnt);        &#125;    &#125;;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=tot;i++)&#123;        <span class="hljs-keyword">if</span>(vp[i].<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;            cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=tot;i++) <span class="hljs-keyword">if</span>(lst[i] &lt; vp[i].<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">dfs</span>(i);    cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="F-Fibonacci-Additions"><a href="#F-Fibonacci-Additions" class="headerlink" title="F. Fibonacci Additions"></a>F. Fibonacci Additions</h4><p>一道差分好题</p><p>题意：有长度为 $n$ 的 $a$ 数组和 $b$ 数组，接下来有若干次修改：使 $a$ 或者 $b$ 数组的 $[l,r]$ 段依次加上斐波那契数列，即 $a_l+1$，$a_{l+1}+1$，$a_{l+3}+2$…</p><p>每次修改完成后，要求输出 $a$ 与 $b$ 是否完全相等。</p><p>首先需要利用斐波那契数列的性质：$f_i&#x3D;f_{i-1}+f_{i-2}$</p><p>在空数组上随便修改几段试一下就会发现，不论怎么修改，在修改量上，永远有 $d_i&#x3D;d_{i-1}+d_{i-2}$</p><p>既然如此，可以考虑对修改量差分（前缀和的形式改为斐波那契形式）</p><p>写个例子理解一下，比如要对3-6这段区间加斐波那契数列：</p><p>修改量：0 0 f1 f2 f3 f4   0   0   0</p><p>差分d： 0 0  f1  0  0  0  -f5 -f4 0</p><p>如果我们对差分数组这样修改，那么它的斐波那契前缀和即为修改量；</p><p>这样就简单啦，显然任意一组修改量和它的差分数组是一一对应的，我们直接把初始情况转化为差分数组，然后每次在差分数组上进行3次单点修改，就可以很方便的判断是否一样了。</p><div class="code-wrapper"><pre><code class="hljs c++">ll n, q, mod, a[maxn], tot = <span class="hljs-number">0</span>;ll f[maxn]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(ll x, ll ad)</span></span>&#123;    <span class="hljs-keyword">if</span>(x &gt; n) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(a[x] == <span class="hljs-number">0</span>) tot--;    a[x] = (a[x] + ad + mod) % mod;    <span class="hljs-keyword">if</span>(a[x] == <span class="hljs-number">0</span>) tot++;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; q &gt;&gt; mod;    f[<span class="hljs-number">1</span>] = f[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">3</span>;i&lt;=n;i++) f[i] = (f[i<span class="hljs-number">-1</span>] + f[i<span class="hljs-number">-2</span>]) % mod;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        ll x; cin &gt;&gt; x;        a[i] -= x;        a[i] = (a[i] % mod + mod) % mod;    &#125;    <span class="hljs-keyword">for</span>(ll i=n;i&gt;=<span class="hljs-number">2</span>;i--) a[i] -= a[i<span class="hljs-number">-1</span>] + a[i<span class="hljs-number">-2</span>], a[i] = (a[i] % mod + mod) % mod;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++) tot += !a[i];     <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;        <span class="hljs-type">char</span> c; ll x, y;        cin &gt;&gt; c &gt;&gt; x &gt;&gt; y;        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;A&#x27;</span>)&#123;            <span class="hljs-built_in">modify</span>(x, <span class="hljs-number">1</span>);            <span class="hljs-built_in">modify</span>(y+<span class="hljs-number">2</span>, -f[y-x+<span class="hljs-number">1</span>]);            <span class="hljs-built_in">modify</span>(y+<span class="hljs-number">1</span>, -f[y-x+<span class="hljs-number">2</span>]);        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">modify</span>(x, <span class="hljs-number">-1</span>);            <span class="hljs-built_in">modify</span>(y+<span class="hljs-number">2</span>, f[y-x+<span class="hljs-number">1</span>]);            <span class="hljs-built_in">modify</span>(y+<span class="hljs-number">1</span>, f[y-x+<span class="hljs-number">2</span>]);        &#125;        cout &lt;&lt; vector&lt;string&gt;&#123;<span class="hljs-string">&quot;NO&quot;</span>, <span class="hljs-string">&quot;YES&quot;</span>&#125;[tot == n] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发简记-多人联机游戏demo（socket实现）</title>
    <link href="/2022/01/19/2022-01-19-%E5%BC%80%E5%8F%91%E7%AE%80%E8%AE%B0-%E5%A4%9A%E4%BA%BA%E8%81%94%E6%9C%BA%E6%B8%B8%E6%88%8Fdemo%EF%BC%88socket%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
    <url>/2022/01/19/2022-01-19-%E5%BC%80%E5%8F%91%E7%AE%80%E8%AE%B0-%E5%A4%9A%E4%BA%BA%E8%81%94%E6%9C%BA%E6%B8%B8%E6%88%8Fdemo%EF%BC%88socket%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<hr><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>做一个仿MC的简单场景，多名玩家可以联机在其中移动，破坏和放置方块</p><p>要求是尽量简单、可拓展性强，能作为联机模板使用</p><p>本篇是一个开发简记（乱记）</p><h4 id="主要逻辑"><a href="#主要逻辑" class="headerlink" title="主要逻辑"></a>主要逻辑</h4><p>工程文件已上传Github，<del>这里就不贴了</del></p><p>服务端保存所有在线玩家的昵称和位置信息，以及世界中每一个方块的信息（当然，世界要是大的话这并不科学…）</p><p>然后处理的请求包括用户登录，登出，修改方块，修改玩家位置；另外需要支持向所有玩家广播消息，需要广播的有所有玩家的位置信息，和玩家登录登出消息。</p><p>客户端处理所有游戏本身的东西，向服务端发送登录登出，位置信息，修改方块请求。</p><p>连接时，双方建立Connect之后，服务端即为这一客户端开启一个子线程专门用来接收，客户端也开启监听；随后客户端可以发送登录请求，由服务端检测用户名重复等问题后，回应一个允许登录或错误信息，若允许登录，服务端就把这一用户名和Socket等信息录入，客户端接收到允许登录后，请求世界信息（第一次要求发送全部世界的信息，文本量较大容易失败），若请求成功则登入，若请求失败则发送登出信息，同时关闭客户端的监听，服务端收到登出消息也会删除其用户信息和关闭相应监听。</p><hr><p>一个坑：</p><p>发现对Socket的理解不够准确，这里明确一些东西：</p><ul><li>Socket无需频繁地建立，一次Connect和Accept即可让双方都获得对方Socket，将这个Socket保存起来即可不断地进行Send和Rreceive；在服务端中，每监听到一个连接就为其单独开一个子线程来循环接收其消息。这里不需要担心端口占用的问题，我的理解是：Socket当中会存储两组IP+端口信息，分别是自身的和对方的，在服务端同时执行多个Socket的Receive方法时，消息到达端口后还会根据其存储的源IP+端口信息，再次分配给指定的Socket接收。简言之，一个进程中的多个Socket监听同一个端口，来自这个端口的消息还是会根据来源地址信息分流。</li><li>规范而言，一次Send后需要Receive一次来确定消息是否到达（因为Send并不是阻塞方法，发出去就不管了，而网络通信由于网络波动，中间出错并不少见），但出于性能考虑我们应该灵活变通，对于重要消息（如登录等）需要确认，对于频繁调用的不重要消息（玩家更新位置）等可以不必确认到达。</li></ul><hr><p>一个坑：</p><p>之前为了避免连接问题影响本地运行，把客户端的监听放到子线程里了，但是现在发现——unity不允许子线程修改任何跟unity有关的东西，包括场景切换，修改场景物体等；</p><p>百度了一波发现，untiy其实是一个单线程引擎，多个脚本间和协程其实是通过Time slicing（时间分片）完成的，这样做的话能有固定的运行顺序，不容易引发异步导致的各种冲突。故不允许子线程修改游戏本身内容其实很好理解；</p><p>绕过去的方法，最粗暴的就是搞一个bool，在子线程中设为1，主线程中监控这个bool。。。</p><p>显然这样的做法过于不雅，但也没找到特别优雅的解决方案。我目前的做法是搞一个todoList队列，子进程只负责监听，收到消息后将消息扔进队列，主线程中发现队列中有内容就去完成它。</p><p>这个思路同样可以用于服务端，在服务端为多个客户开多个监听线程时，这样避免异步导致的冲突</p><p>为了进一步避免线程间的资源竞争，需要引入封锁机制，这里也只需要对toDoList的存取做封锁就可以了</p><hr><p>遇到了一个很奇怪的bug：</p><p>向服务器发送消息成功了，返回消息也成功了，但客户端没有任何反应</p><p>反复查找，最后发现客户端在刚连上时接收到了下面这条消息：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;UpdateAllUser&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;[&#123;\&quot;playername\&quot;:\&quot;tyin\&quot;,\&quot;px\&quot;:20.0,\&quot;py\&quot;:20.0,\&quot;pz\&quot;:20.0,\&quot;rx\&quot;:0.0,\&quot;ry\&quot;:0.0,\&quot;rz\&quot;:0.0&#125;]&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;UpdateAllUser&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;[&#123;\&quot;playername\&quot;:\&quot;tyin\&quot;,\&quot;px\&quot;:20.0,\&quot;py\&quot;:20.0,\&quot;pz\&quot;:20.0,\&quot;rx\&quot;:0.0,\&quot;ry\&quot;:0.0,\&quot;rz\&quot;:0.0&#125;]&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;UpdateAllUser&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;[&#123;\&quot;playername\&quot;:\&quot;tyin\&quot;,\&quot;px\&quot;:20.0,\&quot;py\&quot;:20.0,\&quot;pz\&quot;:20.0,\&quot;rx\&quot;:0.0,\&quot;ry\&quot;:0.0,\&quot;rz\&quot;:0.0&#125;]&quot;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>接收到的三条正常的信息合并到一条了，导致Json转义失败</p><p>这是由于服务端处理用户登录请求后，就把用户信息登记上了，此时登录成功的消息还没有发给客户，客户尚未开始监听，而服务端已经开始向客户推送消息；这些消息就堆叠了起来。。在客户开始监听时一次性接收。。</p><p>解决方案：</p><p>让服务端接受登录后延迟推送显然不可行（就变成来自客户端的消息堆叠了）</p><p>所以就在每条消息的后面加上了一个’\0’，接收后先根据此标识拆分成多个字符串。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unity</tag>
      
      <tag>联机</tag>
      
      <tag>Socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初探 Socket</title>
    <link href="/2022/01/17/2022-01-17-Socket%E5%85%A5%E9%97%A8/"/>
    <url>/2022/01/17/2022-01-17-Socket%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<hr><p>起因是寒假没事干搞了个70块一年的云服务器玩玩，试图整一个联机游戏demo</p><p>感谢大佬：<a href="https://www.cnblogs.com/dolphinX/p/3460545.html">https://www.cnblogs.com/dolphinX/p/3460545.html</a></p><h4 id="socket是什么"><a href="#socket是什么" class="headerlink" title="socket是什么"></a>socket是什么</h4><p><a href="https://www.bilibili.com/video/BV1eg411G7pW?from=search&amp;seid=14838178887423899974&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1eg411G7pW?from=search&amp;seid=14838178887423899974&amp;spm_id_from=333.337.0.0</a></p><p>这里以TCP为例</p><h4 id="socket通信基本流程"><a href="#socket通信基本流程" class="headerlink" title="socket通信基本流程"></a>socket通信基本流程</h4><p><img src="https://images0.cnblogs.com/blog/349217/201312/05232335-fb19fc7527e944d4845ef40831da4ec2.png"></p><p>通信基本流程如上图，在accept之后，客户端和服务端双方都获得了连接对方的Socket，随后即可不断地进行点对点地Send和Receive</p><h4 id="通信demo"><a href="#通信demo" class="headerlink" title="通信demo"></a>通信demo</h4><p>注：以下程序编译指令需加：<code>-lwsock32</code></p><p>以Windows下，C++为例</p><p>顺序即实际流程顺序：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span></span>;<span class="hljs-comment">//客户端和服务端均创建Socket，返回它的标识符，后续用这个int来代表这一socket</span><span class="hljs-comment">//domain： 协议族，常用AF_INET表示使用IPv4</span><span class="hljs-comment">//type：socket类型，常用SOCK_STREAM</span><span class="hljs-comment">//protocol：所用协议，常用IPPROTO_TCP</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(SOCKET sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> addrlen)</span></span>;<span class="hljs-comment">//服务端，绑定一个端口，返回错误信号</span><span class="hljs-comment">//用法见下，其中slisten服务端的socket标识符：</span>sockaddr_in sin; <span class="hljs-comment">//这是一个地址对象</span>sin.sin_family = AF_INET;sin.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8888</span>);<span class="hljs-comment">//绑定的端口，要改的只有这里</span>sin.sin_addr.S_un.S_addr = INADDR_ANY;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">bind</span>(slisten, (LPSOCKADDR)&amp;sin, <span class="hljs-built_in">sizeof</span>(sin)) == SOCKET_ERROR) &#123;    cout &lt;&lt; <span class="hljs-string">&quot;bind error !\n&quot;</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(SOCKET sockfd, <span class="hljs-type">int</span> backlog)</span></span>;<span class="hljs-comment">//服务端，开始监听，返回错误信号（这是开启监听的命令，不是阻塞方法）</span><span class="hljs-comment">//backlog：最大可排队连接数</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(SOCKET sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> addrlen)</span></span>;<span class="hljs-comment">//客户端：连接服务端，返回错误信号</span><span class="hljs-comment">//用法如下，其中sclient为客户端的socket标识符：</span>sockaddr_in serAddr;serAddr.sin_family = AF_INET;serAddr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8888</span>);<span class="hljs-comment">//端口</span>serAddr.sin_addr.S_un.S_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;124.223.118.118&quot;</span>);<span class="hljs-comment">//IP</span><span class="hljs-keyword">if</span>(<span class="hljs-built_in">connect</span>(sclient, (sockaddr *)&amp;serAddr, <span class="hljs-built_in">sizeof</span>(serAddr)) == SOCKET_ERROR) &#123;    cerr &lt;&lt; <span class="hljs-string">&quot;connect error !\n&quot;</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(SOCKET sockfd, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> *addrlen)</span></span>;<span class="hljs-comment">//服务端，阻塞方法，等待来自客户端的connect，等到后返回客户端的socket标识符</span><span class="hljs-comment">//到这一步，服务端知晓了客户端的SOCKET标识和IP，可以记录下来便于未来主动向客户端发送消息</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">send</span><span class="hljs-params">(SOCKET sclient, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> flags)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">recv</span><span class="hljs-params">(SOCKET sclient, <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> flags)</span></span>;<span class="hljs-comment">//收发消息服务端和客户端均可使用，sclient处都使用accept方法得到的客户端的SOCKET标识即可</span><span class="hljs-comment">//这里的通信就自由了，客户度send，服务端recv，随后还可以服务端send，客户端recv进行一个回复；</span></code></pre></div><p>另一提：网络间通信，由于网络波动等，一次消息的发送或接收失败很正常，应做出错误处理而非中断程序；</p><p>客户端：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;WINSOCK2.H&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ctime&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;ws2_32.lib&quot;</span>)</span><span class="hljs-type">const</span> <span class="hljs-type">char</span> *ipv4 = <span class="hljs-string">&quot;124.223.118.118&quot;</span>;<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> hton = <span class="hljs-number">8888</span>;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sendToServer</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg)</span></span>&#123;    <span class="hljs-comment">//连接</span>    SOCKET sclient = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);    <span class="hljs-keyword">if</span>(sclient == INVALID_SOCKET) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;invalid socket!\n&quot;</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    sockaddr_in serAddr;    serAddr.sin_family = AF_INET;    serAddr.sin_port = <span class="hljs-built_in">htons</span>(hton);<span class="hljs-comment">//端口</span>    serAddr.sin_addr.S_un.S_addr = <span class="hljs-built_in">inet_addr</span>(ipv4);<span class="hljs-comment">//IP</span>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">connect</span>(sclient, (sockaddr *)&amp;serAddr, <span class="hljs-built_in">sizeof</span>(serAddr)) == SOCKET_ERROR) &#123;        <span class="hljs-comment">//连接失败</span>        cerr &lt;&lt; <span class="hljs-string">&quot;connect error !\n&quot;</span>;        <span class="hljs-built_in">closesocket</span>(sclient);        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-comment">//send()用来将数据由指定的socket传给对方主机</span>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">send</span>(sclient, msg, <span class="hljs-built_in">strlen</span>(msg), <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>)&#123;        cerr &lt;&lt; <span class="hljs-string">&quot;send failed!\n&quot;</span>;        <span class="hljs-built_in">closesocket</span>(sclient);        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-comment">//recv()来自服务端的回信</span>    <span class="hljs-type">char</span> recData[<span class="hljs-number">255</span>];    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recv</span>(sclient, recData, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span>(ret&gt;<span class="hljs-number">0</span>) &#123;        recData[ret] = <span class="hljs-number">0x00</span>;        cout &lt;&lt; recData;    &#125;    <span class="hljs-built_in">closesocket</span>(sclient);    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//初始化</span>    WORD sockVersion = <span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);    WSADATA data;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">WSAStartup</span>(sockVersion, &amp;data)!=<span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;        string data;        cin &gt;&gt; data;        <span class="hljs-built_in">sendToServer</span>(data.<span class="hljs-built_in">c_str</span>());        <span class="hljs-keyword">if</span>(data == <span class="hljs-string">&quot;END&quot;</span>) <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-built_in">WSACleanup</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>服务端：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winsock2.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib,<span class="hljs-string">&quot;ws2_32.lib&quot;</span>)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;    <span class="hljs-comment">//初始化WSA</span>    WORD sockVersion = <span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);    WSADATA wsaData;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">WSAStartup</span>(sockVersion, &amp;wsaData)!=<span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">//创建套接字</span>    SOCKET slisten = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);    <span class="hljs-keyword">if</span>(slisten == INVALID_SOCKET) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;socket error !\n&quot;</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">//绑定IP和端口</span>    sockaddr_in sin;    sin.sin_family = AF_INET;    sin.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8888</span>);    sin.sin_addr.S_un.S_addr = INADDR_ANY;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">bind</span>(slisten, (LPSOCKADDR)&amp;sin, <span class="hljs-built_in">sizeof</span>(sin)) == SOCKET_ERROR) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;bind error !\n&quot;</span>;    &#125;    <span class="hljs-comment">//开始监听</span>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">listen</span>(slisten, <span class="hljs-number">5</span>) == SOCKET_ERROR) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;listen error !\n&quot;</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">//循环接收数据</span>    SOCKET sClient;    sockaddr_in remoteAddr;    <span class="hljs-type">int</span> nAddrlen = <span class="hljs-built_in">sizeof</span>(remoteAddr);    <span class="hljs-type">char</span> revData[<span class="hljs-number">255</span>];    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;Waiting...\n&quot;</span>;        sClient = <span class="hljs-built_in">accept</span>(slisten, (SOCKADDR *)&amp;remoteAddr, &amp;nAddrlen);        <span class="hljs-keyword">if</span>(sClient == INVALID_SOCKET)        &#123;            cout &lt;&lt; <span class="hljs-string">&quot;accept error !\n&quot;</span>;            <span class="hljs-keyword">continue</span>;        &#125;        cout &lt;&lt; <span class="hljs-string">&quot;received connect: &quot;</span> &lt;&lt;  <span class="hljs-built_in">inet_ntoa</span>(remoteAddr.sin_addr) &lt;&lt; <span class="hljs-string">&quot; \r\n&quot;</span>;        <span class="hljs-comment">//接收数据</span>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recv</span>(sClient, revData, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span>(ret &gt; <span class="hljs-number">0</span>) &#123;            revData[ret] = <span class="hljs-number">0x00</span>;            cout &lt;&lt; revData &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;        &#125;        <span class="hljs-comment">//发送数据</span>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> * sendData = <span class="hljs-string">&quot;how are you? \n&quot;</span>;        <span class="hljs-built_in">send</span>(sClient, sendData, <span class="hljs-built_in">strlen</span>(sendData), <span class="hljs-number">0</span>);        <span class="hljs-built_in">closesocket</span>(sClient);    &#125;    <span class="hljs-built_in">closesocket</span>(slisten);    <span class="hljs-built_in">WSACleanup</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>避个坑：服务端的回信不是必须的（三次握手在更加底层的地方，已经有人完成好了），此处只是为了方便查看通信结果；</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Socket</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库和mysql小记</title>
    <link href="/2022/01/02/2022-01-02-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8Cmysql%E5%B0%8F%E8%AE%B0/"/>
    <url>/2022/01/02/2022-01-02-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8Cmysql%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<hr><h4 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h4><h5 id="建表和完整性约束"><a href="#建表和完整性约束" class="headerlink" title="建表和完整性约束:"></a>建表和完整性约束:</h5><div class="code-wrapper"><pre><code class="hljs mysql">create table student(  -- 建表    sno int unique, -- 属性名 类型 列级（属性上的）完整性约束...    cno int,sname char(6),    class char(4),    Foreign key(cno) references class(cno),    Primary key(sno, cno) -- 最后两行是表级（元组上的）完整性约束，主键有多个时，必须作为表级完整性来写);drop table student [cascade|restrict]; -- 删除，其他东西的删除往往也是这个格式</code></pre></div><p>这样创建的是一个表的结构，还没有具体内容</p><p>列级（属性级）完整性约束包括<code>NOT NULL</code> <code>UNIQUE</code> <code>CHECK(条件)</code></p><p><code>CHECK</code> 也可以定义表级完整性约束，对元组各个属性之间的关系作出要求</p><p>完整性约束命名：就是在约束前面加上 <code>constraint 名字</code></p><p>断言是一种更高级别的约束，可以定义表与表之间的约束关系：</p><div class="code-wrapper"><pre><code class="hljs mysql">create assertion 名字check(...);</code></pre></div><p>任何操作都需要检查所有和它有关的完整性约束，若不符合则进行违约处理：拒绝，级联更新或置空</p><h5 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h5><div class="code-wrapper"><pre><code class="hljs mysql">select sno, student.sname-- 投影，保留了sno和sname两属性列from student, class-- 连接where student.sname = class.sname;-- 选择</code></pre></div><p>多表查询时，属性名唯一的可以直接写，有冲突的需要 <code>表名.属性名</code> 这样；</p><p>上面是一个典型的自然连接，在做等值连接的同时，仅select了其中一个同名属性列，生成的表将含 <code>sname</code> 而非 <code>student.sname</code> 或 <code>sname(1)</code></p><div class="code-wrapper"><pre><code class="hljs mysql">select sno, sum(score)from student;</code></pre></div><p>使用聚集函数时，如果没有跟上 <code>group by</code> 分组，则会把所有东西拼成一组，像上面那样得到的结果就没什么实际含义；</p><div class="code-wrapper"><pre><code class="hljs mysql">select class, sum(score) as total -- as total 造了一个别名，输出时将名为total，as可略from studentgroup by classhaving avg(score) &gt; 80;-- group by紧跟着一个having，表示仅筛选满足条件的组-- 这里面，当然，也可以用聚集函数</code></pre></div><p>这样即可对 <code>class</code> 属性列分组，相同的为一组，聚集函数对每个组求一次值。<br>这里便能得到各个班级的总分；</p><p>查询聚集函数得到的结果，可以直接当成数值来用：</p><div class="code-wrapper"><pre><code class="hljs mysql">-- 嵌套查询，查询平均分之上的同学select *from studentwhere score &gt;= (select avg(score)from student);</code></pre></div><h5 id="修改："><a href="#修改：" class="headerlink" title="修改："></a>修改：</h5><p>修改表结构：</p><div class="code-wrapper"><pre><code class="hljs mysql">alter table class ...; -- 注意alter只能根一个修改语句，不是语句块add teacher char(8) unique;drop teacher;change 列名 新列名 新类型; -- 这里和书上不一样add constraint 表级完整性约束;drop constraint 表级完整性约束名;</code></pre></div><p>修改数据：</p><div class="code-wrapper"><pre><code class="hljs mysql">-- 插入insert into student(a, b, c)values(1, 2001, &quot;tyj&quot;, ), (..), (..);-- 值的顺序和上面的列a, b, c列一一对应-- 可不提供(a, b, c)这样的顺序，按照默认顺序-- 可以一次插入多个值-- 删除deletefrom studentwhere score &lt; 60; -- 删除60分以下的学生-- 修改update studentset cno = 2where cno = 1;</code></pre></div><h5 id="授权："><a href="#授权：" class="headerlink" title="授权："></a>授权：</h5><div class="code-wrapper"><pre><code class="hljs mysql">Grant update(sno) -- 权限名: select(查询),insert(插入),update(修改),all privileges等on table studentto u1; -- 用户/角色，public表示所有用户[with grant option] -- 加上表示允许该用户传递此权限Revoke update(sno)on table studentfrom u1 [cascade|restrict];-- 和删除类似，级联即同时回收u1传递出去的权限，默认cascade</code></pre></div><p>【角色】是权限的集合——比如职工，经理等角色；可以在给角色分配好权限后，给多个用户直接分配这一角色的权限。</p><div class="code-wrapper"><pre><code class="hljs mysql">Grant 角色1,角色2...to 角色/用户[with grant option]</code></pre></div><h4 id="范式："><a href="#范式：" class="headerlink" title="范式："></a>范式：</h4><p>好东西：<a href="https://blog.csdn.net/yangbodong22011/article/details/51619590">https://blog.csdn.net/yangbodong22011/article/details/51619590</a></p><ul><li>候选码：能唯一标识一个元组，且其子集不能的属性组，一个表可以有多组候选码</li><li>选择其中的一组候选码，即作为主码</li><li><strong>所有候选码的属性称为主属性</strong>（个人感觉定义最奇怪的地方，也是导致BCNF理解困难的原因）</li></ul><p>简单概括：</p><ul><li>1NF：数据项不可分割</li><li>2NF：非主属性对主属性不能存在部分函数依赖</li><li>3NF：非主属性对主属性不能存在传递函数依赖</li><li>BCNF：<strong>任一主属性</strong>对<strong>其他候选码</strong>不存在部分和传递依赖<ul><li>上面那句话不好理解，个人有另一种理解：</li><li>BCNF是3NF的扩展：如果有多个候选码，则把其中任一组看成主属性，其他看成非主属性（按定义，本来应是主属性）后，仍然满足3NFs</li></ul></li><li>4NF：属性间不存在非平凡且非函数的多值依赖（我暂且记个定义）</li></ul><h4 id="一些细节："><a href="#一些细节：" class="headerlink" title="一些细节："></a>一些细节：</h4><p>代码不加分号也能过：分号有类似分区的作用，出现错误时，其他加了分号的部分仍然正常执行</p><p>空值的判断是 <code>is [not] null</code></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VHDL小记</title>
    <link href="/2021/12/19/2021-12-19-VHDL%E5%B0%8F%E8%AE%B0/"/>
    <url>/2021/12/19/2021-12-19-VHDL%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<hr><h5 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h5><div class="code-wrapper"><pre><code class="hljs vhdl"><span class="hljs-keyword">Library</span> ieee;<span class="hljs-keyword">Use</span> ieee.std_logic_1164.<span class="hljs-keyword">all</span>;    <span class="hljs-comment">--调库，调包</span><span class="hljs-keyword">Entity</span> mux21a <span class="hljs-keyword">is</span><span class="hljs-comment">--实体，和文件同名</span>    <span class="hljs-keyword">port</span>(a, b, c: <span class="hljs-keyword">in</span> <span class="hljs-built_in">std_logic</span>;<span class="hljs-comment">--定义输入输出</span>        d: <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic</span>);<span class="hljs-comment">--输出信号不可读！输入信号不可写！</span><span class="hljs-keyword">End</span> <span class="hljs-keyword">entity</span> mux21a;<span class="hljs-keyword">Architecture</span> one <span class="hljs-keyword">of</span> mux21a <span class="hljs-keyword">is</span>   <span class="hljs-comment">--结构体</span><span class="hljs-keyword">Begin</span>   ...<span class="hljs-comment">--其他语句</span>    [名字]: <span class="hljs-keyword">Process</span> (a, b, c)<span class="hljs-comment">--进程，结构体可以包含多个语句和进程</span>    <span class="hljs-keyword">Begin</span>        ...    <span class="hljs-keyword">End</span> <span class="hljs-keyword">process</span> [名字];<span class="hljs-keyword">End</span> <span class="hljs-keyword">Architecture</span> one;</code></pre></div><p>其中进程中的内容和常规编程思路一致，运行顺序同书写顺序；</p><p>而结构体中的其他语句是并发执行的，和书写顺序无关；</p><p>故顺序语句（<code>if for</code> 等等）只能出现在进程当中，并行语句（选择、条件赋值语句，元件例化语句）不能放在进程中；</p><p>整个 <code>Process</code> 也可看成其他语句的一部分，在括号中的内容 <code>(a, b, c)</code> 改变时进入进程</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>常用顺序执行的语句：</p><div class="code-wrapper"><pre><code class="hljs vhdl"><span class="hljs-keyword">if</span> ... <span class="hljs-keyword">then</span> ...;<span class="hljs-keyword">elsif</span> ...;<span class="hljs-keyword">else</span> ...;<span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> <span class="hljs-keyword">to</span> <span class="hljs-number">7</span> <span class="hljs-keyword">loop</span>    ...;<span class="hljs-keyword">end</span> <span class="hljs-keyword">loop</span>;</code></pre></div><p>注意选择信号赋值语句：</p><div class="code-wrapper"><pre><code class="hljs VHDL"><span class="hljs-keyword">WITH</span> 选择表达式 <span class="hljs-keyword">SELECT</span>赋值目标信号 &lt;= 表达式<span class="hljs-number">1</span> <span class="hljs-keyword">WHEN</span> 选择值 <span class="hljs-number">1</span>，                  表达式<span class="hljs-number">2</span> <span class="hljs-keyword">WHEN</span> 选择值 <span class="hljs-number">2</span>，                  表达式n <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">OTHERS</span>;</code></pre></div><p>是一个并行语句，不具备优先级，所以它必须指明所有可能的情况或者指定others，且它的条件必须互斥，不能重叠；</p><p>而条件信号赋值语句：</p><div class="code-wrapper"><pre><code class="hljs vhdl">赋值目标信号 &lt;= 表达式<span class="hljs-number">1</span> <span class="hljs-keyword">WHEN</span> 赋值条件<span class="hljs-number">1</span> <span class="hljs-keyword">ELSE</span>  表达式<span class="hljs-number">2</span> <span class="hljs-keyword">WHEN</span> 赋值条件<span class="hljs-number">2</span> <span class="hljs-keyword">ELSE</span>      表达式n <span class="hljs-keyword">WHEN</span> 赋值条件n <span class="hljs-keyword">ELSE</span>      表达式；</code></pre></div><p>也是一个并行语句，但它在赋值时按照优先级从上到下赋值，所以允许条件重叠（最后一条相当于没有条件的ELSE，保证了全覆盖）；</p><p>CASE语句：</p><div class="code-wrapper"><pre><code class="hljs vhdl"><span class="hljs-keyword">CASE</span> &lt;表达式&gt; <span class="hljs-keyword">IS</span><span class="hljs-keyword">WHEN</span> &lt;选择值&gt; =&gt; &lt;顺序语句&gt;; ... ; &lt;顺序语句&gt;;<span class="hljs-keyword">WHEN</span> &lt;选择值&gt; =&gt; &lt;顺序语句&gt;; ... ; &lt;顺序语句&gt;;...<span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">OTHERS</span> =&gt; &lt;顺序语句&gt;;<span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span>;</code></pre></div><p>是顺序语句，必须指明所有可能的情况或者指定others，条件允许重叠</p><h5 id="变量和信号"><a href="#变量和信号" class="headerlink" title="变量和信号"></a>变量和信号</h5><p>变量是电路内部的操作，代表临时数据，可以认为是一个局部变量；</p><p>信号代表的是电路单元，代表真实电路，是全局变量，不能在进程和子进程中定义；</p><div class="code-wrapper"><pre><code class="hljs vhdl"><span class="hljs-keyword">Signal</span> 名称: 类型:= 初始值;<span class="hljs-keyword">variable</span> 名称: 类型:= 初始值;变量 := 赋值;信号 &lt;= 赋值;</code></pre></div><p>赋值时，变量是立即赋值的，而信号会延迟赋值</p><p>常用类型：<code>std_logic</code> 和 <code>std_logic_vector</code></p><p>一般把一个 <code>std_logic</code> 当成一位01信号，而事实上它可以存储9种信号（另有：’X’表示未知，’U’表示未设置，’-‘表示不关心等等），用于充分地表达一处电路线上的真实情况。</p><p>用行为描述方式时，两个同位的 <code>std_logic_vector</code> 可以直接相加</p><h5 id="元件例化、生成语句"><a href="#元件例化、生成语句" class="headerlink" title="元件例化、生成语句"></a>元件例化、生成语句</h5><p>注意将元件加入library的方法</p><div class="code-wrapper"><pre><code class="hljs vhdl"><span class="hljs-comment">--定义和调用</span><span class="hljs-keyword">Architecture</span> one <span class="hljs-keyword">of</span> add4 <span class="hljs-keyword">is</span><span class="hljs-keyword">Component</span> add1<span class="hljs-keyword">port</span>(a, b, ci: <span class="hljs-keyword">in</span> <span class="hljs-built_in">std_logic</span>;co, f: <span class="hljs-keyword">out</span> <span class="hljs-built_in">std_logic</span>);<span class="hljs-keyword">End</span> <span class="hljs-keyword">component</span>;    ...<span class="hljs-keyword">begin</span><span class="hljs-comment">--调用</span>[随便写个名字]: add1 <span class="hljs-keyword">port</span> <span class="hljs-keyword">map</span>(, ,co =&gt; x ,);<span class="hljs-comment">--可以一一对应，也可以使用上述方式指定co端口接x（位置关联和名字关联）</span><span class="hljs-comment">--测试了一下，混合关联好像会有另外的要求，（a=&gt;ai, b=&gt;bi, f）就不行 建议不用</span></code></pre></div><p>元件例化的调用是一个并行语句，不能写在process里面</p><p>生成语句：</p><div class="code-wrapper"><pre><code class="hljs vhdl">[随便写个名字]: <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> <span class="hljs-keyword">to</span> <span class="hljs-number">7</span> <span class="hljs-keyword">generate</span><span class="hljs-keyword">Begin</span>    <span class="hljs-comment">--并行语句</span><span class="hljs-keyword">End</span> <span class="hljs-keyword">generate</span>;</code></pre></div><p>生成语句循环内的是并行语句，但调用是从0到7按顺序的</p><p>可以认为整个for是一个并行语句，不能放进process，但其执行时是按顺序的，每一步又是并行地执行块（个人理解）</p><h5 id="边沿判定"><a href="#边沿判定" class="headerlink" title="边沿判定"></a>边沿判定</h5><div class="code-wrapper"><pre><code class="hljs vhdl">clk<span class="hljs-symbol">&#x27;event</span> <span class="hljs-keyword">and</span> clk = <span class="hljs-string">&#x27;1&#x27;</span>; <span class="hljs-comment">--上升沿判定</span>clk<span class="hljs-symbol">&#x27;event</span> <span class="hljs-keyword">and</span> clk = <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-comment">--下降沿判定</span><span class="hljs-comment">--发生&#x27;event事件时，clk已经变化</span>rising_edge(clk); <span class="hljs-comment">--上升沿判定</span>falling_edge(clk); <span class="hljs-comment">--下降沿判定</span></code></pre></div><h5 id="描述方式"><a href="#描述方式" class="headerlink" title="描述方式"></a>描述方式</h5><p>逻辑综合：指将电路的行为级描述（代码）转化成门级电路的过程，以供硬件使用</p><p>VHDL的三种描述风格：</p><ul><li>行为描述方式：和高级语言比较接近，大量使用算数运算，关系运算等等，一般只用于系统仿真，难以进行逻辑综合。要使用算数运算，需要<code>use ieee.std_logic_unsigned.all;</code> </li><li>数据流描述方式：即表示行为也隐含地表示了结构，一般用布尔方程和并行赋值语句实现，可以进行逻辑综合。</li><li>结构化描述方式：多层次，常用元件例化，生成语句，可以进行逻辑综合。</li></ul><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><div class="code-wrapper"><pre><code class="hljs vhdl">A <span class="hljs-keyword">nand</span> B <span class="hljs-comment">--与非（不是不等于）</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VHDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新生赛题解之chiking的俄罗斯方块</title>
    <link href="/2021/12/10/2021-12-10-%E6%96%B0%E7%94%9F%E8%B5%9B%E9%A2%98%E8%A7%A3-%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/"/>
    <url>/2021/12/10/2021-12-10-%E6%96%B0%E7%94%9F%E8%B5%9B%E9%A2%98%E8%A7%A3-%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="XX的俄罗斯方块"><a href="#XX的俄罗斯方块" class="headerlink" title="XX的俄罗斯方块"></a>XX的俄罗斯方块</h2><h6 id="时间限制：1000ms-空间限制：256M"><a href="#时间限制：1000ms-空间限制：256M" class="headerlink" title="时间限制：1000ms  空间限制：256M"></a>时间限制：1000ms  空间限制：256M</h6><h5 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景:"></a>题目背景:</h5><p>XX沉迷一款叫俄罗斯方块的游戏，但这个游戏对他来说实在太难了，于是它决定玩无敌版</p><p>无敌版俄罗斯方块中，有一个宽4格，高度无限的网格图，游戏流程如下：</p><ol><li><p>初始时网格图为空</p></li><li><p>一个由方块组成的砖块（只有1x4和2x2两种）出现在网格图内很高的地方，XX可以对它进行任意次操作：</p><ol><li>将这个方块整体左移一格（不能被已有的方块阻挡或超出边界）</li><li>将这个方块整体右移一格（不能被已有的方块阻挡或超出边界）</li></ol></li><li><p>砖块块每隔一段时间就会整体下落一格（当然由于XX的手速非常快，它可以在下落的间隙中进行无数次平移），当因被阻挡或即将超出下边界而无法下落时，它就会<strong>固定</strong>，紧接着出现下一个砖块</p></li><li><p>方块固定后，如果有一整行的四格方块都填满，这一行将被消除，XX得到1分；如果一次同时消除了多行，第二行将能得到2分，第三行就是3分，以此类推。</p><p>所以一次性消除4行就能获得一共10分！</p></li></ol><p><strong>注意</strong>：砖块不可分割，不可旋转，所有1x4的砖块均竖直，<strong>且保证1x4的方块仅出现偶数次</strong></p><p>下面这种插入方式也是允许的：</p><p><img src="http://lxtyin.ac.cn/img/problem/Tetris/9.png" alt="9"></p><h5 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h5><p>XX现在正在打一局无敌版的俄罗斯方块，他知道接下来出现的 n 个砖块的种类，你能帮他算一算他最高能获得多少分吗？</p><h5 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h5><p>输入有两行</p><p>第一行一个正整数 n，表示接下来有 n 个砖块 (1&lt;&#x3D; n &lt;&#x3D; 10^6)</p><p>第二行 n 个正整数，依次表示接下来出现的砖块种类，0表示 2x2 的砖块，1表示 1x4 的砖块</p><h5 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h5><p>输出一个正整数，为XX能获得的最大分数</p><h5 id="样例输入："><a href="#样例输入：" class="headerlink" title="样例输入："></a>样例输入：</h5><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">4</span><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span></code></pre></div><h5 id="样例输出："><a href="#样例输出：" class="headerlink" title="样例输出："></a>样例输出：</h5><div class="code-wrapper"><pre><code class="hljs">6</code></pre></div><p><strong>样例解释：</strong></p><p>按下面这种方式堆放：</p><p><img src="http://lxtyin.ac.cn/img/problem/Tetris/10.png" alt="10"></p><p>第三个插入时连消了两行，获得1+2分</p><p>第五个插入时连消了两行，获得1+2分</p><p>一共6分，不存在比这得分更多的方案</p><hr><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>先说结论：</p><p>用任何方式算出最大四连消的次数即可，其余尽可能多地三连消，最后可能剩余一个 $2\times2$ 或者 $2\times4$，可以发现一点：只要存在正方形的砖块，最后就不可能剩下 $2\times4$ 的情况。</p><hr><p>首先可以看出，只有2连消和4连消两种消法，分别对应3分和10分；</p><p>从贪心的角度来讲，我们需要尽可能多4连消；随便定一个数字 $k$，考虑怎么去判断<strong>能否进行 $k$ 次4连消</strong>：</p><ul><li>$k$ 至多为1的数量的一半；</li><li>先在第四列堆 $k$ 根1x4，在前两列尽可能堆高，最后 $k$ 根长条都插入第三列，这样能尽可能保证4连消；</li><li>在这种策略下，如果在第三列每根1*4插入时，前两列高度都 $\ge4$，则能够进行 $k$ 次4连消，否则一定不能；</li></ul><p>所以进行 $k$ 次4连消的条件就是：对于任意倒数第 $b$ 个1 ($b\le k$)，都满足到这里为止，前面可用的1和0在前两列能够堆的高度 $\ge$ $(k-b+1) \times4$，所谓“可用的0和1”就是指所有的0和去掉放在第四列的 $k$ 个和第三列的 $k-b+1$ 个1；</p><p>即对于任意倒数第 $b$ 个1（$b\le k$），假设它在第 $i$ 位，满足 $(cnt1[i]-k-(k-b+1))&#x2F;2\times4 + cnt0[i]\times2\ge(k-b+1)\times4$</p><p> 其中 $cnt0[i]$，$cnt1[i]$ 分别为前 $i$ 个块中0，1的数量；（式中除号为整除）</p><p>有了这个式子，最大的 $k$ 就不难算了：初始将 $k$ 设为 $cnt1[n]&#x2F;2$，我们从后往前枚举，每枚举到一个1时就依据上式判断，不断减小 $k$ 直到上式成立，这样就得到了最大的 $k$。</p><hr><p>有必要解释一下：$x$ 个 1可以在前两列堆出 $x&#x2F;2\times4$ 的高度：（式中除号为整除）</p><p><img src="http://lxtyin.ac.cn/img/problem/Tetris/6.png" alt="2"></p><p>当插入一根1x4时，直接放在第一列，接下来如果是方块则正常放置不影响，下一根1x4用这种插入的方式补在第二列即可，因为直到最后 $k$ 个1之前第三列都是空的，这种方式一定行的通。</p><hr><p>一二列堆的多余部分要尽可能2连消，这个比较简单，堆的高度超出 $k\times4$ 后左右来回放就行了，总得分就是 $k\times4+(n-k)&#x2F;2\times3$，最后可能会剩余1个2x2，这个没有办法消除；（式中除号为整除）</p><p>最后也有可能不得不剩下两根1x4，这种情况当且仅当全场都是1的时候才成立，否则一定能通过改变一个0的位置消掉（感性理解即可，想要严格证明可以私聊我，不太好讲）</p><p>因为 $k$ 是最大的4连消次数，在此情况下也最多只会浪费两个方块，减少4连消次数损失的10收益远大于可能获得的3收益，所以这就是得分最大的方案。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, a[maxn];<span class="hljs-type">int</span> cnt0[maxn], cnt1[maxn];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cnt0[i] = cnt0[i<span class="hljs-number">-1</span>];        cnt1[i] = cnt1[i<span class="hljs-number">-1</span>];        <span class="hljs-keyword">if</span>(a[i] == <span class="hljs-number">0</span>) cnt0[i]++;        <span class="hljs-keyword">else</span> cnt1[i]++;    &#125;    <span class="hljs-type">int</span> k = cnt1[n] / <span class="hljs-number">2</span>;    <span class="hljs-type">int</span> brk = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;        <span class="hljs-keyword">if</span>(a[i] == <span class="hljs-number">1</span>)&#123;            brk++;            <span class="hljs-keyword">while</span>(k &gt;= brk &amp;&amp; (cnt1[i]-(k+k-brk+<span class="hljs-number">1</span>))/<span class="hljs-number">2</span>*<span class="hljs-number">4</span> + cnt0[i]*<span class="hljs-number">2</span> &lt; (k-brk+<span class="hljs-number">1</span>)*<span class="hljs-number">4</span>) k--;        &#125;    &#125;    <span class="hljs-keyword">if</span>(cnt0[n]) cout &lt;&lt; k*<span class="hljs-number">10</span>+(n-k*<span class="hljs-number">4</span>)/<span class="hljs-number">2</span>*<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    <span class="hljs-keyword">else</span> cout &lt;&lt; n/<span class="hljs-number">4</span>*<span class="hljs-number">10</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="PS：由于这题最终答案偏差不大，其他贪心方式也有机会通过（"><a href="#PS：由于这题最终答案偏差不大，其他贪心方式也有机会通过（" class="headerlink" title="PS：由于这题最终答案偏差不大，其他贪心方式也有机会通过（"></a>PS：由于这题最终答案偏差不大，其他贪心方式也有机会通过（</h3><p>来自老老会长的ac代码：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span>, lPos</span>;    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">flag</span><span class="hljs-params">(n, <span class="hljs-literal">true</span>)</span></span>;    queue&lt;<span class="hljs-type">int</span>&gt; oPos;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i];    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, tot2 = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 2*2 + 2*2 + 1*4 + 1*4</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;        <span class="hljs-keyword">if</span> (data[i] == <span class="hljs-number">0</span>) &#123;            oPos.<span class="hljs-built_in">push</span>(i);            tot2++;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span>) oPos.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span> &amp;&amp; (<span class="hljs-type">int</span>) lPos.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">1</span>) &#123;                flag[oPos.<span class="hljs-built_in">front</span>()] = <span class="hljs-literal">false</span>;                oPos.<span class="hljs-built_in">pop</span>();                flag[oPos.<span class="hljs-built_in">front</span>()] = <span class="hljs-literal">false</span>;                oPos.<span class="hljs-built_in">pop</span>();                flag[lPos.<span class="hljs-built_in">back</span>()] = <span class="hljs-literal">false</span>;                flag[i] = <span class="hljs-literal">false</span>;                lPos.<span class="hljs-built_in">pop_back</span>();                res += <span class="hljs-number">10</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                lPos.<span class="hljs-built_in">push_back</span>(i);            &#125;        &#125;    &#125;    <span class="hljs-type">int</span> cnt1 = (<span class="hljs-type">int</span>) lPos.<span class="hljs-built_in">size</span>();    <span class="hljs-type">int</span> cnt2 = (<span class="hljs-type">int</span>) oPos.<span class="hljs-built_in">size</span>();    <span class="hljs-comment">// 1*4 + 1*4 + 1*4 + 1*4</span>    <span class="hljs-type">int</span> tmp = cnt1 / <span class="hljs-number">4</span>;    res += tmp * <span class="hljs-number">10</span>;    cnt1 -= tmp * <span class="hljs-number">4</span>;    <span class="hljs-comment">// 1*4 + 1*4 + 2*2 + 2*2</span>    <span class="hljs-keyword">if</span> (cnt1 == <span class="hljs-number">2</span> &amp;&amp; cnt2 &gt;= <span class="hljs-number">2</span>) &#123;        res += <span class="hljs-number">6</span>;        cnt2 -= <span class="hljs-number">2</span>;        cnt1 -= <span class="hljs-number">2</span>;    &#125;    <span class="hljs-comment">// 2*2 + 2*2</span>    res += <span class="hljs-number">3</span> * (cnt2 / <span class="hljs-number">2</span>);    <span class="hljs-keyword">if</span> (cnt1 == <span class="hljs-number">2</span> &amp;&amp; (cnt2 == <span class="hljs-number">1</span> || tot2 &gt;= <span class="hljs-number">2</span>)) &#123;        res += <span class="hljs-number">3</span>;    &#125;    cout &lt;&lt; res &lt;&lt; endl;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新生赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 117 A-E</title>
    <link href="/2021/11/22/2021-11-22-Educational%20Codeforces%20Round%20117/"/>
    <url>/2021/11/22/2021-11-22-Educational%20Codeforces%20Round%20117/</url>
    
    <content type="html"><![CDATA[<h4 id="A-Distance"><a href="#A-Distance" class="headerlink" title="A. Distance"></a>A. Distance</h4><p>题意：给出 $B$ 点坐标 $bx,by$，要输出 $C$ 的坐标使得 $C$ 到原点，$C$ 到 $B$ 点的曼哈顿距离都为 $B$ 到原点的曼哈顿距离的一半。</p><p>分奇偶讨论即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> x, y;    cin &gt;&gt; x &gt;&gt; y;    <span class="hljs-type">int</span> dis =(<span class="hljs-built_in">abs</span>(x) + <span class="hljs-built_in">abs</span>(y));    <span class="hljs-keyword">if</span>(dis % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(x) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;            cout &lt;&lt; x/<span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; y/<span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            cout &lt;&lt; <span class="hljs-built_in">floor</span>(x/<span class="hljs-number">2.0</span>) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-built_in">ceil</span>(y/<span class="hljs-number">2.0</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;        &#125;    &#125;<span class="hljs-keyword">else</span>&#123;        cout &lt;&lt; <span class="hljs-string">&quot;-1 -1\n&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="B-Special-Permutation"><a href="#B-Special-Permutation" class="headerlink" title="B. Special Permutation"></a>B. Special Permutation</h4><p>题意：要构造一个 $n$ 的排列（$n$ 为偶数），使得左半边最小值为 $a$，右半边最小值为 $b$</p><p>左边取 $a$ 和尽可能大的值，右边取 $b$ 和尽可能小的值，因为 $n$ 只给了100，可以 $n^2$ 暴力，省去了分类讨论的麻烦</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m, s[maxn];<span class="hljs-type">bool</span> vis[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a, b;    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) vis[i] = <span class="hljs-number">0</span>;    s[<span class="hljs-number">1</span>] = a; vis[a] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n/<span class="hljs-number">2</span>;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n;j&gt;=a;j--)&#123;            <span class="hljs-keyword">if</span>(!vis[j] &amp;&amp; j != b)&#123;                s[i] = j;                vis[j] = <span class="hljs-number">1</span>;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span>(j == a)&#123;                cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=b;j&gt;=<span class="hljs-number">1</span>;j--)&#123;            <span class="hljs-keyword">if</span>(!vis[j])&#123;                s[i] = j;                vis[j] = <span class="hljs-number">1</span>;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">1</span>)&#123;                cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) cout &lt;&lt; s[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    cout &lt;&lt; s[n] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="C-Chat-Ban"><a href="#C-Chat-Ban" class="headerlink" title="C. Chat Ban"></a>C. Chat Ban</h4><p>题意：你要依次发送 $2k-1$ 条消息，每条消息的字符个数分别为 1,2,3…k,k-1…2,1，输入达到 $x$ 个字符时就会终止，问能发出几条消息（发一半也算）</p><p>分类讨论写比较麻烦，写一个计算发送前 $x$ 条消息需要的字符的函数 $f(x)$，然后二分答案即可。</p><div class="code-wrapper"><pre><code class="hljs c++">ll k, x;<span class="hljs-function">ll <span class="hljs-title">cntk</span><span class="hljs-params">(ll s)</span></span>&#123;    <span class="hljs-keyword">if</span>(s &lt;= k) <span class="hljs-keyword">return</span> s*(s+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;    <span class="hljs-keyword">else</span>&#123;        ll r = (<span class="hljs-number">2</span>*k<span class="hljs-number">-1</span>-s+k) * (s-k) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">return</span> k*(k+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span> + r;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; k &gt;&gt; x;    ll l = <span class="hljs-number">1</span>, r = <span class="hljs-number">2</span>*k<span class="hljs-number">-1</span>;    <span class="hljs-keyword">while</span>(l &lt; r)&#123;        ll mid = (l+r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cntk</span>(mid) &gt;= x)&#123;            r = mid;        &#125;<span class="hljs-keyword">else</span>&#123;            l = mid+<span class="hljs-number">1</span>;        &#125;    &#125;    cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="D-X-Magic-Pair"><a href="#D-X-Magic-Pair" class="headerlink" title="D. X-Magic Pair"></a>D. X-Magic Pair</h4><p>题意：有两个数字 $a,b$，可以一次操作将 $a&#x3D;|a-b|$ 或 $b&#x3D;|a-b|$，问能否凑出 $x$（$a$ 或 $b$ 等于 $x$ 都可，可以进行任意次操作）</p><p>用手模拟一下可以发现，当前为 $a,b$（假设 $a\lt b$），不论怎么操作一定会经过 $a,b-a$ 这个状态</p><p>那么可以用类似辗转相除法的办法处理，如果 $x$ 在 $a,b$ 之间且 $x\equiv b\pmod a$，则可行，否则变化为 $b%a,a$ 继续；</p><p>记得判余数为 $0$ 的情况</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(ll a, ll b, ll x)</span></span>&#123;    <span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span> || b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(x == a || x == b) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(x &gt; b) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span>(b%a == x%a) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">judge</span>(b%a, a, x);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    ll a, b, x;    string sout[<span class="hljs-number">2</span>] = &#123;<span class="hljs-string">&quot;NO&quot;</span>, <span class="hljs-string">&quot;YES&quot;</span>&#125;;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; x;    <span class="hljs-keyword">if</span>(a &gt; b) <span class="hljs-built_in">swap</span>(a, b);    cout &lt;&lt; sout[<span class="hljs-built_in">judge</span>(a, b, x)] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="E-Messages"><a href="#E-Messages" class="headerlink" title="E. Messages"></a>E. Messages</h4><p>题意：有 $n$ 个人，每个人有一个期望读到的信 $m_i$，和他将读的信数 $k_i$，每个人都会在信堆里等概率地随机抽取 $k_i$ 封信阅读（不会取走）。现在你可以选择将哪些信放进信堆，使得读到想读信的人数期望最大。</p><p>第一反应想到了二分答案，因为确定了要放信的数量后比较容易judge</p><hr><p>考虑怎么计算：选择一共放 $m$ 封信时的最大期望</p><p>对于每个人来说，它读到想要的信的概率是 $\frac{min(k_i, m)}{m}$，我们可以对于每一封信，统计想读它的人的 $\min(k_i, m)$ 之和（记为 $tot$），那么选这封信的收益就是 $\frac{tot}{m}$ ；</p><p>将信按照 $tot$ 排序后选取前 $m$ 封就可以计算出最大期望了</p><hr><p>然后很显然地发现，答案不具有单调性，二份答案X</p><p>输入数据保证了 $k\le20$，用手模拟了一下极端情况，大胆猜测选 $20$ 封左右信时收益达到阈值，再多选收益一定更低</p><p>然后暴力跑了 $m\le50$ 的情况，就过了！</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<span class="hljs-type">int</span> a[maxn], b[maxn];<span class="hljs-type">bool</span> apr[maxn];vector&lt;<span class="hljs-type">int</span>&gt; all;ll tot[maxn];<span class="hljs-type">double</span> ans[maxn]; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmpf</span><span class="hljs-params">(ll x, ll y)</span></span>&#123; <span class="hljs-keyword">return</span> x &gt; y;&#125; <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        tot[a[i]] += <span class="hljs-built_in">min</span>(b[i], m);    &#125;    <span class="hljs-built_in">sort</span>(tot+<span class="hljs-number">1</span>, tot+<span class="hljs-number">200000</span>+<span class="hljs-number">1</span>, cmpf);    ll fz = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        fz += tot[i];    &#125;    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(tot[i] &gt; <span class="hljs-number">0</span>) tot[i++] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> fz * <span class="hljs-number">1.0</span> / m;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; a[i] &gt;&gt; b[i];        <span class="hljs-keyword">if</span>(!apr[a[i]])&#123;            all.<span class="hljs-built_in">push_back</span>(a[i]);            apr[a[i]] = <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(<span class="hljs-number">50</span>, n);i++)&#123;        ans[i] = <span class="hljs-built_in">judge</span>(i);        <span class="hljs-keyword">if</span>(ans[i] &gt; ans[p]) p = i;    &#125;    cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) tot[a[i]] += <span class="hljs-built_in">min</span>(b[i], p);    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; vp;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:all) vp.<span class="hljs-built_in">push_back</span>(&#123;tot[v], v&#125;);    <span class="hljs-built_in">sort</span>(vp.<span class="hljs-built_in">begin</span>(), vp.<span class="hljs-built_in">end</span>());    <span class="hljs-type">bool</span> fg = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">while</span>(p--)&#123;        <span class="hljs-keyword">if</span>(fg) cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;        <span class="hljs-keyword">else</span> fg = <span class="hljs-number">1</span>;        cout &lt;&lt; vp.<span class="hljs-built_in">back</span>().second;        vp.<span class="hljs-built_in">pop_back</span>();    &#125;    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 746 div.2 CDE</title>
    <link href="/2021/11/17/2021-10-07-Codeforces%20Round%20746%20div.2/"/>
    <url>/2021/11/17/2021-10-07-Codeforces%20Round%20746%20div.2/</url>
    
    <content type="html"><![CDATA[<p>这场没打，赛后看了一下题值得补</p><h4 id="C-Bakry-and-Partitioning"><a href="#C-Bakry-and-Partitioning" class="headerlink" title="C. Bakry and Partitioning"></a>C. Bakry and Partitioning</h4><p>题意：给出一棵 $n$ 节点的树，每个点有权值 $a_i$，问能否割去至少一条，至多 $k-1$ 条边，使得割完后各个连通块的权值异或和相等。</p><p>显然，如果整棵树的异或和为0，那么任选一条边割得到的两个连通块异或和都相等。（异或的性质）</p><p>如果整棵树异或和为 $x$ ，那么问题就等价于能不能把树拆出三个异或和为 $x$ 的连通块（三个可以合并成一个，所以能拆成更多块的也一定能拆成三块）</p><p>dfs地去找，当某个子树的异或和为 $x$ 时，记录并将这个子树清零，跑完之后看找到了几个即可</p><p>记得对 $k&#x3D;2$ 特判</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, k;<span class="hljs-type">int</span> a[maxn], xs[maxn];<span class="hljs-type">int</span> xsum, ans;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;    <span class="hljs-type">int</span> t, nt;&#125;e[maxn &lt;&lt; <span class="hljs-number">1</span>];<span class="hljs-type">int</span> head[maxn], cnt = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;    e[++cnt].t = y;    e[cnt].nt = head[x];    head[x] = cnt;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span></span>&#123;    xs[p] = a[p];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[p];i;i=e[i].nt)&#123;        <span class="hljs-type">int</span> v = e[i].t;        <span class="hljs-keyword">if</span>(v != fa)&#123;            <span class="hljs-built_in">dfs</span>(v, p);            xs[p] ^= xs[v];        &#125;    &#125;    <span class="hljs-keyword">if</span>(xs[p] == xsum)&#123;        ans++;        xs[p] = <span class="hljs-number">0</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; k;    xsum = cnt = ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) head[i] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; a[i];        xsum ^= a[i];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        <span class="hljs-built_in">add</span>(x, y);        <span class="hljs-built_in">add</span>(y, x);    &#125;    <span class="hljs-keyword">if</span>(xsum == <span class="hljs-number">0</span>)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">if</span>(k &lt;= <span class="hljs-number">2</span>)&#123;            cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span>(ans &gt; <span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="D-Hemose-in-ICPC"><a href="#D-Hemose-in-ICPC" class="headerlink" title="D. Hemose in ICPC ?"></a>D. Hemose in ICPC ?</h4><p>题意：交互题，现有一棵 $n$ 节点的树，每个边有边权（边权未知），可以进行至多12次询问：每次询问一个点集，回复是这个点集中 $Dist(a,b)$ 的最大值，$Dist(a,b)$ 定义为 $a$ 到 $b$ 路径上所有边权的gcd，求使 $Dist(a,b)$ 最大的 $a,b$</p><p>首先可以看出要找的就是权值最大的边，gcd是纯唬人的。</p><p>第一次查询先查询所有的点，这样就可以知道最大的边权是多少。</p><p>查询次数为12，数据规模 $n&lt;1000$，如果我们能以某种方式把树映射到序列上，且序列上连续的点在树上也连续，就可以二分地询问，找最大边的位置（因为连续，所以序列上两点之间就是边）。</p><p>欧拉序即可保证连续性。</p><p>ps：一开始用dfs序糊里糊涂过了，不能保证连续性但也能通过某种玄学的巧合AC，正确性不是很显然，我也讲不清楚，就不介绍了</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;    <span class="hljs-type">int</span> fr, t, nt;&#125;e[maxn &lt;&lt; <span class="hljs-number">1</span>];<span class="hljs-type">int</span> head[maxn], cnt = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> vis[maxn], vp = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> a[maxn &lt;&lt; <span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;    e[++cnt].t = y;    e[cnt].fr = x;    e[cnt].nt = head[x];    head[x] = cnt;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa)</span></span>&#123;    a[++cnt] = p;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[p];i;i=e[i].nt)&#123;        <span class="hljs-type">int</span> v = e[i].t;        <span class="hljs-keyword">if</span>(v != fa)&#123;            <span class="hljs-built_in">dfs</span>(v, p);            a[++cnt] = p;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getans</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;    vp++;    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, res;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;i++)&#123;        <span class="hljs-keyword">if</span>(vis[a[i]] != vp) vis[a[i]] = vp, k++;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; k;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(vis[i] == vp) cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; i;    &#125;    cout &lt;&lt; endl;    <span class="hljs-built_in">fflush</span>(stdout);    cin &gt;&gt; res;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    cnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        <span class="hljs-built_in">add</span>(x, y);        <span class="hljs-built_in">add</span>(y, x);    &#125;    cnt = <span class="hljs-number">0</span>;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);    <span class="hljs-type">int</span> mx;    cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    cout &lt;&lt; n &lt;&lt; endl;    <span class="hljs-built_in">fflush</span>(stdout);    cin &gt;&gt; mx;    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = cnt, mid;    <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> &lt; r)&#123;        mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">getans</span>(l, mid) == mx)&#123;            r = mid;        &#125;<span class="hljs-keyword">else</span>&#123;            l = mid;<span class="hljs-comment">//二分部分小改一下 因为要找的是两点间的连边</span>        &#125;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; a[l] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; a[r] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="E-Bored-Bakry"><a href="#E-Bored-Bakry" class="headerlink" title="E. Bored Bakry"></a>E. Bored Bakry</h4><p>题意：给一个长度为 $n$ 的序列 $a$，找到最长的子区间 $a_l..a_r$ 使得子区间所有元素的与运算和大于异或和</p><p>对每一位考虑，在第 $k$ 位上，与和为1的条件是区间所有数第 $k$ 位全是1；异或和为1的条件是区间中第 $k$ 位为1的数量是奇数个</p><p>那么可以注意到如果区间长度为奇数，任一位上与和为1的时候异或和也一定为1，与和不可能大于异或和</p><p>现在考虑，对于特定一个区间，如何判断它是否满足条件：</p><ul><li>首先它的长度必须为偶数</li><li>从高位到低位枚举，如果它在第 $k$ 位时第一次满足了<strong>区间第 $k$ 位全为1</strong>，那么比 $k$ 更高的位上1数量必须都为偶数</li></ul><p>可以维护一个前缀异或和（记为 $xsum$），从高位到低位枚举到第 $k$ 位时，$xsum(i)$表示仅考虑前 $k-1$ 位值时，前 $i$ 位的异或和</p><p>第二个条件其实就相当于 $xsum(r) &#x3D; xsum(l-1)$，因为前面这些位上的1都是偶数个</p><p>那么做法就很显然了：从高位到低位枚举，每一层中对于每一个1的位置 $r$，去找最小的满足条件的 $l$，同时维护 $xsum$ 即可</p><p>关于找最小的 $l$ ，记录同一段连续1内每一个 $xsum$ 值最早出现的位置即可（详见代码）</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gtw</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> w)</span></span>&#123; <span class="hljs-keyword">return</span> (x &gt;&gt; (w<span class="hljs-number">-1</span>)) &amp; <span class="hljs-number">1</span>;&#125;<span class="hljs-type">int</span> n, a[maxn], p[maxn];<span class="hljs-type">int</span> xsum[maxn], pos[maxn * <span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; a[i];    &#125;    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">21</span>;k&gt;=<span class="hljs-number">1</span>;k--)&#123;        <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r;        <span class="hljs-keyword">while</span>(l &lt; n)&#123;            <span class="hljs-keyword">while</span>(l &lt;= n &amp;&amp; <span class="hljs-built_in">gtw</span>(a[l], k) == <span class="hljs-number">0</span>) l++;            <span class="hljs-keyword">if</span>(l &gt; n) <span class="hljs-keyword">break</span>;            r = l + <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span>(r &lt;= n &amp;&amp; <span class="hljs-built_in">gtw</span>(a[r], k) == <span class="hljs-number">1</span>) r++;            r--;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=l<span class="hljs-number">-1</span>;j&lt;=r;j+=<span class="hljs-number">2</span>) pos[xsum[j]] = <span class="hljs-number">-1</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=l<span class="hljs-number">-1</span>;j&lt;=r;j+=<span class="hljs-number">2</span>)&#123;                <span class="hljs-keyword">if</span>(pos[xsum[j]] == <span class="hljs-number">-1</span>) pos[xsum[j]] = j;                <span class="hljs-keyword">else</span> ans = <span class="hljs-built_in">max</span>(ans, j - pos[xsum[j]]);            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=l;j&lt;=r;j+=<span class="hljs-number">2</span>) pos[xsum[j]] = <span class="hljs-number">-1</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=l;j&lt;=r;j+=<span class="hljs-number">2</span>)&#123;                <span class="hljs-keyword">if</span>(pos[xsum[j]] == <span class="hljs-number">-1</span>) pos[xsum[j]] = j;                <span class="hljs-keyword">else</span> ans = <span class="hljs-built_in">max</span>(ans, j - pos[xsum[j]]);            &#125;            l = r + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;            p[i] += a[i] &amp; (<span class="hljs-number">1</span> &lt;&lt; (k<span class="hljs-number">-1</span>));            xsum[i] = xsum[i<span class="hljs-number">-1</span>] ^ p[i];        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 755 div.1 ABC</title>
    <link href="/2021/11/14/2021-11-14-Codeforces%20Round%20755%20div.1/"/>
    <url>/2021/11/14/2021-11-14-Codeforces%20Round%20755%20div.1/</url>
    
    <content type="html"><![CDATA[<p>第一次打div1，头被锤烂了（</p><h4 id="A-Two-Arrays"><a href="#A-Two-Arrays" class="headerlink" title="A. Two Arrays"></a>A. Two Arrays</h4><p>题意：有两个 $1-n$ 的排列 $a,b$，可以对 $a$ 序列进行如下操作：</p><ol><li>将一些位置上的数+1</li><li>任意改变 $a$ 的顺序</li></ol><p>问能否一次操作将 $a$ 变成 $b$</p><p>排序后依次判断每一位上的 $a$ 能否变成 $b$ 即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn], b[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; b[i];    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+n+<span class="hljs-number">1</span>);    <span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>, b+n+<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(a[i] &gt; b[i])&#123;            cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(a[i] &lt; b[i] - <span class="hljs-number">1</span>)&#123;            cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;&#125;</code></pre></div><p>7分钟签完这题，剩下时间都在坐牢了（（</p><h4 id="B-Guess-the-Permutation"><a href="#B-Guess-the-Permutation" class="headerlink" title="B. Guess the Permutation"></a>B. Guess the Permutation</h4><p>题意：交互题，有一个 $1-n$ 的排列 $a$，初始时 $a_i &#x3D; i$，电脑对这个序列进行了一次更改：将 $[i,j-1]$，$[j,k]$ 两个区间翻转了，你可以询问：$[l,r]$ 上有多少个逆序对？询问至多40次，要猜出 $i,j,k$</p><p>先二分找到 $i$，用至多30次，然后可以根据 $[i,n]$ 的结果减去 $[i+1,n]$ 直接得出第一个逆序串的长度。。同理第二个也很好弄了。</p><p>考场上剩下时间全在搞这个题的玄学二分优化、三分</p><p>赛后一看代码，发现核心思维压根就没想到，很服气</p><div class="code-wrapper"><pre><code class="hljs c++">ll n;<span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll l, ll r)</span></span>&#123;    cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; l &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; r &lt;&lt; endl;    cout.<span class="hljs-built_in">flush</span>();    ll x;    cin &gt;&gt; x;    <span class="hljs-keyword">return</span> x;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;     cin &gt;&gt; n;    ll l = <span class="hljs-number">1</span>, r = n;    <span class="hljs-keyword">while</span>(l &lt; r)&#123;        ll mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        ll x = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, mid);        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>)&#123;            l = mid;        &#125;<span class="hljs-keyword">else</span>&#123;            r = mid - <span class="hljs-number">1</span>;        &#125;    &#125;    ll s1 = <span class="hljs-number">1</span> + <span class="hljs-built_in">query</span>(l, n) - <span class="hljs-built_in">query</span>(l + <span class="hljs-number">1</span>, n);    ll j = l + s1;    ll s2 = <span class="hljs-number">1</span> + <span class="hljs-built_in">query</span>(j, n) - <span class="hljs-built_in">query</span>(j + <span class="hljs-number">1</span>, n);    cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; l &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; l + s1 &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; l + s1 + s2 - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;     cout.<span class="hljs-built_in">flush</span>();&#125;</code></pre></div><h4 id="C-Game-with-Stones"><a href="#C-Game-with-Stones" class="headerlink" title="C. Game with Stones"></a>C. Game with Stones</h4><p>题意：有一列石头堆 $a$，$a_i$ 表示第 $i$ 堆石头的数量，Bob每次可以选择两个相邻的石头堆，同时从中拿走一个石头（不能选择空石头堆），如果Bob可以把这列石头堆全部清空，则Bob获胜。现在问有多少组 $[l,r]$ 使得单独拿出 $l$ 到 $r$ 位置上的石头，可以使Bob获胜。</p><p>首先可以注意到，任意一列石头，Bob必须从两端开始取，比如从左到右取，那么就依次让每个位置上的值减去上一位的值，设 $c_i&#x3D;a_i-c_{i-1}$，如果取的中途出现了一位 $c_i$ 为负数，则一定不能获胜；取到结尾处如果 $c_n&#x3D;0$ 则恰能获胜，否则还是不能获胜。</p><p>考虑左端点为1的情况：直接一遍计算出所有的 $c$，然后统计 $c$ <strong>在第一个负数之前0的个数</strong>，即为左端点为1的答案。</p><p>接下来考虑如何快速转移：忽略第一堆石头，将左端点为1情况下的 $c$ 转移到左端点为2的情况。</p><p>很显然，将最左边的 $a_1$ 去掉会使得 $c_2$ 加上 $a_1$，$c_3$ 减去 $a_1$，$c_4$ 又加上 $a_1$ …</p><p>即使得后面的所有奇数位加上或减去 $a_1$，偶数位反之；在任何一次转移中，所有的奇数位都同时变化，偶数位也同时变化。</p><p>那么可以考虑将奇偶数位分开维护，这样我们只需要一种数据结构，需要支持<strong>区间加减法</strong>和区间查找 $c$ <strong>在第一个负数之前0的个数</strong></p><p>这里给出一种线段树维护的思路：</p><p>对于奇数位和偶数位各开一个线段树，维护区间<strong>最小值</strong>和<strong>最小值的数量</strong>，这个在区间加减法下很容易维护。</p><p>写两种操作：查询<strong>区间第一个负数的位置</strong> 和查询<strong>不含负数区间中0的数量</strong>，显然这两个操作能够满足需求。</p><p>第一种操作，查找时若左段的最小值为负，则查找左边，否则查找右边；</p><p>第二种操作，因为保证区间没有负数了，找到对应区间后直接返回最小值数量即可，注意要筛掉最小值不为0的区间。</p><div class="code-wrapper"><pre><code class="hljs c++">ll n, a[maxn], c[maxn];<span class="hljs-function">ll <span class="hljs-title">f1</span><span class="hljs-params">(ll x)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x - <span class="hljs-number">1</span>;&#125;<span class="hljs-function">ll <span class="hljs-title">f2</span><span class="hljs-params">(ll x)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x;&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegTree</span>&#123;    ll num[maxn &lt;&lt; <span class="hljs-number">2</span>], mi[maxn &lt;&lt; <span class="hljs-number">2</span>], tad[maxn &lt;&lt; <span class="hljs-number">2</span>];    ll ls[maxn &lt;&lt; <span class="hljs-number">2</span>], rs[maxn &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-built_in">ll</span> (*fp)(ll);    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(ll p)</span></span>&#123;        num[p] = num[ls[p]] + num[rs[p]];        mi[p] = <span class="hljs-built_in">min</span>(mi[ls[p]], mi[rs[p]]);        num[p] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(mi[p] == mi[ls[p]]) num[p] += num[ls[p]];        <span class="hljs-keyword">if</span>(mi[p] == mi[rs[p]]) num[p] += num[rs[p]];    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_add</span><span class="hljs-params">(ll p, ll ad)</span></span>&#123;        mi[p] += ad;        tad[p] += ad;    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(ll p)</span></span>&#123;        <span class="hljs-built_in">push_add</span>(ls[p], tad[p]);        <span class="hljs-built_in">push_add</span>(rs[p], tad[p]);        tad[p] = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll p, ll l, ll r)</span></span>&#123;        <span class="hljs-keyword">if</span>(l &gt; r) <span class="hljs-keyword">return</span>;        tad[p] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(l == r)&#123;            num[p] = <span class="hljs-number">1</span>;            mi[p] = c[<span class="hljs-built_in">fp</span>(l)];            <span class="hljs-keyword">return</span>;        &#125;        ll mid = (l + r) / <span class="hljs-number">2</span>;        ls[p] = p*<span class="hljs-number">2</span>, rs[p] = p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;        <span class="hljs-built_in">build</span>(p*<span class="hljs-number">2</span>, l, mid);        <span class="hljs-built_in">build</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r);        <span class="hljs-built_in">push_up</span>(p);    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(ll p, ll l, ll r, ll L, ll R, ll ad)</span></span>&#123;        <span class="hljs-comment">//lr为线段树中节点管辖下标范围，LR为实际查询范围</span>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fp</span>(l) &gt; R || <span class="hljs-built_in">fp</span>(r) &lt; L) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(L &lt;= <span class="hljs-built_in">fp</span>(l) &amp;&amp; <span class="hljs-built_in">fp</span>(r) &lt;= R)&#123;            <span class="hljs-built_in">push_add</span>(p, ad);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-built_in">push_down</span>(p);        ll mid = (l + r) / <span class="hljs-number">2</span>;        <span class="hljs-built_in">modify</span>(ls[p], l, mid, L, R, ad);        <span class="hljs-built_in">modify</span>(rs[p], mid+<span class="hljs-number">1</span>, r, L, R, ad);        <span class="hljs-built_in">push_up</span>(p);    &#125;    <span class="hljs-function">ll <span class="hljs-title">query_lz</span><span class="hljs-params">(ll p, ll l, ll r, ll L, ll R)</span></span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fp</span>(l) &gt; R || <span class="hljs-built_in">fp</span>(r) &lt; L) <span class="hljs-keyword">return</span> <span class="hljs-number">1e9</span>;        <span class="hljs-keyword">if</span>(mi[p] &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1e9</span>;        <span class="hljs-keyword">if</span>(l == r) <span class="hljs-keyword">return</span> <span class="hljs-built_in">fp</span>(l);        <span class="hljs-built_in">push_down</span>(p);        ll mid = (l + r) / <span class="hljs-number">2</span>, re = <span class="hljs-number">1e9</span>;        re = <span class="hljs-built_in">min</span>(re, <span class="hljs-built_in">query_lz</span>(ls[p], l, mid, L, R));        <span class="hljs-keyword">if</span>(re &gt; <span class="hljs-number">1e8</span>) re = <span class="hljs-built_in">min</span>(re, <span class="hljs-built_in">query_lz</span>(rs[p], mid+<span class="hljs-number">1</span>, r, L, R));        <span class="hljs-keyword">return</span> re;    &#125;    <span class="hljs-function">ll <span class="hljs-title">query_num</span><span class="hljs-params">(ll p, ll l, ll r, ll L, ll R)</span></span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fp</span>(l) &gt; R || <span class="hljs-built_in">fp</span>(r) &lt; L) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(mi[p] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(L &lt;= <span class="hljs-built_in">fp</span>(l) &amp;&amp; <span class="hljs-built_in">fp</span>(r) &lt;= R) <span class="hljs-keyword">return</span> num[p];<span class="hljs-comment">//已经确认mi[p] == 0</span>        <span class="hljs-built_in">push_down</span>(p);        ll mid = (l + r) / <span class="hljs-number">2</span>, re = <span class="hljs-number">0</span>;        re += <span class="hljs-built_in">query_num</span>(ls[p], l, mid, L, R);        re += <span class="hljs-built_in">query_num</span>(rs[p], mid+<span class="hljs-number">1</span>, r, L, R);        <span class="hljs-keyword">return</span> re;    &#125;&#125;st1, st2;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin &gt;&gt; a[i];    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++) c[i] = a[i] - c[i<span class="hljs-number">-1</span>];    st1.fp = f1;    st2.fp = f2;    st1.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>);    st2.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n/<span class="hljs-number">2</span>);    ll ans = <span class="hljs-number">0</span>;    ll zp = <span class="hljs-built_in">min</span>(st1.<span class="hljs-built_in">query_lz</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, n),                 st2.<span class="hljs-built_in">query_lz</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, n));    <span class="hljs-keyword">if</span>(zp &gt; <span class="hljs-number">1e8</span>) zp = n + <span class="hljs-number">1</span>;    ans += st1.<span class="hljs-built_in">query_num</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, zp<span class="hljs-number">-1</span>);    ans += st2.<span class="hljs-built_in">query_num</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, zp<span class="hljs-number">-1</span>);    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;            st1.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>, i+<span class="hljs-number">1</span>, n, a[i]);            st2.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n/<span class="hljs-number">2</span>, i+<span class="hljs-number">1</span>, n, -a[i]);        &#125;<span class="hljs-keyword">else</span>&#123;            st1.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>, i+<span class="hljs-number">1</span>, n, -a[i]);            st2.<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n/<span class="hljs-number">2</span>, i+<span class="hljs-number">1</span>, n, a[i]);        &#125;        ll zp = <span class="hljs-built_in">min</span>(st1.<span class="hljs-built_in">query_lz</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>, i+<span class="hljs-number">1</span>, n),                     st2.<span class="hljs-built_in">query_lz</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n/<span class="hljs-number">2</span>, i+<span class="hljs-number">1</span>, n));        <span class="hljs-keyword">if</span>(zp &gt; <span class="hljs-number">1e8</span>) zp = n + <span class="hljs-number">1</span>;        ans += st1.<span class="hljs-built_in">query_num</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>, i+<span class="hljs-number">1</span>, zp<span class="hljs-number">-1</span>);        ans += st2.<span class="hljs-built_in">query_num</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n/<span class="hljs-number">2</span>, i+<span class="hljs-number">1</span>, zp<span class="hljs-number">-1</span>);    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 749 div.1 2 A-E</title>
    <link href="/2021/10/17/2021-10-17-Codeforces%20Round%20749%20div.1%202/"/>
    <url>/2021/10/17/2021-10-17-Codeforces%20Round%20749%20div.1%202/</url>
    
    <content type="html"><![CDATA[<h4 id="A-Windblume-Ode"><a href="#A-Windblume-Ode" class="headerlink" title="A. Windblume Ode"></a>A. Windblume Ode</h4><p>题意：给一个数字集合（$n\ge3$），要从中取出尽可能多的数字，使之和为合数</p><p>判断总和是否为质数，是质数就随便去掉一个奇数就好了</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[maxn]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; a[i];        sum += a[i];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;sum;i++)&#123;        <span class="hljs-keyword">if</span>(sum % i == <span class="hljs-number">0</span>)&#123;            cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;            cout &lt;&lt; n &lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(a[i] %<span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;            cout &lt;&lt; n - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;            <span class="hljs-type">bool</span> f = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;                <span class="hljs-keyword">if</span>(j == i) <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">if</span>(f) cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;                <span class="hljs-keyword">else</span> f = <span class="hljs-literal">true</span>;                cout &lt;&lt; j;            &#125;            cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;&#125;</code></pre></div><h4 id="B-Omkar-and-Heavenly-Tree"><a href="#B-Omkar-and-Heavenly-Tree" class="headerlink" title="B. Omkar and Heavenly Tree"></a>B. Omkar and Heavenly Tree</h4><p>题意：要构造一个 $n$ 个节点的数，满足 $m$ 个约束。一个约束描述为 $a,b,c$，表示节点 $b$ 不能在 $a,c$ 之间的简单路径上，（$m\lt n$）</p><p>这题乍一看没什么思路，突破口在于 $m \lt n$ 这个条件，我们发现，至少有一个节点没有被约束，设它为 $mid$</p><p>只需要把其他所有点都直接连在 $mid$ 上即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> vis[maxn]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        vis[i] = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-type">int</span> x, y, z;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;        vis[y] = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-type">int</span> mid;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(!vis[i])&#123;            mid = i;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(i != mid)&#123;            cout &lt;&lt; mid &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;        &#125;    &#125; &#125;</code></pre></div><h4 id="C-Omkar-and-Determination"><a href="#C-Omkar-and-Determination" class="headerlink" title="C. Omkar and Determination"></a>C. Omkar and Determination</h4><p>题意：给出一个 $n\times m$ 的地图，每一格可以是空地或墙，每个空地上存在一个机器人，它可以向左或向上走；</p><p>​对于一个地图，我们可以把所有<strong>能走出地图</strong>的空格染成白色，其他格子染成黑色；</p><p>​如果一个地图可以<strong>仅根据染色后的结果</strong>推断出原先的图（哪些是空地哪些是墙），那么称这个地图是<strong>有决心的</strong>；</p><p>​接下来有 $q$ 个询问，每次询问从 $x_1$ 列到 $x_2$ 列的这个子图是不是有决心的。</p><p>解：考虑什么样的图的有决心的，可以想到如果存在这样的两个墙，一定不是有决心的（右下角无法确定）<br>$$<br>0 1\<br>1 ?<br>$$<br>​再想一想可以发现，所有<strong>有决心的</strong>图都一定不包含这种东西</p><p>​对于每一列 $j$，如果 $j$ 和 $j+1$ 列中存在这样的形状就记这列为1，前缀和搞一下查询就好了</p><div class="code-wrapper"><pre><code class="hljs c++">string s[<span class="hljs-number">1000004</span>];<span class="hljs-type">int</span> n, m, sum[<span class="hljs-number">1000004</span>]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; s[i];        s[i] = <span class="hljs-string">&#x27;0&#x27;</span> + s[i];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) sum[i] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;m;j++)&#123;            <span class="hljs-keyword">if</span>(s[i][j] == <span class="hljs-string">&#x27;X&#x27;</span> &amp;&amp; s[i<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;X&#x27;</span>)&#123;                sum[j] = <span class="hljs-number">1</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;=m;j++) sum[j] += sum[j<span class="hljs-number">-1</span>];    <span class="hljs-type">int</span> Q;    cin &gt;&gt; Q;    <span class="hljs-keyword">while</span>(Q--)&#123;        <span class="hljs-type">int</span> l, r;        cin &gt;&gt; l &gt;&gt; r;        <span class="hljs-keyword">if</span>(sum[r<span class="hljs-number">-1</span>]-sum[l<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;    &#125;&#125;</code></pre></div><h4 id="D-Omkar-and-the-Meaning-of-Life"><a href="#D-Omkar-and-the-Meaning-of-Life" class="headerlink" title="D. Omkar and the Meaning of Life"></a>D. Omkar and the Meaning of Life</h4><p>题意：交互题，要猜一个 $n$ 的排列 $p_1,p_2…p_n$ ，每次猜测可以输入一个长度为 $n$ 的数列 $a_1,a_2…a_n$，随后形成一个新的序列 $s$，根据 $s_i &#x3D; a_i+p_i$ ，然后会返回 $s$ 中<strong>第一次重复出现元素的下标</strong>，都不重复则返回0，询问至多 $2n$ 次</p><p>解：交互题往往有个构造题的思路，先考虑给所有数都加上1，唯独最后一个数加 $x$，如果 $p_n + x \gt n+1$，那么输出为0，否则有其他输出，那么可以从小到大枚举 $x$，最多 $n$ 次即可猜出 $p_n$ 的数值</p><p>现在知道最后一位数的值了，接下来给所有数都加上 $p_n$，唯独最后一位数加上1，就可以知道1所在的位置</p><p>依次类推，再 $n$ 次查询即可知道所有数的位置。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, a[maxn]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    a[n] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=n;k&gt;=<span class="hljs-number">2</span>;k--)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;        cout &lt;&lt; n-k+<span class="hljs-number">2</span> &lt;&lt; endl;        cout.<span class="hljs-built_in">flush</span>();        <span class="hljs-type">int</span> re;        cin &gt;&gt; re;        <span class="hljs-keyword">if</span>(re == <span class="hljs-number">0</span>)&#123;            a[n] = k;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(i == a[n]) <span class="hljs-keyword">continue</span>;        cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++) cout &lt;&lt; a[n] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;        cout &lt;&lt; i &lt;&lt; endl;        cout.<span class="hljs-built_in">flush</span>();         <span class="hljs-type">int</span> re;        cin &gt;&gt; re;        a[re] = i;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;!&quot;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; a[i];    cout &lt;&lt; endl;&#125;</code></pre></div><h4 id="D2-Half-of-Same"><a href="#D2-Half-of-Same" class="headerlink" title="D2. Half of Same"></a>D2. Half of Same</h4><p>题意：和D1一样，区别在于只需要有一半数减去若干个 $k$ 后变成相同的数字</p><p>$n\le40, -10^6\le a_i \le 10^6$</p><p>先考虑，如果有一个 $k$，我们怎么判断它是否合法：</p><p>可以让每个数都减 $k$ 减到<strong>第一次小于 $mi$ 为止</strong>，然后数一下有多少数是相同的</p><p>这个Judge过程是 $O(n)$ 的</p><p>那么有多少个 $k$ 需要judge呢？</p><p>可以从1到2e6全部枚举一遍，$O(2e6\times n)$ 看似可行，然而被卡常了</p><p>想到这个 $k$ 一定是某两个数的差的约数，又因为 $n$ 很小，可以非常暴力地枚举任意两个数，再枚举它们差的约数，总复杂度 $O(n^2\sqrt{2\times10^6}\times n)$</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">50</span>];<span class="hljs-type">int</span> mia, mxa;<span class="hljs-type">int</span> num[<span class="hljs-number">5000009</span>];<span class="hljs-type">int</span> n; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;    <span class="hljs-type">bool</span> re = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> t = a[i] - (a[i]-mia+k<span class="hljs-number">-1</span>)/k*k;        num[t]++;        <span class="hljs-keyword">if</span>(num[t] &gt;= n/<span class="hljs-number">2</span>) re = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> t = a[i] - (a[i]-mia+k<span class="hljs-number">-1</span>)/k*k;        num[t]--;    &#125;    <span class="hljs-keyword">return</span> re;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    mia = <span class="hljs-number">2e8</span>, mxa = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; a[i];        a[i] += <span class="hljs-number">4000000</span>;        mia = <span class="hljs-built_in">min</span>(mia, a[i]);        mxa = <span class="hljs-built_in">max</span>(mxa, a[i]);    &#125;     <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+n+<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n;j++)&#123;            <span class="hljs-keyword">if</span>(a[j] != a[i])&#123;                i = j - <span class="hljs-number">1</span>;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span>(j - i + <span class="hljs-number">1</span> &gt;= n/<span class="hljs-number">2</span>)&#123;                cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;        &#125;    &#125;     <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;            <span class="hljs-type">int</span> d = <span class="hljs-built_in">abs</span>(a[j] - a[i]);            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-built_in">sqrt</span>(d);k++)&#123;                <span class="hljs-keyword">if</span>(d % k != <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(k)) ans = <span class="hljs-built_in">max</span>(ans, k);                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(d/k)) ans = <span class="hljs-built_in">max</span>(ans, d/k);            &#125;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="E-Moment-of-Bloom"><a href="#E-Moment-of-Bloom" class="headerlink" title="E. Moment of Bloom"></a>E. Moment of Bloom</h4><p>个人感觉最妙的一道题，做的时候一点思路没有，一看题解恍然大悟</p><p>题意：有一个 $n$ 节点，$m$ 条边的连通图（无重边自环），有 $q$ 个操作，每次操作仅给出 $a,b$ 两个点，可以在两点间任选一条简单路径，使路径上的边权都+1（初始为0），问这 $q$ 个操作后能否使所有边权均为偶数？如果不能输出需要额外操作的数量</p><p>解：一个点<strong>相邻边的边权之和</strong> &#x3D; 以这个点为端点的路径条数 + 其他经过这个点的路径条数 * 2</p><p>​那么如果一个点在操作中出现了奇数次，那么它连的边权之和也为奇数，也就是说必然存在一条边不满足条件</p><p>​所以可以统计所有操作中各个点出现的次数，如果存在奇数次的点，答案即为NO，额外需要奇数点个数&#x2F;2次操作</p><p>​所有点均出现偶数次，答案即为YES，这题还要求输出每一个操作所选择的路径，怎么构造呢——</p><p>​其实很简单，把图改造成任一个生成树，然后走唯一路径就好了（（具体可以颅内理解一下，不难证明正确性</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> cnt[maxn];vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];vector&lt;<span class="hljs-type">int</span>&gt; vt[maxn]; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Query</span>&#123;    <span class="hljs-type">int</span> x, y;&#125;q[maxn]; <span class="hljs-type">int</span> vis[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;    vis[p] = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;v : vp[p])&#123;        <span class="hljs-keyword">if</span>(!vis[v])&#123;            vt[p].<span class="hljs-built_in">push_back</span>(v);            vt[v].<span class="hljs-built_in">push_back</span>(p);            <span class="hljs-built_in">dfs</span>(v);        &#125;    &#125;&#125; <span class="hljs-type">int</span> ans[maxn], hd;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfsf</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> t)</span></span>&#123;    ans[++hd] = p;    <span class="hljs-keyword">if</span>(p == t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;v : vt[p])&#123;        <span class="hljs-keyword">if</span>(v != fa)&#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfsf</span>(v, p, t)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;    &#125;    hd--;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        vp[x].<span class="hljs-built_in">push_back</span>(y);        vp[y].<span class="hljs-built_in">push_back</span>(x);    &#125;    <span class="hljs-type">int</span> qm;    cin &gt;&gt; qm;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=qm;i++)&#123;        cin &gt;&gt; q[i].x &gt;&gt; q[i].y;        cnt[q[i].x]++;        cnt[q[i].y]++;    &#125;    <span class="hljs-type">int</span> odd = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) odd += cnt[i]%<span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span>(odd &gt; <span class="hljs-number">0</span>)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;        cout &lt;&lt; odd/<span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=qm;i++)&#123;            hd = <span class="hljs-number">0</span>;            <span class="hljs-built_in">dfsf</span>(q[i].x, <span class="hljs-number">-1</span>, q[i].y);            cout &lt;&lt; hd &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;hd;j++) cout &lt;&lt; ans[j] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;            cout &lt;&lt; ans[hd] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 748 div.3 A-G</title>
    <link href="/2021/10/13/2021-10-13-Codeforces%20Round%20748%20div.3/"/>
    <url>/2021/10/13/2021-10-13-Codeforces%20Round%20748%20div.3/</url>
    
    <content type="html"><![CDATA[<h4 id="A-Elections"><a href="#A-Elections" class="headerlink" title="A. Elections"></a>A. Elections</h4><p>题意：有三个数ABC，问他们分别需要加多少才能成为三个数中最大的</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> a, b, c;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;    <span class="hljs-type">int</span> mx = <span class="hljs-built_in">max</span>(a, <span class="hljs-built_in">max</span>(b, c));    <span class="hljs-type">int</span> mx2 = a+b+c - mx - <span class="hljs-built_in">min</span>(a, <span class="hljs-built_in">min</span>(b, c));     <span class="hljs-keyword">if</span>(a == mx &amp;&amp; mx2 != mx) cout &lt;&lt; <span class="hljs-string">&quot;0 &quot;</span>;    <span class="hljs-keyword">else</span> cout &lt;&lt; mx+<span class="hljs-number">1</span>-a &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    <span class="hljs-keyword">if</span>(b == mx &amp;&amp; mx2 != mx) cout &lt;&lt; <span class="hljs-string">&quot;0 &quot;</span>;    <span class="hljs-keyword">else</span> cout &lt;&lt; mx+<span class="hljs-number">1</span>-b &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;     <span class="hljs-keyword">if</span>(c == mx &amp;&amp; mx2 != mx) cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;    <span class="hljs-keyword">else</span> cout &lt;&lt; mx+<span class="hljs-number">1</span>-c &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; &#125;</code></pre></div><h4 id="B-Make-it-Divisible-by-25"><a href="#B-Make-it-Divisible-by-25" class="headerlink" title="B. Make it Divisible by 25"></a>B. Make it Divisible by 25</h4><p>题意：给定一个数字，问至少从中删除几位数，可以使他能被25整除</p><p>只要最后两位是00,25,50,75即可，那么从低位到高位找，分别找这几种第一次出现的位置，取最小即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[maxn], ans;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getnum</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">int</span> a2)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">20</span>;i++)&#123;        <span class="hljs-keyword">if</span>(a[i] == a2)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;<span class="hljs-number">20</span>;j++)&#123;                <span class="hljs-keyword">if</span>(a[j] == a1)&#123;                    ans = <span class="hljs-built_in">min</span>(ans, j - <span class="hljs-number">2</span>);                    <span class="hljs-keyword">return</span>;                &#125;            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    ll n;    cin &gt;&gt; n;    ans = <span class="hljs-number">1e9</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">20</span>;i++)&#123;        a[i] = n%<span class="hljs-number">10</span>;        n /= <span class="hljs-number">10</span>;    &#125;    <span class="hljs-built_in">getnum</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    <span class="hljs-built_in">getnum</span>(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>);    <span class="hljs-built_in">getnum</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);    <span class="hljs-built_in">getnum</span>(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>);    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="C-Save-More-Mice"><a href="#C-Save-More-Mice" class="headerlink" title="C. Save More Mice"></a>C. Save More Mice</h4><p>题意：X轴上有若干个老鼠，每个老鼠的位置都是整数，$(n,0)$ 处有一个洞，$(0,0)$ 中有一只猫，每回合可以选择一只老鼠向右移动一格，抵达洞即安全，每回合猫也向右移动一格，吃掉该格上的老鼠。问最多可以让多少老鼠存活</p><p>因为老鼠和猫的移动速度相同，任何一只老鼠都不可能和猫拉开距离，所以每次都选择离洞最近的老鼠让它进洞，答案一定最大。模拟即可。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    ll n, k;    cin &gt;&gt; n &gt;&gt; k;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;        cin &gt;&gt; a[i];    &#125;    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+k+<span class="hljs-number">1</span>);    ll ans = <span class="hljs-number">0</span>, p = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k;i&gt;=<span class="hljs-number">1</span>;i--)&#123;        <span class="hljs-keyword">if</span>(p &gt;= a[i]) <span class="hljs-keyword">break</span>;        p += n - a[i];        ans++;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="D1-All-are-Same"><a href="#D1-All-are-Same" class="headerlink" title="D1. All are Same"></a>D1. All are Same</h4><p>题意：给一个序列，要找一个最大的 $k$，使得所有数都可以减去若干个 $k$ 后变成相同的数字</p><p>找到最小的数 $mi$，然后计算每个数和 $mi$ 的差的 $gcd$ 和即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> st[maxn];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;    <span class="hljs-type">int</span> t, nt, tp;&#125;e[maxn &lt;&lt; <span class="hljs-number">1</span>];<span class="hljs-type">int</span> head[maxn], ecnt = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> tp)</span></span>&#123;    e[++ecnt].t = y;    e[ecnt].tp = tp;    e[ecnt].nt = head[x];    head[x] = ecnt;&#125;<span class="hljs-type">int</span> num[<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[p];i;i=e[i].nt)&#123;        <span class="hljs-type">int</span> v = e[i].t;        <span class="hljs-keyword">if</span>(st[v] == <span class="hljs-number">-1</span>)&#123;            st[v] = st[p] ^ e[i].tp;            num[st[v]]++;            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(v)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(st[v] != (st[p] ^ e[i].tp)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n, m;    cin &gt;&gt; n &gt;&gt; m;    ecnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        head[i] = <span class="hljs-number">0</span>;        st[i] = <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-type">int</span> x, y; string s;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; s;        <span class="hljs-type">int</span> tp = (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;i&#x27;</span>);        <span class="hljs-built_in">add</span>(x, y, tp);        <span class="hljs-built_in">add</span>(y, x, tp);    &#125;    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(st[i] == <span class="hljs-number">-1</span>)&#123;            st[i] = <span class="hljs-number">1</span>;            num[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;            num[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i))&#123;                cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;            ans += <span class="hljs-built_in">max</span>(num[<span class="hljs-number">0</span>], num[<span class="hljs-number">1</span>]);        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="D2-Half-of-Same"><a href="#D2-Half-of-Same" class="headerlink" title="D2. Half of Same"></a>D2. Half of Same</h4><p>题意：和D1一样，区别在于只需要有一半数减去若干个 $k$ 后变成相同的数字</p><p>$n\le40, -10^6\le a_i \le 10^6$</p><p>先考虑，如果有一个 $k$，我们怎么判断它是否合法：</p><p>可以让每个数都减 $k$ 减到<strong>第一次小于 $mi$ 为止</strong>，然后数一下有多少数是相同的</p><p>这个Judge过程是 $O(n)$ 的</p><p>那么有多少个 $k$ 需要judge呢？</p><p>可以从1到2e6全部枚举一遍，$O(2e6\times n)$ 看似可行，然而被卡常了</p><p>想到这个 $k$ 一定是某两个数的差的约数，又因为 $n$ 很小，可以非常暴力地枚举任意两个数，再枚举它们差的约数，总复杂度 $O(n^2\sqrt{2\times10^6}\times n)$</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">50</span>];<span class="hljs-type">int</span> mia, mxa;<span class="hljs-type">int</span> num[<span class="hljs-number">5000009</span>];<span class="hljs-type">int</span> n; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;    <span class="hljs-type">bool</span> re = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> t = a[i] - (a[i]-mia+k<span class="hljs-number">-1</span>)/k*k;        num[t]++;        <span class="hljs-keyword">if</span>(num[t] &gt;= n/<span class="hljs-number">2</span>) re = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">int</span> t = a[i] - (a[i]-mia+k<span class="hljs-number">-1</span>)/k*k;        num[t]--;    &#125;    <span class="hljs-keyword">return</span> re;&#125; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n;    mia = <span class="hljs-number">2e8</span>, mxa = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        cin &gt;&gt; a[i];        a[i] += <span class="hljs-number">4000000</span>;        mia = <span class="hljs-built_in">min</span>(mia, a[i]);        mxa = <span class="hljs-built_in">max</span>(mxa, a[i]);    &#125;     <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+n+<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n;j++)&#123;            <span class="hljs-keyword">if</span>(a[j] != a[i])&#123;                i = j - <span class="hljs-number">1</span>;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span>(j - i + <span class="hljs-number">1</span> &gt;= n/<span class="hljs-number">2</span>)&#123;                cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;        &#125;    &#125;     <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;            <span class="hljs-type">int</span> d = <span class="hljs-built_in">abs</span>(a[j] - a[i]);            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-built_in">sqrt</span>(d);k++)&#123;                <span class="hljs-keyword">if</span>(d % k != <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(k)) ans = <span class="hljs-built_in">max</span>(ans, k);                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(d/k)) ans = <span class="hljs-built_in">max</span>(ans, d/k);            &#125;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="E-Gardener-and-Tree"><a href="#E-Gardener-and-Tree" class="headerlink" title="E. Gardener and Tree"></a>E. Gardener and Tree</h4><p>题意：有一棵树，每次操作可以删除所有的叶子节点（度数为1的节点），问几次操作后树为空</p><p>很明显拓扑删一遍即可，队友说也可以换根dp，改天了解一下（</p><div class="code-wrapper"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; vp[maxn];<span class="hljs-type">int</span> du[maxn]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n, k;    cin &gt;&gt; n &gt;&gt; k;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) vp[i].<span class="hljs-built_in">clear</span>(), du[i] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> x, y;        cin &gt;&gt; x &gt;&gt; y;        vp[x].<span class="hljs-built_in">push_back</span>(y);        vp[y].<span class="hljs-built_in">push_back</span>(x);        du[x]++;        du[y]++;    &#125;    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;        cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;        <span class="hljs-keyword">return</span>;    &#125;    queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(du[i] == <span class="hljs-number">1</span>)&#123;            q.<span class="hljs-built_in">push</span>(i);        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;        vector&lt;<span class="hljs-type">int</span>&gt; tmp;        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;            <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();            q.<span class="hljs-built_in">pop</span>();            du[u]--;            n--;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;j:vp[u])&#123;                <span class="hljs-keyword">if</span>(du[j] &gt; <span class="hljs-number">0</span>)&#123;                    du[j]--;                    <span class="hljs-keyword">if</span>(du[j] == <span class="hljs-number">1</span>) tmp.<span class="hljs-built_in">push_back</span>(j);                &#125;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;x:tmp) q.<span class="hljs-built_in">push</span>(x);    &#125;    cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="F-Red-Black-Number"><a href="#F-Red-Black-Number" class="headerlink" title="F. Red-Black Number"></a>F. Red-Black Number</h4><p>题意：<del>红黑数</del> 给一个可能含前导0的数字，要求对将每一位染色成红或者黑，在满足红色数字拼起来后可以被 $A$ 整除，黑色数字拼起来可以被 $B$ 整除的条件下，涂红和涂黑的数量差最小，输出涂色方案。</p><p>乍一看有点不好下手，一看数据范围 $n\le40,A,B\le40$，考虑暴力dp</p><p>设 $dp[i][r][m_1][m_2]$ 表示前 $i$ 位中，涂了 $r$ 个红色，红色部分模 $A$ 结果为 $m_1$，黑色部分模 $B$ 结果为 $m_2$ 时，选择的红色位置（状态压缩，保存方案）</p><p>这样设置状态的原因在于，在后方添加一个新数位时（比如涂成红色），$m_1$ 可以转移到 $(m_1\times10+a[i+1])\mod A$，转移很方便，模结果为0即为合法答案</p><p>想到了状态后，转移不难写</p><div class="code-wrapper"><pre><code class="hljs c++"> <span class="hljs-type">int</span> n, mda, mdb;string a;ll dp[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>][<span class="hljs-number">50</span>][<span class="hljs-number">50</span>];<span class="hljs-comment">//pos, rednum, redres, blkres = respos</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; mda &gt;&gt; mdb;    cin &gt;&gt; a; a = <span class="hljs-string">&quot;s&quot;</span> + a;     <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(dp));    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>; r &lt;= i; r++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> rs = <span class="hljs-number">0</span>; rs &lt; mda; rs++)&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> rb = <span class="hljs-number">0</span>; rb &lt; mdb; rb++)&#123;                    ll t = dp[i][r][rs][rb];                    <span class="hljs-keyword">if</span>(t &gt;= <span class="hljs-number">0</span>)&#123;                        dp[i+<span class="hljs-number">1</span>][r][rs][(rb * <span class="hljs-number">10</span> + a[i+<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>)%mdb] = t;                        dp[i+<span class="hljs-number">1</span>][r+<span class="hljs-number">1</span>][(rs * <span class="hljs-number">10</span> + a[i+<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>)%mda][rb] = t | (<span class="hljs-number">1ll</span> &lt;&lt; i);                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-type">int</span> ans = <span class="hljs-number">1e9</span>;    ll redp;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = n<span class="hljs-number">-1</span>; r &gt;= <span class="hljs-number">1</span>; r--)&#123;        <span class="hljs-keyword">if</span>(dp[n][r][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &gt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>(ans &gt; <span class="hljs-built_in">abs</span>(<span class="hljs-number">2</span> * r - n))&#123;                ans = <span class="hljs-built_in">abs</span>(<span class="hljs-number">2</span> * r - n);                redp = dp[n][r][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(ans &gt;= n) cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;    <span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;            <span class="hljs-keyword">if</span>(redp &amp; (<span class="hljs-number">1ll</span> &lt;&lt; (i<span class="hljs-number">-1</span>))) cout &lt;&lt; <span class="hljs-string">&quot;R&quot;</span>;            <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;B&quot;</span>;        &#125;        cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125;&#125;</code></pre></div><h4 id="G-Changing-Brackets"><a href="#G-Changing-Brackets" class="headerlink" title="G. Changing Brackets"></a>G. Changing Brackets</h4><p>题意：有一个括号序列，包含 ( ) [ ] 四种括号，可以免费将括号翻转，或花费1块把圆括号变方括号（或者反过来），有多个询问，每次询问 $[l,r]$ ，需要最少花费多少使这个区间的括号合法，保证 $[l,r]$ 长度为偶数</p><p>一道纯思维题，考虑怎么样的一个括号序列才合法：我们不断将序列中相邻的同类括号删掉，两边的拼在一起，不断这样删去，最后可能全删了（即这个括号序合法），或者剩下形如 ( [ ( [ 这样交替出现的括号，剩下的长度的一半就是最小的花费</p><p>一个很容易理解（但可能比较难想到）的性质：圆括号我们直接不管了，剩下的方括号要么全在奇数位，要么全在偶数位</p><p>而这个序列中被删掉的那些方括号，也一定是一奇一偶一起删的</p><p>所以区间 $[l,r]$ 的答案就是区间中 奇数位方括号数量 - 偶数位方括号数量 再取个绝对值。前缀和搞一下就好了</p><p>感觉很不错的一个题，思维略有难度，但正解很容易让人接受</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> sum[maxn]; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    string s;    cin &gt;&gt; s;    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();    s = <span class="hljs-string">&quot;0&quot;</span> + s;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        sum[i] = sum[i<span class="hljs-number">-1</span>];        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;[&#x27;</span> || s[i] == <span class="hljs-string">&#x27;]&#x27;</span>)&#123;            <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) sum[i]++;            <span class="hljs-keyword">else</span> sum[i]--;        &#125;    &#125;    <span class="hljs-type">int</span> q;    cin &gt;&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;        <span class="hljs-type">int</span> l, r;        cin &gt;&gt; l &gt;&gt; r;        cout &lt;&lt; <span class="hljs-built_in">abs</span>(sum[r] - sum[l<span class="hljs-number">-1</span>]) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    &#125; &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 747 div.2 A-E</title>
    <link href="/2021/10/09/2021-10-09-Codeforces%20Round%20747%20div.2/"/>
    <url>/2021/10/09/2021-10-09-Codeforces%20Round%20747%20div.2/</url>
    
    <content type="html"><![CDATA[<h4 id="A-Consecutive-Sum-Riddle"><a href="#A-Consecutive-Sum-Riddle" class="headerlink" title="A. Consecutive Sum Riddle"></a>A. Consecutive Sum Riddle</h4><p>题意：给定一个 $n$，要找出 $l,r$ 使得 $\sum_{i&#x3D;l}^{r}i&#x3D;n$ </p><p>解：显然，从 $-n+1$ 加到 $n$ 即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    ll n;    cin &gt;&gt; n;    cout &lt;&lt; -n+<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="B-Special-Numbers"><a href="#B-Special-Numbers" class="headerlink" title="B. Special Numbers"></a>B. Special Numbers</h4><p>题意：找第 $k$ 个 $n$ 好数，$n$ 好数就是可以被 $n$ 的不同次幂组成，比如 $n^0+n^2…$ 的方式表示</p><p>解：把 $k$ 转化为二进制，然后每一位按照 $n$ 的次幂加权计算即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    ll n, k;    cin &gt;&gt; n &gt;&gt; k;    ll ans = <span class="hljs-number">0</span>, t = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(k &gt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>)&#123;            ans = (ans + t) % mode;        &#125;        k &gt;&gt;= <span class="hljs-number">1</span>;        t = t * n % mode;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="C-Make-Them-Equal"><a href="#C-Make-Them-Equal" class="headerlink" title="C. Make Them Equal"></a>C. Make Them Equal</h4><p>题意：给出一个字符串 $s$ 和字符 $c$，可以进行若干次操作，每次操作可以选择一个数 $x$，然后令字符串中所有下标不能被 $x$ 的整除的位置上的字符变成 $c$，问最少多少次操作可以使字符串全变成 $c$</p><p>解：由于 $n&gt;2$，两次操作分别选择 $n$ 和 $n-1$ 一定可以完成，那么只需要考虑能不能一次完成</p><p>一次完成要求存在一个数 $x$，串中所有可以被 $x$ 整除的位置上都已经是 $c$ 了，暴力枚举即可，复杂度比较玄学但它就是 $nlogn$</p><p>后来又听了无敌的会长的优化方案：只需要枚举 $n&#x2F;2$ 以上的 $x$ 即可，因为更小的 $x$ 总有一个倍数比它更优，复杂度 $2n$</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n;    <span class="hljs-type">char</span> c;    string s;    cin &gt;&gt; n &gt;&gt; c &gt;&gt; s;    s = <span class="hljs-string">&quot;0&quot;</span> + s;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-type">bool</span> flg = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n;j+=i)&#123;            <span class="hljs-keyword">if</span>(s[j] != c)&#123;                flg = <span class="hljs-literal">false</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(flg)&#123;            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>)&#123;                cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;            cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    cout &lt;&lt; <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    cout &lt;&lt; n<span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="D-The-Number-of-Imposters"><a href="#D-The-Number-of-Imposters" class="headerlink" title="D. The Number of Imposters"></a>D. The Number of Imposters</h4><p>题意：有 $n$ 个人和 $m$ 个陈述，每个陈述形如：$i,j,imposter&#x2F;crewmate$ 表示 $i$ 说 $j$ 是说真话的人&#x2F;说谎者，问说谎话的人最多有几个</p><p>解：注意到一个性质：如果 $i$ 说 $j$ 说的是谎话，那么 $i$ 和 $j$ 必定相反；如果 $i$ 说 $j$ 说的是真话，那么 $i$ 和 $j$ 相同。</p><p>那么每个陈述都可以转化为一条边，对每个联通块进行染色后取较多的颜色加入贡献即可</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> st[maxn];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;    <span class="hljs-type">int</span> t, nt, tp;&#125;e[maxn &lt;&lt; <span class="hljs-number">1</span>];<span class="hljs-type">int</span> head[maxn], ecnt = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> tp)</span></span>&#123;    e[++ecnt].t = y;    e[ecnt].tp = tp;    e[ecnt].nt = head[x];    head[x] = ecnt;&#125;<span class="hljs-type">int</span> num[<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[p];i;i=e[i].nt)&#123;        <span class="hljs-type">int</span> v = e[i].t;        <span class="hljs-keyword">if</span>(st[v] == <span class="hljs-number">-1</span>)&#123;            st[v] = st[p] ^ e[i].tp;            num[st[v]]++;            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(v)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(st[v] != (st[p] ^ e[i].tp)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n, m;    cin &gt;&gt; n &gt;&gt; m;    ecnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        head[i] = <span class="hljs-number">0</span>;        st[i] = <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;        <span class="hljs-type">int</span> x, y; string s;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; s;        <span class="hljs-type">int</span> tp = (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;i&#x27;</span>);        <span class="hljs-built_in">add</span>(x, y, tp);        <span class="hljs-built_in">add</span>(y, x, tp);    &#125;    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(st[i] == <span class="hljs-number">-1</span>)&#123;            st[i] = <span class="hljs-number">1</span>;            num[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;            num[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i))&#123;                cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;                <span class="hljs-keyword">return</span>;            &#125;            ans += <span class="hljs-built_in">max</span>(num[<span class="hljs-number">0</span>], num[<span class="hljs-number">1</span>]);        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><h4 id="E1-Rubik’s-Cube-Coloring-easy-version"><a href="#E1-Rubik’s-Cube-Coloring-easy-version" class="headerlink" title="E1. Rubik’s Cube Coloring (easy version)"></a>E1. Rubik’s Cube Coloring (easy version)</h4><p>题意：给一颗 $k$ 层的完全二叉树，每个节点有一个颜色（共六种），要求每个节点和其相邻节点颜色不能相同，并且规定了三对不能相邻的颜色，问有多少中染色方案</p><p>解：答案为 $4^{2^n-2}\times 6$</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll x, ll p)</span></span>&#123;    ll r = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(p &gt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">if</span>(p &amp; <span class="hljs-number">1</span>) r = r * x % mode;        x = x * x % mode;        p &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> r;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    cout &lt;&lt; <span class="hljs-built_in">qpow</span>(<span class="hljs-number">4</span>, (<span class="hljs-number">1ll</span> &lt;&lt; n) - <span class="hljs-number">2</span>) * <span class="hljs-number">6</span> % mode &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>codeforces</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不稳定扫雷 - LudumDare49</title>
    <link href="/2021/10/03/2021-10-03-%E4%B8%8D%E7%A8%B3%E5%AE%9A%E6%89%AB%E9%9B%B7/"/>
    <url>/2021/10/03/2021-10-03-%E4%B8%8D%E7%A8%B3%E5%AE%9A%E6%89%AB%E9%9B%B7/</url>
    
    <content type="html"><![CDATA[<h4 id="Unstable-Sweeping"><a href="#Unstable-Sweeping" class="headerlink" title="Unstable-Sweeping"></a>Unstable-Sweeping</h4><p>It’s a crazy game different from the original minesweeping:</p><ul><li>Each mine has a countdown! When a grid around the mine is opened, the countdown will begin.</li><li>The numbers no longer show the number of mines, but the minimum time left to count down in the surrounding circle of mines.</li><li>The mine will explode at the end of the countdown, then destroy the land within 3x3.</li><li>The mine explosion will detonate other mines around at the same time!</li><li>Left click to open a plot (point to the mine will explode directly!), right click to delete the mine in a plot (wrong deletion will accelerate the countdown of the surrounding mines!)</li></ul><p>Remove as many mines as possible, protect more land plots and get higher scores.</p><p>It may be difficult. Relax. It’s better to enjoy the explosion quietly…</p><p>Well, have a good time!</p><p>这是一个疯狂的游戏，他在原版扫雷的基础上加上了——</p><ul><li>每个地雷都有一个倒计时，当地雷周围一圈有格子被打开时，就会开始倒计时——</li><li>数字显示的不再是地雷数量，而是周围一圈雷中倒计时剩下的最少时间——</li><li>地雷倒计时结束就会爆炸，不过它不会直接导致你Gameover，而是摧毁3x3范围内的地块——</li><li>地雷爆炸同时会引爆周围的其他地雷——</li><li>左键点开一个地块（点到地雷会直接爆炸！），右键删去一个地块的地雷（删错会导致周围的地雷倒计时加速！）</li></ul><p>尽可能地切除更多地雷，保护更多地块，获得更高的评分——</p><p>可能会很难，放轻松，不如静静地欣赏爆炸——</p><p>那么，游戏愉快！</p><p><img src="http://lxtyin.ac.cn/img/Unstable-Sweeping/0.png" alt="1"></p><p><img src="http://lxtyin.ac.cn/img/Unstable-Sweeping/3.png" alt="2"></p><p><img src="http://lxtyin.ac.cn/img/Unstable-Sweeping/1.png" alt="3"></p><p>这已经是我最好的成绩了（在Easy难度下</p><p>&#x3D;》<a href="https://lx-tyin.itch.io/unstable-sweeping">下载链接(windows)</a></p><p>&#x3D;》<a href="https://github.com/lxtyin/lxtyin.github.io">Github源码</a></p><p>&#x3D;》<a href="https://ldjam.com/events/ludum-dare/49/unstable-sweeping">参赛界面</a>（多多支持！感谢！</p>]]></content>
    
    
    <categories>
      
      <category>自制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unity</tag>
      
      <tag>自制游戏</tag>
      
      <tag>LudumDare</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>切炸弹小游戏</title>
    <link href="/2021/08/27/2021-08-27-%E5%88%87%E7%82%B8%E5%BC%B9%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    <url>/2021/08/27/2021-08-27-%E5%88%87%E7%82%B8%E5%BC%B9%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<p>这是一个我自己做的小游戏：</p><p>鼠标点击操控三角形，切除或躲避从四周扔来的炸弹，不被炸到即可</p><p>游戏共25关，每5关会出现一种新的敌人，默认模式下按住鼠标会有缓时效果，难度不大</p><p>鼠标右键打开设置，可以开启release模式，取消缓时（难度较高，欢迎挑战！</p><p>欢迎体验，游戏愉快 ^_^</p><p><img src="http://lxtyin.ac.cn/img/littlegameofcut/1.png" alt="1"></p><p><img src="http://lxtyin.ac.cn/img/littlegameofcut/2.png" alt="2"></p><p><img src="http://lxtyin.ac.cn/img/littlegameofcut/3.png" alt="3"></p><p><img src="http://lxtyin.ac.cn/img/littlegameofcut/4.png" alt="4"></p><p><strong>下载链接：<a href="https://pan.baidu.com/s/1sByr24vguePcj3u9CMZ1Hg">https://pan.baidu.com/s/1sByr24vguePcj3u9CMZ1Hg</a></strong> </p><p><strong>提取码：</strong>5207</p>]]></content>
    
    
    <categories>
      
      <category>自制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unity</tag>
      
      <tag>自制游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
